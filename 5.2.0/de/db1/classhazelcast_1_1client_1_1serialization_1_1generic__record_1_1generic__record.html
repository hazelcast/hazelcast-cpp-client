<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hazelcast C++ Client: hazelcast::client::serialization::generic_record::generic_record Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../IMDG_blue_logo_square_RGB-dark_200px.png"/></td>
  <td id="projectalign">
   <div id="projectname">Hazelcast C++ Client
   </div>
   <div id="projectbrief">Hazelcast C++ Client Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d5/dce/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">hazelcast::client::serialization::generic_record::generic_record Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A generic object interface that is returned to the user when the domain class can not be created from any of the distributed Hazelcast data structures like <code><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html">imap</a></code>, <code><a class="el" href="../../dd/df1/classhazelcast_1_1client_1_1iqueue.html">iqueue</a></code> etc.  
 <a href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d8/d76/generic__record_8h_source.html">generic_record.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a511d0dfcf85537bea02a6060170b5e34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a511d0dfcf85537bea02a6060170b5e34">new_builder</a> () const</td></tr>
<tr class="memdesc:a511d0dfcf85537bea02a6060170b5e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a></code> allows to create a new object.  <br /></td></tr>
<tr class="separator:a511d0dfcf85537bea02a6060170b5e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be4ec9ba393576c4ec4607cc42eafbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">new_builder_with_clone</a> () const</td></tr>
<tr class="memdesc:a9be4ec9ba393576c4ec4607cc42eafbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned <code><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a></code> can be used to have exact copy and also just to update a couple of fields.  <br /></td></tr>
<tr class="separator:a9be4ec9ba393576c4ec4607cc42eafbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd6854435e51bc57dcf9e1165d7ef52"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#abfd6854435e51bc57dcf9e1165d7ef52">get_field_names</a> () const</td></tr>
<tr class="separator:abfd6854435e51bc57dcf9e1165d7ef52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ea3a313d17de70c0cd91c4ac9a8930"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dda/namespacehazelcast_1_1client_1_1serialization.html#a248143625dedc7b2c97fec8200c480f5">field_kind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ad2ea3a313d17de70c0cd91c4ac9a8930">get_field_kind</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:ad2ea3a313d17de70c0cd91c4ac9a8930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the kind of the field for the given field name.  <br /></td></tr>
<tr class="separator:ad2ea3a313d17de70c0cd91c4ac9a8930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7714133e6dd7b939d6e4230a4f259ed2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a7714133e6dd7b939d6e4230a4f259ed2">has_field</a> (std::string field_name) const</td></tr>
<tr class="separator:a7714133e6dd7b939d6e4230a4f259ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714d32a8d65dd5815b6e9fa5d3daa7bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a714d32a8d65dd5815b6e9fa5d3daa7bc">get_boolean</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a714d32a8d65dd5815b6e9fa5d3daa7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c753233daa8dd84131a13ab53d030cc"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a2c753233daa8dd84131a13ab53d030cc">get_boolean</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a2c753233daa8dd84131a13ab53d030cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867486e399981546274d8e390d3cdf52"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a867486e399981546274d8e390d3cdf52">get_int8</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a867486e399981546274d8e390d3cdf52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135d1d3fcb76bb8a4308fc2c5d3c833d"><td class="memItemLeft" align="right" valign="top">int8_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a135d1d3fcb76bb8a4308fc2c5d3c833d">get_int8</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a135d1d3fcb76bb8a4308fc2c5d3c833d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ecdbbc371b27bda548d7fc8309cd87"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a45ecdbbc371b27bda548d7fc8309cd87">get_int16</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a45ecdbbc371b27bda548d7fc8309cd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74667307604e64156b68cd4e4af11e09"><td class="memItemLeft" align="right" valign="top">int16_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a74667307604e64156b68cd4e4af11e09">get_int16</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a74667307604e64156b68cd4e4af11e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ddb93e1bc70f2e83d855e7e66d2f5c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ab5ddb93e1bc70f2e83d855e7e66d2f5c">get_int32</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:ab5ddb93e1bc70f2e83d855e7e66d2f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5321fab5625c00dc6945d93640fefd1"><td class="memItemLeft" align="right" valign="top">int32_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ab5321fab5625c00dc6945d93640fefd1">get_int32</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:ab5321fab5625c00dc6945d93640fefd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08972f6889fb31c7131fcddc07741b69"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a08972f6889fb31c7131fcddc07741b69">get_int64</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a08972f6889fb31c7131fcddc07741b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd52a9dd2d1ba4187dde5c35a245b2c"><td class="memItemLeft" align="right" valign="top">int64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a1bd52a9dd2d1ba4187dde5c35a245b2c">get_int64</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a1bd52a9dd2d1ba4187dde5c35a245b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe139b1193ca9e7d919a7b0131026f9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#abbe139b1193ca9e7d919a7b0131026f9">get_float32</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:abbe139b1193ca9e7d919a7b0131026f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13411e4de976b0ff1afbcd3130096a9a"><td class="memItemLeft" align="right" valign="top">float &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a13411e4de976b0ff1afbcd3130096a9a">get_float32</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a13411e4de976b0ff1afbcd3130096a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b143babc84fa4e58750b7249ec8a728"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a3b143babc84fa4e58750b7249ec8a728">get_float64</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a3b143babc84fa4e58750b7249ec8a728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2ca6e3013c10421c7ab34758f48317"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#adf2ca6e3013c10421c7ab34758f48317">get_float64</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:adf2ca6e3013c10421c7ab34758f48317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa891502c5e705479906cf00fb481f9b1"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aa891502c5e705479906cf00fb481f9b1">get_string</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:aa891502c5e705479906cf00fb481f9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951656f04ffd5cd5cae6e2bfe6cd4485"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a951656f04ffd5cd5cae6e2bfe6cd4485">get_string</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a951656f04ffd5cd5cae6e2bfe6cd4485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf277041c6f05a77bbe5dfc8686356c8"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#acf277041c6f05a77bbe5dfc8686356c8">get_decimal</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:acf277041c6f05a77bbe5dfc8686356c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee378ca6320b240988204664b6a4d13"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a6ee378ca6320b240988204664b6a4d13">get_decimal</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a6ee378ca6320b240988204664b6a4d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af590dc9ed44075027334666fbbaebc22"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#af590dc9ed44075027334666fbbaebc22">get_time</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:af590dc9ed44075027334666fbbaebc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb67f6f8d0b9b6b3665777e5c2c7409"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aedb67f6f8d0b9b6b3665777e5c2c7409">get_time</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:aedb67f6f8d0b9b6b3665777e5c2c7409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abead288cf747dd9191c063c5791c5950"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#abead288cf747dd9191c063c5791c5950">get_date</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:abead288cf747dd9191c063c5791c5950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc9a6f940b858d2614deb98a2025db9"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9bc9a6f940b858d2614deb98a2025db9">get_date</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a9bc9a6f940b858d2614deb98a2025db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7569777ad59a4ba7f75145f5c01ebd6d"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a7569777ad59a4ba7f75145f5c01ebd6d">get_timestamp</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a7569777ad59a4ba7f75145f5c01ebd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0a17af5ec6428f88f8aaa57580d514"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a0a0a17af5ec6428f88f8aaa57580d514">get_timestamp</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a0a0a17af5ec6428f88f8aaa57580d514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da8a5af57b79f7b23518ec39e21a053"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a6da8a5af57b79f7b23518ec39e21a053">get_timestamp_with_timezone</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a6da8a5af57b79f7b23518ec39e21a053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036490b36cb12625db194a62cfb12a0b"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a036490b36cb12625db194a62cfb12a0b">get_timestamp_with_timezone</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a036490b36cb12625db194a62cfb12a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324d0ce0261501034d525c7d99768e79"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a324d0ce0261501034d525c7d99768e79">get_generic_record</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a324d0ce0261501034d525c7d99768e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae06a17de17f44769ab5c0febff93f27"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aae06a17de17f44769ab5c0febff93f27">get_generic_record</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:aae06a17de17f44769ab5c0febff93f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9564677a34e6c7f63829d8ce771894"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; bool &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aab9564677a34e6c7f63829d8ce771894">get_array_of_boolean</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:aab9564677a34e6c7f63829d8ce771894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6400c6564d16e970aeef3517857454c"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; bool &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ad6400c6564d16e970aeef3517857454c">get_array_of_boolean</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:ad6400c6564d16e970aeef3517857454c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc23b5d5ee0db4b854d996a2dad92d4"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; int8_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#afdc23b5d5ee0db4b854d996a2dad92d4">get_array_of_int8</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:afdc23b5d5ee0db4b854d996a2dad92d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29cedda58f050f26530991d1a6bb5a61"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; int8_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a29cedda58f050f26530991d1a6bb5a61">get_array_of_int8</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a29cedda58f050f26530991d1a6bb5a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb3a671fedff2f2fba00a3212a4d269"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; int16_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aaeb3a671fedff2f2fba00a3212a4d269">get_array_of_int16</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:aaeb3a671fedff2f2fba00a3212a4d269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6147bfd6bc9e4af64a29d9717804e14"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; int16_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ac6147bfd6bc9e4af64a29d9717804e14">get_array_of_int16</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:ac6147bfd6bc9e4af64a29d9717804e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cfd4389efed5465e0bf942d00ef25c"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; int32_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#af0cfd4389efed5465e0bf942d00ef25c">get_array_of_int32</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:af0cfd4389efed5465e0bf942d00ef25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c732f1915180f6960d1f1be0c49194"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; int32_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ab7c732f1915180f6960d1f1be0c49194">get_array_of_int32</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:ab7c732f1915180f6960d1f1be0c49194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd5b3164e61e30947a80c8c3c23d413"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; int64_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a4cd5b3164e61e30947a80c8c3c23d413">get_array_of_int64</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a4cd5b3164e61e30947a80c8c3c23d413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82141206b5fe696b237c27c5806d0596"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; int64_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a82141206b5fe696b237c27c5806d0596">get_array_of_int64</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a82141206b5fe696b237c27c5806d0596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6ffe4f706e92ffb3a0f8e4b1186d9f"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; float &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aec6ffe4f706e92ffb3a0f8e4b1186d9f">get_array_of_float32</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:aec6ffe4f706e92ffb3a0f8e4b1186d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b96c8d6a2ae8fc07050660706a7693"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; float &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ab2b96c8d6a2ae8fc07050660706a7693">get_array_of_float32</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:ab2b96c8d6a2ae8fc07050660706a7693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b1944c66a6c40a3ac1d9b26ed669f9"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a78b1944c66a6c40a3ac1d9b26ed669f9">get_array_of_float64</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a78b1944c66a6c40a3ac1d9b26ed669f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916aa6fbd0ccf215529e4f37ab280393"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a916aa6fbd0ccf215529e4f37ab280393">get_array_of_float64</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a916aa6fbd0ccf215529e4f37ab280393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad453a29a4c8dab0169e653c6cfc7fbf4"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; std::string &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ad453a29a4c8dab0169e653c6cfc7fbf4">get_array_of_string</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:ad453a29a4c8dab0169e653c6cfc7fbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1959b7dc53a7c8c78b896fddc12953b"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; std::string &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ac1959b7dc53a7c8c78b896fddc12953b">get_array_of_string</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:ac1959b7dc53a7c8c78b896fddc12953b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ce3c3e3e605a553cec71a1c8e2d1eb"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ad7ce3c3e3e605a553cec71a1c8e2d1eb">get_array_of_decimal</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:ad7ce3c3e3e605a553cec71a1c8e2d1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43a2b2fd5ab8ad03784f2b396a431b8"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aa43a2b2fd5ab8ad03784f2b396a431b8">get_array_of_decimal</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:aa43a2b2fd5ab8ad03784f2b396a431b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af575a44a1312820e8e363b16a953a0f4"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#af575a44a1312820e8e363b16a953a0f4">get_array_of_time</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:af575a44a1312820e8e363b16a953a0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e5f9c190856afe84b34bdcd8c4fa38"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a51e5f9c190856afe84b34bdcd8c4fa38">get_array_of_time</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a51e5f9c190856afe84b34bdcd8c4fa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e91229f25eb001839c37ada2198b30"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a63e91229f25eb001839c37ada2198b30">get_array_of_date</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a63e91229f25eb001839c37ada2198b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050b80acf1bfdc6eea94f2b67c62c18a"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a050b80acf1bfdc6eea94f2b67c62c18a">get_array_of_date</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a050b80acf1bfdc6eea94f2b67c62c18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e1a9aa57db557f94973306958478a8"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aa2e1a9aa57db557f94973306958478a8">get_array_of_timestamp</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:aa2e1a9aa57db557f94973306958478a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb66e3d48e41c705b9c4d47d8b6c2db6"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aeb66e3d48e41c705b9c4d47d8b6c2db6">get_array_of_timestamp</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:aeb66e3d48e41c705b9c4d47d8b6c2db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d094118319c9cec2645e4e02873342"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ae9d094118319c9cec2645e4e02873342">get_array_of_timestamp_with_timezone</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:ae9d094118319c9cec2645e4e02873342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae249d864bb1d399115693f16ba22d8da"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ae249d864bb1d399115693f16ba22d8da">get_array_of_timestamp_with_timezone</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:ae249d864bb1d399115693f16ba22d8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573daf6c2ef08014ffc372892b3dd89f"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a573daf6c2ef08014ffc372892b3dd89f">get_array_of_generic_record</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a573daf6c2ef08014ffc372892b3dd89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc7229a52f0a3a62e4037cdc44251a4"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a3dc7229a52f0a3a62e4037cdc44251a4">get_array_of_generic_record</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a3dc7229a52f0a3a62e4037cdc44251a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d8e3be66a383c6fbf77397a0eab6dd"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ad1d8e3be66a383c6fbf77397a0eab6dd">get_nullable_boolean</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:ad1d8e3be66a383c6fbf77397a0eab6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:ad1d8e3be66a383c6fbf77397a0eab6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d51814873acede23c821af25b94c84e"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; bool &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a1d51814873acede23c821af25b94c84e">get_nullable_boolean</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a1d51814873acede23c821af25b94c84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a1d51814873acede23c821af25b94c84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aeca39439597cd66622d274117d3b1e"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a0aeca39439597cd66622d274117d3b1e">get_nullable_int8</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:a0aeca39439597cd66622d274117d3b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a0aeca39439597cd66622d274117d3b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355b390a3845681c436d0d09692108ae"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int8_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a355b390a3845681c436d0d09692108ae">get_nullable_int8</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a355b390a3845681c436d0d09692108ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a355b390a3845681c436d0d09692108ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73021280492c27351155c4b7d1c2776"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ac73021280492c27351155c4b7d1c2776">get_nullable_int16</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:ac73021280492c27351155c4b7d1c2776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:ac73021280492c27351155c4b7d1c2776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36610e49f7f341897fe946d75328d810"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int16_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a36610e49f7f341897fe946d75328d810">get_nullable_int16</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a36610e49f7f341897fe946d75328d810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a36610e49f7f341897fe946d75328d810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85b73d459eabf71924ecfc51c4da6a1"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#af85b73d459eabf71924ecfc51c4da6a1">get_nullable_int32</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:af85b73d459eabf71924ecfc51c4da6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:af85b73d459eabf71924ecfc51c4da6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d6be32c16aa479c5fcd22e2c2cf3a5"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int32_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ac1d6be32c16aa479c5fcd22e2c2cf3a5">get_nullable_int32</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:ac1d6be32c16aa479c5fcd22e2c2cf3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:ac1d6be32c16aa479c5fcd22e2c2cf3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f1ce8bf80df090ae378b3331587f52"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a71f1ce8bf80df090ae378b3331587f52">get_nullable_int64</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:a71f1ce8bf80df090ae378b3331587f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a71f1ce8bf80df090ae378b3331587f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88f20ad3d56bfe992d68cd1e3745362"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int64_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#af88f20ad3d56bfe992d68cd1e3745362">get_nullable_int64</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:af88f20ad3d56bfe992d68cd1e3745362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:af88f20ad3d56bfe992d68cd1e3745362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ee798406d233fde22e846ca7207dac"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a13ee798406d233fde22e846ca7207dac">get_nullable_float32</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:a13ee798406d233fde22e846ca7207dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a13ee798406d233fde22e846ca7207dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef63c63455ad97eaada9461f52a14cc"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; float &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#adef63c63455ad97eaada9461f52a14cc">get_nullable_float32</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:adef63c63455ad97eaada9461f52a14cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:adef63c63455ad97eaada9461f52a14cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144c440ac39ed5887882ed2eb4c16871"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a144c440ac39ed5887882ed2eb4c16871">get_nullable_float64</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:a144c440ac39ed5887882ed2eb4c16871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a144c440ac39ed5887882ed2eb4c16871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbb3ef2415fbdeecc38964b1cd6e67e"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aabbb3ef2415fbdeecc38964b1cd6e67e">get_nullable_float64</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:aabbb3ef2415fbdeecc38964b1cd6e67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:aabbb3ef2415fbdeecc38964b1cd6e67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af630bd4caf89fc31fc928c60802f8d24"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; bool &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#af630bd4caf89fc31fc928c60802f8d24">get_array_of_nullable_boolean</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:af630bd4caf89fc31fc928c60802f8d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:af630bd4caf89fc31fc928c60802f8d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1157d47c6e52992bfd10778a54deb7fc"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; bool &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a1157d47c6e52992bfd10778a54deb7fc">get_array_of_nullable_boolean</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a1157d47c6e52992bfd10778a54deb7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a1157d47c6e52992bfd10778a54deb7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa868ff55d01537d4b331d1d8be74c09"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; int8_t &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aaa868ff55d01537d4b331d1d8be74c09">get_array_of_nullable_int8</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:aaa868ff55d01537d4b331d1d8be74c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:aaa868ff55d01537d4b331d1d8be74c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bb774531d520d8dc36dc8423a3fa1e"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; int8_t &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a70bb774531d520d8dc36dc8423a3fa1e">get_array_of_nullable_int8</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a70bb774531d520d8dc36dc8423a3fa1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a70bb774531d520d8dc36dc8423a3fa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92fb239bfbc3cefc4028c18b85252ca"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; int16_t &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ad92fb239bfbc3cefc4028c18b85252ca">get_array_of_nullable_int16</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:ad92fb239bfbc3cefc4028c18b85252ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:ad92fb239bfbc3cefc4028c18b85252ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e9c16b0c8932b8b147729b4cc91efe"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; int16_t &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#af8e9c16b0c8932b8b147729b4cc91efe">get_array_of_nullable_int16</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:af8e9c16b0c8932b8b147729b4cc91efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:af8e9c16b0c8932b8b147729b4cc91efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac064a0c9bb34d087fb445b53292d4f98"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; int32_t &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ac064a0c9bb34d087fb445b53292d4f98">get_array_of_nullable_int32</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:ac064a0c9bb34d087fb445b53292d4f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:ac064a0c9bb34d087fb445b53292d4f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808e1cb772c70ad188dcf2a9cfeefcaf"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; int32_t &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a808e1cb772c70ad188dcf2a9cfeefcaf">get_array_of_nullable_int32</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a808e1cb772c70ad188dcf2a9cfeefcaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a808e1cb772c70ad188dcf2a9cfeefcaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a9c2f59d8730831115c3e9d0a7197b"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; int64_t &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a32a9c2f59d8730831115c3e9d0a7197b">get_array_of_nullable_int64</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:a32a9c2f59d8730831115c3e9d0a7197b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a32a9c2f59d8730831115c3e9d0a7197b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602ed261c3dbc9f27b24f4fa258a02f0"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; int64_t &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a602ed261c3dbc9f27b24f4fa258a02f0">get_array_of_nullable_int64</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a602ed261c3dbc9f27b24f4fa258a02f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a602ed261c3dbc9f27b24f4fa258a02f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185b3cd8f638662317429145d9aa52f2"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; float &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a185b3cd8f638662317429145d9aa52f2">get_array_of_nullable_float32</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:a185b3cd8f638662317429145d9aa52f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a185b3cd8f638662317429145d9aa52f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241cadf5983c4e433e1d4d510b773470"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; float &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a241cadf5983c4e433e1d4d510b773470">get_array_of_nullable_float32</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a241cadf5983c4e433e1d4d510b773470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a241cadf5983c4e433e1d4d510b773470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59bd9f95d7db2f4184ee5f2a669688a"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; double &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ab59bd9f95d7db2f4184ee5f2a669688a">get_array_of_nullable_float64</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:ab59bd9f95d7db2f4184ee5f2a669688a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:ab59bd9f95d7db2f4184ee5f2a669688a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ee86bf14644512d0cf0e0f9c3cdf44"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; double &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ae8ee86bf14644512d0cf0e0f9c3cdf44">get_array_of_nullable_float64</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:ae8ee86bf14644512d0cf0e0f9c3cdf44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:ae8ee86bf14644512d0cf0e0f9c3cdf44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a43e6ffbe06e93b1c3c131a18e4d21b3b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a43e6ffbe06e93b1c3c131a18e4d21b3b">generic_record_builder</a></td></tr>
<tr class="separator:a43e6ffbe06e93b1c3c131a18e4d21b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a96bb9ebecd6d3a6506dffa0173d93"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a51a96bb9ebecd6d3a6506dffa0173d93">pimpl::compact_stream_serializer</a></td></tr>
<tr class="separator:a51a96bb9ebecd6d3a6506dffa0173d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778ca519c51aba88b1b6f240f2725d55"><td class="memItemLeft" align="right" valign="top">std::ostream HAZELCAST_API &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a778ca519c51aba88b1b6f240f2725d55">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;)</td></tr>
<tr class="separator:a778ca519c51aba88b1b6f240f2725d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac373fa6215c12b50cee2a36062f2ee91"><td class="memItemLeft" align="right" valign="top">bool HAZELCAST_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ac373fa6215c12b50cee2a36062f2ee91">operator==</a> (const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;, const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;)</td></tr>
<tr class="separator:ac373fa6215c12b50cee2a36062f2ee91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0e36cea8a99b0d0adc16459890aeec"><td class="memItemLeft" align="right" valign="top">bool HAZELCAST_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aff0e36cea8a99b0d0adc16459890aeec">operator!=</a> (const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;, const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;)</td></tr>
<tr class="separator:aff0e36cea8a99b0d0adc16459890aeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f40f26e342b61258d571760a3bbc25"><td class="memItemLeft" align="right" valign="top">boost::property_tree::ptree&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ad9f40f26e342b61258d571760a3bbc25">write_generic_record</a> (const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;)</td></tr>
<tr class="separator:ad9f40f26e342b61258d571760a3bbc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A generic object interface that is returned to the user when the domain class can not be created from any of the distributed Hazelcast data structures like <code><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html">imap</a></code>, <code><a class="el" href="../../dd/df1/classhazelcast_1_1client_1_1iqueue.html">iqueue</a></code> etc. </p>
<p>GenericRecord also allows reading from a cluster without having the classes on the client side. If <code>T</code> is specified as <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a></code>, any compact objects can be read and written objects back to the cluster without the need to have the domain classes definition on client side. </p>
<p>Currently, only compact serializable objects are supported.</p>
<p>Multiple threads can simultaneous read from <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> but concurrent writes are not supported. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d76/generic__record_8h_source.html#l00059">59</a> of file <a class="el" href="../../d8/d76/generic__record_8h_source.html">generic_record.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad6400c6564d16e970aeef3517857454c" name="ad6400c6564d16e970aeef3517857454c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6400c6564d16e970aeef3517857454c">&#9670;&#160;</a></span>get_array_of_boolean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; bool &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01084">1084</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1085</span>{</div>
<div class="line"><span class="lineno"> 1086</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;bool&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1087</span>                                        field_kind::ARRAY_OF_BOOLEAN,</div>
<div class="line"><span class="lineno"> 1088</span>                                        field_kind::ARRAY_OF_NULLABLE_BOOLEAN,</div>
<div class="line"><span class="lineno"> 1089</span>                                        <span class="stringliteral">&quot;boolean&quot;</span>);</div>
<div class="line"><span class="lineno"> 1090</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aab9564677a34e6c7f63829d8ce771894" name="aab9564677a34e6c7f63829d8ce771894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9564677a34e6c7f63829d8ce771894">&#9670;&#160;</a></span>get_array_of_boolean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; bool &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01075">1075</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1076</span>{</div>
<div class="line"><span class="lineno"> 1077</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;bool&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1078</span>                                        field_kind::ARRAY_OF_BOOLEAN,</div>
<div class="line"><span class="lineno"> 1079</span>                                        field_kind::ARRAY_OF_NULLABLE_BOOLEAN,</div>
<div class="line"><span class="lineno"> 1080</span>                                        <span class="stringliteral">&quot;boolean&quot;</span>);</div>
<div class="line"><span class="lineno"> 1081</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a050b80acf1bfdc6eea94f2b67c62c18a" name="a050b80acf1bfdc6eea94f2b67c62c18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050b80acf1bfdc6eea94f2b67c62c18a">&#9670;&#160;</a></span>get_array_of_date() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_date </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#abead288cf747dd9191c063c5791c5950">get_date()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01379">1379</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1380</span>{</div>
<div class="line"><span class="lineno"> 1381</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;local_date&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1382</span>      field_name, field_kind::ARRAY_OF_DATE);</div>
<div class="line"><span class="lineno"> 1383</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a63e91229f25eb001839c37ada2198b30" name="a63e91229f25eb001839c37ada2198b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e91229f25eb001839c37ada2198b30">&#9670;&#160;</a></span>get_array_of_date() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_date </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#abead288cf747dd9191c063c5791c5950">get_date()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01372">1372</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1373</span>{</div>
<div class="line"><span class="lineno"> 1374</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;local_date&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1375</span>      field_name, field_kind::ARRAY_OF_DATE);</div>
<div class="line"><span class="lineno"> 1376</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa43a2b2fd5ab8ad03784f2b396a431b8" name="aa43a2b2fd5ab8ad03784f2b396a431b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43a2b2fd5ab8ad03784f2b396a431b8">&#9670;&#160;</a></span>get_array_of_decimal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_decimal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#acf277041c6f05a77bbe5dfc8686356c8">get_decimal()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01351">1351</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1352</span>{</div>
<div class="line"><span class="lineno"> 1353</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;big_decimal&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1354</span>      field_name, field_kind::ARRAY_OF_DECIMAL);</div>
<div class="line"><span class="lineno"> 1355</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad7ce3c3e3e605a553cec71a1c8e2d1eb" name="ad7ce3c3e3e605a553cec71a1c8e2d1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ce3c3e3e605a553cec71a1c8e2d1eb">&#9670;&#160;</a></span>get_array_of_decimal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_decimal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema/class definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#acf277041c6f05a77bbe5dfc8686356c8">get_decimal()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01344">1344</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1345</span>{</div>
<div class="line"><span class="lineno"> 1346</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;big_decimal&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1347</span>      field_name, field_kind::ARRAY_OF_DECIMAL);</div>
<div class="line"><span class="lineno"> 1348</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab2b96c8d6a2ae8fc07050660706a7693" name="ab2b96c8d6a2ae8fc07050660706a7693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b96c8d6a2ae8fc07050660706a7693">&#9670;&#160;</a></span>get_array_of_float32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; float &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01174">1174</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1175</span>{</div>
<div class="line"><span class="lineno"> 1176</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;float&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1177</span>                                         field_kind::ARRAY_OF_FLOAT32,</div>
<div class="line"><span class="lineno"> 1178</span>                                         field_kind::ARRAY_OF_NULLABLE_FLOAT32,</div>
<div class="line"><span class="lineno"> 1179</span>                                         <span class="stringliteral">&quot;float32&quot;</span>);</div>
<div class="line"><span class="lineno"> 1180</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aec6ffe4f706e92ffb3a0f8e4b1186d9f" name="aec6ffe4f706e92ffb3a0f8e4b1186d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6ffe4f706e92ffb3a0f8e4b1186d9f">&#9670;&#160;</a></span>get_array_of_float32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; float &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01165">1165</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1166</span>{</div>
<div class="line"><span class="lineno"> 1167</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;float&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1168</span>                                         field_kind::ARRAY_OF_FLOAT32,</div>
<div class="line"><span class="lineno"> 1169</span>                                         field_kind::ARRAY_OF_NULLABLE_FLOAT32,</div>
<div class="line"><span class="lineno"> 1170</span>                                         <span class="stringliteral">&quot;float32&quot;</span>);</div>
<div class="line"><span class="lineno"> 1171</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a916aa6fbd0ccf215529e4f37ab280393" name="a916aa6fbd0ccf215529e4f37ab280393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916aa6fbd0ccf215529e4f37ab280393">&#9670;&#160;</a></span>get_array_of_float64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; double &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01192">1192</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1193</span>{</div>
<div class="line"><span class="lineno"> 1194</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;double&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1195</span>                                          field_kind::ARRAY_OF_FLOAT64,</div>
<div class="line"><span class="lineno"> 1196</span>                                          field_kind::ARRAY_OF_NULLABLE_FLOAT64,</div>
<div class="line"><span class="lineno"> 1197</span>                                          <span class="stringliteral">&quot;float64&quot;</span>);</div>
<div class="line"><span class="lineno"> 1198</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a78b1944c66a6c40a3ac1d9b26ed669f9" name="a78b1944c66a6c40a3ac1d9b26ed669f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b1944c66a6c40a3ac1d9b26ed669f9">&#9670;&#160;</a></span>get_array_of_float64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; double &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01183">1183</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1184</span>{</div>
<div class="line"><span class="lineno"> 1185</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;double&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1186</span>                                          field_kind::ARRAY_OF_FLOAT64,</div>
<div class="line"><span class="lineno"> 1187</span>                                          field_kind::ARRAY_OF_NULLABLE_FLOAT64,</div>
<div class="line"><span class="lineno"> 1188</span>                                          <span class="stringliteral">&quot;float64&quot;</span>);</div>
<div class="line"><span class="lineno"> 1189</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3dc7229a52f0a3a62e4037cdc44251a4" name="a3dc7229a52f0a3a62e4037cdc44251a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc7229a52f0a3a62e4037cdc44251a4">&#9670;&#160;</a></span>get_array_of_generic_record() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_generic_record </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01423">1423</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1424</span>{</div>
<div class="line"><span class="lineno"> 1425</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;generic_record&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1426</span>      field_name, field_kind::ARRAY_OF_COMPACT);</div>
<div class="line"><span class="lineno"> 1427</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a573daf6c2ef08014ffc372892b3dd89f" name="a573daf6c2ef08014ffc372892b3dd89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573daf6c2ef08014ffc372892b3dd89f">&#9670;&#160;</a></span>get_array_of_generic_record() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_generic_record </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01416">1416</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1417</span>{</div>
<div class="line"><span class="lineno"> 1418</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;generic_record&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1419</span>      field_name, field_kind::ARRAY_OF_COMPACT);</div>
<div class="line"><span class="lineno"> 1420</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac6147bfd6bc9e4af64a29d9717804e14" name="ac6147bfd6bc9e4af64a29d9717804e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6147bfd6bc9e4af64a29d9717804e14">&#9670;&#160;</a></span>get_array_of_int16() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; int16_t &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01120">1120</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1121</span>{</div>
<div class="line"><span class="lineno"> 1122</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;int16_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1123</span>                                           field_kind::ARRAY_OF_INT16,</div>
<div class="line"><span class="lineno"> 1124</span>                                           field_kind::ARRAY_OF_NULLABLE_INT16,</div>
<div class="line"><span class="lineno"> 1125</span>                                           <span class="stringliteral">&quot;int16&quot;</span>);</div>
<div class="line"><span class="lineno"> 1126</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aaeb3a671fedff2f2fba00a3212a4d269" name="aaeb3a671fedff2f2fba00a3212a4d269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb3a671fedff2f2fba00a3212a4d269">&#9670;&#160;</a></span>get_array_of_int16() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; int16_t &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01111">1111</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1112</span>{</div>
<div class="line"><span class="lineno"> 1113</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;int16_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1114</span>                                           field_kind::ARRAY_OF_INT16,</div>
<div class="line"><span class="lineno"> 1115</span>                                           field_kind::ARRAY_OF_NULLABLE_INT16,</div>
<div class="line"><span class="lineno"> 1116</span>                                           <span class="stringliteral">&quot;int16&quot;</span>);</div>
<div class="line"><span class="lineno"> 1117</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab7c732f1915180f6960d1f1be0c49194" name="ab7c732f1915180f6960d1f1be0c49194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c732f1915180f6960d1f1be0c49194">&#9670;&#160;</a></span>get_array_of_int32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; int32_t &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01138">1138</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1139</span>{</div>
<div class="line"><span class="lineno"> 1140</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;int32_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1141</span>                                           field_kind::ARRAY_OF_INT32,</div>
<div class="line"><span class="lineno"> 1142</span>                                           field_kind::ARRAY_OF_NULLABLE_INT32,</div>
<div class="line"><span class="lineno"> 1143</span>                                           <span class="stringliteral">&quot;int32&quot;</span>);</div>
<div class="line"><span class="lineno"> 1144</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af0cfd4389efed5465e0bf942d00ef25c" name="af0cfd4389efed5465e0bf942d00ef25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0cfd4389efed5465e0bf942d00ef25c">&#9670;&#160;</a></span>get_array_of_int32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; int32_t &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01129">1129</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1130</span>{</div>
<div class="line"><span class="lineno"> 1131</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;int32_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1132</span>                                           field_kind::ARRAY_OF_INT32,</div>
<div class="line"><span class="lineno"> 1133</span>                                           field_kind::ARRAY_OF_NULLABLE_INT32,</div>
<div class="line"><span class="lineno"> 1134</span>                                           <span class="stringliteral">&quot;int32&quot;</span>);</div>
<div class="line"><span class="lineno"> 1135</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a82141206b5fe696b237c27c5806d0596" name="a82141206b5fe696b237c27c5806d0596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82141206b5fe696b237c27c5806d0596">&#9670;&#160;</a></span>get_array_of_int64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; int64_t &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01156">1156</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1157</span>{</div>
<div class="line"><span class="lineno"> 1158</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;int64_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1159</span>                                           field_kind::ARRAY_OF_INT64,</div>
<div class="line"><span class="lineno"> 1160</span>                                           field_kind::ARRAY_OF_NULLABLE_INT64,</div>
<div class="line"><span class="lineno"> 1161</span>                                           <span class="stringliteral">&quot;int64&quot;</span>);</div>
<div class="line"><span class="lineno"> 1162</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4cd5b3164e61e30947a80c8c3c23d413" name="a4cd5b3164e61e30947a80c8c3c23d413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd5b3164e61e30947a80c8c3c23d413">&#9670;&#160;</a></span>get_array_of_int64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; int64_t &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01147">1147</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1148</span>{</div>
<div class="line"><span class="lineno"> 1149</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;int64_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1150</span>                                           field_kind::ARRAY_OF_INT64,</div>
<div class="line"><span class="lineno"> 1151</span>                                           field_kind::ARRAY_OF_NULLABLE_INT64,</div>
<div class="line"><span class="lineno"> 1152</span>                                           <span class="stringliteral">&quot;int64&quot;</span>);</div>
<div class="line"><span class="lineno"> 1153</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a29cedda58f050f26530991d1a6bb5a61" name="a29cedda58f050f26530991d1a6bb5a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29cedda58f050f26530991d1a6bb5a61">&#9670;&#160;</a></span>get_array_of_int8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; int8_t &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01102">1102</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1103</span>{</div>
<div class="line"><span class="lineno"> 1104</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;int8_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1105</span>                                          field_kind::ARRAY_OF_INT8,</div>
<div class="line"><span class="lineno"> 1106</span>                                          field_kind::ARRAY_OF_NULLABLE_INT8,</div>
<div class="line"><span class="lineno"> 1107</span>                                          <span class="stringliteral">&quot;int8&quot;</span>);</div>
<div class="line"><span class="lineno"> 1108</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="afdc23b5d5ee0db4b854d996a2dad92d4" name="afdc23b5d5ee0db4b854d996a2dad92d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc23b5d5ee0db4b854d996a2dad92d4">&#9670;&#160;</a></span>get_array_of_int8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; int8_t &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01093">1093</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1094</span>{</div>
<div class="line"><span class="lineno"> 1095</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;int8_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1096</span>                                          field_kind::ARRAY_OF_INT8,</div>
<div class="line"><span class="lineno"> 1097</span>                                          field_kind::ARRAY_OF_NULLABLE_INT8,</div>
<div class="line"><span class="lineno"> 1098</span>                                          <span class="stringliteral">&quot;int8&quot;</span>);</div>
<div class="line"><span class="lineno"> 1099</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1157d47c6e52992bfd10778a54deb7fc" name="a1157d47c6e52992bfd10778a54deb7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1157d47c6e52992bfd10778a54deb7fc">&#9670;&#160;</a></span>get_array_of_nullable_boolean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; bool &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01211">1211</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1212</span>{</div>
<div class="line"><span class="lineno"> 1213</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;bool&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1214</span>                                       field_kind::ARRAY_OF_BOOLEAN,</div>
<div class="line"><span class="lineno"> 1215</span>                                       field_kind::ARRAY_OF_NULLABLE_BOOLEAN,</div>
<div class="line"><span class="lineno"> 1216</span>                                       <span class="stringliteral">&quot;boolean&quot;</span>);</div>
<div class="line"><span class="lineno"> 1217</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af630bd4caf89fc31fc928c60802f8d24" name="af630bd4caf89fc31fc928c60802f8d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af630bd4caf89fc31fc928c60802f8d24">&#9670;&#160;</a></span>get_array_of_nullable_boolean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; bool &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01201">1201</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1203</span>{</div>
<div class="line"><span class="lineno"> 1204</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;bool&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1205</span>                                       field_kind::ARRAY_OF_BOOLEAN,</div>
<div class="line"><span class="lineno"> 1206</span>                                       field_kind::ARRAY_OF_NULLABLE_BOOLEAN,</div>
<div class="line"><span class="lineno"> 1207</span>                                       <span class="stringliteral">&quot;boolean&quot;</span>);</div>
<div class="line"><span class="lineno"> 1208</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a241cadf5983c4e433e1d4d510b773470" name="a241cadf5983c4e433e1d4d510b773470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241cadf5983c4e433e1d4d510b773470">&#9670;&#160;</a></span>get_array_of_nullable_float32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; float &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01302">1302</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1303</span>{</div>
<div class="line"><span class="lineno"> 1304</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;float&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1305</span>                                        field_kind::ARRAY_OF_FLOAT32,</div>
<div class="line"><span class="lineno"> 1306</span>                                        field_kind::ARRAY_OF_NULLABLE_FLOAT32,</div>
<div class="line"><span class="lineno"> 1307</span>                                        <span class="stringliteral">&quot;float32&quot;</span>);</div>
<div class="line"><span class="lineno"> 1308</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a185b3cd8f638662317429145d9aa52f2" name="a185b3cd8f638662317429145d9aa52f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185b3cd8f638662317429145d9aa52f2">&#9670;&#160;</a></span>get_array_of_nullable_float32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; float &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01292">1292</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1294</span>{</div>
<div class="line"><span class="lineno"> 1295</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;float&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1296</span>                                        field_kind::ARRAY_OF_FLOAT32,</div>
<div class="line"><span class="lineno"> 1297</span>                                        field_kind::ARRAY_OF_NULLABLE_FLOAT32,</div>
<div class="line"><span class="lineno"> 1298</span>                                        <span class="stringliteral">&quot;float32&quot;</span>);</div>
<div class="line"><span class="lineno"> 1299</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae8ee86bf14644512d0cf0e0f9c3cdf44" name="ae8ee86bf14644512d0cf0e0f9c3cdf44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ee86bf14644512d0cf0e0f9c3cdf44">&#9670;&#160;</a></span>get_array_of_nullable_float64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; double &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01321">1321</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1322</span>{</div>
<div class="line"><span class="lineno"> 1323</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;double&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1324</span>                                         field_kind::ARRAY_OF_FLOAT64,</div>
<div class="line"><span class="lineno"> 1325</span>                                         field_kind::ARRAY_OF_NULLABLE_FLOAT64,</div>
<div class="line"><span class="lineno"> 1326</span>                                         <span class="stringliteral">&quot;float64&quot;</span>);</div>
<div class="line"><span class="lineno"> 1327</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab59bd9f95d7db2f4184ee5f2a669688a" name="ab59bd9f95d7db2f4184ee5f2a669688a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59bd9f95d7db2f4184ee5f2a669688a">&#9670;&#160;</a></span>get_array_of_nullable_float64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; double &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01311">1311</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1313</span>{</div>
<div class="line"><span class="lineno"> 1314</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;double&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1315</span>                                         field_kind::ARRAY_OF_FLOAT64,</div>
<div class="line"><span class="lineno"> 1316</span>                                         field_kind::ARRAY_OF_NULLABLE_FLOAT64,</div>
<div class="line"><span class="lineno"> 1317</span>                                         <span class="stringliteral">&quot;float64&quot;</span>);</div>
<div class="line"><span class="lineno"> 1318</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af8e9c16b0c8932b8b147729b4cc91efe" name="af8e9c16b0c8932b8b147729b4cc91efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e9c16b0c8932b8b147729b4cc91efe">&#9670;&#160;</a></span>get_array_of_nullable_int16() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; int16_t &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01247">1247</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1248</span>{</div>
<div class="line"><span class="lineno"> 1249</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;int16_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1250</span>                                          field_kind::ARRAY_OF_INT16,</div>
<div class="line"><span class="lineno"> 1251</span>                                          field_kind::ARRAY_OF_NULLABLE_INT16,</div>
<div class="line"><span class="lineno"> 1252</span>                                          <span class="stringliteral">&quot;int16&quot;</span>);</div>
<div class="line"><span class="lineno"> 1253</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad92fb239bfbc3cefc4028c18b85252ca" name="ad92fb239bfbc3cefc4028c18b85252ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92fb239bfbc3cefc4028c18b85252ca">&#9670;&#160;</a></span>get_array_of_nullable_int16() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; int16_t &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01238">1238</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1239</span>{</div>
<div class="line"><span class="lineno"> 1240</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;int16_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1241</span>                                          field_kind::ARRAY_OF_INT16,</div>
<div class="line"><span class="lineno"> 1242</span>                                          field_kind::ARRAY_OF_NULLABLE_INT16,</div>
<div class="line"><span class="lineno"> 1243</span>                                          <span class="stringliteral">&quot;int16&quot;</span>);</div>
<div class="line"><span class="lineno"> 1244</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a808e1cb772c70ad188dcf2a9cfeefcaf" name="a808e1cb772c70ad188dcf2a9cfeefcaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808e1cb772c70ad188dcf2a9cfeefcaf">&#9670;&#160;</a></span>get_array_of_nullable_int32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; int32_t &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01265">1265</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1266</span>{</div>
<div class="line"><span class="lineno"> 1267</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;int32_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1268</span>                                          field_kind::ARRAY_OF_INT32,</div>
<div class="line"><span class="lineno"> 1269</span>                                          field_kind::ARRAY_OF_NULLABLE_INT32,</div>
<div class="line"><span class="lineno"> 1270</span>                                          <span class="stringliteral">&quot;int32&quot;</span>);</div>
<div class="line"><span class="lineno"> 1271</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac064a0c9bb34d087fb445b53292d4f98" name="ac064a0c9bb34d087fb445b53292d4f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac064a0c9bb34d087fb445b53292d4f98">&#9670;&#160;</a></span>get_array_of_nullable_int32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; int32_t &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01256">1256</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1257</span>{</div>
<div class="line"><span class="lineno"> 1258</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;int32_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1259</span>                                          field_kind::ARRAY_OF_INT32,</div>
<div class="line"><span class="lineno"> 1260</span>                                          field_kind::ARRAY_OF_NULLABLE_INT32,</div>
<div class="line"><span class="lineno"> 1261</span>                                          <span class="stringliteral">&quot;int32&quot;</span>);</div>
<div class="line"><span class="lineno"> 1262</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a602ed261c3dbc9f27b24f4fa258a02f0" name="a602ed261c3dbc9f27b24f4fa258a02f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602ed261c3dbc9f27b24f4fa258a02f0">&#9670;&#160;</a></span>get_array_of_nullable_int64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; int64_t &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01283">1283</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1284</span>{</div>
<div class="line"><span class="lineno"> 1285</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;int64_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1286</span>                                          field_kind::ARRAY_OF_INT64,</div>
<div class="line"><span class="lineno"> 1287</span>                                          field_kind::ARRAY_OF_NULLABLE_INT64,</div>
<div class="line"><span class="lineno"> 1288</span>                                          <span class="stringliteral">&quot;int64&quot;</span>);</div>
<div class="line"><span class="lineno"> 1289</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a32a9c2f59d8730831115c3e9d0a7197b" name="a32a9c2f59d8730831115c3e9d0a7197b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a9c2f59d8730831115c3e9d0a7197b">&#9670;&#160;</a></span>get_array_of_nullable_int64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; int64_t &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01274">1274</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1275</span>{</div>
<div class="line"><span class="lineno"> 1276</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;int64_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1277</span>                                          field_kind::ARRAY_OF_INT64,</div>
<div class="line"><span class="lineno"> 1278</span>                                          field_kind::ARRAY_OF_NULLABLE_INT64,</div>
<div class="line"><span class="lineno"> 1279</span>                                          <span class="stringliteral">&quot;int64&quot;</span>);</div>
<div class="line"><span class="lineno"> 1280</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a70bb774531d520d8dc36dc8423a3fa1e" name="a70bb774531d520d8dc36dc8423a3fa1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bb774531d520d8dc36dc8423a3fa1e">&#9670;&#160;</a></span>get_array_of_nullable_int8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; int8_t &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01229">1229</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1230</span>{</div>
<div class="line"><span class="lineno"> 1231</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;int8_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1232</span>                                         field_kind::ARRAY_OF_INT8,</div>
<div class="line"><span class="lineno"> 1233</span>                                         field_kind::ARRAY_OF_NULLABLE_INT8,</div>
<div class="line"><span class="lineno"> 1234</span>                                         <span class="stringliteral">&quot;int8&quot;</span>);</div>
<div class="line"><span class="lineno"> 1235</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aaa868ff55d01537d4b331d1d8be74c09" name="aaa868ff55d01537d4b331d1d8be74c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa868ff55d01537d4b331d1d8be74c09">&#9670;&#160;</a></span>get_array_of_nullable_int8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; int8_t &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01220">1220</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1221</span>{</div>
<div class="line"><span class="lineno"> 1222</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;int8_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1223</span>                                         field_kind::ARRAY_OF_INT8,</div>
<div class="line"><span class="lineno"> 1224</span>                                         field_kind::ARRAY_OF_NULLABLE_INT8,</div>
<div class="line"><span class="lineno"> 1225</span>                                         <span class="stringliteral">&quot;int8&quot;</span>);</div>
<div class="line"><span class="lineno"> 1226</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac1959b7dc53a7c8c78b896fddc12953b" name="ac1959b7dc53a7c8c78b896fddc12953b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1959b7dc53a7c8c78b896fddc12953b">&#9670;&#160;</a></span>get_array_of_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; std::string &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01337">1337</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1338</span>{</div>
<div class="line"><span class="lineno"> 1339</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;std::string&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1340</span>      field_name, field_kind::ARRAY_OF_STRING);</div>
<div class="line"><span class="lineno"> 1341</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad453a29a4c8dab0169e653c6cfc7fbf4" name="ad453a29a4c8dab0169e653c6cfc7fbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad453a29a4c8dab0169e653c6cfc7fbf4">&#9670;&#160;</a></span>get_array_of_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; std::string &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01330">1330</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1331</span>{</div>
<div class="line"><span class="lineno"> 1332</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;std::string&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1333</span>      field_name, field_kind::ARRAY_OF_STRING);</div>
<div class="line"><span class="lineno"> 1334</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a51e5f9c190856afe84b34bdcd8c4fa38" name="a51e5f9c190856afe84b34bdcd8c4fa38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e5f9c190856afe84b34bdcd8c4fa38">&#9670;&#160;</a></span>get_array_of_time() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_time </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schem definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#af590dc9ed44075027334666fbbaebc22">get_time()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01365">1365</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1366</span>{</div>
<div class="line"><span class="lineno"> 1367</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;local_time&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1368</span>      field_name, field_kind::ARRAY_OF_TIME);</div>
<div class="line"><span class="lineno"> 1369</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af575a44a1312820e8e363b16a953a0f4" name="af575a44a1312820e8e363b16a953a0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af575a44a1312820e8e363b16a953a0f4">&#9670;&#160;</a></span>get_array_of_time() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_time </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#af590dc9ed44075027334666fbbaebc22">get_time()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01358">1358</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1359</span>{</div>
<div class="line"><span class="lineno"> 1360</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;local_time&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1361</span>      field_name, field_kind::ARRAY_OF_TIME);</div>
<div class="line"><span class="lineno"> 1362</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb66e3d48e41c705b9c4d47d8b6c2db6" name="aeb66e3d48e41c705b9c4d47d8b6c2db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb66e3d48e41c705b9c4d47d8b6c2db6">&#9670;&#160;</a></span>get_array_of_timestamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_timestamp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a7569777ad59a4ba7f75145f5c01ebd6d">get_timestamp()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01393">1393</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1394</span>{</div>
<div class="line"><span class="lineno"> 1395</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;local_date_time&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1396</span>      field_name, field_kind::ARRAY_OF_TIMESTAMP);</div>
<div class="line"><span class="lineno"> 1397</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa2e1a9aa57db557f94973306958478a8" name="aa2e1a9aa57db557f94973306958478a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e1a9aa57db557f94973306958478a8">&#9670;&#160;</a></span>get_array_of_timestamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_timestamp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a7569777ad59a4ba7f75145f5c01ebd6d">get_timestamp()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01386">1386</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1387</span>{</div>
<div class="line"><span class="lineno"> 1388</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;local_date_time&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1389</span>      field_name, field_kind::ARRAY_OF_TIMESTAMP);</div>
<div class="line"><span class="lineno"> 1390</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae249d864bb1d399115693f16ba22d8da" name="ae249d864bb1d399115693f16ba22d8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae249d864bb1d399115693f16ba22d8da">&#9670;&#160;</a></span>get_array_of_timestamp_with_timezone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_timestamp_with_timezone </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a6da8a5af57b79f7b23518ec39e21a053">get_timestamp_with_timezone()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01408">1408</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1410</span>{</div>
<div class="line"><span class="lineno"> 1411</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;offset_date_time&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1412</span>      field_name, field_kind::ARRAY_OF_TIMESTAMP_WITH_TIMEZONE);</div>
<div class="line"><span class="lineno"> 1413</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae9d094118319c9cec2645e4e02873342" name="ae9d094118319c9cec2645e4e02873342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d094118319c9cec2645e4e02873342">&#9670;&#160;</a></span>get_array_of_timestamp_with_timezone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_timestamp_with_timezone </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a6da8a5af57b79f7b23518ec39e21a053">get_timestamp_with_timezone()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01400">1400</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1402</span>{</div>
<div class="line"><span class="lineno"> 1403</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;offset_date_time&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1404</span>      field_name, field_kind::ARRAY_OF_TIMESTAMP_WITH_TIMEZONE);</div>
<div class="line"><span class="lineno"> 1405</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2c753233daa8dd84131a13ab53d030cc" name="a2c753233daa8dd84131a13ab53d030cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c753233daa8dd84131a13ab53d030cc">&#9670;&#160;</a></span>get_boolean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool &amp; hazelcast::client::serialization::generic_record::generic_record::get_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00800">800</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  801</span>{</div>
<div class="line"><span class="lineno">  802</span>    <span class="keywordflow">return</span> get_non_null&lt;bool&gt;(</div>
<div class="line"><span class="lineno">  803</span>      field_name, field_kind::BOOLEAN, field_kind::NULLABLE_BOOLEAN, <span class="stringliteral">&quot;Boolean&quot;</span>);</div>
<div class="line"><span class="lineno">  804</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a714d32a8d65dd5815b6e9fa5d3daa7bc" name="a714d32a8d65dd5815b6e9fa5d3daa7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714d32a8d65dd5815b6e9fa5d3daa7bc">&#9670;&#160;</a></span>get_boolean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hazelcast::client::serialization::generic_record::generic_record::get_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00793">793</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  794</span>{</div>
<div class="line"><span class="lineno">  795</span>    <span class="keywordflow">return</span> get_non_null&lt;bool&gt;(</div>
<div class="line"><span class="lineno">  796</span>      field_name, field_kind::BOOLEAN, field_kind::NULLABLE_BOOLEAN, <span class="stringliteral">&quot;Boolean&quot;</span>);</div>
<div class="line"><span class="lineno">  797</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9bc9a6f940b858d2614deb98a2025db9" name="a9bc9a6f940b858d2614deb98a2025db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc9a6f940b858d2614deb98a2025db9">&#9670;&#160;</a></span>get_date() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_date </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>date field consisting of year, month of the year and day of the month as <code><a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01041">1041</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1042</span>{</div>
<div class="line"><span class="lineno"> 1043</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;local_date&gt;&gt;(field_name, field_kind::DATE);</div>
<div class="line"><span class="lineno"> 1044</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abead288cf747dd9191c063c5791c5950" name="abead288cf747dd9191c063c5791c5950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abead288cf747dd9191c063c5791c5950">&#9670;&#160;</a></span>get_date() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_date </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>date field consisting of year, month of the year and day of the month as <code><a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01035">1035</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1036</span>{</div>
<div class="line"><span class="lineno"> 1037</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;local_date&gt;&gt;(field_name, field_kind::DATE);</div>
<div class="line"><span class="lineno"> 1038</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6ee378ca6320b240988204664b6a4d13" name="a6ee378ca6320b240988204664b6a4d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee378ca6320b240988204664b6a4d13">&#9670;&#160;</a></span>get_decimal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_decimal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decimal which is arbitrary precision and scale floating-point number as <code><a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01017">1017</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1018</span>{</div>
<div class="line"><span class="lineno"> 1019</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;big_decimal&gt;&gt;(field_name, field_kind::DECIMAL);</div>
<div class="line"><span class="lineno"> 1020</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acf277041c6f05a77bbe5dfc8686356c8" name="acf277041c6f05a77bbe5dfc8686356c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf277041c6f05a77bbe5dfc8686356c8">&#9670;&#160;</a></span>get_decimal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_decimal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decimal which is arbitrary precision and scale floating-point number as <code><a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01011">1011</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1012</span>{</div>
<div class="line"><span class="lineno"> 1013</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;big_decimal&gt;&gt;(field_name, field_kind::DECIMAL);</div>
<div class="line"><span class="lineno"> 1014</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad2ea3a313d17de70c0cd91c4ac9a8930" name="ad2ea3a313d17de70c0cd91c4ac9a8930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ea3a313d17de70c0cd91c4ac9a8930">&#9670;&#160;</a></span>get_field_kind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dda/namespacehazelcast_1_1client_1_1serialization.html#a248143625dedc7b2c97fec8200c480f5">field_kind</a> hazelcast::client::serialization::generic_record::generic_record::get_field_kind </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the kind of the field for the given field name. </p>
<p>If the field with the given name does not exist, <code><a class="el" href="../../#a248143625dedc7b2c97fec8200c480f5ad07995fa8f4a3a019d134fcbfca4669a">field_kind#NOT_AVAILABLE</a></code> is returned. </p>
<p>This method can be used to check the existence of a field, which can be useful when the class is evolved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kind of the field </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00775">775</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  776</span>{</div>
<div class="line"><span class="lineno">  777</span>    <span class="keyword">auto</span> descriptor = schema_-&gt;get_field(field_name);</div>
<div class="line"><span class="lineno">  778</span> </div>
<div class="line"><span class="lineno">  779</span>    <span class="keywordflow">if</span> (!descriptor) {</div>
<div class="line"><span class="lineno">  780</span>        <span class="keywordflow">return</span> field_kind::NOT_AVAILABLE;</div>
<div class="line"><span class="lineno">  781</span>    }</div>
<div class="line"><span class="lineno">  782</span> </div>
<div class="line"><span class="lineno">  783</span>    <span class="keywordflow">return</span> descriptor-&gt;kind;</div>
<div class="line"><span class="lineno">  784</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abfd6854435e51bc57dcf9e1165d7ef52" name="abfd6854435e51bc57dcf9e1165d7ef52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd6854435e51bc57dcf9e1165d7ef52">&#9670;&#160;</a></span>get_field_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; std::string &gt; hazelcast::client::serialization::generic_record::generic_record::get_field_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>set of field names of this <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00758">758</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  759</span>{</div>
<div class="line"><span class="lineno">  760</span>    std::unordered_set&lt;std::string&gt; field_names;</div>
<div class="line"><span class="lineno">  761</span> </div>
<div class="line"><span class="lineno">  762</span>    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; fields = schema_-&gt;fields();</div>
<div class="line"><span class="lineno">  763</span> </div>
<div class="line"><span class="lineno">  764</span>    transform(begin(fields),</div>
<div class="line"><span class="lineno">  765</span>              end(fields),</div>
<div class="line"><span class="lineno">  766</span>              inserter(field_names, end(field_names)),</div>
<div class="line"><span class="lineno">  767</span>              [](<span class="keyword">const</span> std::pair&lt;std::string, pimpl::field_descriptor&gt;&amp; p) {</div>
<div class="line"><span class="lineno">  768</span>                  <span class="keywordflow">return</span> p.first;</div>
<div class="line"><span class="lineno">  769</span>              });</div>
<div class="line"><span class="lineno">  770</span> </div>
<div class="line"><span class="lineno">  771</span>    <span class="keywordflow">return</span> field_names;</div>
<div class="line"><span class="lineno">  772</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a13411e4de976b0ff1afbcd3130096a9a" name="a13411e4de976b0ff1afbcd3130096a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13411e4de976b0ff1afbcd3130096a9a">&#9670;&#160;</a></span>get_float32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float &amp; hazelcast::client::serialization::generic_record::generic_record::get_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00870">870</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  871</span>{</div>
<div class="line"><span class="lineno">  872</span>    <span class="keywordflow">return</span> get_non_null&lt;float&gt;(</div>
<div class="line"><span class="lineno">  873</span>      field_name, field_kind::FLOAT32, field_kind::NULLABLE_FLOAT32, <span class="stringliteral">&quot;Float32&quot;</span>);</div>
<div class="line"><span class="lineno">  874</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abbe139b1193ca9e7d919a7b0131026f9" name="abbe139b1193ca9e7d919a7b0131026f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe139b1193ca9e7d919a7b0131026f9">&#9670;&#160;</a></span>get_float32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hazelcast::client::serialization::generic_record::generic_record::get_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00863">863</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  864</span>{</div>
<div class="line"><span class="lineno">  865</span>    <span class="keywordflow">return</span> get_non_null&lt;float&gt;(</div>
<div class="line"><span class="lineno">  866</span>      field_name, field_kind::FLOAT32, field_kind::NULLABLE_FLOAT32, <span class="stringliteral">&quot;Float32&quot;</span>);</div>
<div class="line"><span class="lineno">  867</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="adf2ca6e3013c10421c7ab34758f48317" name="adf2ca6e3013c10421c7ab34758f48317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2ca6e3013c10421c7ab34758f48317">&#9670;&#160;</a></span>get_float64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double &amp; hazelcast::client::serialization::generic_record::generic_record::get_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00884">884</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  885</span>{</div>
<div class="line"><span class="lineno">  886</span>    <span class="keywordflow">return</span> get_non_null&lt;double&gt;(</div>
<div class="line"><span class="lineno">  887</span>      field_name, field_kind::FLOAT64, field_kind::NULLABLE_FLOAT64, <span class="stringliteral">&quot;Float64&quot;</span>);</div>
<div class="line"><span class="lineno">  888</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b143babc84fa4e58750b7249ec8a728" name="a3b143babc84fa4e58750b7249ec8a728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b143babc84fa4e58750b7249ec8a728">&#9670;&#160;</a></span>get_float64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double hazelcast::client::serialization::generic_record::generic_record::get_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00877">877</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  878</span>{</div>
<div class="line"><span class="lineno">  879</span>    <span class="keywordflow">return</span> get_non_null&lt;double&gt;(</div>
<div class="line"><span class="lineno">  880</span>      field_name, field_kind::FLOAT64, field_kind::NULLABLE_FLOAT64, <span class="stringliteral">&quot;Float64&quot;</span>);</div>
<div class="line"><span class="lineno">  881</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aae06a17de17f44769ab5c0febff93f27" name="aae06a17de17f44769ab5c0febff93f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae06a17de17f44769ab5c0febff93f27">&#9670;&#160;</a></span>get_generic_record() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_generic_record </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01004">1004</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1005</span>{</div>
<div class="line"><span class="lineno"> 1006</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;generic_record&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1007</span>                                                field_kind::COMPACT);</div>
<div class="line"><span class="lineno"> 1008</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a324d0ce0261501034d525c7d99768e79" name="a324d0ce0261501034d525c7d99768e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324d0ce0261501034d525c7d99768e79">&#9670;&#160;</a></span>get_generic_record() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_generic_record </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00997">997</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  998</span>{</div>
<div class="line"><span class="lineno">  999</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;generic_record&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1000</span>                                                field_kind::COMPACT);</div>
<div class="line"><span class="lineno"> 1001</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a74667307604e64156b68cd4e4af11e09" name="a74667307604e64156b68cd4e4af11e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74667307604e64156b68cd4e4af11e09">&#9670;&#160;</a></span>get_int16() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t &amp; hazelcast::client::serialization::generic_record::generic_record::get_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00828">828</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  829</span>{</div>
<div class="line"><span class="lineno">  830</span>    <span class="keywordflow">return</span> get_non_null&lt;int16_t&gt;(</div>
<div class="line"><span class="lineno">  831</span>      field_name, field_kind::INT16, field_kind::NULLABLE_INT16, <span class="stringliteral">&quot;Int16&quot;</span>);</div>
<div class="line"><span class="lineno">  832</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a45ecdbbc371b27bda548d7fc8309cd87" name="a45ecdbbc371b27bda548d7fc8309cd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ecdbbc371b27bda548d7fc8309cd87">&#9670;&#160;</a></span>get_int16() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t hazelcast::client::serialization::generic_record::generic_record::get_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00821">821</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  822</span>{</div>
<div class="line"><span class="lineno">  823</span>    <span class="keywordflow">return</span> get_non_null&lt;int16_t&gt;(</div>
<div class="line"><span class="lineno">  824</span>      field_name, field_kind::INT16, field_kind::NULLABLE_INT16, <span class="stringliteral">&quot;Int16&quot;</span>);</div>
<div class="line"><span class="lineno">  825</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab5321fab5625c00dc6945d93640fefd1" name="ab5321fab5625c00dc6945d93640fefd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5321fab5625c00dc6945d93640fefd1">&#9670;&#160;</a></span>get_int32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t &amp; hazelcast::client::serialization::generic_record::generic_record::get_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00842">842</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  843</span>{</div>
<div class="line"><span class="lineno">  844</span>    <span class="keywordflow">return</span> get_non_null&lt;int32_t&gt;(</div>
<div class="line"><span class="lineno">  845</span>      field_name, field_kind::INT32, field_kind::NULLABLE_INT32, <span class="stringliteral">&quot;Int32&quot;</span>);</div>
<div class="line"><span class="lineno">  846</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab5ddb93e1bc70f2e83d855e7e66d2f5c" name="ab5ddb93e1bc70f2e83d855e7e66d2f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ddb93e1bc70f2e83d855e7e66d2f5c">&#9670;&#160;</a></span>get_int32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t hazelcast::client::serialization::generic_record::generic_record::get_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00835">835</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  836</span>{</div>
<div class="line"><span class="lineno">  837</span>    <span class="keywordflow">return</span> get_non_null&lt;int32_t&gt;(</div>
<div class="line"><span class="lineno">  838</span>      field_name, field_kind::INT32, field_kind::NULLABLE_INT32, <span class="stringliteral">&quot;Int32&quot;</span>);</div>
<div class="line"><span class="lineno">  839</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1bd52a9dd2d1ba4187dde5c35a245b2c" name="a1bd52a9dd2d1ba4187dde5c35a245b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd52a9dd2d1ba4187dde5c35a245b2c">&#9670;&#160;</a></span>get_int64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t &amp; hazelcast::client::serialization::generic_record::generic_record::get_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00856">856</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  857</span>{</div>
<div class="line"><span class="lineno">  858</span>    <span class="keywordflow">return</span> get_non_null&lt;int64_t&gt;(</div>
<div class="line"><span class="lineno">  859</span>      field_name, field_kind::INT64, field_kind::NULLABLE_INT64, <span class="stringliteral">&quot;Int64&quot;</span>);</div>
<div class="line"><span class="lineno">  860</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a08972f6889fb31c7131fcddc07741b69" name="a08972f6889fb31c7131fcddc07741b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08972f6889fb31c7131fcddc07741b69">&#9670;&#160;</a></span>get_int64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t hazelcast::client::serialization::generic_record::generic_record::get_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00849">849</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  850</span>{</div>
<div class="line"><span class="lineno">  851</span>    <span class="keywordflow">return</span> get_non_null&lt;int64_t&gt;(</div>
<div class="line"><span class="lineno">  852</span>      field_name, field_kind::INT64, field_kind::NULLABLE_INT64, <span class="stringliteral">&quot;Int64&quot;</span>);</div>
<div class="line"><span class="lineno">  853</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a135d1d3fcb76bb8a4308fc2c5d3c833d" name="a135d1d3fcb76bb8a4308fc2c5d3c833d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135d1d3fcb76bb8a4308fc2c5d3c833d">&#9670;&#160;</a></span>get_int8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t &amp; hazelcast::client::serialization::generic_record::generic_record::get_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00814">814</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  815</span>{</div>
<div class="line"><span class="lineno">  816</span>    <span class="keywordflow">return</span> get_non_null&lt;int8_t&gt;(</div>
<div class="line"><span class="lineno">  817</span>      field_name, field_kind::INT8, field_kind::NULLABLE_INT8, <span class="stringliteral">&quot;Int8&quot;</span>);</div>
<div class="line"><span class="lineno">  818</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a867486e399981546274d8e390d3cdf52" name="a867486e399981546274d8e390d3cdf52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867486e399981546274d8e390d3cdf52">&#9670;&#160;</a></span>get_int8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t hazelcast::client::serialization::generic_record::generic_record::get_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00807">807</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  808</span>{</div>
<div class="line"><span class="lineno">  809</span>    <span class="keywordflow">return</span> get_non_null&lt;int8_t&gt;(</div>
<div class="line"><span class="lineno">  810</span>      field_name, field_kind::INT8, field_kind::NULLABLE_INT8, <span class="stringliteral">&quot;Int8&quot;</span>);</div>
<div class="line"><span class="lineno">  811</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1d51814873acede23c821af25b94c84e" name="a1d51814873acede23c821af25b94c84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d51814873acede23c821af25b94c84e">&#9670;&#160;</a></span>get_nullable_boolean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; bool &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_nullable_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00897">897</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  898</span>{</div>
<div class="line"><span class="lineno">  899</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;bool&gt;&gt;(field_name, field_kind::NULLABLE_BOOLEAN);</div>
<div class="line"><span class="lineno">  900</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad1d8e3be66a383c6fbf77397a0eab6dd" name="ad1d8e3be66a383c6fbf77397a0eab6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d8e3be66a383c6fbf77397a0eab6dd">&#9670;&#160;</a></span>get_nullable_boolean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; bool &gt; hazelcast::client::serialization::generic_record::generic_record::get_nullable_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00891">891</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  892</span>{</div>
<div class="line"><span class="lineno">  893</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;bool&gt;&gt;(field_name, field_kind::NULLABLE_BOOLEAN);</div>
<div class="line"><span class="lineno">  894</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="adef63c63455ad97eaada9461f52a14cc" name="adef63c63455ad97eaada9461f52a14cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef63c63455ad97eaada9461f52a14cc">&#9670;&#160;</a></span>get_nullable_float32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; float &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_nullable_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00964">964</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  965</span>{</div>
<div class="line"><span class="lineno">  966</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;float&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno">  967</span>                                       field_kind::NULLABLE_FLOAT32);</div>
<div class="line"><span class="lineno">  968</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a13ee798406d233fde22e846ca7207dac" name="a13ee798406d233fde22e846ca7207dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ee798406d233fde22e846ca7207dac">&#9670;&#160;</a></span>get_nullable_float32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; float &gt; hazelcast::client::serialization::generic_record::generic_record::get_nullable_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00957">957</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  958</span>{</div>
<div class="line"><span class="lineno">  959</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;float&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno">  960</span>                                       field_kind::NULLABLE_FLOAT32);</div>
<div class="line"><span class="lineno">  961</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aabbb3ef2415fbdeecc38964b1cd6e67e" name="aabbb3ef2415fbdeecc38964b1cd6e67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbb3ef2415fbdeecc38964b1cd6e67e">&#9670;&#160;</a></span>get_nullable_float64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; double &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_nullable_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00978">978</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  979</span>{</div>
<div class="line"><span class="lineno">  980</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;double&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno">  981</span>                                        field_kind::NULLABLE_FLOAT64);</div>
<div class="line"><span class="lineno">  982</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a144c440ac39ed5887882ed2eb4c16871" name="a144c440ac39ed5887882ed2eb4c16871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144c440ac39ed5887882ed2eb4c16871">&#9670;&#160;</a></span>get_nullable_float64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; double &gt; hazelcast::client::serialization::generic_record::generic_record::get_nullable_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00971">971</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  972</span>{</div>
<div class="line"><span class="lineno">  973</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;double&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno">  974</span>                                        field_kind::NULLABLE_FLOAT64);</div>
<div class="line"><span class="lineno">  975</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a36610e49f7f341897fe946d75328d810" name="a36610e49f7f341897fe946d75328d810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36610e49f7f341897fe946d75328d810">&#9670;&#160;</a></span>get_nullable_int16() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int16_t &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_nullable_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00922">922</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  923</span>{</div>
<div class="line"><span class="lineno">  924</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;int16_t&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno">  925</span>                                         field_kind::NULLABLE_INT16);</div>
<div class="line"><span class="lineno">  926</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac73021280492c27351155c4b7d1c2776" name="ac73021280492c27351155c4b7d1c2776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73021280492c27351155c4b7d1c2776">&#9670;&#160;</a></span>get_nullable_int16() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int16_t &gt; hazelcast::client::serialization::generic_record::generic_record::get_nullable_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00915">915</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  916</span>{</div>
<div class="line"><span class="lineno">  917</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;int16_t&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno">  918</span>                                         field_kind::NULLABLE_INT16);</div>
<div class="line"><span class="lineno">  919</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac1d6be32c16aa479c5fcd22e2c2cf3a5" name="ac1d6be32c16aa479c5fcd22e2c2cf3a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d6be32c16aa479c5fcd22e2c2cf3a5">&#9670;&#160;</a></span>get_nullable_int32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int32_t &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_nullable_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00936">936</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  937</span>{</div>
<div class="line"><span class="lineno">  938</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;int32_t&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno">  939</span>                                         field_kind::NULLABLE_INT32);</div>
<div class="line"><span class="lineno">  940</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af85b73d459eabf71924ecfc51c4da6a1" name="af85b73d459eabf71924ecfc51c4da6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85b73d459eabf71924ecfc51c4da6a1">&#9670;&#160;</a></span>get_nullable_int32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int32_t &gt; hazelcast::client::serialization::generic_record::generic_record::get_nullable_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00929">929</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  930</span>{</div>
<div class="line"><span class="lineno">  931</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;int32_t&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno">  932</span>                                         field_kind::NULLABLE_INT32);</div>
<div class="line"><span class="lineno">  933</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af88f20ad3d56bfe992d68cd1e3745362" name="af88f20ad3d56bfe992d68cd1e3745362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88f20ad3d56bfe992d68cd1e3745362">&#9670;&#160;</a></span>get_nullable_int64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int64_t &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_nullable_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00950">950</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  951</span>{</div>
<div class="line"><span class="lineno">  952</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;int64_t&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno">  953</span>                                         field_kind::NULLABLE_INT64);</div>
<div class="line"><span class="lineno">  954</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a71f1ce8bf80df090ae378b3331587f52" name="a71f1ce8bf80df090ae378b3331587f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f1ce8bf80df090ae378b3331587f52">&#9670;&#160;</a></span>get_nullable_int64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int64_t &gt; hazelcast::client::serialization::generic_record::generic_record::get_nullable_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00943">943</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  944</span>{</div>
<div class="line"><span class="lineno">  945</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;int64_t&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno">  946</span>                                         field_kind::NULLABLE_INT64);</div>
<div class="line"><span class="lineno">  947</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a355b390a3845681c436d0d09692108ae" name="a355b390a3845681c436d0d09692108ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355b390a3845681c436d0d09692108ae">&#9670;&#160;</a></span>get_nullable_int8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int8_t &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_nullable_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00909">909</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  910</span>{</div>
<div class="line"><span class="lineno">  911</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;int8_t&gt;&gt;(field_name, field_kind::NULLABLE_INT8);</div>
<div class="line"><span class="lineno">  912</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0aeca39439597cd66622d274117d3b1e" name="a0aeca39439597cd66622d274117d3b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aeca39439597cd66622d274117d3b1e">&#9670;&#160;</a></span>get_nullable_int8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int8_t &gt; hazelcast::client::serialization::generic_record::generic_record::get_nullable_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00903">903</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  904</span>{</div>
<div class="line"><span class="lineno">  905</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;int8_t&gt;&gt;(field_name, field_kind::NULLABLE_INT8);</div>
<div class="line"><span class="lineno">  906</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a951656f04ffd5cd5cae6e2bfe6cd4485" name="a951656f04ffd5cd5cae6e2bfe6cd4485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951656f04ffd5cd5cae6e2bfe6cd4485">&#9670;&#160;</a></span>get_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::string &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema/class definition or the type of the field does not match the one in the schema/class definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00991">991</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  992</span>{</div>
<div class="line"><span class="lineno">  993</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::string&gt;&gt;(field_name, field_kind::STRING);</div>
<div class="line"><span class="lineno">  994</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa891502c5e705479906cf00fb481f9b1" name="aa891502c5e705479906cf00fb481f9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa891502c5e705479906cf00fb481f9b1">&#9670;&#160;</a></span>get_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::string &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00985">985</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  986</span>{</div>
<div class="line"><span class="lineno">  987</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::string&gt;&gt;(field_name, field_kind::STRING);</div>
<div class="line"><span class="lineno">  988</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aedb67f6f8d0b9b6b3665777e5c2c7409" name="aedb67f6f8d0b9b6b3665777e5c2c7409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb67f6f8d0b9b6b3665777e5c2c7409">&#9670;&#160;</a></span>get_time() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_time </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>time field consisting of hour, minute, seconds and nanos parts as <code><a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01029">1029</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1030</span>{</div>
<div class="line"><span class="lineno"> 1031</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;local_time&gt;&gt;(field_name, field_kind::TIME);</div>
<div class="line"><span class="lineno"> 1032</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af590dc9ed44075027334666fbbaebc22" name="af590dc9ed44075027334666fbbaebc22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af590dc9ed44075027334666fbbaebc22">&#9670;&#160;</a></span>get_time() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_time </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>time field consisting of hour, minute, seconds and nanos parts as <code><a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01023">1023</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1024</span>{</div>
<div class="line"><span class="lineno"> 1025</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;local_time&gt;&gt;(field_name, field_kind::TIME);</div>
<div class="line"><span class="lineno"> 1026</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0a0a17af5ec6428f88f8aaa57580d514" name="a0a0a17af5ec6428f88f8aaa57580d514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0a17af5ec6428f88f8aaa57580d514">&#9670;&#160;</a></span>get_timestamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_timestamp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>timestamp field consisting of year, month of the year, day of the month, hour, minute, seconds, nanos parts as <code><a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01054">1054</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1055</span>{</div>
<div class="line"><span class="lineno"> 1056</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;local_date_time&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1057</span>                                                 field_kind::TIMESTAMP);</div>
<div class="line"><span class="lineno"> 1058</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7569777ad59a4ba7f75145f5c01ebd6d" name="a7569777ad59a4ba7f75145f5c01ebd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7569777ad59a4ba7f75145f5c01ebd6d">&#9670;&#160;</a></span>get_timestamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_timestamp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>timestamp field consisting of year, month of the year, day of the month, hour, minute, seconds, nanos parts as <code><a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01047">1047</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1048</span>{</div>
<div class="line"><span class="lineno"> 1049</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;local_date_time&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1050</span>                                                 field_kind::TIMESTAMP);</div>
<div class="line"><span class="lineno"> 1051</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a036490b36cb12625db194a62cfb12a0b" name="a036490b36cb12625db194a62cfb12a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036490b36cb12625db194a62cfb12a0b">&#9670;&#160;</a></span>get_timestamp_with_timezone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_timestamp_with_timezone </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>timestamp with timezone field consisting of year, month of the year, day of the month, offset seconds, hour, minute, seconds, nanos parts as <code><a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01068">1068</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1069</span>{</div>
<div class="line"><span class="lineno"> 1070</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;offset_date_time&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1071</span>      field_name, field_kind::TIMESTAMP_WITH_TIMEZONE);</div>
<div class="line"><span class="lineno"> 1072</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6da8a5af57b79f7b23518ec39e21a053" name="a6da8a5af57b79f7b23518ec39e21a053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da8a5af57b79f7b23518ec39e21a053">&#9670;&#160;</a></span>get_timestamp_with_timezone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_timestamp_with_timezone </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>timestamp with timezone field consisting of year, month of the year, day of the month, offset seconds, hour, minute, seconds, nanos parts as <code><a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01061">1061</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1062</span>{</div>
<div class="line"><span class="lineno"> 1063</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;offset_date_time&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1064</span>      field_name, field_kind::TIMESTAMP_WITH_TIMEZONE);</div>
<div class="line"><span class="lineno"> 1065</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7714133e6dd7b939d6e4230a4f259ed2" name="a7714133e6dd7b939d6e4230a4f259ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7714133e6dd7b939d6e4230a4f259ed2">&#9670;&#160;</a></span>has_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hazelcast::client::serialization::generic_record::generic_record::has_field </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if field exists in the schema/class definition. Note that returns true even if the field is null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00787">787</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  788</span>{</div>
<div class="line"><span class="lineno">  789</span>    <span class="keywordflow">return</span> objects_.find(field_name) != end(objects_);</div>
<div class="line"><span class="lineno">  790</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a511d0dfcf85537bea02a6060170b5e34" name="a511d0dfcf85537bea02a6060170b5e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511d0dfcf85537bea02a6060170b5e34">&#9670;&#160;</a></span>new_builder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> hazelcast::client::serialization::generic_record::generic_record::new_builder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <code><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a></code> allows to create a new object. </p>
<p>This method is a convenience method to get a builder, without creating the schema/class definition for this type. Here you can see a new object is constructed from an existing <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> with its schema definition:</p>
<pre><code class="JavaDocCode"><br/>
generic_record new_record = record.new_builder()<br/>
     .set_string("name", "bar")<br/>
     .set_int32("id", 4)<br/>
     .build();<br/>
</code></pre><p> &lt;p&lt;blockquote&gt;&zwj; </p>
<p>See <code><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a></code> to create a <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> in <code><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a></code> to create a <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> in Compact format with a different schema.</p>
<dl class="section return"><dt>Returns</dt><dd>an empty generic record builder with same schema as this one </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00746">746</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  747</span>{</div>
<div class="line"><span class="lineno">  748</span>    <span class="keywordflow">return</span> generic_record_builder{ schema_ };</div>
<div class="line"><span class="lineno">  749</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9be4ec9ba393576c4ec4607cc42eafbd" name="a9be4ec9ba393576c4ec4607cc42eafbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be4ec9ba393576c4ec4607cc42eafbd">&#9670;&#160;</a></span>new_builder_with_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> hazelcast::client::serialization::generic_record::generic_record::new_builder_with_clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returned <code><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a></code> can be used to have exact copy and also just to update a couple of fields. </p>
<p>By default, it will copy all the fields. So instead of following where only the <code>id</code> field is updated, </p><pre><code class="JavaDocCode"><br/>
generic_record modified_record = record.newBuilder()<br/>
        .set_string("name", record.get_string("name"))<br/>
        .set_int64("id", 4)<br/>
        .set_string("surname", record.get_string("surname"))<br/>
        .set_int32("age", record.get_int32("age"))<br/>
        .build();<br/>
</code></pre><p> <code>new_builder_with_clone</code> used as follows: </p><pre><code class="JavaDocCode"><br/>
generic_record modified_record = record.new_builder_with_clone()<br/>
        .set_int32("id", 4)<br/>
        .build();<br/>
</code></pre><dl class="section return"><dt>Returns</dt><dd>a generic record builder with same schema definition as this one and populated with same values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00752">752</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  753</span>{</div>
<div class="line"><span class="lineno">  754</span>    <span class="keywordflow">return</span> generic_record_builder{ schema_, objects_ };</div>
<div class="line"><span class="lineno">  755</span>}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a43e6ffbe06e93b1c3c131a18e4d21b3b" name="a43e6ffbe06e93b1c3c131a18e4d21b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e6ffbe06e93b1c3c131a18e4d21b3b">&#9670;&#160;</a></span>generic_record_builder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d8/d76/generic__record_8h_source.html#l01034">1034</a> of file <a class="el" href="../../d8/d76/generic__record_8h_source.html">generic_record.h</a>.</p>

</div>
</div>
<a id="aff0e36cea8a99b0d0adc16459890aeec" name="aff0e36cea8a99b0d0adc16459890aeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0e36cea8a99b0d0adc16459890aeec">&#9670;&#160;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HAZELCAST_API operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01708">1708</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1709</span>{</div>
<div class="line"><span class="lineno"> 1710</span>    <span class="keywordflow">return</span> !(x == y);</div>
<div class="line"><span class="lineno"> 1711</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a778ca519c51aba88b1b6f240f2725d55" name="a778ca519c51aba88b1b6f240f2725d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778ca519c51aba88b1b6f240f2725d55">&#9670;&#160;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream HAZELCAST_API &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;&#160;</td>
          <td class="paramname"><em>record</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01446">1446</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1448</span>{</div>
<div class="line"><span class="lineno"> 1449</span>    boost::property_tree::ptree pt;</div>
<div class="line"><span class="lineno"> 1450</span> </div>
<div class="line"><span class="lineno"> 1451</span>    pt.put_child(record.get_schema().type_name(), write_generic_record(record));</div>
<div class="line"><span class="lineno"> 1452</span> </div>
<div class="line"><span class="lineno"> 1453</span>    boost::property_tree::write_json(os, pt);</div>
<div class="line"><span class="lineno"> 1454</span> </div>
<div class="line"><span class="lineno"> 1455</span>    <span class="keywordflow">return</span> os;</div>
<div class="line"><span class="lineno"> 1456</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac373fa6215c12b50cee2a36062f2ee91" name="ac373fa6215c12b50cee2a36062f2ee91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac373fa6215c12b50cee2a36062f2ee91">&#9670;&#160;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HAZELCAST_API operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01459">1459</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1460</span>{</div>
<div class="line"><span class="lineno"> 1461</span>    <span class="keyword">static</span> <span class="keyword">const</span> std::function&lt;bool(<span class="keyword">const</span> boost::any&amp;, <span class="keyword">const</span> boost::any&amp;)&gt;</div>
<div class="line"><span class="lineno"> 1462</span>      COMPARATORS[] = {</div>
<div class="line"><span class="lineno"> 1463</span>          [](<span class="keyword">const</span> boost::any&amp;, <span class="keyword">const</span> boost::any&amp;) {</div>
<div class="line"><span class="lineno"> 1464</span>              <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1465</span>          },                                             <span class="comment">//[0] NOT_AVAILABLE</span></div>
<div class="line"><span class="lineno"> 1466</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[1] BOOLEAN</span></div>
<div class="line"><span class="lineno"> 1467</span>              <span class="keywordflow">return</span> boost::any_cast&lt;bool&gt;(x) == boost::any_cast&lt;bool&gt;(y);</div>
<div class="line"><span class="lineno"> 1468</span>          },</div>
<div class="line"><span class="lineno"> 1469</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[2] ARRAY_OF_BOOLEAN</span></div>
<div class="line"><span class="lineno"> 1470</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;std::vector&lt;bool&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1471</span>                     boost::any_cast&lt;boost::optional&lt;std::vector&lt;bool&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1472</span>          },</div>
<div class="line"><span class="lineno"> 1473</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[3] INT8</span></div>
<div class="line"><span class="lineno"> 1474</span>              <span class="keywordflow">return</span> boost::any_cast&lt;int8_t&gt;(x) == boost::any_cast&lt;int8_t&gt;(y);</div>
<div class="line"><span class="lineno"> 1475</span>          },</div>
<div class="line"><span class="lineno"> 1476</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[4] ARRAY_OF_INT8</span></div>
<div class="line"><span class="lineno"> 1477</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;std::vector&lt;int8_t&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1478</span>                     boost::any_cast&lt;boost::optional&lt;std::vector&lt;int8_t&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1479</span>          },</div>
<div class="line"><span class="lineno"> 1480</span>          [](<span class="keyword">const</span> boost::any&amp;, <span class="keyword">const</span> boost::any&amp;) { <span class="keywordflow">return</span> <span class="keyword">false</span>; }, <span class="comment">// [5]</span></div>
<div class="line"><span class="lineno"> 1481</span>          [](<span class="keyword">const</span> boost::any&amp;, <span class="keyword">const</span> boost::any&amp;) { <span class="keywordflow">return</span> <span class="keyword">false</span>; }, <span class="comment">// [6]</span></div>
<div class="line"><span class="lineno"> 1482</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[7] INT16</span></div>
<div class="line"><span class="lineno"> 1483</span>              <span class="keywordflow">return</span> boost::any_cast&lt;int16_t&gt;(x) == boost::any_cast&lt;int16_t&gt;(y);</div>
<div class="line"><span class="lineno"> 1484</span>          },</div>
<div class="line"><span class="lineno"> 1485</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[8] ARRAY_OF_INT16</span></div>
<div class="line"><span class="lineno"> 1486</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;std::vector&lt;int16_t&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1487</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1488</span>                     boost::any_cast&lt;boost::optional&lt;std::vector&lt;int16_t&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1489</span>          },</div>
<div class="line"><span class="lineno"> 1490</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[9] INT32</span></div>
<div class="line"><span class="lineno"> 1491</span>              <span class="keywordflow">return</span> boost::any_cast&lt;int32_t&gt;(x) == boost::any_cast&lt;int32_t&gt;(y);</div>
<div class="line"><span class="lineno"> 1492</span>          },</div>
<div class="line"><span class="lineno"> 1493</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[10] ARRAY_OF_INT32</span></div>
<div class="line"><span class="lineno"> 1494</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;std::vector&lt;int32_t&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1495</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1496</span>                     boost::any_cast&lt;boost::optional&lt;std::vector&lt;int32_t&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1497</span>          },</div>
<div class="line"><span class="lineno"> 1498</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[11] INT64</span></div>
<div class="line"><span class="lineno"> 1499</span>              <span class="keywordflow">return</span> boost::any_cast&lt;int64_t&gt;(x) == boost::any_cast&lt;int64_t&gt;(y);</div>
<div class="line"><span class="lineno"> 1500</span>          },</div>
<div class="line"><span class="lineno"> 1501</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[12] ARRAY_OF_INT64</span></div>
<div class="line"><span class="lineno"> 1502</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;std::vector&lt;int64_t&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1503</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1504</span>                     boost::any_cast&lt;boost::optional&lt;std::vector&lt;int64_t&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1505</span>          },</div>
<div class="line"><span class="lineno"> 1506</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[13] FLOAT32</span></div>
<div class="line"><span class="lineno"> 1507</span>              <span class="keywordflow">return</span> boost::any_cast&lt;float&gt;(x) == boost::any_cast&lt;float&gt;(y);</div>
<div class="line"><span class="lineno"> 1508</span>          },</div>
<div class="line"><span class="lineno"> 1509</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[14] ARRAY_OF_FLOAT32</span></div>
<div class="line"><span class="lineno"> 1510</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;std::vector&lt;float&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1511</span>                     boost::any_cast&lt;boost::optional&lt;std::vector&lt;float&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1512</span>          },</div>
<div class="line"><span class="lineno"> 1513</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[15] FLOAT64</span></div>
<div class="line"><span class="lineno"> 1514</span>              <span class="keywordflow">return</span> boost::any_cast&lt;double&gt;(x) == boost::any_cast&lt;double&gt;(y);</div>
<div class="line"><span class="lineno"> 1515</span>          },</div>
<div class="line"><span class="lineno"> 1516</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[16] ARRAY_OF_FLOAT64</span></div>
<div class="line"><span class="lineno"> 1517</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;std::vector&lt;double&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1518</span>                     boost::any_cast&lt;boost::optional&lt;std::vector&lt;double&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1519</span>          },</div>
<div class="line"><span class="lineno"> 1520</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[17] STRING</span></div>
<div class="line"><span class="lineno"> 1521</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;std::string&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1522</span>                     boost::any_cast&lt;boost::optional&lt;std::string&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1523</span>          },</div>
<div class="line"><span class="lineno"> 1524</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[18] ARRAY_OF_STRING</span></div>
<div class="line"><span class="lineno"> 1525</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1526</span>                       std::vector&lt;boost::optional&lt;std::string&gt;&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1527</span>                     boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1528</span>                       std::vector&lt;boost::optional&lt;std::string&gt;&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1529</span>          },</div>
<div class="line"><span class="lineno"> 1530</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[19] DECIMAL</span></div>
<div class="line"><span class="lineno"> 1531</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;big_decimal&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1532</span>                     boost::any_cast&lt;boost::optional&lt;big_decimal&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1533</span>          },</div>
<div class="line"><span class="lineno"> 1534</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[20] ARRAY_OF_DECIMAL</span></div>
<div class="line"><span class="lineno"> 1535</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1536</span>                       std::vector&lt;boost::optional&lt;big_decimal&gt;&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1537</span>                     boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1538</span>                       std::vector&lt;boost::optional&lt;big_decimal&gt;&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1539</span>          },</div>
<div class="line"><span class="lineno"> 1540</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[21] TIME</span></div>
<div class="line"><span class="lineno"> 1541</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;local_time&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1542</span>                     boost::any_cast&lt;boost::optional&lt;local_time&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1543</span>          },</div>
<div class="line"><span class="lineno"> 1544</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[22] ARRAY_OF_TIME</span></div>
<div class="line"><span class="lineno"> 1545</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1546</span>                       std::vector&lt;boost::optional&lt;local_time&gt;&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1547</span>                     boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1548</span>                       std::vector&lt;boost::optional&lt;local_time&gt;&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1549</span>          },</div>
<div class="line"><span class="lineno"> 1550</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[23] DATE</span></div>
<div class="line"><span class="lineno"> 1551</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;local_date&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1552</span>                     boost::any_cast&lt;boost::optional&lt;local_date&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1553</span>          },</div>
<div class="line"><span class="lineno"> 1554</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[24] ARRAY_OF_DATE</span></div>
<div class="line"><span class="lineno"> 1555</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1556</span>                       std::vector&lt;boost::optional&lt;local_date&gt;&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1557</span>                     boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1558</span>                       std::vector&lt;boost::optional&lt;local_date&gt;&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1559</span>          },</div>
<div class="line"><span class="lineno"> 1560</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[25] TIMESTAMP</span></div>
<div class="line"><span class="lineno"> 1561</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;local_date_time&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1562</span>                     boost::any_cast&lt;boost::optional&lt;local_date_time&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1563</span>          },</div>
<div class="line"><span class="lineno"> 1564</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1565</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[26] ARRAY_OF_TIMESTAMP</span></div>
<div class="line"><span class="lineno"> 1566</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1567</span>                       std::vector&lt;boost::optional&lt;local_date_time&gt;&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1568</span>                     boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1569</span>                       std::vector&lt;boost::optional&lt;local_date_time&gt;&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1570</span>          },</div>
<div class="line"><span class="lineno"> 1571</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1572</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[27] TIMESTAMP_WITH_TIMEZONE</span></div>
<div class="line"><span class="lineno"> 1573</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;offset_date_time&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1574</span>                     boost::any_cast&lt;boost::optional&lt;offset_date_time&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1575</span>          },</div>
<div class="line"><span class="lineno"> 1576</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1577</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[28] ARRAY_OF_TIMESTAMP_WITH_TIMEZON</span></div>
<div class="line"><span class="lineno"> 1578</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1579</span>                       std::vector&lt;boost::optional&lt;offset_date_time&gt;&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1580</span>                     boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1581</span>                       std::vector&lt;boost::optional&lt;offset_date_time&gt;&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1582</span>          },</div>
<div class="line"><span class="lineno"> 1583</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[29] COMPACT</span></div>
<div class="line"><span class="lineno"> 1584</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;generic_record&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1585</span>                     boost::any_cast&lt;boost::optional&lt;generic_record&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1586</span>          },</div>
<div class="line"><span class="lineno"> 1587</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[30] ARRAY_OF_COMPACT</span></div>
<div class="line"><span class="lineno"> 1588</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1589</span>                       std::vector&lt;boost::optional&lt;generic_record&gt;&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1590</span>                     boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1591</span>                       std::vector&lt;boost::optional&lt;generic_record&gt;&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1592</span>          },</div>
<div class="line"><span class="lineno"> 1593</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="keywordflow">return</span> <span class="keyword">false</span>; }, <span class="comment">//[31]</span></div>
<div class="line"><span class="lineno"> 1594</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="keywordflow">return</span> <span class="keyword">false</span>; }, <span class="comment">//[32]</span></div>
<div class="line"><span class="lineno"> 1595</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[33] NULLABLE_BOOLEAN</span></div>
<div class="line"><span class="lineno"> 1596</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;bool&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1597</span>                     boost::any_cast&lt;boost::optional&lt;bool&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1598</span>          },</div>
<div class="line"><span class="lineno"> 1599</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1600</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[34] ARRAY_OF_NULLABLE_BOOLEAN</span></div>
<div class="line"><span class="lineno"> 1601</span>              <span class="keywordflow">return</span> boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1602</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;bool&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1603</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1604</span>                     boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1605</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;bool&gt;&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1606</span>          },</div>
<div class="line"><span class="lineno"> 1607</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[35] NULLABLE_INT8</span></div>
<div class="line"><span class="lineno"> 1608</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;int8_t&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1609</span>                     boost::any_cast&lt;boost::optional&lt;int8_t&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1610</span>          },</div>
<div class="line"><span class="lineno"> 1611</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1612</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[36] ARRAY_OF_NULLABLE_INT8</span></div>
<div class="line"><span class="lineno"> 1613</span>              <span class="keywordflow">return</span> boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1614</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;int8_t&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1615</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1616</span>                     boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1617</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;int8_t&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1618</span>                       y);</div>
<div class="line"><span class="lineno"> 1619</span>          },</div>
<div class="line"><span class="lineno"> 1620</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[37] NULLABLE_INT16</span></div>
<div class="line"><span class="lineno"> 1621</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;int16_t&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1622</span>                     boost::any_cast&lt;boost::optional&lt;int16_t&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1623</span>          },</div>
<div class="line"><span class="lineno"> 1624</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1625</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[38] ARRAY_OF_NULLABLE_INT16</span></div>
<div class="line"><span class="lineno"> 1626</span>              <span class="keywordflow">return</span> boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1627</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;int16_t&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1628</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1629</span>                     boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1630</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;int16_t&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1631</span>                       y);</div>
<div class="line"><span class="lineno"> 1632</span>          },</div>
<div class="line"><span class="lineno"> 1633</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[39] NULLABLE_INT32</span></div>
<div class="line"><span class="lineno"> 1634</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;int32_t&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1635</span>                     boost::any_cast&lt;boost::optional&lt;int32_t&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1636</span>          },</div>
<div class="line"><span class="lineno"> 1637</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1638</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[40] ARRAY_OF_NULLABLE_INT32</span></div>
<div class="line"><span class="lineno"> 1639</span>              <span class="keywordflow">return</span> boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1640</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;int32_t&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1641</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1642</span>                     boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1643</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;int32_t&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1644</span>                       y);</div>
<div class="line"><span class="lineno"> 1645</span>          },</div>
<div class="line"><span class="lineno"> 1646</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[41] NULLABLE_INT64</span></div>
<div class="line"><span class="lineno"> 1647</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;int64_t&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1648</span>                     boost::any_cast&lt;boost::optional&lt;int64_t&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1649</span>          },</div>
<div class="line"><span class="lineno"> 1650</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1651</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[42] ARRAY_OF_NULLABLE_INT64</span></div>
<div class="line"><span class="lineno"> 1652</span>              <span class="keywordflow">return</span> boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1653</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;int64_t&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1654</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1655</span>                     boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1656</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;int64_t&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1657</span>                       y);</div>
<div class="line"><span class="lineno"> 1658</span>          },</div>
<div class="line"><span class="lineno"> 1659</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[43] NULLABLE_FLOAT32</span></div>
<div class="line"><span class="lineno"> 1660</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;float&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1661</span>                     boost::any_cast&lt;boost::optional&lt;float&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1662</span>          },</div>
<div class="line"><span class="lineno"> 1663</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1664</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[44] ARRAY_OF_NULLABLE_FLOAT32</span></div>
<div class="line"><span class="lineno"> 1665</span>              <span class="keywordflow">return</span> boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1666</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;float&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1667</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1668</span>                     boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1669</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;float&gt;&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1670</span>          },</div>
<div class="line"><span class="lineno"> 1671</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[45] NULLABLE_FLOAT64</span></div>
<div class="line"><span class="lineno"> 1672</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;double&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1673</span>                     boost::any_cast&lt;boost::optional&lt;double&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1674</span>          },</div>
<div class="line"><span class="lineno"> 1675</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1676</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[46] ARRAY_OF_NULLABLE_FLOAT64</span></div>
<div class="line"><span class="lineno"> 1677</span>              <span class="keywordflow">return</span> boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1678</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;double&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1679</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1680</span>                     boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1681</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;double&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1682</span>                       y);</div>
<div class="line"><span class="lineno"> 1683</span>          }</div>
<div class="line"><span class="lineno"> 1684</span>      };</div>
<div class="line"><span class="lineno"> 1685</span> </div>
<div class="line"><span class="lineno"> 1686</span>    <span class="keyword">const</span> pimpl::schema&amp; xs = x.get_schema();</div>
<div class="line"><span class="lineno"> 1687</span>    <span class="keyword">const</span> pimpl::schema&amp; ys = y.get_schema();</div>
<div class="line"><span class="lineno"> 1688</span> </div>
<div class="line"><span class="lineno"> 1689</span>    <span class="keywordflow">if</span> (xs != ys)</div>
<div class="line"><span class="lineno"> 1690</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1691</span> </div>
<div class="line"><span class="lineno"> 1692</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;const std::string, boost::any&gt;&amp; xp : x.objects_) {</div>
<div class="line"><span class="lineno"> 1693</span>        <span class="keyword">const</span> std::string&amp; field_name = xp.first;</div>
<div class="line"><span class="lineno"> 1694</span>        <span class="keyword">const</span> boost::any&amp; value_of_x = xp.second;</div>
<div class="line"><span class="lineno"> 1695</span>        <span class="keyword">const</span> boost::any&amp; value_of_y = y.objects_.at(field_name);</div>
<div class="line"><span class="lineno"> 1696</span> </div>
<div class="line"><span class="lineno"> 1697</span>        boost::optional&lt;pimpl::field_descriptor&gt; kind_opt =</div>
<div class="line"><span class="lineno"> 1698</span>          xs.get_field(field_name);</div>
<div class="line"><span class="lineno"> 1699</span> </div>
<div class="line"><span class="lineno"> 1700</span>        <span class="keywordflow">if</span> (!COMPARATORS[std::size_t(kind_opt-&gt;kind)](value_of_x, value_of_y))</div>
<div class="line"><span class="lineno"> 1701</span>            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1702</span>    }</div>
<div class="line"><span class="lineno"> 1703</span> </div>
<div class="line"><span class="lineno"> 1704</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1705</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a51a96bb9ebecd6d3a6506dffa0173d93" name="a51a96bb9ebecd6d3a6506dffa0173d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a96bb9ebecd6d3a6506dffa0173d93">&#9670;&#160;</a></span>pimpl::compact_stream_serializer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class pimpl::compact_stream_serializer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d8/d76/generic__record_8h_source.html#l01035">1035</a> of file <a class="el" href="../../d8/d76/generic__record_8h_source.html">generic_record.h</a>.</p>

</div>
</div>
<a id="ad9f40f26e342b61258d571760a3bbc25" name="ad9f40f26e342b61258d571760a3bbc25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f40f26e342b61258d571760a3bbc25">&#9670;&#160;</a></span>write_generic_record</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::property_tree::ptree write_generic_record </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01430">1430</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1431</span>{</div>
<div class="line"><span class="lineno"> 1432</span>    boost::property_tree::ptree node;</div>
<div class="line"><span class="lineno"> 1433</span> </div>
<div class="line"><span class="lineno"> 1434</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;const std::string, boost::any&gt;&amp; p : record.objects_) {</div>
<div class="line"><span class="lineno"> 1435</span>        <span class="keyword">const</span> std::string&amp; field_name = p.first;</div>
<div class="line"><span class="lineno"> 1436</span> </div>
<div class="line"><span class="lineno"> 1437</span>        <a class="code hl_enumeration" href="../../db/dda/namespacehazelcast_1_1client_1_1serialization.html#a248143625dedc7b2c97fec8200c480f5">field_kind</a> kind = record.get_schema().get_field(field_name)-&gt;kind;</div>
<div class="line"><span class="lineno"> 1438</span> </div>
<div class="line"><span class="lineno"> 1439</span>        pimpl::field_operations::get(kind).write_json_formatted_field(</div>
<div class="line"><span class="lineno"> 1440</span>          node, record, field_name);</div>
<div class="line"><span class="lineno"> 1441</span>    }</div>
<div class="line"><span class="lineno"> 1442</span> </div>
<div class="line"><span class="lineno"> 1443</span>    <span class="keywordflow">return</span> node;</div>
<div class="line"><span class="lineno"> 1444</span>}</div>
<div class="ttc" id="anamespacehazelcast_1_1client_1_1serialization_html_a248143625dedc7b2c97fec8200c480f5"><div class="ttname"><a href="../../db/dda/namespacehazelcast_1_1client_1_1serialization.html#a248143625dedc7b2c97fec8200c480f5">hazelcast::client::serialization::field_kind</a></div><div class="ttdeci">field_kind</div><div class="ttdoc">field_kind</div><div class="ttdef"><b>Definition:</b> <a href="../../da/da0/field__kind_8h_source.html#l00036">field_kind.h:37</a></div></div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>hazelcast/include/hazelcast/client/serialization/<a class="el" href="../../d8/d76/generic__record_8h_source.html">generic_record.h</a></li>
<li>hazelcast/src/hazelcast/client/<a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../de/db5/namespacehazelcast.html">hazelcast</a></li><li class="navelem"><a class="el" href="../../da/d95/namespacehazelcast_1_1client.html">client</a></li><li class="navelem"><a class="el" href="../../db/dda/namespacehazelcast_1_1client_1_1serialization.html">serialization</a></li><li class="navelem"><b>generic_record</b></li><li class="navelem"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a></li>
    <li class="footer">Generated on Wed Mar 15 2023 18:23:47 for Hazelcast C++ Client by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
