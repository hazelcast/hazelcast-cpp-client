<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hazelcast C++ Client: hazelcast::client::serialization::generic_record::generic_record Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../IMDG_blue_logo_square_RGB-dark_200px.png"/></td>
  <td id="projectalign">
   <div id="projectname">Hazelcast C++ Client
   </div>
   <div id="projectbrief">Hazelcast C++ Client Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d5/dce/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">hazelcast::client::serialization::generic_record::generic_record Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A generic object interface that is returned to the user when the domain class can not be created from any of the distributed Hazelcast data structures like <code><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html">imap</a></code>, <code><a class="el" href="../../dd/df1/classhazelcast_1_1client_1_1iqueue.html">iqueue</a></code> etc.  
 <a href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d8/d76/generic__record_8h_source.html">generic_record.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a511d0dfcf85537bea02a6060170b5e34" id="r_a511d0dfcf85537bea02a6060170b5e34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a511d0dfcf85537bea02a6060170b5e34">new_builder</a> () const</td></tr>
<tr class="memdesc:a511d0dfcf85537bea02a6060170b5e34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a></code> allows to create a new object.  <br /></td></tr>
<tr class="separator:a511d0dfcf85537bea02a6060170b5e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be4ec9ba393576c4ec4607cc42eafbd" id="r_a9be4ec9ba393576c4ec4607cc42eafbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">new_builder_with_clone</a> () const</td></tr>
<tr class="memdesc:a9be4ec9ba393576c4ec4607cc42eafbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returned <code><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a></code> can be used to have exact copy and also just to update a couple of fields.  <br /></td></tr>
<tr class="separator:a9be4ec9ba393576c4ec4607cc42eafbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd6854435e51bc57dcf9e1165d7ef52" id="r_abfd6854435e51bc57dcf9e1165d7ef52"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#abfd6854435e51bc57dcf9e1165d7ef52">get_field_names</a> () const</td></tr>
<tr class="separator:abfd6854435e51bc57dcf9e1165d7ef52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ea3a313d17de70c0cd91c4ac9a8930" id="r_ad2ea3a313d17de70c0cd91c4ac9a8930"><td class="memItemLeft" align="right" valign="top">field_kind&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ad2ea3a313d17de70c0cd91c4ac9a8930">get_field_kind</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:ad2ea3a313d17de70c0cd91c4ac9a8930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the kind of the field for the given field name.  <br /></td></tr>
<tr class="separator:ad2ea3a313d17de70c0cd91c4ac9a8930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7714133e6dd7b939d6e4230a4f259ed2" id="r_a7714133e6dd7b939d6e4230a4f259ed2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a7714133e6dd7b939d6e4230a4f259ed2">has_field</a> (std::string field_name) const</td></tr>
<tr class="separator:a7714133e6dd7b939d6e4230a4f259ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714d32a8d65dd5815b6e9fa5d3daa7bc" id="r_a714d32a8d65dd5815b6e9fa5d3daa7bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a714d32a8d65dd5815b6e9fa5d3daa7bc">get_boolean</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a714d32a8d65dd5815b6e9fa5d3daa7bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c753233daa8dd84131a13ab53d030cc" id="r_a2c753233daa8dd84131a13ab53d030cc"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a2c753233daa8dd84131a13ab53d030cc">get_boolean</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a2c753233daa8dd84131a13ab53d030cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867486e399981546274d8e390d3cdf52" id="r_a867486e399981546274d8e390d3cdf52"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a867486e399981546274d8e390d3cdf52">get_int8</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a867486e399981546274d8e390d3cdf52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135d1d3fcb76bb8a4308fc2c5d3c833d" id="r_a135d1d3fcb76bb8a4308fc2c5d3c833d"><td class="memItemLeft" align="right" valign="top">int8_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a135d1d3fcb76bb8a4308fc2c5d3c833d">get_int8</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a135d1d3fcb76bb8a4308fc2c5d3c833d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ecdbbc371b27bda548d7fc8309cd87" id="r_a45ecdbbc371b27bda548d7fc8309cd87"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a45ecdbbc371b27bda548d7fc8309cd87">get_int16</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a45ecdbbc371b27bda548d7fc8309cd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74667307604e64156b68cd4e4af11e09" id="r_a74667307604e64156b68cd4e4af11e09"><td class="memItemLeft" align="right" valign="top">int16_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a74667307604e64156b68cd4e4af11e09">get_int16</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a74667307604e64156b68cd4e4af11e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ddb93e1bc70f2e83d855e7e66d2f5c" id="r_ab5ddb93e1bc70f2e83d855e7e66d2f5c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ab5ddb93e1bc70f2e83d855e7e66d2f5c">get_int32</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:ab5ddb93e1bc70f2e83d855e7e66d2f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5321fab5625c00dc6945d93640fefd1" id="r_ab5321fab5625c00dc6945d93640fefd1"><td class="memItemLeft" align="right" valign="top">int32_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ab5321fab5625c00dc6945d93640fefd1">get_int32</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:ab5321fab5625c00dc6945d93640fefd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08972f6889fb31c7131fcddc07741b69" id="r_a08972f6889fb31c7131fcddc07741b69"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a08972f6889fb31c7131fcddc07741b69">get_int64</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a08972f6889fb31c7131fcddc07741b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd52a9dd2d1ba4187dde5c35a245b2c" id="r_a1bd52a9dd2d1ba4187dde5c35a245b2c"><td class="memItemLeft" align="right" valign="top">int64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a1bd52a9dd2d1ba4187dde5c35a245b2c">get_int64</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a1bd52a9dd2d1ba4187dde5c35a245b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe139b1193ca9e7d919a7b0131026f9" id="r_abbe139b1193ca9e7d919a7b0131026f9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#abbe139b1193ca9e7d919a7b0131026f9">get_float32</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:abbe139b1193ca9e7d919a7b0131026f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13411e4de976b0ff1afbcd3130096a9a" id="r_a13411e4de976b0ff1afbcd3130096a9a"><td class="memItemLeft" align="right" valign="top">float &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a13411e4de976b0ff1afbcd3130096a9a">get_float32</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a13411e4de976b0ff1afbcd3130096a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b143babc84fa4e58750b7249ec8a728" id="r_a3b143babc84fa4e58750b7249ec8a728"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a3b143babc84fa4e58750b7249ec8a728">get_float64</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a3b143babc84fa4e58750b7249ec8a728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2ca6e3013c10421c7ab34758f48317" id="r_adf2ca6e3013c10421c7ab34758f48317"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#adf2ca6e3013c10421c7ab34758f48317">get_float64</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:adf2ca6e3013c10421c7ab34758f48317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa891502c5e705479906cf00fb481f9b1" id="r_aa891502c5e705479906cf00fb481f9b1"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aa891502c5e705479906cf00fb481f9b1">get_string</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:aa891502c5e705479906cf00fb481f9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951656f04ffd5cd5cae6e2bfe6cd4485" id="r_a951656f04ffd5cd5cae6e2bfe6cd4485"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a951656f04ffd5cd5cae6e2bfe6cd4485">get_string</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a951656f04ffd5cd5cae6e2bfe6cd4485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf277041c6f05a77bbe5dfc8686356c8" id="r_acf277041c6f05a77bbe5dfc8686356c8"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#acf277041c6f05a77bbe5dfc8686356c8">get_decimal</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:acf277041c6f05a77bbe5dfc8686356c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee378ca6320b240988204664b6a4d13" id="r_a6ee378ca6320b240988204664b6a4d13"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a6ee378ca6320b240988204664b6a4d13">get_decimal</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a6ee378ca6320b240988204664b6a4d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af590dc9ed44075027334666fbbaebc22" id="r_af590dc9ed44075027334666fbbaebc22"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#af590dc9ed44075027334666fbbaebc22">get_time</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:af590dc9ed44075027334666fbbaebc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb67f6f8d0b9b6b3665777e5c2c7409" id="r_aedb67f6f8d0b9b6b3665777e5c2c7409"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aedb67f6f8d0b9b6b3665777e5c2c7409">get_time</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:aedb67f6f8d0b9b6b3665777e5c2c7409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abead288cf747dd9191c063c5791c5950" id="r_abead288cf747dd9191c063c5791c5950"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#abead288cf747dd9191c063c5791c5950">get_date</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:abead288cf747dd9191c063c5791c5950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc9a6f940b858d2614deb98a2025db9" id="r_a9bc9a6f940b858d2614deb98a2025db9"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9bc9a6f940b858d2614deb98a2025db9">get_date</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a9bc9a6f940b858d2614deb98a2025db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7569777ad59a4ba7f75145f5c01ebd6d" id="r_a7569777ad59a4ba7f75145f5c01ebd6d"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a7569777ad59a4ba7f75145f5c01ebd6d">get_timestamp</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a7569777ad59a4ba7f75145f5c01ebd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0a17af5ec6428f88f8aaa57580d514" id="r_a0a0a17af5ec6428f88f8aaa57580d514"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a0a0a17af5ec6428f88f8aaa57580d514">get_timestamp</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a0a0a17af5ec6428f88f8aaa57580d514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da8a5af57b79f7b23518ec39e21a053" id="r_a6da8a5af57b79f7b23518ec39e21a053"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a6da8a5af57b79f7b23518ec39e21a053">get_timestamp_with_timezone</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a6da8a5af57b79f7b23518ec39e21a053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036490b36cb12625db194a62cfb12a0b" id="r_a036490b36cb12625db194a62cfb12a0b"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a036490b36cb12625db194a62cfb12a0b">get_timestamp_with_timezone</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a036490b36cb12625db194a62cfb12a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324d0ce0261501034d525c7d99768e79" id="r_a324d0ce0261501034d525c7d99768e79"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a324d0ce0261501034d525c7d99768e79">get_generic_record</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a324d0ce0261501034d525c7d99768e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae06a17de17f44769ab5c0febff93f27" id="r_aae06a17de17f44769ab5c0febff93f27"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aae06a17de17f44769ab5c0febff93f27">get_generic_record</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:aae06a17de17f44769ab5c0febff93f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9564677a34e6c7f63829d8ce771894" id="r_aab9564677a34e6c7f63829d8ce771894"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; bool &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aab9564677a34e6c7f63829d8ce771894">get_array_of_boolean</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:aab9564677a34e6c7f63829d8ce771894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6400c6564d16e970aeef3517857454c" id="r_ad6400c6564d16e970aeef3517857454c"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; bool &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ad6400c6564d16e970aeef3517857454c">get_array_of_boolean</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:ad6400c6564d16e970aeef3517857454c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc23b5d5ee0db4b854d996a2dad92d4" id="r_afdc23b5d5ee0db4b854d996a2dad92d4"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; int8_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#afdc23b5d5ee0db4b854d996a2dad92d4">get_array_of_int8</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:afdc23b5d5ee0db4b854d996a2dad92d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29cedda58f050f26530991d1a6bb5a61" id="r_a29cedda58f050f26530991d1a6bb5a61"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; int8_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a29cedda58f050f26530991d1a6bb5a61">get_array_of_int8</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a29cedda58f050f26530991d1a6bb5a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb3a671fedff2f2fba00a3212a4d269" id="r_aaeb3a671fedff2f2fba00a3212a4d269"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; int16_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aaeb3a671fedff2f2fba00a3212a4d269">get_array_of_int16</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:aaeb3a671fedff2f2fba00a3212a4d269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6147bfd6bc9e4af64a29d9717804e14" id="r_ac6147bfd6bc9e4af64a29d9717804e14"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; int16_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ac6147bfd6bc9e4af64a29d9717804e14">get_array_of_int16</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:ac6147bfd6bc9e4af64a29d9717804e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0cfd4389efed5465e0bf942d00ef25c" id="r_af0cfd4389efed5465e0bf942d00ef25c"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; int32_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#af0cfd4389efed5465e0bf942d00ef25c">get_array_of_int32</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:af0cfd4389efed5465e0bf942d00ef25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c732f1915180f6960d1f1be0c49194" id="r_ab7c732f1915180f6960d1f1be0c49194"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; int32_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ab7c732f1915180f6960d1f1be0c49194">get_array_of_int32</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:ab7c732f1915180f6960d1f1be0c49194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd5b3164e61e30947a80c8c3c23d413" id="r_a4cd5b3164e61e30947a80c8c3c23d413"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; int64_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a4cd5b3164e61e30947a80c8c3c23d413">get_array_of_int64</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a4cd5b3164e61e30947a80c8c3c23d413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82141206b5fe696b237c27c5806d0596" id="r_a82141206b5fe696b237c27c5806d0596"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; int64_t &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a82141206b5fe696b237c27c5806d0596">get_array_of_int64</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a82141206b5fe696b237c27c5806d0596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6ffe4f706e92ffb3a0f8e4b1186d9f" id="r_aec6ffe4f706e92ffb3a0f8e4b1186d9f"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; float &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aec6ffe4f706e92ffb3a0f8e4b1186d9f">get_array_of_float32</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:aec6ffe4f706e92ffb3a0f8e4b1186d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b96c8d6a2ae8fc07050660706a7693" id="r_ab2b96c8d6a2ae8fc07050660706a7693"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; float &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ab2b96c8d6a2ae8fc07050660706a7693">get_array_of_float32</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:ab2b96c8d6a2ae8fc07050660706a7693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b1944c66a6c40a3ac1d9b26ed669f9" id="r_a78b1944c66a6c40a3ac1d9b26ed669f9"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a78b1944c66a6c40a3ac1d9b26ed669f9">get_array_of_float64</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a78b1944c66a6c40a3ac1d9b26ed669f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916aa6fbd0ccf215529e4f37ab280393" id="r_a916aa6fbd0ccf215529e4f37ab280393"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a916aa6fbd0ccf215529e4f37ab280393">get_array_of_float64</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a916aa6fbd0ccf215529e4f37ab280393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad453a29a4c8dab0169e653c6cfc7fbf4" id="r_ad453a29a4c8dab0169e653c6cfc7fbf4"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; std::string &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ad453a29a4c8dab0169e653c6cfc7fbf4">get_array_of_string</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:ad453a29a4c8dab0169e653c6cfc7fbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1959b7dc53a7c8c78b896fddc12953b" id="r_ac1959b7dc53a7c8c78b896fddc12953b"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; std::string &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ac1959b7dc53a7c8c78b896fddc12953b">get_array_of_string</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:ac1959b7dc53a7c8c78b896fddc12953b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ce3c3e3e605a553cec71a1c8e2d1eb" id="r_ad7ce3c3e3e605a553cec71a1c8e2d1eb"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ad7ce3c3e3e605a553cec71a1c8e2d1eb">get_array_of_decimal</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:ad7ce3c3e3e605a553cec71a1c8e2d1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43a2b2fd5ab8ad03784f2b396a431b8" id="r_aa43a2b2fd5ab8ad03784f2b396a431b8"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aa43a2b2fd5ab8ad03784f2b396a431b8">get_array_of_decimal</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:aa43a2b2fd5ab8ad03784f2b396a431b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af575a44a1312820e8e363b16a953a0f4" id="r_af575a44a1312820e8e363b16a953a0f4"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#af575a44a1312820e8e363b16a953a0f4">get_array_of_time</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:af575a44a1312820e8e363b16a953a0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e5f9c190856afe84b34bdcd8c4fa38" id="r_a51e5f9c190856afe84b34bdcd8c4fa38"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a51e5f9c190856afe84b34bdcd8c4fa38">get_array_of_time</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a51e5f9c190856afe84b34bdcd8c4fa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e91229f25eb001839c37ada2198b30" id="r_a63e91229f25eb001839c37ada2198b30"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a63e91229f25eb001839c37ada2198b30">get_array_of_date</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a63e91229f25eb001839c37ada2198b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050b80acf1bfdc6eea94f2b67c62c18a" id="r_a050b80acf1bfdc6eea94f2b67c62c18a"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a050b80acf1bfdc6eea94f2b67c62c18a">get_array_of_date</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a050b80acf1bfdc6eea94f2b67c62c18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e1a9aa57db557f94973306958478a8" id="r_aa2e1a9aa57db557f94973306958478a8"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aa2e1a9aa57db557f94973306958478a8">get_array_of_timestamp</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:aa2e1a9aa57db557f94973306958478a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb66e3d48e41c705b9c4d47d8b6c2db6" id="r_aeb66e3d48e41c705b9c4d47d8b6c2db6"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aeb66e3d48e41c705b9c4d47d8b6c2db6">get_array_of_timestamp</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:aeb66e3d48e41c705b9c4d47d8b6c2db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d094118319c9cec2645e4e02873342" id="r_ae9d094118319c9cec2645e4e02873342"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ae9d094118319c9cec2645e4e02873342">get_array_of_timestamp_with_timezone</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:ae9d094118319c9cec2645e4e02873342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae249d864bb1d399115693f16ba22d8da" id="r_ae249d864bb1d399115693f16ba22d8da"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ae249d864bb1d399115693f16ba22d8da">get_array_of_timestamp_with_timezone</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:ae249d864bb1d399115693f16ba22d8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573daf6c2ef08014ffc372892b3dd89f" id="r_a573daf6c2ef08014ffc372892b3dd89f"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a573daf6c2ef08014ffc372892b3dd89f">get_array_of_generic_record</a> (const std::string &amp;field_name) const</td></tr>
<tr class="separator:a573daf6c2ef08014ffc372892b3dd89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc7229a52f0a3a62e4037cdc44251a4" id="r_a3dc7229a52f0a3a62e4037cdc44251a4"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a3dc7229a52f0a3a62e4037cdc44251a4">get_array_of_generic_record</a> (const std::string &amp;field_name)</td></tr>
<tr class="separator:a3dc7229a52f0a3a62e4037cdc44251a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d8e3be66a383c6fbf77397a0eab6dd" id="r_ad1d8e3be66a383c6fbf77397a0eab6dd"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ad1d8e3be66a383c6fbf77397a0eab6dd">get_nullable_boolean</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:ad1d8e3be66a383c6fbf77397a0eab6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:ad1d8e3be66a383c6fbf77397a0eab6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d51814873acede23c821af25b94c84e" id="r_a1d51814873acede23c821af25b94c84e"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; bool &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a1d51814873acede23c821af25b94c84e">get_nullable_boolean</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a1d51814873acede23c821af25b94c84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a1d51814873acede23c821af25b94c84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aeca39439597cd66622d274117d3b1e" id="r_a0aeca39439597cd66622d274117d3b1e"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a0aeca39439597cd66622d274117d3b1e">get_nullable_int8</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:a0aeca39439597cd66622d274117d3b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a0aeca39439597cd66622d274117d3b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355b390a3845681c436d0d09692108ae" id="r_a355b390a3845681c436d0d09692108ae"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int8_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a355b390a3845681c436d0d09692108ae">get_nullable_int8</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a355b390a3845681c436d0d09692108ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a355b390a3845681c436d0d09692108ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73021280492c27351155c4b7d1c2776" id="r_ac73021280492c27351155c4b7d1c2776"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ac73021280492c27351155c4b7d1c2776">get_nullable_int16</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:ac73021280492c27351155c4b7d1c2776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:ac73021280492c27351155c4b7d1c2776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36610e49f7f341897fe946d75328d810" id="r_a36610e49f7f341897fe946d75328d810"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int16_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a36610e49f7f341897fe946d75328d810">get_nullable_int16</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a36610e49f7f341897fe946d75328d810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a36610e49f7f341897fe946d75328d810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85b73d459eabf71924ecfc51c4da6a1" id="r_af85b73d459eabf71924ecfc51c4da6a1"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#af85b73d459eabf71924ecfc51c4da6a1">get_nullable_int32</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:af85b73d459eabf71924ecfc51c4da6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:af85b73d459eabf71924ecfc51c4da6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d6be32c16aa479c5fcd22e2c2cf3a5" id="r_ac1d6be32c16aa479c5fcd22e2c2cf3a5"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int32_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ac1d6be32c16aa479c5fcd22e2c2cf3a5">get_nullable_int32</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:ac1d6be32c16aa479c5fcd22e2c2cf3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:ac1d6be32c16aa479c5fcd22e2c2cf3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f1ce8bf80df090ae378b3331587f52" id="r_a71f1ce8bf80df090ae378b3331587f52"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a71f1ce8bf80df090ae378b3331587f52">get_nullable_int64</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:a71f1ce8bf80df090ae378b3331587f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a71f1ce8bf80df090ae378b3331587f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88f20ad3d56bfe992d68cd1e3745362" id="r_af88f20ad3d56bfe992d68cd1e3745362"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int64_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#af88f20ad3d56bfe992d68cd1e3745362">get_nullable_int64</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:af88f20ad3d56bfe992d68cd1e3745362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:af88f20ad3d56bfe992d68cd1e3745362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ee798406d233fde22e846ca7207dac" id="r_a13ee798406d233fde22e846ca7207dac"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a13ee798406d233fde22e846ca7207dac">get_nullable_float32</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:a13ee798406d233fde22e846ca7207dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a13ee798406d233fde22e846ca7207dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef63c63455ad97eaada9461f52a14cc" id="r_adef63c63455ad97eaada9461f52a14cc"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; float &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#adef63c63455ad97eaada9461f52a14cc">get_nullable_float32</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:adef63c63455ad97eaada9461f52a14cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:adef63c63455ad97eaada9461f52a14cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144c440ac39ed5887882ed2eb4c16871" id="r_a144c440ac39ed5887882ed2eb4c16871"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a144c440ac39ed5887882ed2eb4c16871">get_nullable_float64</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:a144c440ac39ed5887882ed2eb4c16871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a144c440ac39ed5887882ed2eb4c16871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbb3ef2415fbdeecc38964b1cd6e67e" id="r_aabbb3ef2415fbdeecc38964b1cd6e67e"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aabbb3ef2415fbdeecc38964b1cd6e67e">get_nullable_float64</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:aabbb3ef2415fbdeecc38964b1cd6e67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:aabbb3ef2415fbdeecc38964b1cd6e67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af630bd4caf89fc31fc928c60802f8d24" id="r_af630bd4caf89fc31fc928c60802f8d24"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; bool &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#af630bd4caf89fc31fc928c60802f8d24">get_array_of_nullable_boolean</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:af630bd4caf89fc31fc928c60802f8d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:af630bd4caf89fc31fc928c60802f8d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1157d47c6e52992bfd10778a54deb7fc" id="r_a1157d47c6e52992bfd10778a54deb7fc"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; bool &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a1157d47c6e52992bfd10778a54deb7fc">get_array_of_nullable_boolean</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a1157d47c6e52992bfd10778a54deb7fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a1157d47c6e52992bfd10778a54deb7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa868ff55d01537d4b331d1d8be74c09" id="r_aaa868ff55d01537d4b331d1d8be74c09"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; int8_t &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aaa868ff55d01537d4b331d1d8be74c09">get_array_of_nullable_int8</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:aaa868ff55d01537d4b331d1d8be74c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:aaa868ff55d01537d4b331d1d8be74c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bb774531d520d8dc36dc8423a3fa1e" id="r_a70bb774531d520d8dc36dc8423a3fa1e"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; int8_t &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a70bb774531d520d8dc36dc8423a3fa1e">get_array_of_nullable_int8</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a70bb774531d520d8dc36dc8423a3fa1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a70bb774531d520d8dc36dc8423a3fa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92fb239bfbc3cefc4028c18b85252ca" id="r_ad92fb239bfbc3cefc4028c18b85252ca"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; int16_t &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ad92fb239bfbc3cefc4028c18b85252ca">get_array_of_nullable_int16</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:ad92fb239bfbc3cefc4028c18b85252ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:ad92fb239bfbc3cefc4028c18b85252ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e9c16b0c8932b8b147729b4cc91efe" id="r_af8e9c16b0c8932b8b147729b4cc91efe"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; int16_t &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#af8e9c16b0c8932b8b147729b4cc91efe">get_array_of_nullable_int16</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:af8e9c16b0c8932b8b147729b4cc91efe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:af8e9c16b0c8932b8b147729b4cc91efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac064a0c9bb34d087fb445b53292d4f98" id="r_ac064a0c9bb34d087fb445b53292d4f98"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; int32_t &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ac064a0c9bb34d087fb445b53292d4f98">get_array_of_nullable_int32</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:ac064a0c9bb34d087fb445b53292d4f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:ac064a0c9bb34d087fb445b53292d4f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808e1cb772c70ad188dcf2a9cfeefcaf" id="r_a808e1cb772c70ad188dcf2a9cfeefcaf"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; int32_t &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a808e1cb772c70ad188dcf2a9cfeefcaf">get_array_of_nullable_int32</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a808e1cb772c70ad188dcf2a9cfeefcaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a808e1cb772c70ad188dcf2a9cfeefcaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a9c2f59d8730831115c3e9d0a7197b" id="r_a32a9c2f59d8730831115c3e9d0a7197b"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; int64_t &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a32a9c2f59d8730831115c3e9d0a7197b">get_array_of_nullable_int64</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:a32a9c2f59d8730831115c3e9d0a7197b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a32a9c2f59d8730831115c3e9d0a7197b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602ed261c3dbc9f27b24f4fa258a02f0" id="r_a602ed261c3dbc9f27b24f4fa258a02f0"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; int64_t &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a602ed261c3dbc9f27b24f4fa258a02f0">get_array_of_nullable_int64</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a602ed261c3dbc9f27b24f4fa258a02f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a602ed261c3dbc9f27b24f4fa258a02f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185b3cd8f638662317429145d9aa52f2" id="r_a185b3cd8f638662317429145d9aa52f2"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; float &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a185b3cd8f638662317429145d9aa52f2">get_array_of_nullable_float32</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:a185b3cd8f638662317429145d9aa52f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a185b3cd8f638662317429145d9aa52f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241cadf5983c4e433e1d4d510b773470" id="r_a241cadf5983c4e433e1d4d510b773470"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; float &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a241cadf5983c4e433e1d4d510b773470">get_array_of_nullable_float32</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a241cadf5983c4e433e1d4d510b773470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:a241cadf5983c4e433e1d4d510b773470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59bd9f95d7db2f4184ee5f2a669688a" id="r_ab59bd9f95d7db2f4184ee5f2a669688a"><td class="memItemLeft" align="right" valign="top">const boost::optional&lt; std::vector&lt; boost::optional&lt; double &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ab59bd9f95d7db2f4184ee5f2a669688a">get_array_of_nullable_float64</a> (const std::string &amp;field_name) const</td></tr>
<tr class="memdesc:ab59bd9f95d7db2f4184ee5f2a669688a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:ab59bd9f95d7db2f4184ee5f2a669688a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ee86bf14644512d0cf0e0f9c3cdf44" id="r_ae8ee86bf14644512d0cf0e0f9c3cdf44"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; double &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ae8ee86bf14644512d0cf0e0f9c3cdf44">get_array_of_nullable_float64</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:ae8ee86bf14644512d0cf0e0f9c3cdf44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported only for Compact.  <br /></td></tr>
<tr class="separator:ae8ee86bf14644512d0cf0e0f9c3cdf44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a43e6ffbe06e93b1c3c131a18e4d21b3b" id="r_a43e6ffbe06e93b1c3c131a18e4d21b3b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a43e6ffbe06e93b1c3c131a18e4d21b3b">generic_record_builder</a></td></tr>
<tr class="separator:a43e6ffbe06e93b1c3c131a18e4d21b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a96bb9ebecd6d3a6506dffa0173d93" id="r_a51a96bb9ebecd6d3a6506dffa0173d93"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a51a96bb9ebecd6d3a6506dffa0173d93">pimpl::compact_stream_serializer</a></td></tr>
<tr class="separator:a51a96bb9ebecd6d3a6506dffa0173d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778ca519c51aba88b1b6f240f2725d55" id="r_a778ca519c51aba88b1b6f240f2725d55"><td class="memItemLeft" align="right" valign="top">std::ostream HAZELCAST_API &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a778ca519c51aba88b1b6f240f2725d55">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;)</td></tr>
<tr class="separator:a778ca519c51aba88b1b6f240f2725d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac373fa6215c12b50cee2a36062f2ee91" id="r_ac373fa6215c12b50cee2a36062f2ee91"><td class="memItemLeft" align="right" valign="top">bool HAZELCAST_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ac373fa6215c12b50cee2a36062f2ee91">operator==</a> (const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;, const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;)</td></tr>
<tr class="separator:ac373fa6215c12b50cee2a36062f2ee91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0e36cea8a99b0d0adc16459890aeec" id="r_aff0e36cea8a99b0d0adc16459890aeec"><td class="memItemLeft" align="right" valign="top">bool HAZELCAST_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#aff0e36cea8a99b0d0adc16459890aeec">operator!=</a> (const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;, const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;)</td></tr>
<tr class="separator:aff0e36cea8a99b0d0adc16459890aeec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f40f26e342b61258d571760a3bbc25" id="r_ad9f40f26e342b61258d571760a3bbc25"><td class="memItemLeft" align="right" valign="top">boost::property_tree::ptree&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#ad9f40f26e342b61258d571760a3bbc25">write_generic_record</a> (const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;)</td></tr>
<tr class="separator:ad9f40f26e342b61258d571760a3bbc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A generic object interface that is returned to the user when the domain class can not be created from any of the distributed Hazelcast data structures like <code><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html">imap</a></code>, <code><a class="el" href="../../dd/df1/classhazelcast_1_1client_1_1iqueue.html">iqueue</a></code> etc. </p>
<p>GenericRecord also allows reading from a cluster without having the classes on the client side. If <code>T</code> is specified as <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a></code>, any compact objects can be read and written objects back to the cluster without the need to have the domain classes definition on client side. </p>
<p>Currently, only compact serializable objects are supported.</p>
<p>Multiple threads can simultaneous read from <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> but concurrent writes are not supported. </p>

<p class="definition">Definition at line <a class="el" href="../../d8/d76/generic__record_8h_source.html#l00059">59</a> of file <a class="el" href="../../d8/d76/generic__record_8h_source.html">generic_record.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad6400c6564d16e970aeef3517857454c" name="ad6400c6564d16e970aeef3517857454c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6400c6564d16e970aeef3517857454c">&#9670;&#160;</a></span>get_array_of_boolean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; bool &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01110">1110</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1111</span>{</div>
<div class="line"><span class="lineno"> 1112</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;bool&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1113</span>                                        field_kind::ARRAY_OF_BOOLEAN,</div>
<div class="line"><span class="lineno"> 1114</span>                                        field_kind::ARRAY_OF_NULLABLE_BOOLEAN,</div>
<div class="line"><span class="lineno"> 1115</span>                                        <span class="stringliteral">&quot;boolean&quot;</span>);</div>
<div class="line"><span class="lineno"> 1116</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aab9564677a34e6c7f63829d8ce771894" name="aab9564677a34e6c7f63829d8ce771894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9564677a34e6c7f63829d8ce771894">&#9670;&#160;</a></span>get_array_of_boolean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; bool &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01101">1101</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1102</span>{</div>
<div class="line"><span class="lineno"> 1103</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;bool&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1104</span>                                        field_kind::ARRAY_OF_BOOLEAN,</div>
<div class="line"><span class="lineno"> 1105</span>                                        field_kind::ARRAY_OF_NULLABLE_BOOLEAN,</div>
<div class="line"><span class="lineno"> 1106</span>                                        <span class="stringliteral">&quot;boolean&quot;</span>);</div>
<div class="line"><span class="lineno"> 1107</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a050b80acf1bfdc6eea94f2b67c62c18a" name="a050b80acf1bfdc6eea94f2b67c62c18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050b80acf1bfdc6eea94f2b67c62c18a">&#9670;&#160;</a></span>get_array_of_date() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_date </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#abead288cf747dd9191c063c5791c5950">get_date()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01405">1405</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1406</span>{</div>
<div class="line"><span class="lineno"> 1407</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;local_date&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1408</span>      field_name, field_kind::ARRAY_OF_DATE);</div>
<div class="line"><span class="lineno"> 1409</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a63e91229f25eb001839c37ada2198b30" name="a63e91229f25eb001839c37ada2198b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e91229f25eb001839c37ada2198b30">&#9670;&#160;</a></span>get_array_of_date() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_date </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#abead288cf747dd9191c063c5791c5950">get_date()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01398">1398</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1399</span>{</div>
<div class="line"><span class="lineno"> 1400</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;local_date&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1401</span>      field_name, field_kind::ARRAY_OF_DATE);</div>
<div class="line"><span class="lineno"> 1402</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa43a2b2fd5ab8ad03784f2b396a431b8" name="aa43a2b2fd5ab8ad03784f2b396a431b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43a2b2fd5ab8ad03784f2b396a431b8">&#9670;&#160;</a></span>get_array_of_decimal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_decimal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#acf277041c6f05a77bbe5dfc8686356c8">get_decimal()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01377">1377</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1378</span>{</div>
<div class="line"><span class="lineno"> 1379</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;big_decimal&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1380</span>      field_name, field_kind::ARRAY_OF_DECIMAL);</div>
<div class="line"><span class="lineno"> 1381</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad7ce3c3e3e605a553cec71a1c8e2d1eb" name="ad7ce3c3e3e605a553cec71a1c8e2d1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ce3c3e3e605a553cec71a1c8e2d1eb">&#9670;&#160;</a></span>get_array_of_decimal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_decimal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema/class definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#acf277041c6f05a77bbe5dfc8686356c8">get_decimal()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01370">1370</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1371</span>{</div>
<div class="line"><span class="lineno"> 1372</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;big_decimal&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1373</span>      field_name, field_kind::ARRAY_OF_DECIMAL);</div>
<div class="line"><span class="lineno"> 1374</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab2b96c8d6a2ae8fc07050660706a7693" name="ab2b96c8d6a2ae8fc07050660706a7693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b96c8d6a2ae8fc07050660706a7693">&#9670;&#160;</a></span>get_array_of_float32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; float &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01200">1200</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1201</span>{</div>
<div class="line"><span class="lineno"> 1202</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;float&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1203</span>                                         field_kind::ARRAY_OF_FLOAT32,</div>
<div class="line"><span class="lineno"> 1204</span>                                         field_kind::ARRAY_OF_NULLABLE_FLOAT32,</div>
<div class="line"><span class="lineno"> 1205</span>                                         <span class="stringliteral">&quot;float32&quot;</span>);</div>
<div class="line"><span class="lineno"> 1206</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aec6ffe4f706e92ffb3a0f8e4b1186d9f" name="aec6ffe4f706e92ffb3a0f8e4b1186d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6ffe4f706e92ffb3a0f8e4b1186d9f">&#9670;&#160;</a></span>get_array_of_float32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; float &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01191">1191</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1192</span>{</div>
<div class="line"><span class="lineno"> 1193</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;float&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1194</span>                                         field_kind::ARRAY_OF_FLOAT32,</div>
<div class="line"><span class="lineno"> 1195</span>                                         field_kind::ARRAY_OF_NULLABLE_FLOAT32,</div>
<div class="line"><span class="lineno"> 1196</span>                                         <span class="stringliteral">&quot;float32&quot;</span>);</div>
<div class="line"><span class="lineno"> 1197</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a916aa6fbd0ccf215529e4f37ab280393" name="a916aa6fbd0ccf215529e4f37ab280393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916aa6fbd0ccf215529e4f37ab280393">&#9670;&#160;</a></span>get_array_of_float64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; double &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01218">1218</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1219</span>{</div>
<div class="line"><span class="lineno"> 1220</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;double&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1221</span>                                          field_kind::ARRAY_OF_FLOAT64,</div>
<div class="line"><span class="lineno"> 1222</span>                                          field_kind::ARRAY_OF_NULLABLE_FLOAT64,</div>
<div class="line"><span class="lineno"> 1223</span>                                          <span class="stringliteral">&quot;float64&quot;</span>);</div>
<div class="line"><span class="lineno"> 1224</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a78b1944c66a6c40a3ac1d9b26ed669f9" name="a78b1944c66a6c40a3ac1d9b26ed669f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b1944c66a6c40a3ac1d9b26ed669f9">&#9670;&#160;</a></span>get_array_of_float64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; double &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01209">1209</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1210</span>{</div>
<div class="line"><span class="lineno"> 1211</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;double&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1212</span>                                          field_kind::ARRAY_OF_FLOAT64,</div>
<div class="line"><span class="lineno"> 1213</span>                                          field_kind::ARRAY_OF_NULLABLE_FLOAT64,</div>
<div class="line"><span class="lineno"> 1214</span>                                          <span class="stringliteral">&quot;float64&quot;</span>);</div>
<div class="line"><span class="lineno"> 1215</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3dc7229a52f0a3a62e4037cdc44251a4" name="a3dc7229a52f0a3a62e4037cdc44251a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc7229a52f0a3a62e4037cdc44251a4">&#9670;&#160;</a></span>get_array_of_generic_record() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_generic_record </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01449">1449</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1450</span>{</div>
<div class="line"><span class="lineno"> 1451</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;generic_record&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1452</span>      field_name, field_kind::ARRAY_OF_COMPACT);</div>
<div class="line"><span class="lineno"> 1453</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a573daf6c2ef08014ffc372892b3dd89f" name="a573daf6c2ef08014ffc372892b3dd89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573daf6c2ef08014ffc372892b3dd89f">&#9670;&#160;</a></span>get_array_of_generic_record() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_generic_record </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01442">1442</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1443</span>{</div>
<div class="line"><span class="lineno"> 1444</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;generic_record&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1445</span>      field_name, field_kind::ARRAY_OF_COMPACT);</div>
<div class="line"><span class="lineno"> 1446</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac6147bfd6bc9e4af64a29d9717804e14" name="ac6147bfd6bc9e4af64a29d9717804e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6147bfd6bc9e4af64a29d9717804e14">&#9670;&#160;</a></span>get_array_of_int16() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; int16_t &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01146">1146</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1147</span>{</div>
<div class="line"><span class="lineno"> 1148</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;int16_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1149</span>                                           field_kind::ARRAY_OF_INT16,</div>
<div class="line"><span class="lineno"> 1150</span>                                           field_kind::ARRAY_OF_NULLABLE_INT16,</div>
<div class="line"><span class="lineno"> 1151</span>                                           <span class="stringliteral">&quot;int16&quot;</span>);</div>
<div class="line"><span class="lineno"> 1152</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aaeb3a671fedff2f2fba00a3212a4d269" name="aaeb3a671fedff2f2fba00a3212a4d269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb3a671fedff2f2fba00a3212a4d269">&#9670;&#160;</a></span>get_array_of_int16() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; int16_t &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01137">1137</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1138</span>{</div>
<div class="line"><span class="lineno"> 1139</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;int16_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1140</span>                                           field_kind::ARRAY_OF_INT16,</div>
<div class="line"><span class="lineno"> 1141</span>                                           field_kind::ARRAY_OF_NULLABLE_INT16,</div>
<div class="line"><span class="lineno"> 1142</span>                                           <span class="stringliteral">&quot;int16&quot;</span>);</div>
<div class="line"><span class="lineno"> 1143</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab7c732f1915180f6960d1f1be0c49194" name="ab7c732f1915180f6960d1f1be0c49194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c732f1915180f6960d1f1be0c49194">&#9670;&#160;</a></span>get_array_of_int32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; int32_t &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01164">1164</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1165</span>{</div>
<div class="line"><span class="lineno"> 1166</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;int32_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1167</span>                                           field_kind::ARRAY_OF_INT32,</div>
<div class="line"><span class="lineno"> 1168</span>                                           field_kind::ARRAY_OF_NULLABLE_INT32,</div>
<div class="line"><span class="lineno"> 1169</span>                                           <span class="stringliteral">&quot;int32&quot;</span>);</div>
<div class="line"><span class="lineno"> 1170</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af0cfd4389efed5465e0bf942d00ef25c" name="af0cfd4389efed5465e0bf942d00ef25c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0cfd4389efed5465e0bf942d00ef25c">&#9670;&#160;</a></span>get_array_of_int32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; int32_t &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01155">1155</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1156</span>{</div>
<div class="line"><span class="lineno"> 1157</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;int32_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1158</span>                                           field_kind::ARRAY_OF_INT32,</div>
<div class="line"><span class="lineno"> 1159</span>                                           field_kind::ARRAY_OF_NULLABLE_INT32,</div>
<div class="line"><span class="lineno"> 1160</span>                                           <span class="stringliteral">&quot;int32&quot;</span>);</div>
<div class="line"><span class="lineno"> 1161</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a82141206b5fe696b237c27c5806d0596" name="a82141206b5fe696b237c27c5806d0596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82141206b5fe696b237c27c5806d0596">&#9670;&#160;</a></span>get_array_of_int64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; int64_t &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01182">1182</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1183</span>{</div>
<div class="line"><span class="lineno"> 1184</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;int64_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1185</span>                                           field_kind::ARRAY_OF_INT64,</div>
<div class="line"><span class="lineno"> 1186</span>                                           field_kind::ARRAY_OF_NULLABLE_INT64,</div>
<div class="line"><span class="lineno"> 1187</span>                                           <span class="stringliteral">&quot;int64&quot;</span>);</div>
<div class="line"><span class="lineno"> 1188</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4cd5b3164e61e30947a80c8c3c23d413" name="a4cd5b3164e61e30947a80c8c3c23d413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd5b3164e61e30947a80c8c3c23d413">&#9670;&#160;</a></span>get_array_of_int64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; int64_t &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01173">1173</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1174</span>{</div>
<div class="line"><span class="lineno"> 1175</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;int64_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1176</span>                                           field_kind::ARRAY_OF_INT64,</div>
<div class="line"><span class="lineno"> 1177</span>                                           field_kind::ARRAY_OF_NULLABLE_INT64,</div>
<div class="line"><span class="lineno"> 1178</span>                                           <span class="stringliteral">&quot;int64&quot;</span>);</div>
<div class="line"><span class="lineno"> 1179</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a29cedda58f050f26530991d1a6bb5a61" name="a29cedda58f050f26530991d1a6bb5a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29cedda58f050f26530991d1a6bb5a61">&#9670;&#160;</a></span>get_array_of_int8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; int8_t &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01128">1128</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1129</span>{</div>
<div class="line"><span class="lineno"> 1130</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;int8_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1131</span>                                          field_kind::ARRAY_OF_INT8,</div>
<div class="line"><span class="lineno"> 1132</span>                                          field_kind::ARRAY_OF_NULLABLE_INT8,</div>
<div class="line"><span class="lineno"> 1133</span>                                          <span class="stringliteral">&quot;int8&quot;</span>);</div>
<div class="line"><span class="lineno"> 1134</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="afdc23b5d5ee0db4b854d996a2dad92d4" name="afdc23b5d5ee0db4b854d996a2dad92d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc23b5d5ee0db4b854d996a2dad92d4">&#9670;&#160;</a></span>get_array_of_int8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; int8_t &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01119">1119</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1120</span>{</div>
<div class="line"><span class="lineno"> 1121</span>    <span class="keywordflow">return</span> get_array_of_primitive&lt;int8_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1122</span>                                          field_kind::ARRAY_OF_INT8,</div>
<div class="line"><span class="lineno"> 1123</span>                                          field_kind::ARRAY_OF_NULLABLE_INT8,</div>
<div class="line"><span class="lineno"> 1124</span>                                          <span class="stringliteral">&quot;int8&quot;</span>);</div>
<div class="line"><span class="lineno"> 1125</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1157d47c6e52992bfd10778a54deb7fc" name="a1157d47c6e52992bfd10778a54deb7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1157d47c6e52992bfd10778a54deb7fc">&#9670;&#160;</a></span>get_array_of_nullable_boolean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; bool &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01237">1237</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1238</span>{</div>
<div class="line"><span class="lineno"> 1239</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;bool&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1240</span>                                       field_kind::ARRAY_OF_BOOLEAN,</div>
<div class="line"><span class="lineno"> 1241</span>                                       field_kind::ARRAY_OF_NULLABLE_BOOLEAN,</div>
<div class="line"><span class="lineno"> 1242</span>                                       <span class="stringliteral">&quot;boolean&quot;</span>);</div>
<div class="line"><span class="lineno"> 1243</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af630bd4caf89fc31fc928c60802f8d24" name="af630bd4caf89fc31fc928c60802f8d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af630bd4caf89fc31fc928c60802f8d24">&#9670;&#160;</a></span>get_array_of_nullable_boolean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; bool &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01227">1227</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1229</span>{</div>
<div class="line"><span class="lineno"> 1230</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;bool&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1231</span>                                       field_kind::ARRAY_OF_BOOLEAN,</div>
<div class="line"><span class="lineno"> 1232</span>                                       field_kind::ARRAY_OF_NULLABLE_BOOLEAN,</div>
<div class="line"><span class="lineno"> 1233</span>                                       <span class="stringliteral">&quot;boolean&quot;</span>);</div>
<div class="line"><span class="lineno"> 1234</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a241cadf5983c4e433e1d4d510b773470" name="a241cadf5983c4e433e1d4d510b773470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241cadf5983c4e433e1d4d510b773470">&#9670;&#160;</a></span>get_array_of_nullable_float32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; float &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01328">1328</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1329</span>{</div>
<div class="line"><span class="lineno"> 1330</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;float&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1331</span>                                        field_kind::ARRAY_OF_FLOAT32,</div>
<div class="line"><span class="lineno"> 1332</span>                                        field_kind::ARRAY_OF_NULLABLE_FLOAT32,</div>
<div class="line"><span class="lineno"> 1333</span>                                        <span class="stringliteral">&quot;float32&quot;</span>);</div>
<div class="line"><span class="lineno"> 1334</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a185b3cd8f638662317429145d9aa52f2" name="a185b3cd8f638662317429145d9aa52f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185b3cd8f638662317429145d9aa52f2">&#9670;&#160;</a></span>get_array_of_nullable_float32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; float &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01318">1318</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1320</span>{</div>
<div class="line"><span class="lineno"> 1321</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;float&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1322</span>                                        field_kind::ARRAY_OF_FLOAT32,</div>
<div class="line"><span class="lineno"> 1323</span>                                        field_kind::ARRAY_OF_NULLABLE_FLOAT32,</div>
<div class="line"><span class="lineno"> 1324</span>                                        <span class="stringliteral">&quot;float32&quot;</span>);</div>
<div class="line"><span class="lineno"> 1325</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae8ee86bf14644512d0cf0e0f9c3cdf44" name="ae8ee86bf14644512d0cf0e0f9c3cdf44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ee86bf14644512d0cf0e0f9c3cdf44">&#9670;&#160;</a></span>get_array_of_nullable_float64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; double &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01347">1347</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1348</span>{</div>
<div class="line"><span class="lineno"> 1349</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;double&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1350</span>                                         field_kind::ARRAY_OF_FLOAT64,</div>
<div class="line"><span class="lineno"> 1351</span>                                         field_kind::ARRAY_OF_NULLABLE_FLOAT64,</div>
<div class="line"><span class="lineno"> 1352</span>                                         <span class="stringliteral">&quot;float64&quot;</span>);</div>
<div class="line"><span class="lineno"> 1353</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab59bd9f95d7db2f4184ee5f2a669688a" name="ab59bd9f95d7db2f4184ee5f2a669688a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab59bd9f95d7db2f4184ee5f2a669688a">&#9670;&#160;</a></span>get_array_of_nullable_float64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; double &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01337">1337</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1339</span>{</div>
<div class="line"><span class="lineno"> 1340</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;double&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1341</span>                                         field_kind::ARRAY_OF_FLOAT64,</div>
<div class="line"><span class="lineno"> 1342</span>                                         field_kind::ARRAY_OF_NULLABLE_FLOAT64,</div>
<div class="line"><span class="lineno"> 1343</span>                                         <span class="stringliteral">&quot;float64&quot;</span>);</div>
<div class="line"><span class="lineno"> 1344</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af8e9c16b0c8932b8b147729b4cc91efe" name="af8e9c16b0c8932b8b147729b4cc91efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e9c16b0c8932b8b147729b4cc91efe">&#9670;&#160;</a></span>get_array_of_nullable_int16() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; int16_t &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01273">1273</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1274</span>{</div>
<div class="line"><span class="lineno"> 1275</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;int16_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1276</span>                                          field_kind::ARRAY_OF_INT16,</div>
<div class="line"><span class="lineno"> 1277</span>                                          field_kind::ARRAY_OF_NULLABLE_INT16,</div>
<div class="line"><span class="lineno"> 1278</span>                                          <span class="stringliteral">&quot;int16&quot;</span>);</div>
<div class="line"><span class="lineno"> 1279</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad92fb239bfbc3cefc4028c18b85252ca" name="ad92fb239bfbc3cefc4028c18b85252ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92fb239bfbc3cefc4028c18b85252ca">&#9670;&#160;</a></span>get_array_of_nullable_int16() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; int16_t &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01264">1264</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1265</span>{</div>
<div class="line"><span class="lineno"> 1266</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;int16_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1267</span>                                          field_kind::ARRAY_OF_INT16,</div>
<div class="line"><span class="lineno"> 1268</span>                                          field_kind::ARRAY_OF_NULLABLE_INT16,</div>
<div class="line"><span class="lineno"> 1269</span>                                          <span class="stringliteral">&quot;int16&quot;</span>);</div>
<div class="line"><span class="lineno"> 1270</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a808e1cb772c70ad188dcf2a9cfeefcaf" name="a808e1cb772c70ad188dcf2a9cfeefcaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808e1cb772c70ad188dcf2a9cfeefcaf">&#9670;&#160;</a></span>get_array_of_nullable_int32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; int32_t &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01291">1291</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1292</span>{</div>
<div class="line"><span class="lineno"> 1293</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;int32_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1294</span>                                          field_kind::ARRAY_OF_INT32,</div>
<div class="line"><span class="lineno"> 1295</span>                                          field_kind::ARRAY_OF_NULLABLE_INT32,</div>
<div class="line"><span class="lineno"> 1296</span>                                          <span class="stringliteral">&quot;int32&quot;</span>);</div>
<div class="line"><span class="lineno"> 1297</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac064a0c9bb34d087fb445b53292d4f98" name="ac064a0c9bb34d087fb445b53292d4f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac064a0c9bb34d087fb445b53292d4f98">&#9670;&#160;</a></span>get_array_of_nullable_int32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; int32_t &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01282">1282</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1283</span>{</div>
<div class="line"><span class="lineno"> 1284</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;int32_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1285</span>                                          field_kind::ARRAY_OF_INT32,</div>
<div class="line"><span class="lineno"> 1286</span>                                          field_kind::ARRAY_OF_NULLABLE_INT32,</div>
<div class="line"><span class="lineno"> 1287</span>                                          <span class="stringliteral">&quot;int32&quot;</span>);</div>
<div class="line"><span class="lineno"> 1288</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a602ed261c3dbc9f27b24f4fa258a02f0" name="a602ed261c3dbc9f27b24f4fa258a02f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602ed261c3dbc9f27b24f4fa258a02f0">&#9670;&#160;</a></span>get_array_of_nullable_int64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; int64_t &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01309">1309</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1310</span>{</div>
<div class="line"><span class="lineno"> 1311</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;int64_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1312</span>                                          field_kind::ARRAY_OF_INT64,</div>
<div class="line"><span class="lineno"> 1313</span>                                          field_kind::ARRAY_OF_NULLABLE_INT64,</div>
<div class="line"><span class="lineno"> 1314</span>                                          <span class="stringliteral">&quot;int64&quot;</span>);</div>
<div class="line"><span class="lineno"> 1315</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a32a9c2f59d8730831115c3e9d0a7197b" name="a32a9c2f59d8730831115c3e9d0a7197b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a9c2f59d8730831115c3e9d0a7197b">&#9670;&#160;</a></span>get_array_of_nullable_int64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; int64_t &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01300">1300</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1301</span>{</div>
<div class="line"><span class="lineno"> 1302</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;int64_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1303</span>                                          field_kind::ARRAY_OF_INT64,</div>
<div class="line"><span class="lineno"> 1304</span>                                          field_kind::ARRAY_OF_NULLABLE_INT64,</div>
<div class="line"><span class="lineno"> 1305</span>                                          <span class="stringliteral">&quot;int64&quot;</span>);</div>
<div class="line"><span class="lineno"> 1306</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a70bb774531d520d8dc36dc8423a3fa1e" name="a70bb774531d520d8dc36dc8423a3fa1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bb774531d520d8dc36dc8423a3fa1e">&#9670;&#160;</a></span>get_array_of_nullable_int8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; int8_t &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01255">1255</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1256</span>{</div>
<div class="line"><span class="lineno"> 1257</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;int8_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1258</span>                                         field_kind::ARRAY_OF_INT8,</div>
<div class="line"><span class="lineno"> 1259</span>                                         field_kind::ARRAY_OF_NULLABLE_INT8,</div>
<div class="line"><span class="lineno"> 1260</span>                                         <span class="stringliteral">&quot;int8&quot;</span>);</div>
<div class="line"><span class="lineno"> 1261</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aaa868ff55d01537d4b331d1d8be74c09" name="aaa868ff55d01537d4b331d1d8be74c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa868ff55d01537d4b331d1d8be74c09">&#9670;&#160;</a></span>get_array_of_nullable_int8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; int8_t &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_nullable_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01246">1246</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1247</span>{</div>
<div class="line"><span class="lineno"> 1248</span>    <span class="keywordflow">return</span> get_array_of_nullable&lt;int8_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1249</span>                                         field_kind::ARRAY_OF_INT8,</div>
<div class="line"><span class="lineno"> 1250</span>                                         field_kind::ARRAY_OF_NULLABLE_INT8,</div>
<div class="line"><span class="lineno"> 1251</span>                                         <span class="stringliteral">&quot;int8&quot;</span>);</div>
<div class="line"><span class="lineno"> 1252</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac1959b7dc53a7c8c78b896fddc12953b" name="ac1959b7dc53a7c8c78b896fddc12953b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1959b7dc53a7c8c78b896fddc12953b">&#9670;&#160;</a></span>get_array_of_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; std::string &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01363">1363</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1364</span>{</div>
<div class="line"><span class="lineno"> 1365</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;std::string&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1366</span>      field_name, field_kind::ARRAY_OF_STRING);</div>
<div class="line"><span class="lineno"> 1367</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad453a29a4c8dab0169e653c6cfc7fbf4" name="ad453a29a4c8dab0169e653c6cfc7fbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad453a29a4c8dab0169e653c6cfc7fbf4">&#9670;&#160;</a></span>get_array_of_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; std::string &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01356">1356</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1357</span>{</div>
<div class="line"><span class="lineno"> 1358</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;std::string&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1359</span>      field_name, field_kind::ARRAY_OF_STRING);</div>
<div class="line"><span class="lineno"> 1360</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a51e5f9c190856afe84b34bdcd8c4fa38" name="a51e5f9c190856afe84b34bdcd8c4fa38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e5f9c190856afe84b34bdcd8c4fa38">&#9670;&#160;</a></span>get_array_of_time() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_time </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schem definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#af590dc9ed44075027334666fbbaebc22">get_time()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01391">1391</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1392</span>{</div>
<div class="line"><span class="lineno"> 1393</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;local_time&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1394</span>      field_name, field_kind::ARRAY_OF_TIME);</div>
<div class="line"><span class="lineno"> 1395</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af575a44a1312820e8e363b16a953a0f4" name="af575a44a1312820e8e363b16a953a0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af575a44a1312820e8e363b16a953a0f4">&#9670;&#160;</a></span>get_array_of_time() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_time </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#af590dc9ed44075027334666fbbaebc22">get_time()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01384">1384</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1385</span>{</div>
<div class="line"><span class="lineno"> 1386</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;local_time&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1387</span>      field_name, field_kind::ARRAY_OF_TIME);</div>
<div class="line"><span class="lineno"> 1388</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb66e3d48e41c705b9c4d47d8b6c2db6" name="aeb66e3d48e41c705b9c4d47d8b6c2db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb66e3d48e41c705b9c4d47d8b6c2db6">&#9670;&#160;</a></span>get_array_of_timestamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_timestamp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a7569777ad59a4ba7f75145f5c01ebd6d">get_timestamp()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01419">1419</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1420</span>{</div>
<div class="line"><span class="lineno"> 1421</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;local_date_time&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1422</span>      field_name, field_kind::ARRAY_OF_TIMESTAMP);</div>
<div class="line"><span class="lineno"> 1423</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa2e1a9aa57db557f94973306958478a8" name="aa2e1a9aa57db557f94973306958478a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e1a9aa57db557f94973306958478a8">&#9670;&#160;</a></span>get_array_of_timestamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_timestamp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a7569777ad59a4ba7f75145f5c01ebd6d">get_timestamp()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01412">1412</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1413</span>{</div>
<div class="line"><span class="lineno"> 1414</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;local_date_time&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1415</span>      field_name, field_kind::ARRAY_OF_TIMESTAMP);</div>
<div class="line"><span class="lineno"> 1416</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae249d864bb1d399115693f16ba22d8da" name="ae249d864bb1d399115693f16ba22d8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae249d864bb1d399115693f16ba22d8da">&#9670;&#160;</a></span>get_array_of_timestamp_with_timezone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_timestamp_with_timezone </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a6da8a5af57b79f7b23518ec39e21a053">get_timestamp_with_timezone()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01434">1434</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1436</span>{</div>
<div class="line"><span class="lineno"> 1437</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;offset_date_time&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1438</span>      field_name, field_kind::ARRAY_OF_TIMESTAMP_WITH_TIMEZONE);</div>
<div class="line"><span class="lineno"> 1439</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae9d094118319c9cec2645e4e02873342" name="ae9d094118319c9cec2645e4e02873342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d094118319c9cec2645e4e02873342">&#9670;&#160;</a></span>get_array_of_timestamp_with_timezone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &gt; &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_array_of_timestamp_with_timezone </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a6da8a5af57b79f7b23518ec39e21a053">get_timestamp_with_timezone()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01426">1426</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1428</span>{</div>
<div class="line"><span class="lineno"> 1429</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::vector&lt;boost::optional&lt;offset_date_time&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1430</span>      field_name, field_kind::ARRAY_OF_TIMESTAMP_WITH_TIMEZONE);</div>
<div class="line"><span class="lineno"> 1431</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2c753233daa8dd84131a13ab53d030cc" name="a2c753233daa8dd84131a13ab53d030cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c753233daa8dd84131a13ab53d030cc">&#9670;&#160;</a></span>get_boolean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool &amp; hazelcast::client::serialization::generic_record::generic_record::get_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00826">826</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  827</span>{</div>
<div class="line"><span class="lineno">  828</span>    <span class="keywordflow">return</span> get_non_null&lt;bool&gt;(</div>
<div class="line"><span class="lineno">  829</span>      field_name, field_kind::BOOLEAN, field_kind::NULLABLE_BOOLEAN, <span class="stringliteral">&quot;Boolean&quot;</span>);</div>
<div class="line"><span class="lineno">  830</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a714d32a8d65dd5815b6e9fa5d3daa7bc" name="a714d32a8d65dd5815b6e9fa5d3daa7bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714d32a8d65dd5815b6e9fa5d3daa7bc">&#9670;&#160;</a></span>get_boolean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hazelcast::client::serialization::generic_record::generic_record::get_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00819">819</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  820</span>{</div>
<div class="line"><span class="lineno">  821</span>    <span class="keywordflow">return</span> get_non_null&lt;bool&gt;(</div>
<div class="line"><span class="lineno">  822</span>      field_name, field_kind::BOOLEAN, field_kind::NULLABLE_BOOLEAN, <span class="stringliteral">&quot;Boolean&quot;</span>);</div>
<div class="line"><span class="lineno">  823</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9bc9a6f940b858d2614deb98a2025db9" name="a9bc9a6f940b858d2614deb98a2025db9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc9a6f940b858d2614deb98a2025db9">&#9670;&#160;</a></span>get_date() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_date </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>date field consisting of year, month of the year and day of the month as <code><a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01067">1067</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1068</span>{</div>
<div class="line"><span class="lineno"> 1069</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;local_date&gt;&gt;(field_name, field_kind::DATE);</div>
<div class="line"><span class="lineno"> 1070</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abead288cf747dd9191c063c5791c5950" name="abead288cf747dd9191c063c5791c5950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abead288cf747dd9191c063c5791c5950">&#9670;&#160;</a></span>get_date() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_date </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>date field consisting of year, month of the year and day of the month as <code><a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01061">1061</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1062</span>{</div>
<div class="line"><span class="lineno"> 1063</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;local_date&gt;&gt;(field_name, field_kind::DATE);</div>
<div class="line"><span class="lineno"> 1064</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6ee378ca6320b240988204664b6a4d13" name="a6ee378ca6320b240988204664b6a4d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee378ca6320b240988204664b6a4d13">&#9670;&#160;</a></span>get_decimal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_decimal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decimal which is arbitrary precision and scale floating-point number as <code><a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01043">1043</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1044</span>{</div>
<div class="line"><span class="lineno"> 1045</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;big_decimal&gt;&gt;(field_name, field_kind::DECIMAL);</div>
<div class="line"><span class="lineno"> 1046</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acf277041c6f05a77bbe5dfc8686356c8" name="acf277041c6f05a77bbe5dfc8686356c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf277041c6f05a77bbe5dfc8686356c8">&#9670;&#160;</a></span>get_decimal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_decimal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decimal which is arbitrary precision and scale floating-point number as <code><a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01037">1037</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1038</span>{</div>
<div class="line"><span class="lineno"> 1039</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;big_decimal&gt;&gt;(field_name, field_kind::DECIMAL);</div>
<div class="line"><span class="lineno"> 1040</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad2ea3a313d17de70c0cd91c4ac9a8930" name="ad2ea3a313d17de70c0cd91c4ac9a8930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ea3a313d17de70c0cd91c4ac9a8930">&#9670;&#160;</a></span>get_field_kind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">field_kind hazelcast::client::serialization::generic_record::generic_record::get_field_kind </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the kind of the field for the given field name. </p>
<p>If the field with the given name does not exist, <code><a class="el" href="../../">field_kind#NOT_AVAILABLE</a></code> is returned. </p>
<p>This method can be used to check the existence of a field, which can be useful when the class is evolved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kind of the field </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00801">801</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  802</span>{</div>
<div class="line"><span class="lineno">  803</span>    <span class="keyword">auto</span> descriptor = schema_-&gt;get_field(field_name);</div>
<div class="line"><span class="lineno">  804</span> </div>
<div class="line"><span class="lineno">  805</span>    <span class="keywordflow">if</span> (!descriptor) {</div>
<div class="line"><span class="lineno">  806</span>        <span class="keywordflow">return</span> field_kind::NOT_AVAILABLE;</div>
<div class="line"><span class="lineno">  807</span>    }</div>
<div class="line"><span class="lineno">  808</span> </div>
<div class="line"><span class="lineno">  809</span>    <span class="keywordflow">return</span> descriptor-&gt;kind;</div>
<div class="line"><span class="lineno">  810</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abfd6854435e51bc57dcf9e1165d7ef52" name="abfd6854435e51bc57dcf9e1165d7ef52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd6854435e51bc57dcf9e1165d7ef52">&#9670;&#160;</a></span>get_field_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt; std::string &gt; hazelcast::client::serialization::generic_record::generic_record::get_field_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>set of field names of this <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00784">784</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  785</span>{</div>
<div class="line"><span class="lineno">  786</span>    std::unordered_set&lt;std::string&gt; field_names;</div>
<div class="line"><span class="lineno">  787</span> </div>
<div class="line"><span class="lineno">  788</span>    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; fields = schema_-&gt;fields();</div>
<div class="line"><span class="lineno">  789</span> </div>
<div class="line"><span class="lineno">  790</span>    transform(begin(fields),</div>
<div class="line"><span class="lineno">  791</span>              end(fields),</div>
<div class="line"><span class="lineno">  792</span>              inserter(field_names, end(field_names)),</div>
<div class="line"><span class="lineno">  793</span>              [](<span class="keyword">const</span> std::pair&lt;std::string, pimpl::field_descriptor&gt;&amp; p) {</div>
<div class="line"><span class="lineno">  794</span>                  <span class="keywordflow">return</span> p.first;</div>
<div class="line"><span class="lineno">  795</span>              });</div>
<div class="line"><span class="lineno">  796</span> </div>
<div class="line"><span class="lineno">  797</span>    <span class="keywordflow">return</span> field_names;</div>
<div class="line"><span class="lineno">  798</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a13411e4de976b0ff1afbcd3130096a9a" name="a13411e4de976b0ff1afbcd3130096a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13411e4de976b0ff1afbcd3130096a9a">&#9670;&#160;</a></span>get_float32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float &amp; hazelcast::client::serialization::generic_record::generic_record::get_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00896">896</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  897</span>{</div>
<div class="line"><span class="lineno">  898</span>    <span class="keywordflow">return</span> get_non_null&lt;float&gt;(</div>
<div class="line"><span class="lineno">  899</span>      field_name, field_kind::FLOAT32, field_kind::NULLABLE_FLOAT32, <span class="stringliteral">&quot;Float32&quot;</span>);</div>
<div class="line"><span class="lineno">  900</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abbe139b1193ca9e7d919a7b0131026f9" name="abbe139b1193ca9e7d919a7b0131026f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe139b1193ca9e7d919a7b0131026f9">&#9670;&#160;</a></span>get_float32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hazelcast::client::serialization::generic_record::generic_record::get_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00889">889</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  890</span>{</div>
<div class="line"><span class="lineno">  891</span>    <span class="keywordflow">return</span> get_non_null&lt;float&gt;(</div>
<div class="line"><span class="lineno">  892</span>      field_name, field_kind::FLOAT32, field_kind::NULLABLE_FLOAT32, <span class="stringliteral">&quot;Float32&quot;</span>);</div>
<div class="line"><span class="lineno">  893</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="adf2ca6e3013c10421c7ab34758f48317" name="adf2ca6e3013c10421c7ab34758f48317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2ca6e3013c10421c7ab34758f48317">&#9670;&#160;</a></span>get_float64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double &amp; hazelcast::client::serialization::generic_record::generic_record::get_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00910">910</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  911</span>{</div>
<div class="line"><span class="lineno">  912</span>    <span class="keywordflow">return</span> get_non_null&lt;double&gt;(</div>
<div class="line"><span class="lineno">  913</span>      field_name, field_kind::FLOAT64, field_kind::NULLABLE_FLOAT64, <span class="stringliteral">&quot;Float64&quot;</span>);</div>
<div class="line"><span class="lineno">  914</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b143babc84fa4e58750b7249ec8a728" name="a3b143babc84fa4e58750b7249ec8a728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b143babc84fa4e58750b7249ec8a728">&#9670;&#160;</a></span>get_float64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double hazelcast::client::serialization::generic_record::generic_record::get_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00903">903</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  904</span>{</div>
<div class="line"><span class="lineno">  905</span>    <span class="keywordflow">return</span> get_non_null&lt;double&gt;(</div>
<div class="line"><span class="lineno">  906</span>      field_name, field_kind::FLOAT64, field_kind::NULLABLE_FLOAT64, <span class="stringliteral">&quot;Float64&quot;</span>);</div>
<div class="line"><span class="lineno">  907</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aae06a17de17f44769ab5c0febff93f27" name="aae06a17de17f44769ab5c0febff93f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae06a17de17f44769ab5c0febff93f27">&#9670;&#160;</a></span>get_generic_record() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_generic_record </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01030">1030</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1031</span>{</div>
<div class="line"><span class="lineno"> 1032</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;generic_record&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1033</span>                                                field_kind::COMPACT);</div>
<div class="line"><span class="lineno"> 1034</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a324d0ce0261501034d525c7d99768e79" name="a324d0ce0261501034d525c7d99768e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324d0ce0261501034d525c7d99768e79">&#9670;&#160;</a></span>get_generic_record() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_generic_record </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01023">1023</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1024</span>{</div>
<div class="line"><span class="lineno"> 1025</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;generic_record&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1026</span>                                                field_kind::COMPACT);</div>
<div class="line"><span class="lineno"> 1027</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a74667307604e64156b68cd4e4af11e09" name="a74667307604e64156b68cd4e4af11e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74667307604e64156b68cd4e4af11e09">&#9670;&#160;</a></span>get_int16() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t &amp; hazelcast::client::serialization::generic_record::generic_record::get_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00854">854</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  855</span>{</div>
<div class="line"><span class="lineno">  856</span>    <span class="keywordflow">return</span> get_non_null&lt;int16_t&gt;(</div>
<div class="line"><span class="lineno">  857</span>      field_name, field_kind::INT16, field_kind::NULLABLE_INT16, <span class="stringliteral">&quot;Int16&quot;</span>);</div>
<div class="line"><span class="lineno">  858</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a45ecdbbc371b27bda548d7fc8309cd87" name="a45ecdbbc371b27bda548d7fc8309cd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ecdbbc371b27bda548d7fc8309cd87">&#9670;&#160;</a></span>get_int16() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t hazelcast::client::serialization::generic_record::generic_record::get_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00847">847</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  848</span>{</div>
<div class="line"><span class="lineno">  849</span>    <span class="keywordflow">return</span> get_non_null&lt;int16_t&gt;(</div>
<div class="line"><span class="lineno">  850</span>      field_name, field_kind::INT16, field_kind::NULLABLE_INT16, <span class="stringliteral">&quot;Int16&quot;</span>);</div>
<div class="line"><span class="lineno">  851</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab5321fab5625c00dc6945d93640fefd1" name="ab5321fab5625c00dc6945d93640fefd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5321fab5625c00dc6945d93640fefd1">&#9670;&#160;</a></span>get_int32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t &amp; hazelcast::client::serialization::generic_record::generic_record::get_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00868">868</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  869</span>{</div>
<div class="line"><span class="lineno">  870</span>    <span class="keywordflow">return</span> get_non_null&lt;int32_t&gt;(</div>
<div class="line"><span class="lineno">  871</span>      field_name, field_kind::INT32, field_kind::NULLABLE_INT32, <span class="stringliteral">&quot;Int32&quot;</span>);</div>
<div class="line"><span class="lineno">  872</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab5ddb93e1bc70f2e83d855e7e66d2f5c" name="ab5ddb93e1bc70f2e83d855e7e66d2f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ddb93e1bc70f2e83d855e7e66d2f5c">&#9670;&#160;</a></span>get_int32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t hazelcast::client::serialization::generic_record::generic_record::get_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00861">861</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  862</span>{</div>
<div class="line"><span class="lineno">  863</span>    <span class="keywordflow">return</span> get_non_null&lt;int32_t&gt;(</div>
<div class="line"><span class="lineno">  864</span>      field_name, field_kind::INT32, field_kind::NULLABLE_INT32, <span class="stringliteral">&quot;Int32&quot;</span>);</div>
<div class="line"><span class="lineno">  865</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1bd52a9dd2d1ba4187dde5c35a245b2c" name="a1bd52a9dd2d1ba4187dde5c35a245b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd52a9dd2d1ba4187dde5c35a245b2c">&#9670;&#160;</a></span>get_int64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t &amp; hazelcast::client::serialization::generic_record::generic_record::get_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00882">882</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  883</span>{</div>
<div class="line"><span class="lineno">  884</span>    <span class="keywordflow">return</span> get_non_null&lt;int64_t&gt;(</div>
<div class="line"><span class="lineno">  885</span>      field_name, field_kind::INT64, field_kind::NULLABLE_INT64, <span class="stringliteral">&quot;Int64&quot;</span>);</div>
<div class="line"><span class="lineno">  886</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a08972f6889fb31c7131fcddc07741b69" name="a08972f6889fb31c7131fcddc07741b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08972f6889fb31c7131fcddc07741b69">&#9670;&#160;</a></span>get_int64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t hazelcast::client::serialization::generic_record::generic_record::get_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00875">875</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  876</span>{</div>
<div class="line"><span class="lineno">  877</span>    <span class="keywordflow">return</span> get_non_null&lt;int64_t&gt;(</div>
<div class="line"><span class="lineno">  878</span>      field_name, field_kind::INT64, field_kind::NULLABLE_INT64, <span class="stringliteral">&quot;Int64&quot;</span>);</div>
<div class="line"><span class="lineno">  879</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a135d1d3fcb76bb8a4308fc2c5d3c833d" name="a135d1d3fcb76bb8a4308fc2c5d3c833d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135d1d3fcb76bb8a4308fc2c5d3c833d">&#9670;&#160;</a></span>get_int8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t &amp; hazelcast::client::serialization::generic_record::generic_record::get_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00840">840</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  841</span>{</div>
<div class="line"><span class="lineno">  842</span>    <span class="keywordflow">return</span> get_non_null&lt;int8_t&gt;(</div>
<div class="line"><span class="lineno">  843</span>      field_name, field_kind::INT8, field_kind::NULLABLE_INT8, <span class="stringliteral">&quot;Int8&quot;</span>);</div>
<div class="line"><span class="lineno">  844</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a867486e399981546274d8e390d3cdf52" name="a867486e399981546274d8e390d3cdf52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867486e399981546274d8e390d3cdf52">&#9670;&#160;</a></span>get_int8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t hazelcast::client::serialization::generic_record::generic_record::get_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00833">833</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  834</span>{</div>
<div class="line"><span class="lineno">  835</span>    <span class="keywordflow">return</span> get_non_null&lt;int8_t&gt;(</div>
<div class="line"><span class="lineno">  836</span>      field_name, field_kind::INT8, field_kind::NULLABLE_INT8, <span class="stringliteral">&quot;Int8&quot;</span>);</div>
<div class="line"><span class="lineno">  837</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1d51814873acede23c821af25b94c84e" name="a1d51814873acede23c821af25b94c84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d51814873acede23c821af25b94c84e">&#9670;&#160;</a></span>get_nullable_boolean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; bool &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_nullable_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00923">923</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  924</span>{</div>
<div class="line"><span class="lineno">  925</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;bool&gt;&gt;(field_name, field_kind::NULLABLE_BOOLEAN);</div>
<div class="line"><span class="lineno">  926</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad1d8e3be66a383c6fbf77397a0eab6dd" name="ad1d8e3be66a383c6fbf77397a0eab6dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d8e3be66a383c6fbf77397a0eab6dd">&#9670;&#160;</a></span>get_nullable_boolean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; bool &gt; hazelcast::client::serialization::generic_record::generic_record::get_nullable_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00917">917</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  918</span>{</div>
<div class="line"><span class="lineno">  919</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;bool&gt;&gt;(field_name, field_kind::NULLABLE_BOOLEAN);</div>
<div class="line"><span class="lineno">  920</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="adef63c63455ad97eaada9461f52a14cc" name="adef63c63455ad97eaada9461f52a14cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef63c63455ad97eaada9461f52a14cc">&#9670;&#160;</a></span>get_nullable_float32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; float &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_nullable_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00990">990</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  991</span>{</div>
<div class="line"><span class="lineno">  992</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;float&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno">  993</span>                                       field_kind::NULLABLE_FLOAT32);</div>
<div class="line"><span class="lineno">  994</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a13ee798406d233fde22e846ca7207dac" name="a13ee798406d233fde22e846ca7207dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ee798406d233fde22e846ca7207dac">&#9670;&#160;</a></span>get_nullable_float32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; float &gt; hazelcast::client::serialization::generic_record::generic_record::get_nullable_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00983">983</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  984</span>{</div>
<div class="line"><span class="lineno">  985</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;float&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno">  986</span>                                       field_kind::NULLABLE_FLOAT32);</div>
<div class="line"><span class="lineno">  987</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aabbb3ef2415fbdeecc38964b1cd6e67e" name="aabbb3ef2415fbdeecc38964b1cd6e67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbb3ef2415fbdeecc38964b1cd6e67e">&#9670;&#160;</a></span>get_nullable_float64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; double &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_nullable_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01004">1004</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1005</span>{</div>
<div class="line"><span class="lineno"> 1006</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;double&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1007</span>                                        field_kind::NULLABLE_FLOAT64);</div>
<div class="line"><span class="lineno"> 1008</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a144c440ac39ed5887882ed2eb4c16871" name="a144c440ac39ed5887882ed2eb4c16871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144c440ac39ed5887882ed2eb4c16871">&#9670;&#160;</a></span>get_nullable_float64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; double &gt; hazelcast::client::serialization::generic_record::generic_record::get_nullable_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00997">997</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  998</span>{</div>
<div class="line"><span class="lineno">  999</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;double&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1000</span>                                        field_kind::NULLABLE_FLOAT64);</div>
<div class="line"><span class="lineno"> 1001</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a36610e49f7f341897fe946d75328d810" name="a36610e49f7f341897fe946d75328d810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36610e49f7f341897fe946d75328d810">&#9670;&#160;</a></span>get_nullable_int16() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int16_t &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_nullable_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00948">948</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  949</span>{</div>
<div class="line"><span class="lineno">  950</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;int16_t&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno">  951</span>                                         field_kind::NULLABLE_INT16);</div>
<div class="line"><span class="lineno">  952</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac73021280492c27351155c4b7d1c2776" name="ac73021280492c27351155c4b7d1c2776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73021280492c27351155c4b7d1c2776">&#9670;&#160;</a></span>get_nullable_int16() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int16_t &gt; hazelcast::client::serialization::generic_record::generic_record::get_nullable_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00941">941</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  942</span>{</div>
<div class="line"><span class="lineno">  943</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;int16_t&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno">  944</span>                                         field_kind::NULLABLE_INT16);</div>
<div class="line"><span class="lineno">  945</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac1d6be32c16aa479c5fcd22e2c2cf3a5" name="ac1d6be32c16aa479c5fcd22e2c2cf3a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d6be32c16aa479c5fcd22e2c2cf3a5">&#9670;&#160;</a></span>get_nullable_int32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int32_t &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_nullable_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00962">962</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  963</span>{</div>
<div class="line"><span class="lineno">  964</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;int32_t&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno">  965</span>                                         field_kind::NULLABLE_INT32);</div>
<div class="line"><span class="lineno">  966</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af85b73d459eabf71924ecfc51c4da6a1" name="af85b73d459eabf71924ecfc51c4da6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85b73d459eabf71924ecfc51c4da6a1">&#9670;&#160;</a></span>get_nullable_int32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int32_t &gt; hazelcast::client::serialization::generic_record::generic_record::get_nullable_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00955">955</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  956</span>{</div>
<div class="line"><span class="lineno">  957</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;int32_t&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno">  958</span>                                         field_kind::NULLABLE_INT32);</div>
<div class="line"><span class="lineno">  959</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af88f20ad3d56bfe992d68cd1e3745362" name="af88f20ad3d56bfe992d68cd1e3745362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88f20ad3d56bfe992d68cd1e3745362">&#9670;&#160;</a></span>get_nullable_int64() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int64_t &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_nullable_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00976">976</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  977</span>{</div>
<div class="line"><span class="lineno">  978</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;int64_t&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno">  979</span>                                         field_kind::NULLABLE_INT64);</div>
<div class="line"><span class="lineno">  980</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a71f1ce8bf80df090ae378b3331587f52" name="a71f1ce8bf80df090ae378b3331587f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f1ce8bf80df090ae378b3331587f52">&#9670;&#160;</a></span>get_nullable_int64() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int64_t &gt; hazelcast::client::serialization::generic_record::generic_record::get_nullable_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00969">969</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  970</span>{</div>
<div class="line"><span class="lineno">  971</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;int64_t&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno">  972</span>                                         field_kind::NULLABLE_INT64);</div>
<div class="line"><span class="lineno">  973</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a355b390a3845681c436d0d09692108ae" name="a355b390a3845681c436d0d09692108ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355b390a3845681c436d0d09692108ae">&#9670;&#160;</a></span>get_nullable_int8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int8_t &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_nullable_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00935">935</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  936</span>{</div>
<div class="line"><span class="lineno">  937</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;int8_t&gt;&gt;(field_name, field_kind::NULLABLE_INT8);</div>
<div class="line"><span class="lineno">  938</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0aeca39439597cd66622d274117d3b1e" name="a0aeca39439597cd66622d274117d3b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aeca39439597cd66622d274117d3b1e">&#9670;&#160;</a></span>get_nullable_int8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int8_t &gt; hazelcast::client::serialization::generic_record::generic_record::get_nullable_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supported only for Compact. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00929">929</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  930</span>{</div>
<div class="line"><span class="lineno">  931</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;int8_t&gt;&gt;(field_name, field_kind::NULLABLE_INT8);</div>
<div class="line"><span class="lineno">  932</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a951656f04ffd5cd5cae6e2bfe6cd4485" name="a951656f04ffd5cd5cae6e2bfe6cd4485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951656f04ffd5cd5cae6e2bfe6cd4485">&#9670;&#160;</a></span>get_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::string &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema/class definition or the type of the field does not match the one in the schema/class definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01017">1017</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1018</span>{</div>
<div class="line"><span class="lineno"> 1019</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::string&gt;&gt;(field_name, field_kind::STRING);</div>
<div class="line"><span class="lineno"> 1020</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa891502c5e705479906cf00fb481f9b1" name="aa891502c5e705479906cf00fb481f9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa891502c5e705479906cf00fb481f9b1">&#9670;&#160;</a></span>get_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; std::string &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01011">1011</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1012</span>{</div>
<div class="line"><span class="lineno"> 1013</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;std::string&gt;&gt;(field_name, field_kind::STRING);</div>
<div class="line"><span class="lineno"> 1014</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aedb67f6f8d0b9b6b3665777e5c2c7409" name="aedb67f6f8d0b9b6b3665777e5c2c7409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb67f6f8d0b9b6b3665777e5c2c7409">&#9670;&#160;</a></span>get_time() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_time </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>time field consisting of hour, minute, seconds and nanos parts as <code><a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01055">1055</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1056</span>{</div>
<div class="line"><span class="lineno"> 1057</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;local_time&gt;&gt;(field_name, field_kind::TIME);</div>
<div class="line"><span class="lineno"> 1058</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af590dc9ed44075027334666fbbaebc22" name="af590dc9ed44075027334666fbbaebc22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af590dc9ed44075027334666fbbaebc22">&#9670;&#160;</a></span>get_time() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_time </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>time field consisting of hour, minute, seconds and nanos parts as <code><a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01049">1049</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1050</span>{</div>
<div class="line"><span class="lineno"> 1051</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;local_time&gt;&gt;(field_name, field_kind::TIME);</div>
<div class="line"><span class="lineno"> 1052</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0a0a17af5ec6428f88f8aaa57580d514" name="a0a0a17af5ec6428f88f8aaa57580d514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0a17af5ec6428f88f8aaa57580d514">&#9670;&#160;</a></span>get_timestamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_timestamp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>timestamp field consisting of year, month of the year, day of the month, hour, minute, seconds, nanos parts as <code><a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01080">1080</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1081</span>{</div>
<div class="line"><span class="lineno"> 1082</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;local_date_time&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1083</span>                                                 field_kind::TIMESTAMP);</div>
<div class="line"><span class="lineno"> 1084</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7569777ad59a4ba7f75145f5c01ebd6d" name="a7569777ad59a4ba7f75145f5c01ebd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7569777ad59a4ba7f75145f5c01ebd6d">&#9670;&#160;</a></span>get_timestamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_timestamp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>timestamp field consisting of year, month of the year, day of the month, hour, minute, seconds, nanos parts as <code><a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01073">1073</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1074</span>{</div>
<div class="line"><span class="lineno"> 1075</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;local_date_time&gt;&gt;(field_name,</div>
<div class="line"><span class="lineno"> 1076</span>                                                 field_kind::TIMESTAMP);</div>
<div class="line"><span class="lineno"> 1077</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a036490b36cb12625db194a62cfb12a0b" name="a036490b36cb12625db194a62cfb12a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036490b36cb12625db194a62cfb12a0b">&#9670;&#160;</a></span>get_timestamp_with_timezone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_timestamp_with_timezone </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>timestamp with timezone field consisting of year, month of the year, day of the month, offset seconds, hour, minute, seconds, nanos parts as <code><a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01094">1094</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1095</span>{</div>
<div class="line"><span class="lineno"> 1096</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;offset_date_time&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1097</span>      field_name, field_kind::TIMESTAMP_WITH_TIMEZONE);</div>
<div class="line"><span class="lineno"> 1098</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6da8a5af57b79f7b23518ec39e21a053" name="a6da8a5af57b79f7b23518ec39e21a053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da8a5af57b79f7b23518ec39e21a053">&#9670;&#160;</a></span>get_timestamp_with_timezone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &amp; hazelcast::client::serialization::generic_record::generic_record::get_timestamp_with_timezone </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>timestamp with timezone field consisting of year, month of the year, day of the month, offset seconds, hour, minute, seconds, nanos parts as <code><a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a></code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01087">1087</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1088</span>{</div>
<div class="line"><span class="lineno"> 1089</span>    <span class="keywordflow">return</span> get&lt;boost::optional&lt;offset_date_time&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1090</span>      field_name, field_kind::TIMESTAMP_WITH_TIMEZONE);</div>
<div class="line"><span class="lineno"> 1091</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7714133e6dd7b939d6e4230a4f259ed2" name="a7714133e6dd7b939d6e4230a4f259ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7714133e6dd7b939d6e4230a4f259ed2">&#9670;&#160;</a></span>has_field()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hazelcast::client::serialization::generic_record::generic_record::has_field </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>the name of the field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if field exists in the schema/class definition. Note that returns true even if the field is null. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00813">813</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  814</span>{</div>
<div class="line"><span class="lineno">  815</span>    <span class="keywordflow">return</span> objects_.find(field_name) != end(objects_);</div>
<div class="line"><span class="lineno">  816</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a511d0dfcf85537bea02a6060170b5e34" name="a511d0dfcf85537bea02a6060170b5e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511d0dfcf85537bea02a6060170b5e34">&#9670;&#160;</a></span>new_builder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> hazelcast::client::serialization::generic_record::generic_record::new_builder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <code><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a></code> allows to create a new object. </p>
<p>This method is a convenience method to get a builder, without creating the schema/class definition for this type. Here you can see a new object is constructed from an existing <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> with its schema definition:</p>
<pre><code class="JavaDocCode"><br/>
generic_record new_record = record.new_builder()<br/>
     .set_string("name", "bar")<br/>
     .set_int32("id", 4)<br/>
     .build();<br/>
</code></pre><p> &lt;p&lt;blockquote&gt;&zwj; </p>
<p>See <code><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a></code> to create a <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> in <code><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a></code> to create a <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> in Compact format with a different schema.</p>
<dl class="section return"><dt>Returns</dt><dd>an empty generic record builder with same schema as this one </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00772">772</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  773</span>{</div>
<div class="line"><span class="lineno">  774</span>    <span class="keywordflow">return</span> generic_record_builder{ schema_ };</div>
<div class="line"><span class="lineno">  775</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9be4ec9ba393576c4ec4607cc42eafbd" name="a9be4ec9ba393576c4ec4607cc42eafbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be4ec9ba393576c4ec4607cc42eafbd">&#9670;&#160;</a></span>new_builder_with_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> hazelcast::client::serialization::generic_record::generic_record::new_builder_with_clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returned <code><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a></code> can be used to have exact copy and also just to update a couple of fields. </p>
<p>By default, it will copy all the fields. So instead of following where only the <code>id</code> field is updated, </p><pre><code class="JavaDocCode"><br/>
generic_record modified_record = record.newBuilder()<br/>
        .set_string("name", record.get_string("name"))<br/>
        .set_int64("id", 4)<br/>
        .set_string("surname", record.get_string("surname"))<br/>
        .set_int32("age", record.get_int32("age"))<br/>
        .build();<br/>
</code></pre><p> <code>new_builder_with_clone</code> used as follows: </p><pre><code class="JavaDocCode"><br/>
generic_record modified_record = record.new_builder_with_clone()<br/>
        .set_int32("id", 4)<br/>
        .build();<br/>
</code></pre><dl class="section return"><dt>Returns</dt><dd>a generic record builder with same schema definition as this one and populated with same values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00778">778</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  779</span>{</div>
<div class="line"><span class="lineno">  780</span>    <span class="keywordflow">return</span> generic_record_builder{ schema_, objects_ };</div>
<div class="line"><span class="lineno">  781</span>}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a43e6ffbe06e93b1c3c131a18e4d21b3b" name="a43e6ffbe06e93b1c3c131a18e4d21b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e6ffbe06e93b1c3c131a18e4d21b3b">&#9670;&#160;</a></span>generic_record_builder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d8/d76/generic__record_8h_source.html#l01034">1034</a> of file <a class="el" href="../../d8/d76/generic__record_8h_source.html">generic_record.h</a>.</p>

</div>
</div>
<a id="aff0e36cea8a99b0d0adc16459890aeec" name="aff0e36cea8a99b0d0adc16459890aeec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0e36cea8a99b0d0adc16459890aeec">&#9670;&#160;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HAZELCAST_API operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01738">1738</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1739</span>{</div>
<div class="line"><span class="lineno"> 1740</span>    <span class="keywordflow">return</span> !(x == y);</div>
<div class="line"><span class="lineno"> 1741</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a778ca519c51aba88b1b6f240f2725d55" name="a778ca519c51aba88b1b6f240f2725d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778ca519c51aba88b1b6f240f2725d55">&#9670;&#160;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream HAZELCAST_API &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;&#160;</td>
          <td class="paramname"><em>record</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01472">1472</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1474</span>{</div>
<div class="line"><span class="lineno"> 1475</span>    boost::property_tree::ptree pt;</div>
<div class="line"><span class="lineno"> 1476</span> </div>
<div class="line"><span class="lineno"> 1477</span>    pt.put_child(record.get_schema().type_name(), write_generic_record(record));</div>
<div class="line"><span class="lineno"> 1478</span> </div>
<div class="line"><span class="lineno"> 1479</span>    boost::property_tree::write_json(os, pt);</div>
<div class="line"><span class="lineno"> 1480</span> </div>
<div class="line"><span class="lineno"> 1481</span>    <span class="keywordflow">return</span> os;</div>
<div class="line"><span class="lineno"> 1482</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac373fa6215c12b50cee2a36062f2ee91" name="ac373fa6215c12b50cee2a36062f2ee91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac373fa6215c12b50cee2a36062f2ee91">&#9670;&#160;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool HAZELCAST_API operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01485">1485</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1486</span>{</div>
<div class="line"><span class="lineno"> 1487</span>    <span class="keyword">static</span> <span class="keyword">const</span> std::function&lt;bool(<span class="keyword">const</span> boost::any&amp;, <span class="keyword">const</span> boost::any&amp;)&gt;</div>
<div class="line"><span class="lineno"> 1488</span>      COMPARATORS[] = {</div>
<div class="line"><span class="lineno"> 1489</span>          [](<span class="keyword">const</span> boost::any&amp;, <span class="keyword">const</span> boost::any&amp;) {</div>
<div class="line"><span class="lineno"> 1490</span>              <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1491</span>          },                                             <span class="comment">//[0] NOT_AVAILABLE</span></div>
<div class="line"><span class="lineno"> 1492</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[1] BOOLEAN</span></div>
<div class="line"><span class="lineno"> 1493</span>              <span class="keywordflow">return</span> boost::any_cast&lt;bool&gt;(x) == boost::any_cast&lt;bool&gt;(y);</div>
<div class="line"><span class="lineno"> 1494</span>          },</div>
<div class="line"><span class="lineno"> 1495</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[2] ARRAY_OF_BOOLEAN</span></div>
<div class="line"><span class="lineno"> 1496</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;std::vector&lt;bool&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1497</span>                     boost::any_cast&lt;boost::optional&lt;std::vector&lt;bool&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1498</span>          },</div>
<div class="line"><span class="lineno"> 1499</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[3] INT8</span></div>
<div class="line"><span class="lineno"> 1500</span>              <span class="keywordflow">return</span> boost::any_cast&lt;int8_t&gt;(x) == boost::any_cast&lt;int8_t&gt;(y);</div>
<div class="line"><span class="lineno"> 1501</span>          },</div>
<div class="line"><span class="lineno"> 1502</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[4] ARRAY_OF_INT8</span></div>
<div class="line"><span class="lineno"> 1503</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;std::vector&lt;int8_t&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1504</span>                     boost::any_cast&lt;boost::optional&lt;std::vector&lt;int8_t&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1505</span>          },</div>
<div class="line"><span class="lineno"> 1506</span>          [](<span class="keyword">const</span> boost::any&amp;, <span class="keyword">const</span> boost::any&amp;) { <span class="keywordflow">return</span> <span class="keyword">false</span>; }, <span class="comment">// [5]</span></div>
<div class="line"><span class="lineno"> 1507</span>          [](<span class="keyword">const</span> boost::any&amp;, <span class="keyword">const</span> boost::any&amp;) { <span class="keywordflow">return</span> <span class="keyword">false</span>; }, <span class="comment">// [6]</span></div>
<div class="line"><span class="lineno"> 1508</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[7] INT16</span></div>
<div class="line"><span class="lineno"> 1509</span>              <span class="keywordflow">return</span> boost::any_cast&lt;int16_t&gt;(x) == boost::any_cast&lt;int16_t&gt;(y);</div>
<div class="line"><span class="lineno"> 1510</span>          },</div>
<div class="line"><span class="lineno"> 1511</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[8] ARRAY_OF_INT16</span></div>
<div class="line"><span class="lineno"> 1512</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;std::vector&lt;int16_t&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1513</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1514</span>                     boost::any_cast&lt;boost::optional&lt;std::vector&lt;int16_t&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1515</span>          },</div>
<div class="line"><span class="lineno"> 1516</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[9] INT32</span></div>
<div class="line"><span class="lineno"> 1517</span>              <span class="keywordflow">return</span> boost::any_cast&lt;int32_t&gt;(x) == boost::any_cast&lt;int32_t&gt;(y);</div>
<div class="line"><span class="lineno"> 1518</span>          },</div>
<div class="line"><span class="lineno"> 1519</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[10] ARRAY_OF_INT32</span></div>
<div class="line"><span class="lineno"> 1520</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;std::vector&lt;int32_t&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1521</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1522</span>                     boost::any_cast&lt;boost::optional&lt;std::vector&lt;int32_t&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1523</span>          },</div>
<div class="line"><span class="lineno"> 1524</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[11] INT64</span></div>
<div class="line"><span class="lineno"> 1525</span>              <span class="keywordflow">return</span> boost::any_cast&lt;int64_t&gt;(x) == boost::any_cast&lt;int64_t&gt;(y);</div>
<div class="line"><span class="lineno"> 1526</span>          },</div>
<div class="line"><span class="lineno"> 1527</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[12] ARRAY_OF_INT64</span></div>
<div class="line"><span class="lineno"> 1528</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;std::vector&lt;int64_t&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1529</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1530</span>                     boost::any_cast&lt;boost::optional&lt;std::vector&lt;int64_t&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1531</span>          },</div>
<div class="line"><span class="lineno"> 1532</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[13] FLOAT32</span></div>
<div class="line"><span class="lineno"> 1533</span>              <span class="keywordflow">return</span> boost::any_cast&lt;float&gt;(x) == boost::any_cast&lt;float&gt;(y);</div>
<div class="line"><span class="lineno"> 1534</span>          },</div>
<div class="line"><span class="lineno"> 1535</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[14] ARRAY_OF_FLOAT32</span></div>
<div class="line"><span class="lineno"> 1536</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;std::vector&lt;float&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1537</span>                     boost::any_cast&lt;boost::optional&lt;std::vector&lt;float&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1538</span>          },</div>
<div class="line"><span class="lineno"> 1539</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[15] FLOAT64</span></div>
<div class="line"><span class="lineno"> 1540</span>              <span class="keywordflow">return</span> boost::any_cast&lt;double&gt;(x) == boost::any_cast&lt;double&gt;(y);</div>
<div class="line"><span class="lineno"> 1541</span>          },</div>
<div class="line"><span class="lineno"> 1542</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[16] ARRAY_OF_FLOAT64</span></div>
<div class="line"><span class="lineno"> 1543</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;std::vector&lt;double&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1544</span>                     boost::any_cast&lt;boost::optional&lt;std::vector&lt;double&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1545</span>          },</div>
<div class="line"><span class="lineno"> 1546</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[17] STRING</span></div>
<div class="line"><span class="lineno"> 1547</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;std::string&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1548</span>                     boost::any_cast&lt;boost::optional&lt;std::string&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1549</span>          },</div>
<div class="line"><span class="lineno"> 1550</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[18] ARRAY_OF_STRING</span></div>
<div class="line"><span class="lineno"> 1551</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1552</span>                       std::vector&lt;boost::optional&lt;std::string&gt;&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1553</span>                     boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1554</span>                       std::vector&lt;boost::optional&lt;std::string&gt;&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1555</span>          },</div>
<div class="line"><span class="lineno"> 1556</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[19] DECIMAL</span></div>
<div class="line"><span class="lineno"> 1557</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;big_decimal&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1558</span>                     boost::any_cast&lt;boost::optional&lt;big_decimal&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1559</span>          },</div>
<div class="line"><span class="lineno"> 1560</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[20] ARRAY_OF_DECIMAL</span></div>
<div class="line"><span class="lineno"> 1561</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1562</span>                       std::vector&lt;boost::optional&lt;big_decimal&gt;&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1563</span>                     boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1564</span>                       std::vector&lt;boost::optional&lt;big_decimal&gt;&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1565</span>          },</div>
<div class="line"><span class="lineno"> 1566</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[21] TIME</span></div>
<div class="line"><span class="lineno"> 1567</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;local_time&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1568</span>                     boost::any_cast&lt;boost::optional&lt;local_time&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1569</span>          },</div>
<div class="line"><span class="lineno"> 1570</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[22] ARRAY_OF_TIME</span></div>
<div class="line"><span class="lineno"> 1571</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1572</span>                       std::vector&lt;boost::optional&lt;local_time&gt;&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1573</span>                     boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1574</span>                       std::vector&lt;boost::optional&lt;local_time&gt;&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1575</span>          },</div>
<div class="line"><span class="lineno"> 1576</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[23] DATE</span></div>
<div class="line"><span class="lineno"> 1577</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;local_date&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1578</span>                     boost::any_cast&lt;boost::optional&lt;local_date&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1579</span>          },</div>
<div class="line"><span class="lineno"> 1580</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[24] ARRAY_OF_DATE</span></div>
<div class="line"><span class="lineno"> 1581</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1582</span>                       std::vector&lt;boost::optional&lt;local_date&gt;&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1583</span>                     boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1584</span>                       std::vector&lt;boost::optional&lt;local_date&gt;&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1585</span>          },</div>
<div class="line"><span class="lineno"> 1586</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[25] TIMESTAMP</span></div>
<div class="line"><span class="lineno"> 1587</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;local_date_time&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1588</span>                     boost::any_cast&lt;boost::optional&lt;local_date_time&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1589</span>          },</div>
<div class="line"><span class="lineno"> 1590</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1591</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[26] ARRAY_OF_TIMESTAMP</span></div>
<div class="line"><span class="lineno"> 1592</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1593</span>                       std::vector&lt;boost::optional&lt;local_date_time&gt;&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1594</span>                     boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1595</span>                       std::vector&lt;boost::optional&lt;local_date_time&gt;&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1596</span>          },</div>
<div class="line"><span class="lineno"> 1597</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1598</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[27] TIMESTAMP_WITH_TIMEZONE</span></div>
<div class="line"><span class="lineno"> 1599</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;offset_date_time&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1600</span>                     boost::any_cast&lt;boost::optional&lt;offset_date_time&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1601</span>          },</div>
<div class="line"><span class="lineno"> 1602</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1603</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[28] ARRAY_OF_TIMESTAMP_WITH_TIMEZON</span></div>
<div class="line"><span class="lineno"> 1604</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1605</span>                       std::vector&lt;boost::optional&lt;offset_date_time&gt;&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1606</span>                     boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1607</span>                       std::vector&lt;boost::optional&lt;offset_date_time&gt;&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1608</span>          },</div>
<div class="line"><span class="lineno"> 1609</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[29] COMPACT</span></div>
<div class="line"><span class="lineno"> 1610</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;generic_record&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1611</span>                     boost::any_cast&lt;boost::optional&lt;generic_record&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1612</span>          },</div>
<div class="line"><span class="lineno"> 1613</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[30] ARRAY_OF_COMPACT</span></div>
<div class="line"><span class="lineno"> 1614</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1615</span>                       std::vector&lt;boost::optional&lt;generic_record&gt;&gt;&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1616</span>                     boost::any_cast&lt;boost::optional&lt;</div>
<div class="line"><span class="lineno"> 1617</span>                       std::vector&lt;boost::optional&lt;generic_record&gt;&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1618</span>          },</div>
<div class="line"><span class="lineno"> 1619</span>          [](<span class="keyword">const</span> boost::any&amp; <span class="comment">/*x*/</span>, <span class="keyword">const</span> boost::any&amp; <span class="comment">/*y*/</span>) {</div>
<div class="line"><span class="lineno"> 1620</span>              <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1621</span>          }, <span class="comment">//[31]</span></div>
<div class="line"><span class="lineno"> 1622</span>          [](<span class="keyword">const</span> boost::any&amp; <span class="comment">/*x*/</span>, <span class="keyword">const</span> boost::any&amp; <span class="comment">/*y*/</span>) {</div>
<div class="line"><span class="lineno"> 1623</span>              <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1624</span>          },                                             <span class="comment">//[32]</span></div>
<div class="line"><span class="lineno"> 1625</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[33] NULLABLE_BOOLEAN</span></div>
<div class="line"><span class="lineno"> 1626</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;bool&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1627</span>                     boost::any_cast&lt;boost::optional&lt;bool&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1628</span>          },</div>
<div class="line"><span class="lineno"> 1629</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1630</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[34] ARRAY_OF_NULLABLE_BOOLEAN</span></div>
<div class="line"><span class="lineno"> 1631</span>              <span class="keywordflow">return</span> boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1632</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;bool&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1633</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1634</span>                     boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1635</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;bool&gt;&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1636</span>          },</div>
<div class="line"><span class="lineno"> 1637</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[35] NULLABLE_INT8</span></div>
<div class="line"><span class="lineno"> 1638</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;int8_t&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1639</span>                     boost::any_cast&lt;boost::optional&lt;int8_t&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1640</span>          },</div>
<div class="line"><span class="lineno"> 1641</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1642</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[36] ARRAY_OF_NULLABLE_INT8</span></div>
<div class="line"><span class="lineno"> 1643</span>              <span class="keywordflow">return</span> boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1644</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;int8_t&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1645</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1646</span>                     boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1647</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;int8_t&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1648</span>                       y);</div>
<div class="line"><span class="lineno"> 1649</span>          },</div>
<div class="line"><span class="lineno"> 1650</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[37] NULLABLE_INT16</span></div>
<div class="line"><span class="lineno"> 1651</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;int16_t&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1652</span>                     boost::any_cast&lt;boost::optional&lt;int16_t&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1653</span>          },</div>
<div class="line"><span class="lineno"> 1654</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1655</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[38] ARRAY_OF_NULLABLE_INT16</span></div>
<div class="line"><span class="lineno"> 1656</span>              <span class="keywordflow">return</span> boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1657</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;int16_t&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1658</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1659</span>                     boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1660</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;int16_t&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1661</span>                       y);</div>
<div class="line"><span class="lineno"> 1662</span>          },</div>
<div class="line"><span class="lineno"> 1663</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[39] NULLABLE_INT32</span></div>
<div class="line"><span class="lineno"> 1664</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;int32_t&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1665</span>                     boost::any_cast&lt;boost::optional&lt;int32_t&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1666</span>          },</div>
<div class="line"><span class="lineno"> 1667</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1668</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[40] ARRAY_OF_NULLABLE_INT32</span></div>
<div class="line"><span class="lineno"> 1669</span>              <span class="keywordflow">return</span> boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1670</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;int32_t&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1671</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1672</span>                     boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1673</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;int32_t&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1674</span>                       y);</div>
<div class="line"><span class="lineno"> 1675</span>          },</div>
<div class="line"><span class="lineno"> 1676</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[41] NULLABLE_INT64</span></div>
<div class="line"><span class="lineno"> 1677</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;int64_t&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1678</span>                     boost::any_cast&lt;boost::optional&lt;int64_t&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1679</span>          },</div>
<div class="line"><span class="lineno"> 1680</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1681</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[42] ARRAY_OF_NULLABLE_INT64</span></div>
<div class="line"><span class="lineno"> 1682</span>              <span class="keywordflow">return</span> boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1683</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;int64_t&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1684</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1685</span>                     boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1686</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;int64_t&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1687</span>                       y);</div>
<div class="line"><span class="lineno"> 1688</span>          },</div>
<div class="line"><span class="lineno"> 1689</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[43] NULLABLE_FLOAT32</span></div>
<div class="line"><span class="lineno"> 1690</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;float&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1691</span>                     boost::any_cast&lt;boost::optional&lt;float&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1692</span>          },</div>
<div class="line"><span class="lineno"> 1693</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1694</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[44] ARRAY_OF_NULLABLE_FLOAT32</span></div>
<div class="line"><span class="lineno"> 1695</span>              <span class="keywordflow">return</span> boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1696</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;float&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1697</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1698</span>                     boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1699</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;float&gt;&gt;&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1700</span>          },</div>
<div class="line"><span class="lineno"> 1701</span>          [](<span class="keyword">const</span> boost::any&amp; x, <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[45] NULLABLE_FLOAT64</span></div>
<div class="line"><span class="lineno"> 1702</span>              <span class="keywordflow">return</span> boost::any_cast&lt;boost::optional&lt;double&gt;&gt;(x) ==</div>
<div class="line"><span class="lineno"> 1703</span>                     boost::any_cast&lt;boost::optional&lt;double&gt;&gt;(y);</div>
<div class="line"><span class="lineno"> 1704</span>          },</div>
<div class="line"><span class="lineno"> 1705</span>          [](<span class="keyword">const</span> boost::any&amp; x,</div>
<div class="line"><span class="lineno"> 1706</span>             <span class="keyword">const</span> boost::any&amp; y) { <span class="comment">//[46] ARRAY_OF_NULLABLE_FLOAT64</span></div>
<div class="line"><span class="lineno"> 1707</span>              <span class="keywordflow">return</span> boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1708</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;double&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1709</span>                       x) ==</div>
<div class="line"><span class="lineno"> 1710</span>                     boost::any_cast&lt;</div>
<div class="line"><span class="lineno"> 1711</span>                       boost::optional&lt;std::vector&lt;boost::optional&lt;double&gt;&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno"> 1712</span>                       y);</div>
<div class="line"><span class="lineno"> 1713</span>          }</div>
<div class="line"><span class="lineno"> 1714</span>      };</div>
<div class="line"><span class="lineno"> 1715</span> </div>
<div class="line"><span class="lineno"> 1716</span>    <span class="keyword">const</span> pimpl::schema&amp; xs = x.get_schema();</div>
<div class="line"><span class="lineno"> 1717</span>    <span class="keyword">const</span> pimpl::schema&amp; ys = y.get_schema();</div>
<div class="line"><span class="lineno"> 1718</span> </div>
<div class="line"><span class="lineno"> 1719</span>    <span class="keywordflow">if</span> (xs != ys)</div>
<div class="line"><span class="lineno"> 1720</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1721</span> </div>
<div class="line"><span class="lineno"> 1722</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;const std::string, boost::any&gt;&amp; xp : x.objects_) {</div>
<div class="line"><span class="lineno"> 1723</span>        <span class="keyword">const</span> std::string&amp; field_name = xp.first;</div>
<div class="line"><span class="lineno"> 1724</span>        <span class="keyword">const</span> boost::any&amp; value_of_x = xp.second;</div>
<div class="line"><span class="lineno"> 1725</span>        <span class="keyword">const</span> boost::any&amp; value_of_y = y.objects_.at(field_name);</div>
<div class="line"><span class="lineno"> 1726</span> </div>
<div class="line"><span class="lineno"> 1727</span>        boost::optional&lt;pimpl::field_descriptor&gt; kind_opt =</div>
<div class="line"><span class="lineno"> 1728</span>          xs.get_field(field_name);</div>
<div class="line"><span class="lineno"> 1729</span> </div>
<div class="line"><span class="lineno"> 1730</span>        <span class="keywordflow">if</span> (!COMPARATORS[std::size_t(kind_opt-&gt;kind)](value_of_x, value_of_y))</div>
<div class="line"><span class="lineno"> 1731</span>            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1732</span>    }</div>
<div class="line"><span class="lineno"> 1733</span> </div>
<div class="line"><span class="lineno"> 1734</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1735</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a51a96bb9ebecd6d3a6506dffa0173d93" name="a51a96bb9ebecd6d3a6506dffa0173d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a96bb9ebecd6d3a6506dffa0173d93">&#9670;&#160;</a></span>pimpl::compact_stream_serializer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class pimpl::compact_stream_serializer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d8/d76/generic__record_8h_source.html#l01035">1035</a> of file <a class="el" href="../../d8/d76/generic__record_8h_source.html">generic_record.h</a>.</p>

</div>
</div>
<a id="ad9f40f26e342b61258d571760a3bbc25" name="ad9f40f26e342b61258d571760a3bbc25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f40f26e342b61258d571760a3bbc25">&#9670;&#160;</a></span>write_generic_record</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::property_tree::ptree write_generic_record </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &amp;&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l01456">1456</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1457</span>{</div>
<div class="line"><span class="lineno"> 1458</span>    boost::property_tree::ptree node;</div>
<div class="line"><span class="lineno"> 1459</span> </div>
<div class="line"><span class="lineno"> 1460</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;const std::string, boost::any&gt;&amp; p : record.objects_) {</div>
<div class="line"><span class="lineno"> 1461</span>        <span class="keyword">const</span> std::string&amp; field_name = p.first;</div>
<div class="line"><span class="lineno"> 1462</span> </div>
<div class="line"><span class="lineno"> 1463</span>        field_kind kind = record.get_schema().get_field(field_name)-&gt;kind;</div>
<div class="line"><span class="lineno"> 1464</span> </div>
<div class="line"><span class="lineno"> 1465</span>        pimpl::field_operations::get(kind).write_json_formatted_field(</div>
<div class="line"><span class="lineno"> 1466</span>          node, record, field_name);</div>
<div class="line"><span class="lineno"> 1467</span>    }</div>
<div class="line"><span class="lineno"> 1468</span> </div>
<div class="line"><span class="lineno"> 1469</span>    <span class="keywordflow">return</span> node;</div>
<div class="line"><span class="lineno"> 1470</span>}</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>hazelcast/include/hazelcast/client/serialization/<a class="el" href="../../d8/d76/generic__record_8h_source.html">generic_record.h</a></li>
<li>hazelcast/src/hazelcast/client/<a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>hazelcast</b></li><li class="navelem"><b>client</b></li><li class="navelem"><b>serialization</b></li><li class="navelem"><b>generic_record</b></li><li class="navelem"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a></li>
    <li class="footer">Generated on Tue Jan 20 2026 11:13:09 for Hazelcast C++ Client by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
