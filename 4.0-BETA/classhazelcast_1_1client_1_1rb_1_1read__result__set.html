<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hazelcast C++ Client: hazelcast::client::rb::read_result_set Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hazelcast C++ Client
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>hazelcast</b></li><li class="navelem"><b>client</b></li><li class="navelem"><b>rb</b></li><li class="navelem"><a class="el" href="classhazelcast_1_1client_1_1rb_1_1read__result__set.html">read_result_set</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classhazelcast_1_1client_1_1rb_1_1read__result__set-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hazelcast::client::rb::read_result_set Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8978790ba208c20c09ee78ea605aad72"><td class="memItemLeft" align="right" valign="top"><a id="a8978790ba208c20c09ee78ea605aad72"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>read_result_set</b> (int32_t <a class="el" href="classhazelcast_1_1client_1_1rb_1_1read__result__set.html#a5ce888b33bf025a1c9b0937561d8c191">read_count</a>, std::vector&lt; serialization::pimpl::data &gt; &amp;&amp;data_items, serialization::pimpl::SerializationService &amp;serialization_service, boost::optional&lt; std::vector&lt; int64_t &gt;&gt; &amp;item_seqs, int64_t next_seq)</td></tr>
<tr class="separator:a8978790ba208c20c09ee78ea605aad72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce888b33bf025a1c9b0937561d8c191"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1rb_1_1read__result__set.html#a5ce888b33bf025a1c9b0937561d8c191">read_count</a> () const</td></tr>
<tr class="memdesc:a5ce888b33bf025a1c9b0937561d8c191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of items that have been read before filtering.  <a href="#a5ce888b33bf025a1c9b0937561d8c191">More...</a><br /></td></tr>
<tr class="separator:a5ce888b33bf025a1c9b0937561d8c191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c26b00942be4962afce56201590df92"><td class="memItemLeft" align="right" valign="top"><a id="a2c26b00942be4962afce56201590df92"></a>
const std::vector&lt; <a class="el" href="classhazelcast_1_1client_1_1typed__data.html">typed_data</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_items</b> () const</td></tr>
<tr class="separator:a2c26b00942be4962afce56201590df92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b915ada3374e24ae29050727bc687ec"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1rb_1_1read__result__set.html#a4b915ada3374e24ae29050727bc687ec">get_sequence</a> (int32_t index) const</td></tr>
<tr class="memdesc:a4b915ada3374e24ae29050727bc687ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sequence number for the item at the given index.  <a href="#a4b915ada3374e24ae29050727bc687ec">More...</a><br /></td></tr>
<tr class="separator:a4b915ada3374e24ae29050727bc687ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77536a2f3377cbe355031d5bec972ba0"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1rb_1_1read__result__set.html#a77536a2f3377cbe355031d5bec972ba0">get_next_sequence_to_read_from</a> () const</td></tr>
<tr class="memdesc:a77536a2f3377cbe355031d5bec972ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sequence of the item following the last read item.  <a href="#a77536a2f3377cbe355031d5bec972ba0">More...</a><br /></td></tr>
<tr class="separator:a77536a2f3377cbe355031d5bec972ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a887193f1a301555a38307b201ea65ea1"><td class="memItemLeft" align="right" valign="top">static const int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1client_1_1rb_1_1read__result__set.html#a887193f1a301555a38307b201ea65ea1">SEQUENCE_UNAVAILABLE</a> = -1</td></tr>
<tr class="memdesc:a887193f1a301555a38307b201ea65ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value returned from methods returning a sequence number when the information is not available (e.g.  <a href="#a887193f1a301555a38307b201ea65ea1">More...</a><br /></td></tr>
<tr class="separator:a887193f1a301555a38307b201ea65ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a77536a2f3377cbe355031d5bec972ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77536a2f3377cbe355031d5bec972ba0">&#9670;&nbsp;</a></span>get_next_sequence_to_read_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t hazelcast::client::rb::read_result_set::get_next_sequence_to_read_from </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sequence of the item following the last read item. </p>
<p>This sequence can then be used to read items following the ones returned by this result set. Usually this sequence is equal to the sequence used to retrieve this result set incremented by the <a class="el" href="">readCount()</a>. In cases when the reader tolerates lost items, this is not the case. For instance, if the reader requests an item with a stale sequence (one which has already been overwritten), the read will jump to the oldest sequence and read from there. Similarly, if the reader requests an item in the future (e.g. because the partition was lost and the reader was unaware of this), the read method will jump back to the newest available sequence. Because of these jumps and only in the case when the reader is loss tolerant, the next sequence must be retrieved using this method. A return value of { SEQUENCE_UNAVAILABLE} means that the information is not available.</p>
<dl class="section return"><dt>Returns</dt><dd>the sequence of the item following the last item in the result set </dd></dl>
<dl class="section since"><dt>Since</dt><dd>3.10 </dd></dl>

</div>
</div>
<a id="a4b915ada3374e24ae29050727bc687ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b915ada3374e24ae29050727bc687ec">&#9670;&nbsp;</a></span>get_sequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t hazelcast::client::rb::read_result_set::get_sequence </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the sequence number for the item at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sequence number for the ringbuffer item </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">illegal_argument</td><td>if index out of bounds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>3.9 </dd></dl>

</div>
</div>
<a id="a5ce888b33bf025a1c9b0937561d8c191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce888b33bf025a1c9b0937561d8c191">&#9670;&nbsp;</a></span>read_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t hazelcast::client::rb::read_result_set::read_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of items that have been read before filtering. </p>
<p>If no filter is set, then the</p><div class="fragment"><div class="line">readCount </div></div><!-- fragment --><p> will be equal to <a class="el" href="">size</a>. But if a filter is applied, it could be that items are read, but are filtered out. So if you are trying to make another read based on the <a class="el" href="classhazelcast_1_1client_1_1rb_1_1read__result__set.html">read_result_set</a> then you should increment the sequence by </p><div class="fragment"><div class="line">readCount </div></div><!-- fragment --><p> and not by <a class="el" href="">size()</a>. Otherwise you will be re-reading the same filtered messages.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of items read (including the filtered ones). </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a887193f1a301555a38307b201ea65ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887193f1a301555a38307b201ea65ea1">&#9670;&nbsp;</a></span>SEQUENCE_UNAVAILABLE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int64_t hazelcast::client::rb::read_result_set::SEQUENCE_UNAVAILABLE = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value returned from methods returning a sequence number when the information is not available (e.g. </p>
<p>because of rolling upgrade and some members not returning the sequence). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>hazelcast/include/hazelcast/client/ringbuffer/<a class="el" href="read__result__set_8h_source.html">read_result_set.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 26 2020 18:10:38 for Hazelcast C++ Client by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
