<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hazelcast C++ Client: hazelcast::client::ringbuffer Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../IMDG_blue_logo_square_RGB-dark_200px.png"/></td>
  <td id="projectalign">
   <div id="projectname">Hazelcast C++ Client
   </div>
   <div id="projectbrief">Hazelcast C++ Client Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d0/d17/classhazelcast_1_1client_1_1ringbuffer.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d1/dc9/classhazelcast_1_1client_1_1ringbuffer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">hazelcast::client::ringbuffer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A Ringbuffer is a data-structure where the content is stored in a ring like structure.  
 <a href="../../d0/d17/classhazelcast_1_1client_1_1ringbuffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d6/da4/ringbuffer_8h_source.html">ringbuffer.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="../../closed.png" alt="+"/> Inheritance diagram for hazelcast::client::ringbuffer:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="../../d0/d17/classhazelcast_1_1client_1_1ringbuffer.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acbeabfda52df1225670a002d9d5be7c3"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:acbeabfda52df1225670a002d9d5be7c3"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; int64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d17/classhazelcast_1_1client_1_1ringbuffer.html#acbeabfda52df1225670a002d9d5be7c3">add</a> (const E &amp;item)</td></tr>
<tr class="memdesc:acbeabfda52df1225670a002d9d5be7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an item to the tail of the Ringbuffer.  <br /></td></tr>
<tr class="separator:acbeabfda52df1225670a002d9d5be7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96685daf2170a7ef5b63f72f0ed9879"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:af96685daf2170a7ef5b63f72f0ed9879"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; boost::optional&lt; E &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d17/classhazelcast_1_1client_1_1ringbuffer.html#af96685daf2170a7ef5b63f72f0ed9879">read_one</a> (int64_t sequence)</td></tr>
<tr class="memdesc:af96685daf2170a7ef5b63f72f0ed9879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads one item from the Ringbuffer.  <br /></td></tr>
<tr class="separator:af96685daf2170a7ef5b63f72f0ed9879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8548165b9a53b5c24633ad3f60b98b"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:acb8548165b9a53b5c24633ad3f60b98b"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; int64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d17/classhazelcast_1_1client_1_1ringbuffer.html#acb8548165b9a53b5c24633ad3f60b98b">add</a> (const E &amp;item, rb::overflow_policy overflow_policy)</td></tr>
<tr class="memdesc:acb8548165b9a53b5c24633ad3f60b98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously writes an item with a configurable <code><a class="el" href="../../">rb::OverflowPolicy</a></code>.  <br /></td></tr>
<tr class="separator:acb8548165b9a53b5c24633ad3f60b98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf6c7f0171b368302afafcf6eab3921"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:a1cf6c7f0171b368302afafcf6eab3921"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; int64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d17/classhazelcast_1_1client_1_1ringbuffer.html#a1cf6c7f0171b368302afafcf6eab3921">add_all</a> (const std::vector&lt; E &gt; &amp;items, rb::overflow_policy overflow_policy)</td></tr>
<tr class="memdesc:a1cf6c7f0171b368302afafcf6eab3921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all the items of a collection to the tail of the Ringbuffer.  <br /></td></tr>
<tr class="separator:a1cf6c7f0171b368302afafcf6eab3921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ad5be408a89a619ec249e615dccda8"><td class="memTemplParams" colspan="2">template&lt;typename IFUNCTION &gt; </td></tr>
<tr class="memitem:aa9ad5be408a89a619ec249e615dccda8"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; <a class="el" href="../../d9/dce/classhazelcast_1_1client_1_1rb_1_1read__result__set.html">rb::read_result_set</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d0/d17/classhazelcast_1_1client_1_1ringbuffer.html#aa9ad5be408a89a619ec249e615dccda8">read_many</a> (int64_t start_sequence, int32_t min_count, int32_t max_count, const IFUNCTION *filter=nullptr)</td></tr>
<tr class="memdesc:aa9ad5be408a89a619ec249e615dccda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a batch of items from the Ringbuffer.  <br /></td></tr>
<tr class="separator:aa9ad5be408a89a619ec249e615dccda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66fb9388cf06d02db8ea61d7c491e82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dce/classhazelcast_1_1client_1_1rb_1_1read__result__set.html">rb::read_result_set</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d17/classhazelcast_1_1client_1_1ringbuffer.html#ab66fb9388cf06d02db8ea61d7c491e82">get_result_set</a> (boost::future&lt; protocol::ClientMessage &gt; f)</td></tr>
<tr class="separator:ab66fb9388cf06d02db8ea61d7c491e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33003bf4840d8b8799fd826a6533353"><td class="memItemLeft" align="right" valign="top">boost::future&lt; <a class="el" href="../../d9/dce/classhazelcast_1_1client_1_1rb_1_1read__result__set.html">rb::read_result_set</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d17/classhazelcast_1_1client_1_1ringbuffer.html#ac33003bf4840d8b8799fd826a6533353">read_many</a> (int64_t start_sequence, int32_t min_count, int32_t max_count)</td></tr>
<tr class="separator:ac33003bf4840d8b8799fd826a6533353"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0195b4df1fa489288a2a52fe5b0e23b7"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d17/classhazelcast_1_1client_1_1ringbuffer.html#a0195b4df1fa489288a2a52fe5b0e23b7">spi::ProxyManager</a></td></tr>
<tr class="separator:a0195b4df1fa489288a2a52fe5b0e23b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A Ringbuffer is a data-structure where the content is stored in a ring like structure. </p>
<p>A ringbuffer has a capacity so it won't grow beyond that capacity and endanger the stability of the system. If that capacity is exceeded, than the oldest item in the ringbuffer is overwritten.</p>
<p>The ringbuffer has 2 always incrementing sequences: </p><ol>
<li>
tailSequence: this is the side where the youngest item is found. So the tail is the side of the ringbuffer where items are added to.  </li>
<li>
headSequence: this is the side where the oldest items are found. So the head is the side where items gets discarded.  </li>
</ol>
<p>The items in the ringbuffer can be found by a sequence that is in between (inclusive) the head and tail sequence.</p>
<p>If data is read from a ringbuffer with a sequence that is smaller than the headSequence, it means that the data is not available anymore and a <code><a class="el" href="../../">stale_sequence</a></code> is thrown.</p>
<p>A Ringbuffer currently is not a distributed data-structure. So all data is stored in a single partition; comparable to the IQueue implementation. But we'll provide an option to partition the data in the near future.</p>
<p>A Ringbuffer can be used in a similar way as a queue, but one of the key differences is that a queue.take is destructive, meaning that only 1 thread is able to take an item. A ringbuffer.read is not destructive, so you can have multiple threads reading the same item multiple times.</p>
<p>The Ringbuffer is the backing data-structure for the reliable <code><a class="el" href="../../">com.hazelcast.core.ITopic</a></code> implementation. See <code><a class="el" href="../../">com.hazelcast.config.ReliableTopicConfig</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="../../d6/da4/ringbuffer_8h_source.html#l00066">66</a> of file <a class="el" href="../../d6/da4/ringbuffer_8h_source.html">ringbuffer.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="acbeabfda52df1225670a002d9d5be7c3" name="acbeabfda52df1225670a002d9d5be7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbeabfda52df1225670a002d9d5be7c3">&#9670;&#160;</a></span>add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt; int64_t &gt; hazelcast::client::ringbuffer::add </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an item to the tail of the Ringbuffer. </p>
<p>If there is no space in the Ringbuffer, the add will overwrite the oldest item in the ringbuffer no matter what the ttl is. For more control on this behavior.</p>
<p>The returned value is the sequence of the added item. Using this sequence you can read the added item.</p>
<h3>Using the sequence as id</h3>
<p>This sequence will always be unique for this Ringbuffer instance so it can be used as a unique id generator if you are publishing items on this Ringbuffer. However you need to take care of correctly determining an initial id when any node uses the ringbuffer for the first time. The most reliable way to do that is to write a dummy item into the ringbuffer and use the returned sequence as initial id. On the reading side, this dummy item should be discard. Please keep in mind that this id is not the sequence of the item you are about to publish but from a previously published item. So it can't be used to find that item.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>the item to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sequence of the added item. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/da4/ringbuffer_8h_source.html#l00094">94</a> of file <a class="el" href="../../d6/da4/ringbuffer_8h_source.html">ringbuffer.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   95</span>    {</div>
<div class="line"><span class="lineno">   96</span>        <span class="keywordflow">return</span> add_data(to_data(item));</div>
<div class="line"><span class="lineno">   97</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="acb8548165b9a53b5c24633ad3f60b98b" name="acb8548165b9a53b5c24633ad3f60b98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8548165b9a53b5c24633ad3f60b98b">&#9670;&#160;</a></span>add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt; int64_t &gt; hazelcast::client::ringbuffer::add </td>
          <td>(</td>
          <td class="paramtype">const E &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rb::overflow_policy&#160;</td>
          <td class="paramname"><em>overflow_policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Asynchronously writes an item with a configurable <code><a class="el" href="../../">rb::OverflowPolicy</a></code>. </p>
<p>If there is space in the Ringbuffer, the call will return the sequence of the written item. If there is no space, it depends on the overflow policy what happens: </p><ol>
<li>
<code><a class="el" href="../../">rb::OverflowPolicy#OVERWRITE</a></code>: we just overwrite the oldest item in the Ringbuffer and we violate the ttl </li>
<li>
<code><a class="el" href="../../">rb::OverflowPolicy#FAIL</a></code>: we return -1  </li>
</ol>
<p>The reason that FAIL exist is to give the opportunity to obey the ttl. If blocking behavior is required, this can be implemented using retrying in combination with an exponential backoff. Example: </p><pre><code class="JavaDocCode"><br/>
int64_t sleepMs = 100;<br/>
for (; ; ) {<br/>
  int64_t result = *(ringbuffer.addAsync(item, FAIL)-&gt;get());<br/>
  if (result != -1) {<br/>
    break;<br/>
  }<br/>
  util::sleepMillis(sleepMs);<br/>
  sleepMs = min(5000, sleepMs * 2);<br/>
}<br/>
</code></pre><p> &lt;p&lt;blockquote&gt;&zwj; </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>the item to add </td></tr>
    <tr><td class="paramname">overflowPolicy</td><td>the rb::OverflowPolicy to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sequenceId of the added item, or -1 if the add failed. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d6/da4/ringbuffer_8h_source.html#l00174">174</a> of file <a class="el" href="../../d6/da4/ringbuffer_8h_source.html">ringbuffer.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  176</span>    {</div>
<div class="line"><span class="lineno">  177</span>        <span class="keywordflow">return</span> addData(to_data(item), overflow_policy);</div>
<div class="line"><span class="lineno">  178</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1cf6c7f0171b368302afafcf6eab3921" name="a1cf6c7f0171b368302afafcf6eab3921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf6c7f0171b368302afafcf6eab3921">&#9670;&#160;</a></span>add_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt; int64_t &gt; hazelcast::client::ringbuffer::add_all </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rb::overflow_policy&#160;</td>
          <td class="paramname"><em>overflow_policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds all the items of a collection to the tail of the Ringbuffer. </p>
<p>An add_all is likely to outperform multiple calls to <code><a class="el" href="../../d0/d17/classhazelcast_1_1client_1_1ringbuffer.html#acbeabfda52df1225670a002d9d5be7c3">add(const
E&amp;)</a></code> due to better io utilization and a reduced number of executed operations. If the batch is empty, the call is ignored. </p>
<p>If the collection is larger than the capacity of the Ringbuffer, then the items that were written first will be overwritten. Therefore this call will not block. </p>
<p>The items are inserted in the order of the Iterator of the collection. If an add_all is executed concurrently with an add or add_all, no guarantee is given that items are contiguous. </p>
<p>The result of the future contains the sequenceId of the last written item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>the batch of items to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the future to synchronize on completion. The result of the future contains the sequenceId of the last written item. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">illegal_argument</td><td>if items is empty </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d6/da4/ringbuffer_8h_source.html#l00199">199</a> of file <a class="el" href="../../d6/da4/ringbuffer_8h_source.html">ringbuffer.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  201</span>    {</div>
<div class="line"><span class="lineno">  202</span>        <span class="keywordflow">return</span> add_all_data(to_data_collection(items), overflow_policy);</div>
<div class="line"><span class="lineno">  203</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab66fb9388cf06d02db8ea61d7c491e82" name="ab66fb9388cf06d02db8ea61d7c491e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66fb9388cf06d02db8ea61d7c491e82">&#9670;&#160;</a></span>get_result_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dce/classhazelcast_1_1client_1_1rb_1_1read__result__set.html">rb::read_result_set</a> hazelcast::client::ringbuffer::get_result_set </td>
          <td>(</td>
          <td class="paramtype">boost::future&lt; protocol::ClientMessage &gt;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d6/da4/ringbuffer_8h_source.html#l00260">260</a> of file <a class="el" href="../../d6/da4/ringbuffer_8h_source.html">ringbuffer.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  261</span>    {</div>
<div class="line"><span class="lineno">  262</span>        <span class="keyword">auto</span> msg = f.get();</div>
<div class="line"><span class="lineno">  263</span>        <span class="keyword">auto</span>* initial_frame =</div>
<div class="line"><span class="lineno">  264</span>          <span class="keyword">reinterpret_cast&lt;</span>protocol::ClientMessage::frame_header_type*<span class="keyword">&gt;</span>(</div>
<div class="line"><span class="lineno">  265</span>            msg.rd_ptr(protocol::ClientMessage::RESPONSE_HEADER_LEN));</div>
<div class="line"><span class="lineno">  266</span>        <span class="keyword">auto</span> read_count = msg.get&lt;int32_t&gt;();</div>
<div class="line"><span class="lineno">  267</span>        <span class="keyword">auto</span> next_seq = msg.get&lt;int64_t&gt;();</div>
<div class="line"><span class="lineno">  268</span>        msg.rd_ptr(<span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(initial_frame-&gt;frame_len) -</div>
<div class="line"><span class="lineno">  269</span>                   protocol::ClientMessage::RESPONSE_HEADER_LEN -</div>
<div class="line"><span class="lineno">  270</span>                   protocol::ClientMessage::INT32_SIZE -</div>
<div class="line"><span class="lineno">  271</span>                   protocol::ClientMessage::INT64_SIZE);</div>
<div class="line"><span class="lineno">  272</span> </div>
<div class="line"><span class="lineno">  273</span>        <span class="keyword">auto</span> datas = msg.get&lt;std::vector&lt;serialization::pimpl::data&gt;&gt;();</div>
<div class="line"><span class="lineno">  274</span>        <span class="keyword">auto</span> item_seqs = msg.get_nullable&lt;std::vector&lt;int64_t&gt;&gt;();</div>
<div class="line"><span class="lineno">  275</span>        <span class="keywordflow">return</span> rb::read_result_set(read_count,</div>
<div class="line"><span class="lineno">  276</span>                                   std::move(datas),</div>
<div class="line"><span class="lineno">  277</span>                                   get_serialization_service(),</div>
<div class="line"><span class="lineno">  278</span>                                   item_seqs,</div>
<div class="line"><span class="lineno">  279</span>                                   next_seq);</div>
<div class="line"><span class="lineno">  280</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac33003bf4840d8b8799fd826a6533353" name="ac33003bf4840d8b8799fd826a6533353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33003bf4840d8b8799fd826a6533353">&#9670;&#160;</a></span>read_many() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt; <a class="el" href="../../d9/dce/classhazelcast_1_1client_1_1rb_1_1read__result__set.html">rb::read_result_set</a> &gt; hazelcast::client::ringbuffer::read_many </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>start_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>min_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>max_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d6/da4/ringbuffer_8h_source.html#l00282">282</a> of file <a class="el" href="../../d6/da4/ringbuffer_8h_source.html">ringbuffer.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  285</span>    {</div>
<div class="line"><span class="lineno">  286</span>        <span class="keywordflow">return</span> read_many_data(start_sequence, min_count, max_count, <span class="keyword">nullptr</span>)</div>
<div class="line"><span class="lineno">  287</span>          .then(boost::launch::sync,</div>
<div class="line"><span class="lineno">  288</span>                [=](boost::future&lt;protocol::ClientMessage&gt; f) {</div>
<div class="line"><span class="lineno">  289</span>                    <span class="keywordflow">return</span> get_result_set(std::move(f));</div>
<div class="line"><span class="lineno">  290</span>                });</div>
<div class="line"><span class="lineno">  291</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa9ad5be408a89a619ec249e615dccda8" name="aa9ad5be408a89a619ec249e615dccda8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ad5be408a89a619ec249e615dccda8">&#9670;&#160;</a></span>read_many() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IFUNCTION &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt; <a class="el" href="../../d9/dce/classhazelcast_1_1client_1_1rb_1_1read__result__set.html">rb::read_result_set</a> &gt; hazelcast::client::ringbuffer::read_many </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>start_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>min_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>max_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IFUNCTION *&#160;</td>
          <td class="paramname"><em>filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a batch of items from the Ringbuffer. </p>
<p>If the number of available items after the first read item is smaller than the <code class="JavaDocCode">maxCount</code>, these items are returned. So it could be the number of items read is smaller than the <code class="JavaDocCode">maxCount</code>. </p>
<p>If there are less items available than <code class="JavaDocCode">minCount</code>, then this call blocks. </p>
<p>Reading a batch of items is likely to perform better because less overhead is involved. </p>
<p>A filter can be provided to only select items that need to be read. If the filter is null, all items are read. If the filter is not null, only items where the filter function returns true are returned. Using filters is a good way to prevent getting items that are of no value to the receiver. This reduces the amount of IO and the number of operations being executed, and can result in a significant performance improvement. </p>
<p>For each item not available in the Ringbuffer an attempt is made to read it from the underlying {com.hazelcast.core.RingbufferStore} via multiple invocations of {com.hazelcast.core.RingbufferStore::load(long)}, if store is configured for the Ringbuffer. These cases may increase the execution time significantly depending on the implementation of the store. Note that exceptions thrown by the store are propagated to the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startSequence</td><td>the startSequence of the first item to read. </td></tr>
    <tr><td class="paramname">minCount</td><td>the minimum number of items to read. </td></tr>
    <tr><td class="paramname">maxCount</td><td>the maximum number of items to read. </td></tr>
    <tr><td class="paramname">filter</td><td>the filter. Filter is allowed to be null, indicating there is no filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a future containing the items read. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">illegal_argument</td><td>if startSequence is smaller than 0 or if startSequence larger than <code><a class="el" href="../../">tailSequence()</a></code> or if minCount smaller than 0 or if minCount larger than maxCount, or if maxCount larger than the capacity of the ringbuffer or if maxCount larger than 1000 (to prevent overload) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d6/da4/ringbuffer_8h_source.html#l00245">245</a> of file <a class="el" href="../../d6/da4/ringbuffer_8h_source.html">ringbuffer.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  250</span>    {</div>
<div class="line"><span class="lineno">  251</span>        <span class="keyword">auto</span> filter_data = to_data&lt;IFUNCTION&gt;(filter);</div>
<div class="line"><span class="lineno">  252</span>        <span class="keywordflow">return</span> read_many_data(</div>
<div class="line"><span class="lineno">  253</span>                 start_sequence, min_count, max_count, &amp;filter_data)</div>
<div class="line"><span class="lineno">  254</span>          .then(boost::launch::sync,</div>
<div class="line"><span class="lineno">  255</span>                [=](boost::future&lt;protocol::ClientMessage&gt; f) {</div>
<div class="line"><span class="lineno">  256</span>                    <span class="keywordflow">return</span> get_result_set(std::move(f));</div>
<div class="line"><span class="lineno">  257</span>                });</div>
<div class="line"><span class="lineno">  258</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af96685daf2170a7ef5b63f72f0ed9879" name="af96685daf2170a7ef5b63f72f0ed9879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96685daf2170a7ef5b63f72f0ed9879">&#9670;&#160;</a></span>read_one()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt; boost::optional&lt; E &gt; &gt; hazelcast::client::ringbuffer::read_one </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads one item from the Ringbuffer. </p>
<p>If the sequence is one beyond the current tail, this call blocks until an item is added.</p>
<p>This means that the ringbuffer can be processed using the following idiom: <code> Ringbuffer&lt;String&gt; ringbuffer = client.getRingbuffer&lt;E&gt;("rb"); long seq = ringbuffer.headSequence(); while(true){ String item = ringbuffer.readOne(seq); seq++; ... process item } </code></p>
<p>This method is not destructive unlike e.g. a queue.take. So the same item can be read by multiple readers or it can be read multiple times by the same reader.</p>
<p>Currently it isn't possible to control how long this call is going to block. In the future we could add e.g. tryReadOne(long sequence, long
timeout, TimeUnit unit).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence</td><td>the sequence of the item to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the read item </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">stale_sequence</td><td>if the sequence is smaller then <code><a class="el" href="../../">headSequence()</a></code>. Because a Ringbuffer won't store all event indefinitely, it can be that the data for the given sequence doesn't exist anymore and the <code><a class="el" href="../../">stale_sequence</a></code> is thrown. It is up to the caller to deal with this particular situation, e.g. throw an Exception or restart from the last known head. That is why the stale_sequence contains the last known head. </td></tr>
    <tr><td class="paramname">illegal_argument</td><td>if sequence is smaller than 0 or larger than <code><a class="el" href="../../">tailSequence()</a></code>+1. </td></tr>
    <tr><td class="paramname">interrupted</td><td>if the call is interrupted while blocking. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d6/da4/ringbuffer_8h_source.html#l00138">138</a> of file <a class="el" href="../../d6/da4/ringbuffer_8h_source.html">ringbuffer.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  139</span>    {</div>
<div class="line"><span class="lineno">  140</span>        <span class="keywordflow">return</span> to_object&lt;E&gt;(read_one_data(sequence));</div>
<div class="line"><span class="lineno">  141</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0195b4df1fa489288a2a52fe5b0e23b7" name="a0195b4df1fa489288a2a52fe5b0e23b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0195b4df1fa489288a2a52fe5b0e23b7">&#9670;&#160;</a></span>spi::ProxyManager</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class spi::ProxyManager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d6/da4/ringbuffer_8h_source.html#l00068">68</a> of file <a class="el" href="../../d6/da4/ringbuffer_8h_source.html">ringbuffer.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>hazelcast/include/hazelcast/client/<a class="el" href="../../d6/da4/ringbuffer_8h_source.html">ringbuffer.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../de/db5/namespacehazelcast.html">hazelcast</a></li><li class="navelem"><a class="el" href="../../da/d95/namespacehazelcast_1_1client.html">client</a></li><li class="navelem"><a class="el" href="../../d0/d17/classhazelcast_1_1client_1_1ringbuffer.html">ringbuffer</a></li>
    <li class="footer">Generated on Wed Mar 15 2023 18:23:46 for Hazelcast C++ Client by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
