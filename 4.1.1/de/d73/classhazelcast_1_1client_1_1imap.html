<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hazelcast C++ Client: hazelcast::client::imap Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../IMDG_blue_logo_square_RGB-dark_200px.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hazelcast C++ Client
   </div>
   <div id="projectbrief">Hazelcast C++ Client Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('de/d73/classhazelcast_1_1client_1_1imap.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../db/d65/classhazelcast_1_1client_1_1imap-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hazelcast::client::imap Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Concurrent, distributed, observable and queryable map client.  
 <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="../../closed.png" alt="+"/> Inheritance diagram for hazelcast::client::imap:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="../../de/d73/classhazelcast_1_1client_1_1imap.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac026ce600cfd531548df77e34a2a5750"><td class="memItemLeft" align="right" valign="top"><a id="ac026ce600cfd531548df77e34a2a5750"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>imap</b> (const std::string &amp;instance_name, spi::ClientContext *context)</td></tr>
<tr class="separator:ac026ce600cfd531548df77e34a2a5750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e44c15a04d7ddabf2779eb238eb351f"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a5e44c15a04d7ddabf2779eb238eb351f"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a5e44c15a04d7ddabf2779eb238eb351f">contains_key</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a5e44c15a04d7ddabf2779eb238eb351f"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if this map contains key.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a5e44c15a04d7ddabf2779eb238eb351f">More...</a><br /></td></tr>
<tr class="separator:a5e44c15a04d7ddabf2779eb238eb351f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9379ff0c704459410ce145212909719d"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a9379ff0c704459410ce145212909719d"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a9379ff0c704459410ce145212909719d">contains_value</a> (const V &amp;value)</td></tr>
<tr class="memdesc:a9379ff0c704459410ce145212909719d"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if this map contains value.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a9379ff0c704459410ce145212909719d">More...</a><br /></td></tr>
<tr class="separator:a9379ff0c704459410ce145212909719d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196974709c5c15d740ae3a9c54b8a175"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a196974709c5c15d740ae3a9c54b8a175"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; boost::optional&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a196974709c5c15d740ae3a9c54b8a175">get</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a196974709c5c15d740ae3a9c54b8a175"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the value.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a196974709c5c15d740ae3a9c54b8a175">More...</a><br /></td></tr>
<tr class="separator:a196974709c5c15d740ae3a9c54b8a175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3532ff9acd963a122578a20d2424645a"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename R  = V&gt; </td></tr>
<tr class="memitem:a3532ff9acd963a122578a20d2424645a"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; boost::optional&lt; R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a3532ff9acd963a122578a20d2424645a">put</a> (const K &amp;key, const V &amp;value)</td></tr>
<tr class="memdesc:a3532ff9acd963a122578a20d2424645a"><td class="mdescLeft">&#160;</td><td class="mdescRight">put new entry into map.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a3532ff9acd963a122578a20d2424645a">More...</a><br /></td></tr>
<tr class="separator:a3532ff9acd963a122578a20d2424645a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99083f1fadd0f1e690ed6c35fdda9fa1"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename R  = V&gt; </td></tr>
<tr class="memitem:a99083f1fadd0f1e690ed6c35fdda9fa1"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; boost::optional&lt; R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a99083f1fadd0f1e690ed6c35fdda9fa1">put</a> (const K &amp;key, const V &amp;value, std::chrono::milliseconds ttl)</td></tr>
<tr class="memdesc:a99083f1fadd0f1e690ed6c35fdda9fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts an entry into this map with a given ttl (time to live) value.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a99083f1fadd0f1e690ed6c35fdda9fa1">More...</a><br /></td></tr>
<tr class="separator:a99083f1fadd0f1e690ed6c35fdda9fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36465e654ae517bd6e2f1c361e0a35d7"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a36465e654ae517bd6e2f1c361e0a35d7"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; boost::optional&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a36465e654ae517bd6e2f1c361e0a35d7">remove</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a36465e654ae517bd6e2f1c361e0a35d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove entry form map  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a36465e654ae517bd6e2f1c361e0a35d7">More...</a><br /></td></tr>
<tr class="separator:a36465e654ae517bd6e2f1c361e0a35d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d01166880c3404117bce1c35784f115"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a0d01166880c3404117bce1c35784f115"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a0d01166880c3404117bce1c35784f115">remove</a> (const K &amp;key, const V &amp;value)</td></tr>
<tr class="memdesc:a0d01166880c3404117bce1c35784f115"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes entry from map if there is an entry with same key and value.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a0d01166880c3404117bce1c35784f115">More...</a><br /></td></tr>
<tr class="separator:a0d01166880c3404117bce1c35784f115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262eab235be3b3e6325c771306879536"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a262eab235be3b3e6325c771306879536"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a262eab235be3b3e6325c771306879536">remove_all</a> (const P &amp;predicate)</td></tr>
<tr class="memdesc:a262eab235be3b3e6325c771306879536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all entries which match with the supplied predicate.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a262eab235be3b3e6325c771306879536">More...</a><br /></td></tr>
<tr class="separator:a262eab235be3b3e6325c771306879536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52ba226a5227b068e7b849a311d945d"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:ad52ba226a5227b068e7b849a311d945d"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#ad52ba226a5227b068e7b849a311d945d">delete_entry</a> (const K &amp;key)</td></tr>
<tr class="memdesc:ad52ba226a5227b068e7b849a311d945d"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes entry from map.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#ad52ba226a5227b068e7b849a311d945d">More...</a><br /></td></tr>
<tr class="separator:ad52ba226a5227b068e7b849a311d945d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64906b278142579ffffaa423672f0945"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a64906b278142579ffffaa423672f0945"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a64906b278142579ffffaa423672f0945">try_remove</a> (const K &amp;key, std::chrono::milliseconds timeout)</td></tr>
<tr class="memdesc:a64906b278142579ffffaa423672f0945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to remove the entry with the given key from this map within specified timeout value.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a64906b278142579ffffaa423672f0945">More...</a><br /></td></tr>
<tr class="separator:a64906b278142579ffffaa423672f0945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa3acffaef927a2ce45842f961390e8"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:adaa3acffaef927a2ce45842f961390e8"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#adaa3acffaef927a2ce45842f961390e8">try_put</a> (const K &amp;key, const V &amp;value, std::chrono::milliseconds timeout)</td></tr>
<tr class="memdesc:adaa3acffaef927a2ce45842f961390e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to put the given key, value into this map within specified timeout value.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#adaa3acffaef927a2ce45842f961390e8">More...</a><br /></td></tr>
<tr class="separator:adaa3acffaef927a2ce45842f961390e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af492c1a39ccb47bd6559be789bc979ed"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:af492c1a39ccb47bd6559be789bc979ed"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#af492c1a39ccb47bd6559be789bc979ed">put_transient</a> (const K &amp;key, const V &amp;value, std::chrono::milliseconds ttl)</td></tr>
<tr class="memdesc:af492c1a39ccb47bd6559be789bc979ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as put(K, V, int64_t, TimeUnit) but MapStore, if defined, will not be called to store/persist the entry.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#af492c1a39ccb47bd6559be789bc979ed">More...</a><br /></td></tr>
<tr class="separator:af492c1a39ccb47bd6559be789bc979ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ce6bebc47e9e4603328f2aea4edad0"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename R  = V&gt; </td></tr>
<tr class="memitem:ad2ce6bebc47e9e4603328f2aea4edad0"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; boost::optional&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#ad2ce6bebc47e9e4603328f2aea4edad0">put_if_absent</a> (const K &amp;key, const V &amp;value)</td></tr>
<tr class="memdesc:ad2ce6bebc47e9e4603328f2aea4edad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts an entry into this map, if the specified key is not already associated with a value.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#ad2ce6bebc47e9e4603328f2aea4edad0">More...</a><br /></td></tr>
<tr class="separator:ad2ce6bebc47e9e4603328f2aea4edad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0336e9273ef5989a55e2a4d5f65cee6e"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename R  = V&gt; </td></tr>
<tr class="memitem:a0336e9273ef5989a55e2a4d5f65cee6e"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; boost::optional&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a0336e9273ef5989a55e2a4d5f65cee6e">put_if_absent</a> (const K &amp;key, const V &amp;value, std::chrono::milliseconds ttl)</td></tr>
<tr class="memdesc:a0336e9273ef5989a55e2a4d5f65cee6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts an entry into this map with a given ttl (time to live) value if the specified key is not already associated with a value.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a0336e9273ef5989a55e2a4d5f65cee6e">More...</a><br /></td></tr>
<tr class="separator:a0336e9273ef5989a55e2a4d5f65cee6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f78e949d6b15f2ccf917978889bd6e3"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename N  = V&gt; </td></tr>
<tr class="memitem:a4f78e949d6b15f2ccf917978889bd6e3"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a4f78e949d6b15f2ccf917978889bd6e3">replace</a> (const K &amp;key, const V &amp;old_value, const N &amp;new_value)</td></tr>
<tr class="memdesc:a4f78e949d6b15f2ccf917978889bd6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the entry for a key only if currently mapped to a given value.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a4f78e949d6b15f2ccf917978889bd6e3">More...</a><br /></td></tr>
<tr class="separator:a4f78e949d6b15f2ccf917978889bd6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a1c366c91a4d0e00cf449e8f56785f"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename R  = V&gt; </td></tr>
<tr class="memitem:a28a1c366c91a4d0e00cf449e8f56785f"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; boost::optional&lt; R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a28a1c366c91a4d0e00cf449e8f56785f">replace</a> (const K &amp;key, const V &amp;value)</td></tr>
<tr class="memdesc:a28a1c366c91a4d0e00cf449e8f56785f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the entry for a key only if currently mapped to some value.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a28a1c366c91a4d0e00cf449e8f56785f">More...</a><br /></td></tr>
<tr class="separator:a28a1c366c91a4d0e00cf449e8f56785f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379a3c77d126e3af456f344ec0e84bcf"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename R  = V&gt; </td></tr>
<tr class="memitem:a379a3c77d126e3af456f344ec0e84bcf"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a379a3c77d126e3af456f344ec0e84bcf">set</a> (const K &amp;key, const V &amp;value)</td></tr>
<tr class="memdesc:a379a3c77d126e3af456f344ec0e84bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts an entry into this map.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a379a3c77d126e3af456f344ec0e84bcf">More...</a><br /></td></tr>
<tr class="separator:a379a3c77d126e3af456f344ec0e84bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7a799390c27a6bb05691b35b390f14"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:aea7a799390c27a6bb05691b35b390f14"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#aea7a799390c27a6bb05691b35b390f14">set</a> (const K &amp;key, const V &amp;value, std::chrono::milliseconds ttl)</td></tr>
<tr class="memdesc:aea7a799390c27a6bb05691b35b390f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts an entry into this map.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#aea7a799390c27a6bb05691b35b390f14">More...</a><br /></td></tr>
<tr class="separator:aea7a799390c27a6bb05691b35b390f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fc7decd9267b75a4196ea04f33dba8"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a66fc7decd9267b75a4196ea04f33dba8"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a66fc7decd9267b75a4196ea04f33dba8">lock</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a66fc7decd9267b75a4196ea04f33dba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the lock for the specified key.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a66fc7decd9267b75a4196ea04f33dba8">More...</a><br /></td></tr>
<tr class="separator:a66fc7decd9267b75a4196ea04f33dba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075097cf4a98597cec81d2a4cf044302"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a075097cf4a98597cec81d2a4cf044302"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a075097cf4a98597cec81d2a4cf044302">lock</a> (const K &amp;key, std::chrono::milliseconds lease_time)</td></tr>
<tr class="memdesc:a075097cf4a98597cec81d2a4cf044302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires the lock for the specified key for the specified lease time.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a075097cf4a98597cec81d2a4cf044302">More...</a><br /></td></tr>
<tr class="separator:a075097cf4a98597cec81d2a4cf044302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4148d5ddb38c82c60ce883fbc0c798c"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:aa4148d5ddb38c82c60ce883fbc0c798c"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#aa4148d5ddb38c82c60ce883fbc0c798c">is_locked</a> (const K &amp;key)</td></tr>
<tr class="memdesc:aa4148d5ddb38c82c60ce883fbc0c798c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the lock for the specified key.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#aa4148d5ddb38c82c60ce883fbc0c798c">More...</a><br /></td></tr>
<tr class="separator:aa4148d5ddb38c82c60ce883fbc0c798c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94a5c0fb7f03790a914d97a58a7ea18"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:ad94a5c0fb7f03790a914d97a58a7ea18"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#ad94a5c0fb7f03790a914d97a58a7ea18">try_lock</a> (const K &amp;key)</td></tr>
<tr class="memdesc:ad94a5c0fb7f03790a914d97a58a7ea18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to acquire the lock for the specified key.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#ad94a5c0fb7f03790a914d97a58a7ea18">More...</a><br /></td></tr>
<tr class="separator:ad94a5c0fb7f03790a914d97a58a7ea18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2aa45add90c27f52135d0eedec1e5a2"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:ad2aa45add90c27f52135d0eedec1e5a2"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#ad2aa45add90c27f52135d0eedec1e5a2">try_lock</a> (const K &amp;key, std::chrono::milliseconds timeout)</td></tr>
<tr class="memdesc:ad2aa45add90c27f52135d0eedec1e5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to acquire the lock for the specified key.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#ad2aa45add90c27f52135d0eedec1e5a2">More...</a><br /></td></tr>
<tr class="separator:ad2aa45add90c27f52135d0eedec1e5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07959d4b672498324db81018a59236ad"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a07959d4b672498324db81018a59236ad"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a07959d4b672498324db81018a59236ad">try_lock</a> (const K &amp;key, std::chrono::milliseconds timeout, std::chrono::milliseconds lease_time)</td></tr>
<tr class="memdesc:a07959d4b672498324db81018a59236ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to acquire the lock for the specified key for the specified lease time.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a07959d4b672498324db81018a59236ad">More...</a><br /></td></tr>
<tr class="separator:a07959d4b672498324db81018a59236ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee14c9bbb94ec14055cf5ee6a93f1d06"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:aee14c9bbb94ec14055cf5ee6a93f1d06"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#aee14c9bbb94ec14055cf5ee6a93f1d06">unlock</a> (const K &amp;key)</td></tr>
<tr class="memdesc:aee14c9bbb94ec14055cf5ee6a93f1d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock for the specified key.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#aee14c9bbb94ec14055cf5ee6a93f1d06">More...</a><br /></td></tr>
<tr class="separator:aee14c9bbb94ec14055cf5ee6a93f1d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508ccc6450a8a32b2893a2473915e975"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a508ccc6450a8a32b2893a2473915e975"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a508ccc6450a8a32b2893a2473915e975">force_unlock</a> (const K &amp;key)</td></tr>
<tr class="memdesc:a508ccc6450a8a32b2893a2473915e975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the lock for the specified key regardless of the lock owner.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a508ccc6450a8a32b2893a2473915e975">More...</a><br /></td></tr>
<tr class="separator:a508ccc6450a8a32b2893a2473915e975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0648a26eb1bccc074c2281b3e0c3f7"><td class="memTemplParams" colspan="2">template&lt;typename MapInterceptor &gt; </td></tr>
<tr class="memitem:a6b0648a26eb1bccc074c2281b3e0c3f7"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; std::string &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a6b0648a26eb1bccc074c2281b3e0c3f7">add_interceptor</a> (const MapInterceptor &amp;interceptor)</td></tr>
<tr class="memdesc:a6b0648a26eb1bccc074c2281b3e0c3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an interceptor for this map.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a6b0648a26eb1bccc074c2281b3e0c3f7">More...</a><br /></td></tr>
<tr class="separator:a6b0648a26eb1bccc074c2281b3e0c3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1854724dfdd7994465d6a7fd3d7dfc"><td class="memItemLeft" align="right" valign="top">boost::future&lt; boost::uuids::uuid &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a0a1854724dfdd7994465d6a7fd3d7dfc">add_entry_listener</a> (<a class="el" href="../../d8/d8f/classhazelcast_1_1client_1_1entry__listener.html">entry_listener</a> &amp;&amp;listener, bool include_value)</td></tr>
<tr class="memdesc:a0a1854724dfdd7994465d6a7fd3d7dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an entry listener for this map.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a0a1854724dfdd7994465d6a7fd3d7dfc">More...</a><br /></td></tr>
<tr class="separator:a0a1854724dfdd7994465d6a7fd3d7dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b6719194971f2991bd8e004ee49c13"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a56b6719194971f2991bd8e004ee49c13"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; boost::uuids::uuid &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a56b6719194971f2991bd8e004ee49c13">add_entry_listener</a> (<a class="el" href="../../d8/d8f/classhazelcast_1_1client_1_1entry__listener.html">entry_listener</a> &amp;&amp;listener, const P &amp;predicate, bool include_value)</td></tr>
<tr class="memdesc:a56b6719194971f2991bd8e004ee49c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an entry listener for this map.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a56b6719194971f2991bd8e004ee49c13">More...</a><br /></td></tr>
<tr class="separator:a56b6719194971f2991bd8e004ee49c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1008273c62bdccf854a2b9abe42bad9c"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a1008273c62bdccf854a2b9abe42bad9c"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; boost::uuids::uuid &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a1008273c62bdccf854a2b9abe42bad9c">add_entry_listener</a> (<a class="el" href="../../d8/d8f/classhazelcast_1_1client_1_1entry__listener.html">entry_listener</a> &amp;&amp;listener, bool include_value, const K &amp;key)</td></tr>
<tr class="memdesc:a1008273c62bdccf854a2b9abe42bad9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified entry listener for the specified key.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a1008273c62bdccf854a2b9abe42bad9c">More...</a><br /></td></tr>
<tr class="separator:a1008273c62bdccf854a2b9abe42bad9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfca0a849a47026bafa0821d36c7d4c4"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:adfca0a849a47026bafa0821d36c7d4c4"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; boost::optional&lt; <a class="el" href="../../de/d4c/classhazelcast_1_1client_1_1entry__view.html">entry_view</a>&lt; K, V &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#adfca0a849a47026bafa0821d36c7d4c4">get_entry_view</a> (const K &amp;key)</td></tr>
<tr class="memdesc:adfca0a849a47026bafa0821d36c7d4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>EntryView</code> for the specified key.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#adfca0a849a47026bafa0821d36c7d4c4">More...</a><br /></td></tr>
<tr class="separator:adfca0a849a47026bafa0821d36c7d4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8cb1823f33d095fb755533048954cb"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:ada8cb1823f33d095fb755533048954cb"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#ada8cb1823f33d095fb755533048954cb">evict</a> (const K &amp;key)</td></tr>
<tr class="memdesc:ada8cb1823f33d095fb755533048954cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evicts the specified key from this map.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#ada8cb1823f33d095fb755533048954cb">More...</a><br /></td></tr>
<tr class="separator:ada8cb1823f33d095fb755533048954cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473116a22e142d2387f8984ecb14f439"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a473116a22e142d2387f8984ecb14f439"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; std::unordered_map&lt; K, V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a473116a22e142d2387f8984ecb14f439">get_all</a> (const std::unordered_set&lt; K &gt; &amp;keys)</td></tr>
<tr class="memdesc:a473116a22e142d2387f8984ecb14f439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the entries for the given keys.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a473116a22e142d2387f8984ecb14f439">More...</a><br /></td></tr>
<tr class="separator:a473116a22e142d2387f8984ecb14f439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87847ae45caf088cf7b390121a9dc00d"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a87847ae45caf088cf7b390121a9dc00d"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; std::vector&lt; K &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a87847ae45caf088cf7b390121a9dc00d">key_set</a> ()</td></tr>
<tr class="memdesc:a87847ae45caf088cf7b390121a9dc00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector clone of the keys contained in this map.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a87847ae45caf088cf7b390121a9dc00d">More...</a><br /></td></tr>
<tr class="separator:a87847ae45caf088cf7b390121a9dc00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29c6b1f9b028c713ed14677552cf5bd"><td class="memTemplParams" colspan="2">template&lt;typename K , typename P , class  = typename std::enable_if&lt;!std::is_base_of&lt;query::paging_predicate_marker, P&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ad29c6b1f9b028c713ed14677552cf5bd"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; std::vector&lt; K &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#ad29c6b1f9b028c713ed14677552cf5bd">key_set</a> (const P &amp;predicate)</td></tr>
<tr class="memdesc:ad29c6b1f9b028c713ed14677552cf5bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the map based on the specified predicate and returns the keys of matching entries.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#ad29c6b1f9b028c713ed14677552cf5bd">More...</a><br /></td></tr>
<tr class="separator:ad29c6b1f9b028c713ed14677552cf5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7605507c000eb548a7ec5691561a06d9"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a7605507c000eb548a7ec5691561a06d9"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; std::vector&lt; K &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a7605507c000eb548a7ec5691561a06d9">key_set</a> (<a class="el" href="../../d6/dd0/classhazelcast_1_1client_1_1query_1_1paging__predicate.html">query::paging_predicate</a>&lt; K, V &gt; &amp;predicate)</td></tr>
<tr class="memdesc:a7605507c000eb548a7ec5691561a06d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the map based on the specified predicate and returns the keys of matching entries.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a7605507c000eb548a7ec5691561a06d9">More...</a><br /></td></tr>
<tr class="separator:a7605507c000eb548a7ec5691561a06d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f474d6313fab3dc603fce4b8cef76a5"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a6f474d6313fab3dc603fce4b8cef76a5"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; std::vector&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a6f474d6313fab3dc603fce4b8cef76a5">values</a> ()</td></tr>
<tr class="memdesc:a6f474d6313fab3dc603fce4b8cef76a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector clone of the values contained in this map.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a6f474d6313fab3dc603fce4b8cef76a5">More...</a><br /></td></tr>
<tr class="separator:a6f474d6313fab3dc603fce4b8cef76a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a43a25ce75e75067affa57cedb46774"><td class="memTemplParams" colspan="2">template&lt;typename V , typename P , class  = typename std::enable_if&lt;!std::is_base_of&lt;query::paging_predicate_marker, P&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a2a43a25ce75e75067affa57cedb46774"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; std::vector&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a2a43a25ce75e75067affa57cedb46774">values</a> (const P &amp;predicate)</td></tr>
<tr class="memdesc:a2a43a25ce75e75067affa57cedb46774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector clone of the values contained in this map.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a2a43a25ce75e75067affa57cedb46774">More...</a><br /></td></tr>
<tr class="separator:a2a43a25ce75e75067affa57cedb46774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85bd6056976dcc6e66d612f2271c9bc1"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a85bd6056976dcc6e66d612f2271c9bc1"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; std::vector&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a85bd6056976dcc6e66d612f2271c9bc1">values</a> (<a class="el" href="../../d6/dd0/classhazelcast_1_1client_1_1query_1_1paging__predicate.html">query::paging_predicate</a>&lt; K, V &gt; &amp;predicate)</td></tr>
<tr class="memdesc:a85bd6056976dcc6e66d612f2271c9bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector clone of the values contained in this map.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a85bd6056976dcc6e66d612f2271c9bc1">More...</a><br /></td></tr>
<tr class="separator:a85bd6056976dcc6e66d612f2271c9bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018508ba564fac5f7c1a487b0776e2cc"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a018508ba564fac5f7c1a487b0776e2cc"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; std::vector&lt; std::pair&lt; K, V &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a018508ba564fac5f7c1a487b0776e2cc">entry_set</a> ()</td></tr>
<tr class="memdesc:a018508ba564fac5f7c1a487b0776e2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a std::vector&lt; std::pair&lt;K, V&gt; &gt; clone of the mappings contained in this map.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a018508ba564fac5f7c1a487b0776e2cc">More...</a><br /></td></tr>
<tr class="separator:a018508ba564fac5f7c1a487b0776e2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f67ef395cef6aa84b465d5f052203ae"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename P , class  = typename std::enable_if&lt;!std::is_base_of&lt;query::paging_predicate_marker, P&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a1f67ef395cef6aa84b465d5f052203ae"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; std::vector&lt; std::pair&lt; K, V &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a1f67ef395cef6aa84b465d5f052203ae">entry_set</a> (const P &amp;predicate)</td></tr>
<tr class="memdesc:a1f67ef395cef6aa84b465d5f052203ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the map based on the specified predicate and returns the matching entries.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a1f67ef395cef6aa84b465d5f052203ae">More...</a><br /></td></tr>
<tr class="separator:a1f67ef395cef6aa84b465d5f052203ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d959cb8ae287036eb157b0247e15343"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a4d959cb8ae287036eb157b0247e15343"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; std::vector&lt; std::pair&lt; K, V &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a4d959cb8ae287036eb157b0247e15343">entry_set</a> (<a class="el" href="../../d6/dd0/classhazelcast_1_1client_1_1query_1_1paging__predicate.html">query::paging_predicate</a>&lt; K, V &gt; &amp;predicate)</td></tr>
<tr class="memdesc:a4d959cb8ae287036eb157b0247e15343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the map based on the specified predicate and returns the matching entries.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a4d959cb8ae287036eb157b0247e15343">More...</a><br /></td></tr>
<tr class="separator:a4d959cb8ae287036eb157b0247e15343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7eaaff6829eff18333d48319cc9980"><td class="memItemLeft" align="right" valign="top">boost::future&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#aad7eaaff6829eff18333d48319cc9980">add_index</a> (const <a class="el" href="../../df/dbf/structhazelcast_1_1client_1_1config_1_1index__config.html">config::index_config</a> &amp;config)</td></tr>
<tr class="memdesc:aad7eaaff6829eff18333d48319cc9980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an index to this map for the specified entries so that queries can run faster.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#aad7eaaff6829eff18333d48319cc9980">More...</a><br /></td></tr>
<tr class="separator:aad7eaaff6829eff18333d48319cc9980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9fc4c087ac6965cb75049a7ccc8d0f"><td class="memTemplParams" colspan="2">template&lt;typename ... T&gt; </td></tr>
<tr class="memitem:a4a9fc4c087ac6965cb75049a7ccc8d0f"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a4a9fc4c087ac6965cb75049a7ccc8d0f">add_index</a> (<a class="el" href="../../df/dbf/structhazelcast_1_1client_1_1config_1_1index__config.html#aefac15fd07cd4c0dc34fc1691817e59f">config::index_config::index_type</a> type, T... attributes)</td></tr>
<tr class="memdesc:a4a9fc4c087ac6965cb75049a7ccc8d0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient method to add an index to this map with the given type and attributes.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a4a9fc4c087ac6965cb75049a7ccc8d0f">More...</a><br /></td></tr>
<tr class="separator:a4a9fc4c087ac6965cb75049a7ccc8d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1375da14c4b194ce3aca17d5b80383ab"><td class="memItemLeft" align="right" valign="top"><a id="a1375da14c4b194ce3aca17d5b80383ab"></a>
boost::future&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="separator:a1375da14c4b194ce3aca17d5b80383ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789cc83402339e7ba178931c4706a37a"><td class="memTemplParams" colspan="2">template&lt;typename K , typename ResultType , typename EntryProcessor &gt; </td></tr>
<tr class="memitem:a789cc83402339e7ba178931c4706a37a"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; boost::optional&lt; ResultType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a789cc83402339e7ba178931c4706a37a">execute_on_key</a> (const K &amp;key, const EntryProcessor &amp;entry_processor)</td></tr>
<tr class="memdesc:a789cc83402339e7ba178931c4706a37a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the user defined EntryProcessor to the entry mapped by the key.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a789cc83402339e7ba178931c4706a37a">More...</a><br /></td></tr>
<tr class="separator:a789cc83402339e7ba178931c4706a37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d262dbcfa8f977d3f9f4d2eaa8acd48"><td class="memTemplParams" colspan="2">template&lt;typename K , typename ResultType , typename EntryProcessor &gt; </td></tr>
<tr class="memitem:a2d262dbcfa8f977d3f9f4d2eaa8acd48"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; boost::optional&lt; ResultType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a2d262dbcfa8f977d3f9f4d2eaa8acd48">submit_to_key</a> (const K &amp;key, const EntryProcessor &amp;entry_processor)</td></tr>
<tr class="memdesc:a2d262dbcfa8f977d3f9f4d2eaa8acd48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the user defined EntryProcessor to the entry mapped by the key.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a2d262dbcfa8f977d3f9f4d2eaa8acd48">More...</a><br /></td></tr>
<tr class="separator:a2d262dbcfa8f977d3f9f4d2eaa8acd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8843a1a55921b7b7f9be5fea2e684e9f"><td class="memTemplParams" colspan="2">template&lt;typename K , typename ResultType , typename EntryProcessor &gt; </td></tr>
<tr class="memitem:a8843a1a55921b7b7f9be5fea2e684e9f"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; std::unordered_map&lt; K, boost::optional&lt; ResultType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a8843a1a55921b7b7f9be5fea2e684e9f">execute_on_keys</a> (const std::unordered_set&lt; K &gt; &amp;keys, const EntryProcessor &amp;entry_processor)</td></tr>
<tr class="memdesc:a8843a1a55921b7b7f9be5fea2e684e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the user defined EntryProcessor to the entries mapped by the collection of keys.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a8843a1a55921b7b7f9be5fea2e684e9f">More...</a><br /></td></tr>
<tr class="separator:a8843a1a55921b7b7f9be5fea2e684e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b59773d026cfa4690bf9f552a91d45"><td class="memTemplParams" colspan="2">template&lt;typename K , typename ResultType , typename EntryProcessor &gt; </td></tr>
<tr class="memitem:ad4b59773d026cfa4690bf9f552a91d45"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; std::unordered_map&lt; K, boost::optional&lt; ResultType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#ad4b59773d026cfa4690bf9f552a91d45">execute_on_entries</a> (const EntryProcessor &amp;entry_processor)</td></tr>
<tr class="memdesc:ad4b59773d026cfa4690bf9f552a91d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the user defined EntryProcessor to the all entries in the map.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#ad4b59773d026cfa4690bf9f552a91d45">More...</a><br /></td></tr>
<tr class="separator:ad4b59773d026cfa4690bf9f552a91d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403c102f0a90d4eefb4f7a361e20b9bf"><td class="memTemplParams" colspan="2">template&lt;typename K , typename ResultType , typename EntryProcessor , typename P &gt; </td></tr>
<tr class="memitem:a403c102f0a90d4eefb4f7a361e20b9bf"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; std::unordered_map&lt; K, boost::optional&lt; ResultType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a403c102f0a90d4eefb4f7a361e20b9bf">execute_on_entries</a> (const EntryProcessor &amp;entry_processor, const P &amp;predicate)</td></tr>
<tr class="memdesc:a403c102f0a90d4eefb4f7a361e20b9bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the user defined EntryProcessor to the all entries in the map.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a403c102f0a90d4eefb4f7a361e20b9bf">More...</a><br /></td></tr>
<tr class="separator:a403c102f0a90d4eefb4f7a361e20b9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87029736a712e347d1d4dbbb3bc83103"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a87029736a712e347d1d4dbbb3bc83103"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a87029736a712e347d1d4dbbb3bc83103">put_all</a> (const std::unordered_map&lt; K, V &gt; &amp;entries)</td></tr>
<tr class="memdesc:a87029736a712e347d1d4dbbb3bc83103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all of the mappings from the specified map to this map (optional operation).  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a87029736a712e347d1d4dbbb3bc83103">More...</a><br /></td></tr>
<tr class="separator:a87029736a712e347d1d4dbbb3bc83103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5eff52f4ddd34fb3ab1644f0fb0d03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/dd6/classhazelcast_1_1client_1_1monitor_1_1local__map__stats.html">monitor::local_map_stats</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a7c5eff52f4ddd34fb3ab1644f0fb0d03">get_local_map_stats</a> ()</td></tr>
<tr class="memdesc:a7c5eff52f4ddd34fb3ab1644f0fb0d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns LocalMapStats for this map.  <a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a7c5eff52f4ddd34fb3ab1644f0fb0d03">More...</a><br /></td></tr>
<tr class="separator:a7c5eff52f4ddd34fb3ab1644f0fb0d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80567f243d68ff5b7098755a49a41e22"><td class="memTemplParams" colspan="2"><a id="a80567f243d68ff5b7098755a49a41e22"></a>
template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a80567f243d68ff5b7098755a49a41e22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/dd0/classhazelcast_1_1client_1_1query_1_1paging__predicate.html">query::paging_predicate</a>&lt; K, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>new_paging_predicate</b> (size_t predicate_page_size)</td></tr>
<tr class="separator:a80567f243d68ff5b7098755a49a41e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e050e85ca5cdf8d679b6b1d166fcbb3"><td class="memTemplParams" colspan="2"><a id="a2e050e85ca5cdf8d679b6b1d166fcbb3"></a>
template&lt;typename K , typename V , typename INNER_PREDICATE &gt; </td></tr>
<tr class="memitem:a2e050e85ca5cdf8d679b6b1d166fcbb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/dd0/classhazelcast_1_1client_1_1query_1_1paging__predicate.html">query::paging_predicate</a>&lt; K, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>new_paging_predicate</b> (size_t predicate_page_size, const INNER_PREDICATE &amp;predicate)</td></tr>
<tr class="separator:a2e050e85ca5cdf8d679b6b1d166fcbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50d5977c4cf66ffe763e4430f68e59f"><td class="memTemplParams" colspan="2"><a id="aa50d5977c4cf66ffe763e4430f68e59f"></a>
template&lt;typename K , typename V , typename COMPARATOR &gt; </td></tr>
<tr class="memitem:aa50d5977c4cf66ffe763e4430f68e59f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/dd0/classhazelcast_1_1client_1_1query_1_1paging__predicate.html">query::paging_predicate</a>&lt; K, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>new_paging_predicate</b> (COMPARATOR &amp;&amp;comparator, size_t predicate_page_size)</td></tr>
<tr class="separator:aa50d5977c4cf66ffe763e4430f68e59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab156dcd53205fe96a8c71e64ac4eeb84"><td class="memTemplParams" colspan="2"><a id="ab156dcd53205fe96a8c71e64ac4eeb84"></a>
template&lt;typename K , typename V , typename INNER_PREDICATE , typename COMPARATOR &gt; </td></tr>
<tr class="memitem:ab156dcd53205fe96a8c71e64ac4eeb84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/dd0/classhazelcast_1_1client_1_1query_1_1paging__predicate.html">query::paging_predicate</a>&lt; K, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>new_paging_predicate</b> (const INNER_PREDICATE &amp;predicate, COMPARATOR &amp;&amp;comparator, size_t predicate_page_size)</td></tr>
<tr class="separator:ab156dcd53205fe96a8c71e64ac4eeb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a606a50ca862ec1d5018b403c626bbf13"><td class="memItemLeft" align="right" valign="top"><a id="a606a50ca862ec1d5018b403c626bbf13"></a>
static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><b>SERVICE_NAME</b> = &quot;hz:impl:mapService&quot;</td></tr>
<tr class="separator:a606a50ca862ec1d5018b403c626bbf13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a51eb697943dcc30d99539faab696fb17"><td class="memItemLeft" align="right" valign="top"><a id="a51eb697943dcc30d99539faab696fb17"></a>
virtual boost::future&lt; boost::optional&lt; serialization::pimpl::data &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_internal</b> (const serialization::pimpl::data &amp;key_data)</td></tr>
<tr class="separator:a51eb697943dcc30d99539faab696fb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ed4d1131f1a6fb13ce779e63e1f9b1"><td class="memItemLeft" align="right" valign="top"><a id="a30ed4d1131f1a6fb13ce779e63e1f9b1"></a>
virtual boost::future&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>contains_key_internal</b> (const serialization::pimpl::data &amp;key_data)</td></tr>
<tr class="separator:a30ed4d1131f1a6fb13ce779e63e1f9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ac3f930a435b3b0fe0f8b9d187de88"><td class="memItemLeft" align="right" valign="top"><a id="a52ac3f930a435b3b0fe0f8b9d187de88"></a>
virtual boost::future&lt; boost::optional&lt; serialization::pimpl::data &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>remove_internal</b> (const serialization::pimpl::data &amp;key_data)</td></tr>
<tr class="separator:a52ac3f930a435b3b0fe0f8b9d187de88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9913bba91d44e237d728bef6eabea96b"><td class="memItemLeft" align="right" valign="top"><a id="a9913bba91d44e237d728bef6eabea96b"></a>
virtual boost::future&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>remove_internal</b> (const serialization::pimpl::data &amp;key_data, const serialization::pimpl::data &amp;value_data)</td></tr>
<tr class="separator:a9913bba91d44e237d728bef6eabea96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14adbf21ab8357f23185039c598eb7de"><td class="memItemLeft" align="right" valign="top"><a id="a14adbf21ab8357f23185039c598eb7de"></a>
virtual boost::future&lt; protocol::ClientMessage &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>remove_all_internal</b> (const serialization::pimpl::data &amp;predicate_data)</td></tr>
<tr class="separator:a14adbf21ab8357f23185039c598eb7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6557b6d8d8f6026f90eb392245ca2597"><td class="memItemLeft" align="right" valign="top"><a id="a6557b6d8d8f6026f90eb392245ca2597"></a>
virtual boost::future&lt; protocol::ClientMessage &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>delete_internal</b> (const serialization::pimpl::data &amp;key_data)</td></tr>
<tr class="separator:a6557b6d8d8f6026f90eb392245ca2597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad550dadfbe2b9bddc5501082e5448e21"><td class="memItemLeft" align="right" valign="top"><a id="ad550dadfbe2b9bddc5501082e5448e21"></a>
virtual boost::future&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>try_remove_internal</b> (const serialization::pimpl::data &amp;key_data, std::chrono::milliseconds timeout)</td></tr>
<tr class="separator:ad550dadfbe2b9bddc5501082e5448e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe7e40bd4cfe7e927ea1fdaca0986a0"><td class="memItemLeft" align="right" valign="top"><a id="a0fe7e40bd4cfe7e927ea1fdaca0986a0"></a>
virtual boost::future&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>try_put_internal</b> (const serialization::pimpl::data &amp;key_data, const serialization::pimpl::data &amp;value_data, std::chrono::milliseconds timeout)</td></tr>
<tr class="separator:a0fe7e40bd4cfe7e927ea1fdaca0986a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbba318ae0be4945bdac14702dce9c9"><td class="memItemLeft" align="right" valign="top"><a id="afbbba318ae0be4945bdac14702dce9c9"></a>
virtual boost::future&lt; boost::optional&lt; serialization::pimpl::data &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>put_internal</b> (const serialization::pimpl::data &amp;key_data, const serialization::pimpl::data &amp;value_data, std::chrono::milliseconds ttl)</td></tr>
<tr class="separator:afbbba318ae0be4945bdac14702dce9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f431d65c7d5673761d706c09ce817fd"><td class="memItemLeft" align="right" valign="top"><a id="a2f431d65c7d5673761d706c09ce817fd"></a>
virtual boost::future&lt; protocol::ClientMessage &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>try_put_transient_internal</b> (const serialization::pimpl::data &amp;key_data, const serialization::pimpl::data &amp;value_data, std::chrono::milliseconds ttl)</td></tr>
<tr class="separator:a2f431d65c7d5673761d706c09ce817fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d219d92d4bb1a50b4f595abe0fc731c"><td class="memItemLeft" align="right" valign="top"><a id="a5d219d92d4bb1a50b4f595abe0fc731c"></a>
virtual boost::future&lt; boost::optional&lt; serialization::pimpl::data &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>put_if_absent_internal</b> (const serialization::pimpl::data &amp;key_data, const serialization::pimpl::data &amp;value_data, std::chrono::milliseconds ttl)</td></tr>
<tr class="separator:a5d219d92d4bb1a50b4f595abe0fc731c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09f4ec5f26ae30b0c31a54d357e2de0"><td class="memItemLeft" align="right" valign="top"><a id="aa09f4ec5f26ae30b0c31a54d357e2de0"></a>
virtual boost::future&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>replace_if_same_internal</b> (const serialization::pimpl::data &amp;key_data, const serialization::pimpl::data &amp;value_data, const serialization::pimpl::data &amp;new_value_data)</td></tr>
<tr class="separator:aa09f4ec5f26ae30b0c31a54d357e2de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec53e7a1f490075cd32960f975d51abb"><td class="memItemLeft" align="right" valign="top"><a id="aec53e7a1f490075cd32960f975d51abb"></a>
virtual boost::future&lt; boost::optional&lt; serialization::pimpl::data &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>replace_internal</b> (const serialization::pimpl::data &amp;key_data, const serialization::pimpl::data &amp;value_data)</td></tr>
<tr class="separator:aec53e7a1f490075cd32960f975d51abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf13aa7edde18e796161da8e4ccee66f"><td class="memItemLeft" align="right" valign="top"><a id="abf13aa7edde18e796161da8e4ccee66f"></a>
virtual boost::future&lt; protocol::ClientMessage &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>set_internal</b> (const serialization::pimpl::data &amp;key_data, const serialization::pimpl::data &amp;value_data, std::chrono::milliseconds ttl)</td></tr>
<tr class="separator:abf13aa7edde18e796161da8e4ccee66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad605eed07426d80df10030f0b441f85d"><td class="memItemLeft" align="right" valign="top"><a id="ad605eed07426d80df10030f0b441f85d"></a>
virtual boost::future&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>evict_internal</b> (const serialization::pimpl::data &amp;key_data)</td></tr>
<tr class="separator:ad605eed07426d80df10030f0b441f85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca39ab8cd767ab5cbdd1a8db9ef096b1"><td class="memItemLeft" align="right" valign="top"><a id="aca39ab8cd767ab5cbdd1a8db9ef096b1"></a>
virtual boost::future&lt; EntryVector &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_all_internal</b> (int partition_id, const std::vector&lt; serialization::pimpl::data &gt; &amp;partition_keys)</td></tr>
<tr class="separator:aca39ab8cd767ab5cbdd1a8db9ef096b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97499919407c82ce883a5d3a62ab1dcc"><td class="memItemLeft" align="right" valign="top"><a id="a97499919407c82ce883a5d3a62ab1dcc"></a>
virtual boost::future&lt; boost::optional&lt; serialization::pimpl::data &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>execute_on_key_internal</b> (const serialization::pimpl::data &amp;key_data, const serialization::pimpl::data &amp;processor)</td></tr>
<tr class="separator:a97499919407c82ce883a5d3a62ab1dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db08ff7b9232ed7a00ac0872fc783a9"><td class="memItemLeft" align="right" valign="top"><a id="a1db08ff7b9232ed7a00ac0872fc783a9"></a>
boost::future&lt; boost::optional&lt; serialization::pimpl::data &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>submit_to_key_internal</b> (const serialization::pimpl::data &amp;key_data, const serialization::pimpl::data &amp;processor)</td></tr>
<tr class="separator:a1db08ff7b9232ed7a00ac0872fc783a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ac76f5c03313172ce4d719bdd9560d"><td class="memTemplParams" colspan="2"><a id="ad4ac76f5c03313172ce4d719bdd9560d"></a>
template&lt;typename K , typename EntryProcessor &gt; </td></tr>
<tr class="memitem:ad4ac76f5c03313172ce4d719bdd9560d"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; EntryVector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>execute_on_keys_internal</b> (const std::unordered_set&lt; K &gt; &amp;keys, const EntryProcessor &amp;entry_processor)</td></tr>
<tr class="separator:ad4ac76f5c03313172ce4d719bdd9560d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f3de4d19ee698ffa9f9d10e8313f68"><td class="memItemLeft" align="right" valign="top"><a id="a77f3de4d19ee698ffa9f9d10e8313f68"></a>
virtual boost::future&lt; protocol::ClientMessage &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>put_all_internal</b> (int partition_id, const EntryVector &amp;entries)</td></tr>
<tr class="separator:a77f3de4d19ee698ffa9f9d10e8313f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af7622904c27cea133020684bd341a283"><td class="memItemLeft" align="right" valign="top"><a id="af7622904c27cea133020684bd341a283"></a>
monitor::impl::LocalMapStatsImpl&#160;</td><td class="memItemRight" valign="bottom"><b>local_map_stats_</b></td></tr>
<tr class="separator:af7622904c27cea133020684bd341a283"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a95567bf4dff1e6727e8a173186fcee7e"><td class="memItemLeft" align="right" valign="top"><a id="a95567bf4dff1e6727e8a173186fcee7e"></a>
static constexpr std::chrono::milliseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a95567bf4dff1e6727e8a173186fcee7e">UNSET</a> {-1}</td></tr>
<tr class="memdesc:a95567bf4dff1e6727e8a173186fcee7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default TTL value of a record. <br /></td></tr>
<tr class="separator:a95567bf4dff1e6727e8a173186fcee7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0195b4df1fa489288a2a52fe5b0e23b7"><td class="memItemLeft" align="right" valign="top"><a id="a0195b4df1fa489288a2a52fe5b0e23b7"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>spi::ProxyManager</b></td></tr>
<tr class="separator:a0195b4df1fa489288a2a52fe5b0e23b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Concurrent, distributed, observable and queryable map client. </p>
<p>Notice that this class have a private constructor. You can access get an IMap in the following way </p><pre class="fragment"> auto client = new_client().get();
 auto imap = client.get_map("aMap").get();
</pre> 
<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00063">63</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0a1854724dfdd7994465d6a7fd3d7dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1854724dfdd7994465d6a7fd3d7dfc">&#9670;&nbsp;</a></span>add_entry_listener() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;boost::uuids::uuid&gt; hazelcast::client::imap::add_entry_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d8f/classhazelcast_1_1client_1_1entry__listener.html">entry_listener</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an entry listener for this map. </p>
<p>Warning 1: If listener should do a time consuming operation, off-load the operation to another thread. otherwise it will slow down the system.</p>
<p>Warning 2: Do not make a call to hazelcast. It can cause deadlock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>entry listener </td></tr>
    <tr><td class="paramname">includeValue</td><td><code>true</code> if <code>EntryEvent</code> should contain the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>registrationId of added listener that can be used to remove the entry listener. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00471">471</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;                                                                                                          {</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;                <span class="keyword">const</span> <span class="keyword">auto</span> listener_flags = listener.flags_;</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;                <span class="keywordflow">return</span> proxy::IMapImpl::add_entry_listener(</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;                        std::unique_ptr&lt;impl::BaseEventHandler&gt;(</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;                                <span class="keyword">new</span> impl::EntryEventHandler&lt;protocol::codec::map_addentrylistener_handler&gt;(</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;                                        get_name(), get_context().get_client_cluster_service(),</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;                                        get_context().get_serialization_service(),</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;                                        std::move(listener),</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;                                        include_value, get_context().get_logger())), include_value, listener_flags);</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1008273c62bdccf854a2b9abe42bad9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1008273c62bdccf854a2b9abe42bad9c">&#9670;&nbsp;</a></span>add_entry_listener() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;boost::uuids::uuid&gt; hazelcast::client::imap::add_entry_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d8f/classhazelcast_1_1client_1_1entry__listener.html">entry_listener</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the specified entry listener for the specified key. </p>
<p>Warning 1: If listener should do a time consuming operation, off-load the operation to another thread. otherwise it will slow down the system.</p>
<p>Warning 2: Do not make a call to hazelcast. It can cause deadlock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>entry listener </td></tr>
    <tr><td class="paramname">key</td><td>key to listen </td></tr>
    <tr><td class="paramname">includeValue</td><td><code>true</code> if <code>EntryEvent</code> should contain the value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00524">524</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;                                                                                                                        {</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;                <span class="keyword">const</span> <span class="keyword">auto</span> listener_flags = listener.flags_;</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;                <span class="keywordflow">return</span> proxy::IMapImpl::add_entry_listener(</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;                        std::shared_ptr&lt;impl::BaseEventHandler&gt;(</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;                                <span class="keyword">new</span> impl::EntryEventHandler&lt;protocol::codec::map_addentrylistenertokey_handler&gt;(</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;                                        get_name(), get_context().get_client_cluster_service(),</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;                                        get_context().get_serialization_service(),</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;                                        std::move(listener),</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;                                        include_value, get_context().get_logger())), include_value, to_data&lt;K&gt;(key), listener_flags);</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a56b6719194971f2991bd8e004ee49c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b6719194971f2991bd8e004ee49c13">&#9670;&nbsp;</a></span>add_entry_listener() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;boost::uuids::uuid&gt; hazelcast::client::imap::add_entry_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d8f/classhazelcast_1_1client_1_1entry__listener.html">entry_listener</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an entry listener for this map. </p>
<p>Warning 1: If listener should do a time consuming operation, off-load the operation to another thread. otherwise it will slow down the system.</p>
<p>Warning 2: Do not make a call to hazelcast. It can cause deadlock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>entry listener </td></tr>
    <tr><td class="paramname">predicate</td><td>The query filter to use when returning the events to the user. </td></tr>
    <tr><td class="paramname">includeValue</td><td><code>true</code> if <code>EntryEvent</code> should contain the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>registrationId of added listener that can be used to remove the entry listener. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00499">499</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;                                                                                                  {</div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;                <span class="keyword">const</span> <span class="keyword">auto</span> listener_flags = listener.flags_;</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;                <span class="keywordflow">return</span> proxy::IMapImpl::add_entry_listener(</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;                        std::unique_ptr&lt;impl::BaseEventHandler&gt;(</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;                                <span class="keyword">new</span> impl::EntryEventHandler&lt;protocol::codec::map_addentrylistenerwithpredicate_handler&gt;(</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;                                        get_name(), get_context().get_client_cluster_service(),</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;                                        get_context().get_serialization_service(),</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;                                        std::move(listener),</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;                                        include_value, get_context().get_logger())), to_data&lt;P&gt;(predicate), include_value, listener_flags);</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4a9fc4c087ac6965cb75049a7ccc8d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9fc4c087ac6965cb75049a7ccc8d0f">&#9670;&nbsp;</a></span>add_index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;void&gt; hazelcast::client::imap::add_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dbf/structhazelcast_1_1client_1_1config_1_1index__config.html#aefac15fd07cd4c0dc34fc1691817e59f">config::index_config::index_type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T...&#160;</td>
          <td class="paramname"><em>attributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenient method to add an index to this map with the given type and attributes. </p>
<p>Attributes are indexed in ascending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Index type. </td></tr>
    <tr><td class="paramname">attributes</td><td>Attributes to be indexed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00832">832</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;                                                                                            {</div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#aad7eaaff6829eff18333d48319cc9980">add_index</a>(config::index_config(type, std::forward&lt;T&gt;(attributes)...));</div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;            }</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1imap_html_aad7eaaff6829eff18333d48319cc9980"><div class="ttname"><a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#aad7eaaff6829eff18333d48319cc9980">hazelcast::client::imap::add_index</a></div><div class="ttdeci">boost::future&lt; void &gt; add_index(const config::index_config &amp;config)</div><div class="ttdoc">Adds an index to this map for the specified entries so that queries can run faster.</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dcf/imap_8h_source.html#l00819">imap.h:819</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aad7eaaff6829eff18333d48319cc9980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad7eaaff6829eff18333d48319cc9980">&#9670;&nbsp;</a></span>add_index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;void&gt; hazelcast::client::imap::add_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/dbf/structhazelcast_1_1client_1_1config_1_1index__config.html">config::index_config</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an index to this map for the specified entries so that queries can run faster. </p>
<p>Let's say your map values are Employee objects. </p><pre>
  struct Employee {
    bool active;
    int32_t age;
    std::string name;
    // other fields

  }
</pre><p> If you are querying your values mostly based on age and active then you may consider indexing these fields. </p><pre>
  auto imap = client.getMap("employees");
  imap.addIndex(<a class="el" href="../../df/dbf/structhazelcast_1_1client_1_1config_1_1index__config.html" title="Configuration of an index.">config::index_config</a>(config::index_config::index_type::SORTED, "age"));  // Sorted index for range queries
  imap.addIndex(<a class="el" href="../../df/dbf/structhazelcast_1_1client_1_1config_1_1index__config.html" title="Configuration of an index.">config::index_config</a>(config::index_config::index_type::HASH, "active"));  // Sorted index for range queries
</pre><p> Index attribute should either have a getter method or be public. You should also make sure to add the indexes before adding entries to this map. </p>
<p><b>Time to Index</b> </p>
<p>Indexing time is executed in parallel on each partition by operation threads. The Map is not blocked during this operation. </p>
<p>The time taken in proportional to the size of the Map and the number Members. </p>
<p><b>Searches while indexes are being built</b> </p>
<p>Until the index finishes being created, any searches for the attribute will use a full Map scan, thus avoiding using a partially built index and returning incorrect results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Index configuration. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00819">819</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;                                                                          {</div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;                <span class="keywordflow">return</span> to_void_future(proxy::IMapImpl::add_index_data(config));</div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6b0648a26eb1bccc074c2281b3e0c3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0648a26eb1bccc074c2281b3e0c3f7">&#9670;&nbsp;</a></span>add_interceptor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MapInterceptor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;std::string&gt; hazelcast::client::imap::add_interceptor </td>
          <td>(</td>
          <td class="paramtype">const MapInterceptor &amp;&#160;</td>
          <td class="paramname"><em>interceptor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an interceptor for this map. </p>
<p>Added interceptor will intercept operations and execute user defined methods and will cancel operations if user defined method throw exception.</p>
<p>Interceptor should be serializable. Notice that map interceptor runs on the nodes. Because of that same class should be implemented in java side with same classId and factoryId. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interceptor</td><td>map interceptor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>id of registered interceptor </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00453">453</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;                                                                                      {</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;                <span class="keywordflow">return</span> proxy::IMapImpl::add_interceptor(to_data(interceptor));</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5e44c15a04d7ddabf2779eb238eb351f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e44c15a04d7ddabf2779eb238eb351f">&#9670;&nbsp;</a></span>contains_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;bool&gt; hazelcast::client::imap::contains_key </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if this map contains key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contains, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00077">77</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;                                                         {</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;                <span class="keywordflow">return</span> contains_key_internal(to_data(key));</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9379ff0c704459410ce145212909719d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9379ff0c704459410ce145212909719d">&#9670;&nbsp;</a></span>contains_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;bool&gt; hazelcast::client::imap::contains_value </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if this map contains value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if contains, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00087">87</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                                                             {</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;                <span class="keywordflow">return</span> proxy::IMapImpl::contains_value(to_data(value));</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad52ba226a5227b068e7b849a311d945d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52ba226a5227b068e7b849a311d945d">&#9670;&nbsp;</a></span>delete_entry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;void&gt; hazelcast::client::imap::delete_entry </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>removes entry from map. </p>
<p>Does not return anything. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the map entry to remove. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00168">168</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                                                         {</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                <span class="keywordflow">return</span> to_void_future(delete_internal(to_data(key)));</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a018508ba564fac5f7c1a487b0776e2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a018508ba564fac5f7c1a487b0776e2cc">&#9670;&nbsp;</a></span>entry_set() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;std::vector&lt;std::pair&lt;K, V&gt; &gt; &gt; hazelcast::client::imap::entry_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a std::vector&lt; std::pair&lt;K, V&gt; &gt; clone of the mappings contained in this map. </p>
<p>The vector is <b>NOT</b> backed by the map, so changes to the map are <b>NOT</b> reflected in the set, and vice-versa.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector clone of the keys mappings in this map </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00733">733</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;                                                              {</div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;                <span class="keywordflow">return</span> to_entry_object_vector&lt;K,V&gt;(proxy::IMapImpl::entry_set_data());</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1f67ef395cef6aa84b465d5f052203ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f67ef395cef6aa84b465d5f052203ae">&#9670;&nbsp;</a></span>entry_set() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename P , class  = typename std::enable_if&lt;!std::is_base_of&lt;query::paging_predicate_marker, P&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;std::vector&lt;std::pair&lt;K, V&gt; &gt; &gt; hazelcast::client::imap::entry_set </td>
          <td>(</td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries the map based on the specified predicate and returns the matching entries. </p>
<p>Specified predicate runs on all members in parallel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>query criteria </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result entry vector of the query </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00748">748</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;                                                                                {</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;                <span class="keywordflow">return</span> to_entry_object_vector&lt;K,V&gt;(proxy::IMapImpl::entry_set_data(to_data(predicate)));</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4d959cb8ae287036eb157b0247e15343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d959cb8ae287036eb157b0247e15343">&#9670;&nbsp;</a></span>entry_set() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;std::vector&lt;std::pair&lt;K, V&gt; &gt; &gt; hazelcast::client::imap::entry_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/dd0/classhazelcast_1_1client_1_1query_1_1paging__predicate.html">query::paging_predicate</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries the map based on the specified predicate and returns the matching entries. </p>
<p>Specified predicate runs on all members in parallel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>query criteria </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result entry vector of the query </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00763">763</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;                                                                                                    {</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;                predicate.set_iteration_type(query::iteration_type::ENTRY);</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;                <span class="keywordflow">return</span> entry_set_for_paging_predicate_data(</div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;                        protocol::codec::holder::paging_predicate_holder::of(predicate, serialization_service_)).then(</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;                        [=, &amp;predicate](boost::future&lt;std::pair&lt;EntryVector, query::anchor_data_list&gt;&gt; f) {</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;                    <span class="keyword">auto</span> result = f.get();</div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;                    predicate.set_anchor_data_list(std::move(result.second));</div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;                    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;entries_data = result.first;</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;                    std::vector&lt;std::pair&lt;K, V&gt;&gt; entries;</div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;                    entries.reserve(entries_data.size());</div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;                    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;e : entries_data) {</div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;                        entries.emplace_back(*to_object&lt;K&gt;(e.first), *to_object&lt;V&gt;(e.second));</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;                    }</div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;                    <span class="keywordflow">return</span> entries;</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;                });</div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ada8cb1823f33d095fb755533048954cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8cb1823f33d095fb755533048954cb">&#9670;&nbsp;</a></span>evict()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;bool&gt; hazelcast::client::imap::evict </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evicts the specified key from this map. </p>
<p>If a <code>MapStore</code> defined for this map, then the entry is not deleted from the underlying <code>MapStore</code>, evict only removes the entry from the memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to evict </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the key is evicted, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00566">566</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;                                                  {</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;                <span class="keywordflow">return</span> evict_internal(to_data(key));</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad4b59773d026cfa4690bf9f552a91d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b59773d026cfa4690bf9f552a91d45">&#9670;&nbsp;</a></span>execute_on_entries() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename ResultType , typename EntryProcessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;std::unordered_map&lt;K, boost::optional&lt;ResultType&gt; &gt; &gt; hazelcast::client::imap::execute_on_entries </td>
          <td>(</td>
          <td class="paramtype">const EntryProcessor &amp;&#160;</td>
          <td class="paramname"><em>entry_processor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the user defined EntryProcessor to the all entries in the map. </p>
<p>Returns the results mapped by each key in the map.</p>
<p>EntryProcessor should be serializable. Notice that map EntryProcessor runs on the nodes. Because of that, same class should be implemented in java side with same classId and factoryId.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultType</td><td>that entry processor will return </td></tr>
    <tr><td class="paramname">EntryProcessor</td><td>type of entry processor class </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entryProcessor</td><td>that will be applied </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00907">907</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;                                                                                                                                  {</div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;                <span class="keywordflow">return</span> to_object_map&lt;K, ResultType&gt;(proxy::IMapImpl::execute_on_entries_data(to_data(entry_processor)));</div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a403c102f0a90d4eefb4f7a361e20b9bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403c102f0a90d4eefb4f7a361e20b9bf">&#9670;&nbsp;</a></span>execute_on_entries() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename ResultType , typename EntryProcessor , typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;std::unordered_map&lt;K, boost::optional&lt;ResultType&gt; &gt; &gt; hazelcast::client::imap::execute_on_entries </td>
          <td>(</td>
          <td class="paramtype">const EntryProcessor &amp;&#160;</td>
          <td class="paramname"><em>entry_processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the user defined EntryProcessor to the all entries in the map. </p>
<p>Returns the results mapped by each key in the map.</p>
<p>EntryProcessor should be serializable. Notice that map EntryProcessor runs on the nodes. Because of that, same class should be implemented in java side with same classId and factoryId.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultType</td><td>that entry processor will return </td></tr>
    <tr><td class="paramname">EntryProcessor</td><td>type of entry processor class </td></tr>
    <tr><td class="paramname">predicate</td><td>The filter to apply for selecting the entries at the server side. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entryProcessor</td><td>that will be applied </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00927">927</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;                                                                                          {</div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;                <span class="keywordflow">return</span> to_object_map&lt;K, ResultType&gt;(proxy::IMapImpl::execute_on_entries_data(to_data(entry_processor),</div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;                                                                                 to_data(predicate)));</div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a789cc83402339e7ba178931c4706a37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789cc83402339e7ba178931c4706a37a">&#9670;&nbsp;</a></span>execute_on_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename ResultType , typename EntryProcessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;boost::optional&lt;ResultType&gt; &gt; hazelcast::client::imap::execute_on_key </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EntryProcessor &amp;&#160;</td>
          <td class="paramname"><em>entry_processor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the user defined EntryProcessor to the entry mapped by the key. </p>
<p>Returns the the ResultType which is result of the process() method of EntryProcessor.</p>
<p>EntryProcessor should be serializable. Notice that map EntryProcessor runs on the nodes. Because of that, same class should be implemented in java side with same classId and factoryId.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EntryProcessor</td><td>type of entry processor class </td></tr>
    <tr><td class="paramname">ResultType</td><td>that entry processor will return </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entryProcessor</td><td>that will be applied </td></tr>
    <tr><td class="paramname">key</td><td>of entry that entryProcessor will be applied on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result of entry process. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00855">855</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;                                                                                                                       {</div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;                <span class="keywordflow">return</span> to_object&lt;ResultType&gt;(execute_on_key_internal(to_data(key), to_data(entry_processor)));</div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8843a1a55921b7b7f9be5fea2e684e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8843a1a55921b7b7f9be5fea2e684e9f">&#9670;&nbsp;</a></span>execute_on_keys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename ResultType , typename EntryProcessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;std::unordered_map&lt;K, boost::optional&lt;ResultType&gt; &gt; &gt; hazelcast::client::imap::execute_on_keys </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_set&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EntryProcessor &amp;&#160;</td>
          <td class="paramname"><em>entry_processor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the user defined EntryProcessor to the entries mapped by the collection of keys. </p>
<p>Returns the results mapped by each key in the map.</p>
<p>Notice that map EntryProcessor runs on the nodes. Because of that, same class should be implemented in java side</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultType</td><td>that entry processor will return </td></tr>
    <tr><td class="paramname">EntryProcessor</td><td>type of entry processor class </td></tr>
    <tr><td class="paramname">keys</td><td>The keys for which the entry processor will be applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entryProcessor</td><td>that will be applied </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00889">889</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;                                                                                                    {</div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;                <span class="keywordflow">return</span> to_object_map&lt;K, ResultType&gt;(execute_on_keys_internal&lt;K, EntryProcessor&gt;(keys, entry_processor));</div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a508ccc6450a8a32b2893a2473915e975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508ccc6450a8a32b2893a2473915e975">&#9670;&nbsp;</a></span>force_unlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;void&gt; hazelcast::client::imap::force_unlock </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the lock for the specified key regardless of the lock owner. </p>
<p>It always successfully unlocks the key, never blocks and returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to lock. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00437">437</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;                                                         {</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;                <span class="keywordflow">return</span> to_void_future(proxy::IMapImpl::force_unlock(to_data(key)));</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a196974709c5c15d740ae3a9c54b8a175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196974709c5c15d740ae3a9c54b8a175">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;boost::optional&lt;V&gt; &gt; hazelcast::client::imap::get </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value value, if there is no mapping for key then returns boost::none. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00097">97</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;                                                            {</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;                <span class="keywordflow">return</span> to_object&lt;V&gt;(get_internal(to_data(key)));</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a473116a22e142d2387f8984ecb14f439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473116a22e142d2387f8984ecb14f439">&#9670;&nbsp;</a></span>get_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;std::unordered_map&lt;K, V&gt; &gt; hazelcast::client::imap::get_all </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_set&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the entries for the given keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>keys to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>map of entries </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00577">577</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;                                                                                         {</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;                <span class="keywordflow">if</span> (keys.empty()) {</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;                    <span class="keywordflow">return</span> boost::make_ready_future(std::unordered_map&lt;K, V&gt;());</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;                }</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160; </div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;                std::unordered_map&lt;int, std::vector&lt;serialization::pimpl::data&gt;&gt; partition_to_key_data;</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;                <span class="comment">// group the request per server</span></div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;key : keys) {</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;                    <span class="keyword">auto</span> key_data = to_data&lt;K&gt;(key);</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160; </div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;                    <span class="keyword">auto</span> partitionId = get_partition_id(key_data);</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;                    partition_to_key_data[partitionId].push_back(std::move(key_data));</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;                }</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160; </div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;                std::vector&lt;boost::future&lt;EntryVector&gt;&gt; futures;</div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;                futures.reserve(partition_to_key_data.size());</div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;entry : partition_to_key_data) {</div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;                    futures.push_back(get_all_internal(entry.first, entry.second));</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;                }</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160; </div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;                <span class="keywordflow">return</span> boost::when_all(futures.begin(), futures.end()).then(boost::launch::sync,</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;                                                                            [=](boost::future&lt;boost::csbl::vector&lt;boost::future&lt;EntryVector&gt;&gt;&gt; results_data) {</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;                                                                                std::unordered_map&lt;K, V&gt; result;</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;                                                                                <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;entryVectorFuture : results_data.get()) {</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;                                                                                    for (auto &amp;entry : entryVectorFuture.get()) {</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;                                                                                        auto val = to_object&lt;V&gt;(</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;                                                                                                entry.second);</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;                                                                                        <span class="comment">// it is guaranteed that all values are non-null</span></div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;                                                                                        assert(val.has_value());</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;                                                                                        result[to_object&lt;K&gt;(</div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;                                                                                                entry.first).value()] = std::move(</div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;                                                                                                val.value());</div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;                                                                                    }</div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;                                                                                }</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;                                                                                <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;                                                                            });</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adfca0a849a47026bafa0821d36c7d4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfca0a849a47026bafa0821d36c7d4c4">&#9670;&nbsp;</a></span>get_entry_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;boost::optional&lt;<a class="el" href="../../de/d4c/classhazelcast_1_1client_1_1entry__view.html">entry_view</a>&lt;K, V&gt; &gt; &gt; hazelcast::client::imap::get_entry_view </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <code>EntryView</code> for the specified key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>EntryView</code> of the specified key </dd></dl>
<dl class="section see"><dt>See also</dt><dd>EntryView </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00544">544</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;                                                                                      {</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;                <span class="keywordflow">return</span> proxy::IMapImpl::get_entry_view_data(to_data(key)).then([=] (boost::future&lt;boost::optional&lt;map::data_entry_view&gt;&gt; f) {</div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;                    <span class="keyword">auto</span> dataView = f.get();</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;                    <span class="keywordflow">if</span> (!dataView) {</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;                        <span class="keywordflow">return</span> boost::optional&lt;entry_view&lt;K, V&gt;&gt;();</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;                    }</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;                    <span class="keyword">auto</span> v = to_object&lt;V&gt;(dataView-&gt;get_value());</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;                    <span class="keywordflow">return</span> boost::make_optional(entry_view&lt;K, V&gt;(key, std::move(v).value(), *std::move(dataView)));</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;                });</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7c5eff52f4ddd34fb3ab1644f0fb0d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5eff52f4ddd34fb3ab1644f0fb0d03">&#9670;&nbsp;</a></span>get_local_map_stats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/dd6/classhazelcast_1_1client_1_1monitor_1_1local__map__stats.html">monitor::local_map_stats</a>&amp; hazelcast::client::imap::get_local_map_stats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns LocalMapStats for this map. </p>
<p>LocalMapStats is the statistics for the local portion of this distributed map and contains information such as ownedEntryCount backupEntryCount, lastUpdateTime, lockedEntryCount. </p>
<p>Since this stats are only for the local portion of this map, if you need the cluster-wide MapStats then you need to get the LocalMapStats from all members of the cluster and combine them.</p>
<dl class="section return"><dt>Returns</dt><dd>this map's local statistics. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00976">976</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;                                                          {</div>
<div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;                <span class="keywordflow">return</span> local_map_stats_;</div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa4148d5ddb38c82c60ce883fbc0c798c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4148d5ddb38c82c60ce883fbc0c798c">&#9670;&nbsp;</a></span>is_locked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;bool&gt; hazelcast::client::imap::is_locked </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the lock for the specified key. </p>
<p>If the lock is acquired then returns true, else false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to lock to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if lock is acquired, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00347">347</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;                                                      {</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;                <span class="keywordflow">return</span> proxy::IMapImpl::is_locked(to_data(key));</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a87847ae45caf088cf7b390121a9dc00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87847ae45caf088cf7b390121a9dc00d">&#9670;&nbsp;</a></span>key_set() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;std::vector&lt;K&gt; &gt; hazelcast::client::imap::key_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector clone of the keys contained in this map. </p>
<p>The vector is <b>NOT</b> backed by the map, so changes to the map are <b>NOT</b> reflected in the vector, and vice-versa.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector clone of the keys contained in this map </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00623">623</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;                                                {</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;                <span class="keywordflow">return</span> to_object_vector&lt;K&gt;(proxy::IMapImpl::key_set_data());</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad29c6b1f9b028c713ed14677552cf5bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29c6b1f9b028c713ed14677552cf5bd">&#9670;&nbsp;</a></span>key_set() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename P , class  = typename std::enable_if&lt;!std::is_base_of&lt;query::paging_predicate_marker, P&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;std::vector&lt;K&gt; &gt; hazelcast::client::imap::key_set </td>
          <td>(</td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries the map based on the specified predicate and returns the keys of matching entries. </p>
<p>Specified predicate runs on all members in parallel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>query criteria </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result key set of the query </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00639">639</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;                                                                  {</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;                <span class="keywordflow">return</span> to_object_vector&lt;K&gt;(proxy::IMapImpl::key_set_data(to_data(predicate)));</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7605507c000eb548a7ec5691561a06d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7605507c000eb548a7ec5691561a06d9">&#9670;&nbsp;</a></span>key_set() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;std::vector&lt;K&gt; &gt; hazelcast::client::imap::key_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/dd0/classhazelcast_1_1client_1_1query_1_1paging__predicate.html">query::paging_predicate</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queries the map based on the specified predicate and returns the keys of matching entries. </p>
<p>Specified predicate runs on all members in parallel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>query criteria </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result key set of the query </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00655">655</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;                                                                                      {</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;                predicate.set_iteration_type(query::iteration_type::KEY);</div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;                <span class="keywordflow">return</span> key_set_for_paging_predicate_data(</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;                        protocol::codec::holder::paging_predicate_holder::of(predicate, serialization_service_)).then(</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;                        [=, &amp;predicate](</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;                                boost::future&lt;std::pair&lt;std::vector&lt;serialization::pimpl::data&gt;, query::anchor_data_list&gt;&gt; f) {</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;                    <span class="keyword">auto</span> result = f.get();</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;                    predicate.set_anchor_data_list(std::move(result.second));</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;                    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;entries = result.first;</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;                    std::vector&lt;K&gt; <a class="code" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a6f474d6313fab3dc603fce4b8cef76a5">values</a>;</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;                    <a class="code" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a6f474d6313fab3dc603fce4b8cef76a5">values</a>.reserve(entries.size());</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;                    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;e : entries) {</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;                        values.emplace_back(*to_object&lt;K&gt;(e));</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;                    }</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;                    <span class="keywordflow">return</span> <a class="code" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a6f474d6313fab3dc603fce4b8cef76a5">values</a>;</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;                });</div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;            }</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1imap_html_a6f474d6313fab3dc603fce4b8cef76a5"><div class="ttname"><a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a6f474d6313fab3dc603fce4b8cef76a5">hazelcast::client::imap::values</a></div><div class="ttdeci">boost::future&lt; std::vector&lt; V &gt; &gt; values()</div><div class="ttdoc">Returns a vector clone of the values contained in this map.</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dcf/imap_8h_source.html#l00681">imap.h:681</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a66fc7decd9267b75a4196ea04f33dba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66fc7decd9267b75a4196ea04f33dba8">&#9670;&nbsp;</a></span>lock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;void&gt; hazelcast::client::imap::lock </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquires the lock for the specified key. </p>
<p>If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired.</p>
<p>Scope of the lock is this map only. Acquired lock is only for the key in this map.</p>
<p>Locks are re-entrant so if the key is locked N times then it should be unlocked N times before another thread can acquire it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to lock. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00311">311</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                                                 {</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;                <span class="keywordflow">return</span> to_void_future(<a class="code" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a66fc7decd9267b75a4196ea04f33dba8">lock</a>(key, <a class="code" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a95567bf4dff1e6727e8a173186fcee7e">UNSET</a>));</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;            }</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1imap_html_a66fc7decd9267b75a4196ea04f33dba8"><div class="ttname"><a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a66fc7decd9267b75a4196ea04f33dba8">hazelcast::client::imap::lock</a></div><div class="ttdeci">boost::future&lt; void &gt; lock(const K &amp;key)</div><div class="ttdoc">Acquires the lock for the specified key.</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dcf/imap_8h_source.html#l00311">imap.h:311</a></div></div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1imap_html_a95567bf4dff1e6727e8a173186fcee7e"><div class="ttname"><a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a95567bf4dff1e6727e8a173186fcee7e">hazelcast::client::imap::UNSET</a></div><div class="ttdeci">static constexpr std::chrono::milliseconds UNSET</div><div class="ttdoc">Default TTL value of a record.</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dcf/imap_8h_source.html#l01004">imap.h:1004</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a075097cf4a98597cec81d2a4cf044302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075097cf4a98597cec81d2a4cf044302">&#9670;&nbsp;</a></span>lock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;void&gt; hazelcast::client::imap::lock </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>lease_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquires the lock for the specified key for the specified lease time. </p>
<p>After lease time, lock will be released..</p>
<p>If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until the lock has been acquired.</p>
<p>Scope of the lock is this map only. Acquired lock is only for the key in this map.</p>
<p>Locks are re-entrant so if the key is locked N times then it should be unlocked N times before another thread can acquire it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to lock. </td></tr>
    <tr><td class="paramname">leaseTime</td><td>time to wait before releasing the lock. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00334">334</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                                                                                   {</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                <span class="keywordflow">return</span> to_void_future(proxy::IMapImpl::lock(to_data(key), lease_time));</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3532ff9acd963a122578a20d2424645a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3532ff9acd963a122578a20d2424645a">&#9670;&nbsp;</a></span>put() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename R  = V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;boost::optional&lt;R&gt; &gt; hazelcast::client::imap::put </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>put new entry into map. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value. if there is no mapping for key, then returns boost::none. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00108">108</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;                                                                            {</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;                <span class="keywordflow">return</span> put&lt;K, V, R&gt;(key, value, <a class="code" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a95567bf4dff1e6727e8a173186fcee7e">UNSET</a>);</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a99083f1fadd0f1e690ed6c35fdda9fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99083f1fadd0f1e690ed6c35fdda9fa1">&#9670;&nbsp;</a></span>put() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename R  = V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;boost::optional&lt;R&gt; &gt; hazelcast::client::imap::put </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>ttl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts an entry into this map with a given ttl (time to live) value. </p>
<p>Entry will expire and get evicted after the ttl. If ttl is 0, then the entry lives forever.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the entry </td></tr>
    <tr><td class="paramname">value</td><td>value of the entry </td></tr>
    <tr><td class="paramname">ttl</td><td>maximum time for this entry to stay in the map. 0 means infinite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value. if there is no mapping for key, then returns boost::none. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00123">123</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;                                                                                                       {</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;                <span class="keywordflow">return</span> to_object&lt;R&gt;(put_internal(to_data(key), to_data(value), ttl));</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a87029736a712e347d1d4dbbb3bc83103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87029736a712e347d1d4dbbb3bc83103">&#9670;&nbsp;</a></span>put_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;void&gt; hazelcast::client::imap::put_all </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>entries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all of the mappings from the specified map to this map (optional operation). </p>
<p>The effect of this call is equivalent to that of calling put(k, v) on this map once for each mapping from key <code>k</code> to value <code>v</code> in the specified map. The behavior of this operation is undefined if the specified map is modified while the operation is in progress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entries</td><td>mappings to be stored in this map </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00943">943</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;                                                                             {</div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;                std::unordered_map&lt;int, EntryVector&gt; entryMap;</div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;entry : entries) {</div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;                    serialization::pimpl::data key_data = to_data(entry.first);</div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;                    <span class="keywordtype">int</span> partitionId = get_partition_id(key_data);</div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;                    entryMap[partitionId].push_back(std::make_pair(key_data, to_data(entry.second)));</div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;                }</div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160; </div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;                std::vector&lt;boost::future&lt;protocol::ClientMessage&gt;&gt; resultFutures;</div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;&amp;partitionEntry : entryMap) {</div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;                    <span class="keyword">auto</span> partitionId = partitionEntry.first;</div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;                    resultFutures.push_back(put_all_internal(partitionId, std::move(partitionEntry.second)));</div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;                }</div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;                <span class="keywordflow">return</span> boost::when_all(resultFutures.begin(), resultFutures.end()).then(boost::launch::sync,</div>
<div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;                                                                                        [](boost::future&lt;boost::csbl::vector&lt;boost::future&lt;protocol::ClientMessage&gt;&gt;&gt; futures) {</div>
<div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;                                                                                            <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;f : futures.get()) {</div>
<div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;                                                                                                f.get();</div>
<div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;                                                                                            }</div>
<div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;                                                                                        });</div>
<div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad2ce6bebc47e9e4603328f2aea4edad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ce6bebc47e9e4603328f2aea4edad0">&#9670;&nbsp;</a></span>put_if_absent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename R  = V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;boost::optional&lt;V&gt; &gt; hazelcast::client::imap::put_if_absent </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts an entry into this map, if the specified key is not already associated with a value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated </td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value, if there is no mapping for key then returns boost::none. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00226">226</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;                                                                                      {</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#ad2ce6bebc47e9e4603328f2aea4edad0">put_if_absent</a>(key, value, <a class="code" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a95567bf4dff1e6727e8a173186fcee7e">UNSET</a>);</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;            }</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1imap_html_ad2ce6bebc47e9e4603328f2aea4edad0"><div class="ttname"><a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#ad2ce6bebc47e9e4603328f2aea4edad0">hazelcast::client::imap::put_if_absent</a></div><div class="ttdeci">boost::future&lt; boost::optional&lt; V &gt; &gt; put_if_absent(const K &amp;key, const V &amp;value)</div><div class="ttdoc">Puts an entry into this map, if the specified key is not already associated with a value.</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dcf/imap_8h_source.html#l00226">imap.h:226</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0336e9273ef5989a55e2a4d5f65cee6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0336e9273ef5989a55e2a4d5f65cee6e">&#9670;&nbsp;</a></span>put_if_absent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename R  = V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;boost::optional&lt;V&gt; &gt; hazelcast::client::imap::put_if_absent </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>ttl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts an entry into this map with a given ttl (time to live) value if the specified key is not already associated with a value. </p>
<p>Entry will expire and get evicted after the ttl.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the entry </td></tr>
    <tr><td class="paramname">value</td><td>value of the entry </td></tr>
    <tr><td class="paramname">ttl</td><td>maximum time for this entry to stay in the map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value of the entry, if there is no mapping for key then returns boost::none. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00242">242</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;                                                                                                                 {</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;                <span class="keywordflow">return</span> to_object&lt;R&gt;(put_if_absent_internal(to_data(key), to_data(value), ttl));</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af492c1a39ccb47bd6559be789bc979ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af492c1a39ccb47bd6559be789bc979ed">&#9670;&nbsp;</a></span>put_transient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;void&gt; hazelcast::client::imap::put_transient </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>ttl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as put(K, V, int64_t, TimeUnit) but MapStore, if defined, will not be called to store/persist the entry. </p>
<p>If ttl is 0, then the entry lives forever.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the entry </td></tr>
    <tr><td class="paramname">value</td><td>value of the entry </td></tr>
    <tr><td class="paramname">ttl</td><td>maximum time for this entry to stay in the map in milliseconds, 0 means infinite. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00213">213</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                                                                                                     {</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                <span class="keywordflow">return</span> to_void_future(try_put_transient_internal(to_data(key), to_data(value), ttl));</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a36465e654ae517bd6e2f1c361e0a35d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36465e654ae517bd6e2f1c361e0a35d7">&#9670;&nbsp;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;boost::optional&lt;V&gt; &gt; hazelcast::client::imap::remove </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>remove entry form map </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value. if there is no mapping for key then returns boost::none. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00133">133</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;                                                               {</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                <span class="keywordflow">return</span> to_object&lt;V&gt;(remove_internal(to_data(key)));</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d01166880c3404117bce1c35784f115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d01166880c3404117bce1c35784f115">&#9670;&nbsp;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;bool&gt; hazelcast::client::imap::remove </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>removes entry from map if there is an entry with same key and value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the entry to be removed </td></tr>
    <tr><td class="paramname">value</td><td>value of the entry to be removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entry with key and value exists and removed, false otherwise </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00144">144</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;                                                                   {</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;                <span class="keywordflow">return</span> remove_internal(to_data(key), to_data(value));</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a262eab235be3b3e6325c771306879536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262eab235be3b3e6325c771306879536">&#9670;&nbsp;</a></span>remove_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;void&gt; hazelcast::client::imap::remove_all </td>
          <td>(</td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all entries which match with the supplied predicate. </p>
<p>If this map has index, matching entries will be found via index search, otherwise they will be found by full-scan.</p>
<p>Note that calling this method also removes all entries from callers Near Cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>matching entries with this predicate will be removed from this map </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00158">158</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;                                                             {</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                <span class="keywordflow">return</span> to_void_future(remove_all_internal(to_data&lt;P&gt;(predicate)));</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4f78e949d6b15f2ccf917978889bd6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f78e949d6b15f2ccf917978889bd6e3">&#9670;&nbsp;</a></span>replace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename N  = V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;bool&gt; hazelcast::client::imap::replace </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const N &amp;&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the entry for a key only if currently mapped to a given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is associated </td></tr>
    <tr><td class="paramname">oldValue</td><td>value expected to be associated with the specified key </td></tr>
    <tr><td class="paramname">newValue</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the value was replaced </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00254">254</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;                                                                                            {</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;                <span class="keywordflow">return</span> replace_if_same_internal(to_data(key), to_data(old_value), to_data(new_value));</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a28a1c366c91a4d0e00cf449e8f56785f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a1c366c91a4d0e00cf449e8f56785f">&#9670;&nbsp;</a></span>replace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename R  = V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;boost::optional&lt;R&gt; &gt; hazelcast::client::imap::replace </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the entry for a key only if currently mapped to some value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is associated </td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value of the entry, if there is no mapping for key then returns boost::none. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00266">266</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                                                                                {</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;                <span class="keywordflow">return</span> to_object&lt;R&gt;(replace_internal(to_data(key), to_data(value)));</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a379a3c77d126e3af456f344ec0e84bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379a3c77d126e3af456f344ec0e84bcf">&#9670;&nbsp;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename R  = V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;void&gt; hazelcast::client::imap::set </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts an entry into this map. </p>
<p>Similar to put operation except that set doesn't return the old value which is more efficient. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td></td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00278">278</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;                                                                {</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;                <span class="keywordflow">return</span> to_void_future(<a class="code" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a379a3c77d126e3af456f344ec0e84bcf">set</a>(key, value, <a class="code" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a95567bf4dff1e6727e8a173186fcee7e">UNSET</a>));</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;            }</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1imap_html_a379a3c77d126e3af456f344ec0e84bcf"><div class="ttname"><a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a379a3c77d126e3af456f344ec0e84bcf">hazelcast::client::imap::set</a></div><div class="ttdeci">boost::future&lt; void &gt; set(const K &amp;key, const V &amp;value)</div><div class="ttdoc">Puts an entry into this map.</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dcf/imap_8h_source.html#l00278">imap.h:278</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aea7a799390c27a6bb05691b35b390f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7a799390c27a6bb05691b35b390f14">&#9670;&nbsp;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;void&gt; hazelcast::client::imap::set </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>ttl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puts an entry into this map. </p>
<p>Similar to put operation except that set doesn't return the old value which is more efficient. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is associated </td></tr>
    <tr><td class="paramname">value</td><td></td></tr>
    <tr><td class="paramname">ttl</td><td>maximum time in milliseconds for this entry to stay in the map 0 means infinite. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00292">292</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;                                                                                           {</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;                <span class="keywordflow">return</span> to_void_future(set_internal(to_data(key), to_data(value), ttl));</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2d262dbcfa8f977d3f9f4d2eaa8acd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d262dbcfa8f977d3f9f4d2eaa8acd48">&#9670;&nbsp;</a></span>submit_to_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename ResultType , typename EntryProcessor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;boost::optional&lt;ResultType&gt; &gt; hazelcast::client::imap::submit_to_key </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EntryProcessor &amp;&#160;</td>
          <td class="paramname"><em>entry_processor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the user defined EntryProcessor to the entry mapped by the key. </p>
<p>Returns immediately with a Future representing that task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to be processed </td></tr>
    <tr><td class="paramname">entryProcessor</td><td>processor to process the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future from which the result of the operation can be retrieved. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00871">871</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;                                                                               {</div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;                <span class="keywordflow">return</span> to_object&lt;ResultType&gt;(submit_to_key_internal(to_data(key), to_data(entry_processor)));</div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad94a5c0fb7f03790a914d97a58a7ea18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94a5c0fb7f03790a914d97a58a7ea18">&#9670;&nbsp;</a></span>try_lock() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;bool&gt; hazelcast::client::imap::try_lock </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to acquire the lock for the specified key. </p>
<p>If the lock is not available then the current thread doesn't wait and returns false immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if lock is acquired, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00361">361</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;                                                     {</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;                <span class="keywordflow">return</span> <a class="code" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#ad94a5c0fb7f03790a914d97a58a7ea18">try_lock</a>(key, std::chrono::milliseconds(0));</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;            }</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1imap_html_ad94a5c0fb7f03790a914d97a58a7ea18"><div class="ttname"><a href="../../de/d73/classhazelcast_1_1client_1_1imap.html#ad94a5c0fb7f03790a914d97a58a7ea18">hazelcast::client::imap::try_lock</a></div><div class="ttdeci">boost::future&lt; bool &gt; try_lock(const K &amp;key)</div><div class="ttdoc">Tries to acquire the lock for the specified key.</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/dcf/imap_8h_source.html#l00361">imap.h:361</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad2aa45add90c27f52135d0eedec1e5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2aa45add90c27f52135d0eedec1e5a2">&#9670;&nbsp;</a></span>try_lock() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;bool&gt; hazelcast::client::imap::try_lock </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to acquire the lock for the specified key. </p>
<p>If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens: </p><ul>
<li>
The lock is acquired by the current thread; or </li>
<li>
The specified waiting time elapses </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to lock in this map </td></tr>
    <tr><td class="paramname">timeout</td><td>maximum time in milliseconds to wait for the lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the lock was acquired and <code>false</code> if the waiting time elapsed before the lock was acquired. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00382">382</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;                                                                                    {</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;                <span class="keywordflow">return</span> proxy::IMapImpl::try_lock(to_data(key), timeout);</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a07959d4b672498324db81018a59236ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07959d4b672498324db81018a59236ad">&#9670;&nbsp;</a></span>try_lock() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;bool&gt; hazelcast::client::imap::try_lock </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>lease_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to acquire the lock for the specified key for the specified lease time. </p>
<p>After lease time, the lock will be released. </p>
<p>If the lock is not available then the current thread becomes disabled for thread scheduling purposes and lies dormant until one of two things happens: </p><ul>
<li>
The lock is acquired by the current thread; or </li>
<li>
The specified waiting time elapses </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to lock in this map </td></tr>
    <tr><td class="paramname">timeout</td><td>maximum time to wait for the lock </td></tr>
    <tr><td class="paramname">leaseTime</td><td>time to wait before releasing the lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the lock was acquired and <code>false</code> if the waiting time elapsed before the lock was acquired. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00406">406</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;                                                                                                                      {</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;                <span class="keywordflow">return</span> proxy::IMapImpl::try_lock(to_data(key), timeout, lease_time);</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adaa3acffaef927a2ce45842f961390e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa3acffaef927a2ce45842f961390e8">&#9670;&nbsp;</a></span>try_put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;bool&gt; hazelcast::client::imap::try_put </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to put the given key, value into this map within specified timeout value. </p>
<p>If this method returns false, it means that the caller thread couldn't acquire the lock for the key within timeout duration, thus put operation is not successful.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the entry </td></tr>
    <tr><td class="paramname">value</td><td>value of the entry </td></tr>
    <tr><td class="paramname">timeout</td><td>maximum time to wait </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the put is successful, <code>false</code> otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00199">199</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;                                                                                                   {</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;                <span class="keywordflow">return</span> try_put_internal(to_data(key), to_data(value), timeout);</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a64906b278142579ffffaa423672f0945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64906b278142579ffffaa423672f0945">&#9670;&nbsp;</a></span>try_remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;bool&gt; hazelcast::client::imap::try_remove </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to remove the entry with the given key from this map within specified timeout value. </p>
<p>If the key is already locked by another thread and/or member, then this operation will wait timeout amount for acquiring the lock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key of the entry </td></tr>
    <tr><td class="paramname">timeout</td><td>maximum time to wait for acquiring the lock for the key </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00182">182</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;                                                                                      {</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;                <span class="keywordflow">return</span> try_remove_internal(to_data(key), timeout);</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aee14c9bbb94ec14055cf5ee6a93f1d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee14c9bbb94ec14055cf5ee6a93f1d06">&#9670;&nbsp;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;void&gt; hazelcast::client::imap::unlock </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the lock for the specified key. </p>
<p>It never blocks and returns immediately.</p>
<p>If the current thread is the holder of this lock then the hold count is decremented. If the hold count is now zero then the lock is released. If the current thread is not the holder of this lock then illegal_monitor_state is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key to lock. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">illegal_monitor_state</td><td>if the current thread does not hold this lock MTODO </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00424">424</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;                                                   {</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;                <span class="keywordflow">return</span> to_void_future(proxy::IMapImpl::unlock(to_data(key)));</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6f474d6313fab3dc603fce4b8cef76a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f474d6313fab3dc603fce4b8cef76a5">&#9670;&nbsp;</a></span>values() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;std::vector&lt;V&gt; &gt; hazelcast::client::imap::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector clone of the values contained in this map. </p>
<p>The vector is <b>NOT</b> backed by the map, so changes to the map are <b>NOT</b> reflected in the collection, and vice-versa.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector clone of the values contained in this map </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00681">681</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;                                               {</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;                <span class="keywordflow">return</span> to_object_vector&lt;V&gt;(proxy::IMapImpl::values_data());</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2a43a25ce75e75067affa57cedb46774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a43a25ce75e75067affa57cedb46774">&#9670;&nbsp;</a></span>values() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V , typename P , class  = typename std::enable_if&lt;!std::is_base_of&lt;query::paging_predicate_marker, P&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;std::vector&lt;V&gt; &gt; hazelcast::client::imap::values </td>
          <td>(</td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector clone of the values contained in this map. </p>
<p>The vector is <b>NOT</b> backed by the map, so changes to the map are <b>NOT</b> reflected in the collection, and vice-versa.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>the criteria for values to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector clone of the values contained in this map </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00694">694</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;                                                                 {</div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;                <span class="keywordflow">return</span> to_object_vector&lt;V&gt;(proxy::IMapImpl::values_data(to_data(predicate)));</div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a85bd6056976dcc6e66d612f2271c9bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85bd6056976dcc6e66d612f2271c9bc1">&#9670;&nbsp;</a></span>values() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;std::vector&lt;V&gt; &gt; hazelcast::client::imap::values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d6/dd0/classhazelcast_1_1client_1_1query_1_1paging__predicate.html">query::paging_predicate</a>&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector clone of the values contained in this map. </p>
<p>The vector is <b>NOT</b> backed by the map, so changes to the map are <b>NOT</b> reflected in the collection, and vice-versa.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>the criteria for values to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector clone of the values contained in this map </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d4/dcf/imap_8h_source.html#l00708">708</a> of file <a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;                                                                                     {</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;                predicate.set_iteration_type(query::iteration_type::VALUE);</div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;                <span class="keywordflow">return</span> values_for_paging_predicate_data(</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;                        protocol::codec::holder::paging_predicate_holder::of(predicate, serialization_service_)).then(</div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;                        [=, &amp;predicate](boost::future&lt;std::pair&lt;std::vector&lt;serialization::pimpl::data&gt;, query::anchor_data_list&gt;&gt; f) {</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;                    <span class="keyword">auto</span> result = f.get();</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;                    predicate.set_anchor_data_list(std::move(result.second));</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;                    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;entries = result.first;</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;                    std::vector&lt;V&gt; <a class="code" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a6f474d6313fab3dc603fce4b8cef76a5">values</a>;</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;                    <a class="code" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a6f474d6313fab3dc603fce4b8cef76a5">values</a>.reserve(entries.size());</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;                    <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;e : entries) {</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;                        values.emplace_back(*to_object&lt;V&gt;(e));</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;                    }</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;                    <span class="keywordflow">return</span> <a class="code" href="../../de/d73/classhazelcast_1_1client_1_1imap.html#a6f474d6313fab3dc603fce4b8cef76a5">values</a>;</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;                });</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>hazelcast/include/hazelcast/client/<a class="el" href="../../d4/dcf/imap_8h_source.html">imap.h</a></li>
<li>hazelcast/src/hazelcast/client/<a class="el" href="../../da/dbe/proxy_8cpp_source.html">proxy.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>hazelcast</b></li><li class="navelem"><b>client</b></li><li class="navelem"><a class="el" href="../../de/d73/classhazelcast_1_1client_1_1imap.html">imap</a></li>
    <li class="footer">Generated on Wed May 26 2021 14:49:30 for Hazelcast C++ Client by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
