<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hazelcast C++ Client: hazelcast::client::serialization::compact::compact_reader Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../IMDG_blue_logo_square_RGB-dark_200px.png"/></td>
  <td id="projectalign">
   <div id="projectname">Hazelcast C++ Client
   </div>
   <div id="projectbrief">Hazelcast C++ Client Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d5/d7d/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">hazelcast::client::serialization::compact::compact_reader Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Provides means of reading compact serialized fields from the binary data.  
 <a href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../de/d0a/compact_8h_source.html">compact.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0677227e93a9b14581bb1f8720926bb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/dda/namespacehazelcast_1_1client_1_1serialization.html#a248143625dedc7b2c97fec8200c480f5">field_kind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a0677227e93a9b14581bb1f8720926bb4">get_field_kind</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a0677227e93a9b14581bb1f8720926bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the kind of the field for the given field name.  <br /></td></tr>
<tr class="separator:a0677227e93a9b14581bb1f8720926bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294f7d02d9807cd8225e9f512fd1c642"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a294f7d02d9807cd8225e9f512fd1c642">read_boolean</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a294f7d02d9807cd8225e9f512fd1c642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a boolean.  <br /></td></tr>
<tr class="separator:a294f7d02d9807cd8225e9f512fd1c642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0060a3cdb2514c61ac6c88bda056b5"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#aaa0060a3cdb2514c61ac6c88bda056b5">read_int8</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:aaa0060a3cdb2514c61ac6c88bda056b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an 8-bit two's complement signed integer.  <br /></td></tr>
<tr class="separator:aaa0060a3cdb2514c61ac6c88bda056b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8591fbad80871e5f2ffeee22e297ba8"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#ac8591fbad80871e5f2ffeee22e297ba8">read_int16</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:ac8591fbad80871e5f2ffeee22e297ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 16-bit two's complement signed integer.  <br /></td></tr>
<tr class="separator:ac8591fbad80871e5f2ffeee22e297ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a45e5606a8a7e74cae8f42bc530f96e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a0a45e5606a8a7e74cae8f42bc530f96e">read_int32</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a0a45e5606a8a7e74cae8f42bc530f96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 32-bit two's complement signed integer.  <br /></td></tr>
<tr class="separator:a0a45e5606a8a7e74cae8f42bc530f96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf4c977e08236660627a5585a99807a"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#aaaf4c977e08236660627a5585a99807a">read_int64</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:aaaf4c977e08236660627a5585a99807a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 64-bit two's complement signed integer.  <br /></td></tr>
<tr class="separator:aaaf4c977e08236660627a5585a99807a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7f893fa35796b004c9933b2280308c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a2a7f893fa35796b004c9933b2280308c">read_float32</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a2a7f893fa35796b004c9933b2280308c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 32-bit IEEE 754 floating point number.  <br /></td></tr>
<tr class="separator:a2a7f893fa35796b004c9933b2280308c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c63f5ea283c4f5fe31b7c860834a005"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a7c63f5ea283c4f5fe31b7c860834a005">read_float64</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a7c63f5ea283c4f5fe31b7c860834a005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 64-bit IEEE 754 floating point number.  <br /></td></tr>
<tr class="separator:a7c63f5ea283c4f5fe31b7c860834a005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a1ad41ba261f015276987bde0071d0"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#af1a1ad41ba261f015276987bde0071d0">read_string</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:af1a1ad41ba261f015276987bde0071d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an UTF-8 encoded string.  <br /></td></tr>
<tr class="separator:af1a1ad41ba261f015276987bde0071d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c62b05c9d993d94c34da460d2312de"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a67c62b05c9d993d94c34da460d2312de">read_decimal</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a67c62b05c9d993d94c34da460d2312de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an arbitrary precision and scale floating point number.  <br /></td></tr>
<tr class="separator:a67c62b05c9d993d94c34da460d2312de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5ce4b3546d4ec75120586c1c6a456c"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a3b5ce4b3546d4ec75120586c1c6a456c">read_time</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a3b5ce4b3546d4ec75120586c1c6a456c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a time consisting of hour, minute, second, and nano seconds.  <br /></td></tr>
<tr class="separator:a3b5ce4b3546d4ec75120586c1c6a456c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c337d0fefd6f768ecbf7d8bd6d1d92"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#ae4c337d0fefd6f768ecbf7d8bd6d1d92">read_date</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:ae4c337d0fefd6f768ecbf7d8bd6d1d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a date consisting of year, month, and day.  <br /></td></tr>
<tr class="separator:ae4c337d0fefd6f768ecbf7d8bd6d1d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53251772efaa15d183f5b7858c755190"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a53251772efaa15d183f5b7858c755190">read_timestamp</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a53251772efaa15d183f5b7858c755190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a timestamp consisting of date and time.  <br /></td></tr>
<tr class="separator:a53251772efaa15d183f5b7858c755190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b18da103cebe13f3b3e4fc690f020a0"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a6b18da103cebe13f3b3e4fc690f020a0">read_timestamp_with_timezone</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a6b18da103cebe13f3b3e4fc690f020a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a timestamp with timezone consisting of date, time and timezone offset.  <br /></td></tr>
<tr class="separator:a6b18da103cebe13f3b3e4fc690f020a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0c32d153cbb38bb7e70c6bc6537e94"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1b0c32d153cbb38bb7e70c6bc6537e94"><td class="memTemplItemLeft" align="right" valign="top">boost::optional&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a1b0c32d153cbb38bb7e70c6bc6537e94">read_compact</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a1b0c32d153cbb38bb7e70c6bc6537e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a compact object.  <br /></td></tr>
<tr class="separator:a1b0c32d153cbb38bb7e70c6bc6537e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f787db652270da08b511ea96b5d632"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a39f787db652270da08b511ea96b5d632">read_array_of_boolean</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a39f787db652270da08b511ea96b5d632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of booleans.  <br /></td></tr>
<tr class="separator:a39f787db652270da08b511ea96b5d632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67b05f9db27af01618ca46cdb494dcf"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; int8_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#aa67b05f9db27af01618ca46cdb494dcf">read_array_of_int8</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:aa67b05f9db27af01618ca46cdb494dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of 8-bit two's complement signed integers.  <br /></td></tr>
<tr class="separator:aa67b05f9db27af01618ca46cdb494dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e50c25396156ee32010521f90d3abf"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; int16_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a11e50c25396156ee32010521f90d3abf">read_array_of_int16</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a11e50c25396156ee32010521f90d3abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of 16-bit two's complement signed integers.  <br /></td></tr>
<tr class="separator:a11e50c25396156ee32010521f90d3abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9789119f2d175212600bdcbe4a9ec99"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; int32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#af9789119f2d175212600bdcbe4a9ec99">read_array_of_int32</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:af9789119f2d175212600bdcbe4a9ec99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of 32-bit two's complement signed integers.  <br /></td></tr>
<tr class="separator:af9789119f2d175212600bdcbe4a9ec99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e6f15a0d0cb98d4d1ae70fbe34aa17"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a65e6f15a0d0cb98d4d1ae70fbe34aa17">read_array_of_int64</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a65e6f15a0d0cb98d4d1ae70fbe34aa17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of 64-bit two's complement signed integers.  <br /></td></tr>
<tr class="separator:a65e6f15a0d0cb98d4d1ae70fbe34aa17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba77c84e0571ff985a4dc1ee136c2a7b"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; float &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#aba77c84e0571ff985a4dc1ee136c2a7b">read_array_of_float32</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:aba77c84e0571ff985a4dc1ee136c2a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of 32-bit IEEE 754 floating point numbers.  <br /></td></tr>
<tr class="separator:aba77c84e0571ff985a4dc1ee136c2a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf31270e5ec36f299bb219fb20101d59"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#adf31270e5ec36f299bb219fb20101d59">read_array_of_float64</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:adf31270e5ec36f299bb219fb20101d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of 64-bit IEEE 754 floating point numbers.  <br /></td></tr>
<tr class="separator:adf31270e5ec36f299bb219fb20101d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d653534706eef2f3117bc1b470f20b"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; std::string &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a64d653534706eef2f3117bc1b470f20b">read_array_of_string</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a64d653534706eef2f3117bc1b470f20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of UTF-8 encoded strings.  <br /></td></tr>
<tr class="separator:a64d653534706eef2f3117bc1b470f20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a15274fc5d92c8e65b19a3a7665c40"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a80a15274fc5d92c8e65b19a3a7665c40">read_array_of_decimal</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a80a15274fc5d92c8e65b19a3a7665c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of arbitrary precision and scale floating point numbers.  <br /></td></tr>
<tr class="separator:a80a15274fc5d92c8e65b19a3a7665c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112debd7db56971ffc4c7945f9ff85be"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a112debd7db56971ffc4c7945f9ff85be">read_array_of_time</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a112debd7db56971ffc4c7945f9ff85be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of times consisting of hour, minute, second, and nanoseconds.  <br /></td></tr>
<tr class="separator:a112debd7db56971ffc4c7945f9ff85be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c97c23afe499ec976de41210e77c4b"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#aa0c97c23afe499ec976de41210e77c4b">read_array_of_date</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:aa0c97c23afe499ec976de41210e77c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of dates consisting of year, month, and day.  <br /></td></tr>
<tr class="separator:aa0c97c23afe499ec976de41210e77c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb765210798dd5e68e54ed3fa4e86dfb"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#aeb765210798dd5e68e54ed3fa4e86dfb">read_array_of_timestamp</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:aeb765210798dd5e68e54ed3fa4e86dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of timestamps consisting of date and time.  <br /></td></tr>
<tr class="separator:aeb765210798dd5e68e54ed3fa4e86dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fe23b4179411591f0d9b4f2a0bf297"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a11fe23b4179411591f0d9b4f2a0bf297">read_array_of_timestamp_with_timezone</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a11fe23b4179411591f0d9b4f2a0bf297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of timestamps with timezone consisting of date, time and timezone offset.  <br /></td></tr>
<tr class="separator:a11fe23b4179411591f0d9b4f2a0bf297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fded17f223f13b4a5591ce6dba82b6e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0fded17f223f13b4a5591ce6dba82b6e"><td class="memTemplItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a0fded17f223f13b4a5591ce6dba82b6e">read_array_of_compact</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a0fded17f223f13b4a5591ce6dba82b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of compact objects.  <br /></td></tr>
<tr class="separator:a0fded17f223f13b4a5591ce6dba82b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd605dfa1e77c458328d72285d72c14e"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#acd605dfa1e77c458328d72285d72c14e">read_nullable_boolean</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:acd605dfa1e77c458328d72285d72c14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nullable boolean.  <br /></td></tr>
<tr class="separator:acd605dfa1e77c458328d72285d72c14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f45c34bb28c2af0ba65357d29e5c2d"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#ae2f45c34bb28c2af0ba65357d29e5c2d">read_nullable_int8</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:ae2f45c34bb28c2af0ba65357d29e5c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nullable 8-bit two's complement signed integer.  <br /></td></tr>
<tr class="separator:ae2f45c34bb28c2af0ba65357d29e5c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a713300694369c456cc71be519d6fe6"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int16_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a6a713300694369c456cc71be519d6fe6">read_nullable_int16</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a6a713300694369c456cc71be519d6fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nullable 16-bit two's complement signed integer.  <br /></td></tr>
<tr class="separator:a6a713300694369c456cc71be519d6fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c98def2db8d4b8c0fa68eed73833811"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a7c98def2db8d4b8c0fa68eed73833811">read_nullable_int32</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a7c98def2db8d4b8c0fa68eed73833811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nullable 32-bit two's complement signed integer.  <br /></td></tr>
<tr class="separator:a7c98def2db8d4b8c0fa68eed73833811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3351fd3f6388c8d58801ffe2eb911c49"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a3351fd3f6388c8d58801ffe2eb911c49">read_nullable_int64</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a3351fd3f6388c8d58801ffe2eb911c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nullable 64-bit two's complement signed integer.  <br /></td></tr>
<tr class="separator:a3351fd3f6388c8d58801ffe2eb911c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499751677405dddf21a6b5b56582b0d4"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a499751677405dddf21a6b5b56582b0d4">read_nullable_float32</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a499751677405dddf21a6b5b56582b0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nullable 32-bit IEEE 754 floating point number.  <br /></td></tr>
<tr class="separator:a499751677405dddf21a6b5b56582b0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba62bcf0175f01ae4cf3ca68d083c93b"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#aba62bcf0175f01ae4cf3ca68d083c93b">read_nullable_float64</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:aba62bcf0175f01ae4cf3ca68d083c93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nullable 64-bit IEEE 754 floating point number.  <br /></td></tr>
<tr class="separator:aba62bcf0175f01ae4cf3ca68d083c93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2eef53f4bfc04c61bd285cf6d6645a0"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#ad2eef53f4bfc04c61bd285cf6d6645a0">read_array_of_nullable_boolean</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:ad2eef53f4bfc04c61bd285cf6d6645a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nullable array of nullable booleans.  <br /></td></tr>
<tr class="separator:ad2eef53f4bfc04c61bd285cf6d6645a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81dd88579f37356d9169a57ee35e5af"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; int8_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#af81dd88579f37356d9169a57ee35e5af">read_array_of_nullable_int8</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:af81dd88579f37356d9169a57ee35e5af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nullable array of nullable 8-bit two's complement signed integers.  <br /></td></tr>
<tr class="separator:af81dd88579f37356d9169a57ee35e5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108d2c29f278d13ddd8468aa0755778c"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; int16_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a108d2c29f278d13ddd8468aa0755778c">read_array_of_nullable_int16</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a108d2c29f278d13ddd8468aa0755778c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nullable array of nullable 16-bit two's complement signed integers.  <br /></td></tr>
<tr class="separator:a108d2c29f278d13ddd8468aa0755778c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1453eb890cb20d6981ae6b7ade28a1c"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; int32_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#ad1453eb890cb20d6981ae6b7ade28a1c">read_array_of_nullable_int32</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:ad1453eb890cb20d6981ae6b7ade28a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nullable array of nullable 32-bit two's complement signed integers.  <br /></td></tr>
<tr class="separator:ad1453eb890cb20d6981ae6b7ade28a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54ea218c8794dc47cf84d30c8a04a37"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; int64_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#ac54ea218c8794dc47cf84d30c8a04a37">read_array_of_nullable_int64</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:ac54ea218c8794dc47cf84d30c8a04a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nullable array of nullable 64-bit two's complement signed integers.  <br /></td></tr>
<tr class="separator:ac54ea218c8794dc47cf84d30c8a04a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042df2e4e1c35550626c59e9fa32c782"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; float &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a042df2e4e1c35550626c59e9fa32c782">read_array_of_nullable_float32</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a042df2e4e1c35550626c59e9fa32c782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nullable array of nullable 32-bit IEEE 754 floating point numbers.  <br /></td></tr>
<tr class="separator:a042df2e4e1c35550626c59e9fa32c782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f94e902221c863b7dac7e6a889ebf3b"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#a9f94e902221c863b7dac7e6a889ebf3b">read_array_of_nullable_float64</a> (const std::string &amp;field_name)</td></tr>
<tr class="memdesc:a9f94e902221c863b7dac7e6a889ebf3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nullable array of nullable 64-bit IEEE 754 floating point numbers.  <br /></td></tr>
<tr class="separator:a9f94e902221c863b7dac7e6a889ebf3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43224d1b457083d1af83a4c7ec3da9c"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad43224d1b457083d1af83a4c7ec3da9c"><td class="memTemplItemLeft" align="right" valign="top">boost::optional&lt; std::vector&lt; boost::optional&lt; bool &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html#ad43224d1b457083d1af83a4c7ec3da9c">read_primitive_array_as_nullable_array</a> (const pimpl::field_descriptor &amp;field_descriptor)</td></tr>
<tr class="separator:ad43224d1b457083d1af83a4c7ec3da9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:afb08ad68c589efdceaaa568291adc081"><td class="memItemLeft" align="right" valign="top"><a id="afb08ad68c589efdceaaa568291adc081" name="afb08ad68c589efdceaaa568291adc081"></a>
<a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html">compact_reader</a>&#160;</td><td class="memItemRight" valign="bottom"><b>pimpl::create_compact_reader</b> (pimpl::compact_stream_serializer &amp;compact_stream_serializer, <a class="el" href="../../de/d8b/classhazelcast_1_1client_1_1serialization_1_1object__data__input.html">object_data_input</a> &amp;<a class="el" href="../../de/d8b/classhazelcast_1_1client_1_1serialization_1_1object__data__input.html">object_data_input</a>, const pimpl::schema &amp;schema)</td></tr>
<tr class="separator:afb08ad68c589efdceaaa568291adc081"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides means of reading compact serialized fields from the binary data. </p>
<p>Read operations might throw hazelcast_serialization exception when a field with the given name is not found or there is a type mismatch. On such occasions, one might provide default values to the read methods to return it. Providing default values might be especially useful if the class might evolve in the future, either by adding or removing fields.</p>
<p>@Beta </p><dl class="section since"><dt>Since</dt><dd>5.1 </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../de/d0a/compact_8h_source.html#l00090">90</a> of file <a class="el" href="../../de/d0a/compact_8h_source.html">compact.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0677227e93a9b14581bb1f8720926bb4" name="a0677227e93a9b14581bb1f8720926bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0677227e93a9b14581bb1f8720926bb4">&#9670;&#160;</a></span>get_field_kind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/dda/namespacehazelcast_1_1client_1_1serialization.html#a248143625dedc7b2c97fec8200c480f5">field_kind</a> hazelcast::client::serialization::compact::compact_reader::get_field_kind </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the kind of the field for the given field name. </p>
<p>If the field with the given name does not exist, <code><a class="el" href="../../#a248143625dedc7b2c97fec8200c480f5ad07995fa8f4a3a019d134fcbfca4669a">field_kind#NOT_AVAILABLE</a></code> is returned. </p>
<p>This method can be used to check the existence of a field, which can be useful when the class is evolved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kind of the field </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02526">2526</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2527</span>{</div>
<div class="line"><span class="lineno"> 2528</span>    <span class="keyword">auto</span> descriptor = schema.get_field(field_name);</div>
<div class="line"><span class="lineno"> 2529</span> </div>
<div class="line"><span class="lineno"> 2530</span>    <span class="keywordflow">if</span> (!descriptor) {</div>
<div class="line"><span class="lineno"> 2531</span>        <span class="keywordflow">return</span> field_kind::NOT_AVAILABLE;</div>
<div class="line"><span class="lineno"> 2532</span>    }</div>
<div class="line"><span class="lineno"> 2533</span> </div>
<div class="line"><span class="lineno"> 2534</span>    <span class="keywordflow">return</span> descriptor-&gt;kind;</div>
<div class="line"><span class="lineno"> 2535</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a39f787db652270da08b511ea96b5d632" name="a39f787db652270da08b511ea96b5d632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f787db652270da08b511ea96b5d632">&#9670;&#160;</a></span>read_array_of_boolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; bool &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of booleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02627">2627</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2628</span>{</div>
<div class="line"><span class="lineno"> 2629</span>    <span class="keywordflow">return</span> read_array_of_primitive&lt;std::vector&lt;bool&gt;&gt;(</div>
<div class="line"><span class="lineno"> 2630</span>      field_name,</div>
<div class="line"><span class="lineno"> 2631</span>      field_kind::ARRAY_OF_BOOLEAN,</div>
<div class="line"><span class="lineno"> 2632</span>      field_kind::ARRAY_OF_NULLABLE_BOOLEAN,</div>
<div class="line"><span class="lineno"> 2633</span>      <span class="stringliteral">&quot;boolean&quot;</span>);</div>
<div class="line"><span class="lineno"> 2634</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0fded17f223f13b4a5591ce6dba82b6e" name="a0fded17f223f13b4a5591ce6dba82b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fded17f223f13b4a5591ce6dba82b6e">&#9670;&#160;</a></span>read_array_of_compact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; T &gt; &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_compact </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of compact objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d98/compact__impl_8h_source.html#l00401">401</a> of file <a class="el" href="../../dc/d98/compact__impl_8h_source.html">compact_impl.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  402</span>{</div>
<div class="line"><span class="lineno">  403</span>    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; descriptor =</div>
<div class="line"><span class="lineno">  404</span>      get_field_descriptor(field_name, field_kind::ARRAY_OF_COMPACT);</div>
<div class="line"><span class="lineno">  405</span>    <span class="keywordflow">return</span> read_array_of_variable_size&lt;T&gt;(descriptor);</div>
<div class="line"><span class="lineno">  406</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa0c97c23afe499ec976de41210e77c4b" name="aa0c97c23afe499ec976de41210e77c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c97c23afe499ec976de41210e77c4b">&#9670;&#160;</a></span>read_array_of_date()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_date </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of dates consisting of year, month, and day. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02720">2720</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2721</span>{</div>
<div class="line"><span class="lineno"> 2722</span>    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; descriptor =</div>
<div class="line"><span class="lineno"> 2723</span>      get_field_descriptor(field_name, field_kind::ARRAY_OF_DATE);</div>
<div class="line"><span class="lineno"> 2724</span>    <span class="keywordflow">return</span> read_array_of_variable_size&lt;local_date&gt;(descriptor);</div>
<div class="line"><span class="lineno"> 2725</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a80a15274fc5d92c8e65b19a3a7665c40" name="a80a15274fc5d92c8e65b19a3a7665c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80a15274fc5d92c8e65b19a3a7665c40">&#9670;&#160;</a></span>read_array_of_decimal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_decimal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of arbitrary precision and scale floating point numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02704">2704</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2705</span>{</div>
<div class="line"><span class="lineno"> 2706</span>    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; descriptor =</div>
<div class="line"><span class="lineno"> 2707</span>      get_field_descriptor(field_name, field_kind::ARRAY_OF_DECIMAL);</div>
<div class="line"><span class="lineno"> 2708</span>    <span class="keywordflow">return</span> read_array_of_variable_size&lt;big_decimal&gt;(descriptor);</div>
<div class="line"><span class="lineno"> 2709</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aba77c84e0571ff985a4dc1ee136c2a7b" name="aba77c84e0571ff985a4dc1ee136c2a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba77c84e0571ff985a4dc1ee136c2a7b">&#9670;&#160;</a></span>read_array_of_float32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; float &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of 32-bit IEEE 754 floating point numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02676">2676</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2677</span>{</div>
<div class="line"><span class="lineno"> 2678</span>    <span class="keywordflow">return</span> read_array_of_primitive&lt;std::vector&lt;float&gt;&gt;(</div>
<div class="line"><span class="lineno"> 2679</span>      field_name,</div>
<div class="line"><span class="lineno"> 2680</span>      field_kind::ARRAY_OF_FLOAT32,</div>
<div class="line"><span class="lineno"> 2681</span>      field_kind::ARRAY_OF_NULLABLE_FLOAT32,</div>
<div class="line"><span class="lineno"> 2682</span>      <span class="stringliteral">&quot;float32&quot;</span>);</div>
<div class="line"><span class="lineno"> 2683</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="adf31270e5ec36f299bb219fb20101d59" name="adf31270e5ec36f299bb219fb20101d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf31270e5ec36f299bb219fb20101d59">&#9670;&#160;</a></span>read_array_of_float64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; double &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of 64-bit IEEE 754 floating point numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02686">2686</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2687</span>{</div>
<div class="line"><span class="lineno"> 2688</span>    <span class="keywordflow">return</span> read_array_of_primitive&lt;std::vector&lt;double&gt;&gt;(</div>
<div class="line"><span class="lineno"> 2689</span>      field_name,</div>
<div class="line"><span class="lineno"> 2690</span>      field_kind::ARRAY_OF_FLOAT64,</div>
<div class="line"><span class="lineno"> 2691</span>      field_kind::ARRAY_OF_NULLABLE_FLOAT64,</div>
<div class="line"><span class="lineno"> 2692</span>      <span class="stringliteral">&quot;float64&quot;</span>);</div>
<div class="line"><span class="lineno"> 2693</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a11e50c25396156ee32010521f90d3abf" name="a11e50c25396156ee32010521f90d3abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e50c25396156ee32010521f90d3abf">&#9670;&#160;</a></span>read_array_of_int16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; int16_t &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of 16-bit two's complement signed integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02647">2647</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2648</span>{</div>
<div class="line"><span class="lineno"> 2649</span>    <span class="keywordflow">return</span> read_array_of_primitive&lt;std::vector&lt;int16_t&gt;&gt;(</div>
<div class="line"><span class="lineno"> 2650</span>      field_name,</div>
<div class="line"><span class="lineno"> 2651</span>      field_kind::ARRAY_OF_INT16,</div>
<div class="line"><span class="lineno"> 2652</span>      field_kind::ARRAY_OF_NULLABLE_INT16,</div>
<div class="line"><span class="lineno"> 2653</span>      <span class="stringliteral">&quot;int16&quot;</span>);</div>
<div class="line"><span class="lineno"> 2654</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af9789119f2d175212600bdcbe4a9ec99" name="af9789119f2d175212600bdcbe4a9ec99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9789119f2d175212600bdcbe4a9ec99">&#9670;&#160;</a></span>read_array_of_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; int32_t &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of 32-bit two's complement signed integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02657">2657</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2658</span>{</div>
<div class="line"><span class="lineno"> 2659</span>    <span class="keywordflow">return</span> read_array_of_primitive&lt;std::vector&lt;int32_t&gt;&gt;(</div>
<div class="line"><span class="lineno"> 2660</span>      field_name,</div>
<div class="line"><span class="lineno"> 2661</span>      field_kind::ARRAY_OF_INT32,</div>
<div class="line"><span class="lineno"> 2662</span>      field_kind::ARRAY_OF_NULLABLE_INT32,</div>
<div class="line"><span class="lineno"> 2663</span>      <span class="stringliteral">&quot;int32&quot;</span>);</div>
<div class="line"><span class="lineno"> 2664</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a65e6f15a0d0cb98d4d1ae70fbe34aa17" name="a65e6f15a0d0cb98d4d1ae70fbe34aa17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e6f15a0d0cb98d4d1ae70fbe34aa17">&#9670;&#160;</a></span>read_array_of_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; int64_t &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of 64-bit two's complement signed integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02666">2666</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2667</span>{</div>
<div class="line"><span class="lineno"> 2668</span>    <span class="keywordflow">return</span> read_array_of_primitive&lt;std::vector&lt;int64_t&gt;&gt;(</div>
<div class="line"><span class="lineno"> 2669</span>      field_name,</div>
<div class="line"><span class="lineno"> 2670</span>      field_kind::ARRAY_OF_INT64,</div>
<div class="line"><span class="lineno"> 2671</span>      field_kind::ARRAY_OF_NULLABLE_INT64,</div>
<div class="line"><span class="lineno"> 2672</span>      <span class="stringliteral">&quot;int64&quot;</span>);</div>
<div class="line"><span class="lineno"> 2673</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa67b05f9db27af01618ca46cdb494dcf" name="aa67b05f9db27af01618ca46cdb494dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67b05f9db27af01618ca46cdb494dcf">&#9670;&#160;</a></span>read_array_of_int8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; int8_t &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of 8-bit two's complement signed integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02637">2637</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2638</span>{</div>
<div class="line"><span class="lineno"> 2639</span>    <span class="keywordflow">return</span> read_array_of_primitive&lt;std::vector&lt;int8_t&gt;&gt;(</div>
<div class="line"><span class="lineno"> 2640</span>      field_name,</div>
<div class="line"><span class="lineno"> 2641</span>      field_kind::ARRAY_OF_INT8,</div>
<div class="line"><span class="lineno"> 2642</span>      field_kind::ARRAY_OF_NULLABLE_INT8,</div>
<div class="line"><span class="lineno"> 2643</span>      <span class="stringliteral">&quot;int8&quot;</span>);</div>
<div class="line"><span class="lineno"> 2644</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad2eef53f4bfc04c61bd285cf6d6645a0" name="ad2eef53f4bfc04c61bd285cf6d6645a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2eef53f4bfc04c61bd285cf6d6645a0">&#9670;&#160;</a></span>read_array_of_nullable_boolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; bool &gt; &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_nullable_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nullable array of nullable booleans. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02794">2794</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2795</span>{</div>
<div class="line"><span class="lineno"> 2796</span>    <span class="keywordflow">return</span> read_array_of_nullable&lt;bool&gt;(field_name,</div>
<div class="line"><span class="lineno"> 2797</span>                                        field_kind::ARRAY_OF_BOOLEAN,</div>
<div class="line"><span class="lineno"> 2798</span>                                        field_kind::ARRAY_OF_NULLABLE_BOOLEAN);</div>
<div class="line"><span class="lineno"> 2799</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a042df2e4e1c35550626c59e9fa32c782" name="a042df2e4e1c35550626c59e9fa32c782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042df2e4e1c35550626c59e9fa32c782">&#9670;&#160;</a></span>read_array_of_nullable_float32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; float &gt; &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_nullable_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nullable array of nullable 32-bit IEEE 754 floating point numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02834">2834</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2835</span>{</div>
<div class="line"><span class="lineno"> 2836</span>    <span class="keywordflow">return</span> read_array_of_nullable&lt;float&gt;(field_name,</div>
<div class="line"><span class="lineno"> 2837</span>                                         field_kind::ARRAY_OF_FLOAT32,</div>
<div class="line"><span class="lineno"> 2838</span>                                         field_kind::ARRAY_OF_NULLABLE_FLOAT32);</div>
<div class="line"><span class="lineno"> 2839</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9f94e902221c863b7dac7e6a889ebf3b" name="a9f94e902221c863b7dac7e6a889ebf3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f94e902221c863b7dac7e6a889ebf3b">&#9670;&#160;</a></span>read_array_of_nullable_float64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; double &gt; &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_nullable_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nullable array of nullable 64-bit IEEE 754 floating point numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02842">2842</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2843</span>{</div>
<div class="line"><span class="lineno"> 2844</span>    <span class="keywordflow">return</span> read_array_of_nullable&lt;double&gt;(</div>
<div class="line"><span class="lineno"> 2845</span>      field_name,</div>
<div class="line"><span class="lineno"> 2846</span>      field_kind::ARRAY_OF_FLOAT64,</div>
<div class="line"><span class="lineno"> 2847</span>      field_kind::ARRAY_OF_NULLABLE_FLOAT64);</div>
<div class="line"><span class="lineno"> 2848</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a108d2c29f278d13ddd8468aa0755778c" name="a108d2c29f278d13ddd8468aa0755778c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108d2c29f278d13ddd8468aa0755778c">&#9670;&#160;</a></span>read_array_of_nullable_int16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; int16_t &gt; &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_nullable_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nullable array of nullable 16-bit two's complement signed integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02810">2810</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2811</span>{</div>
<div class="line"><span class="lineno"> 2812</span>    <span class="keywordflow">return</span> read_array_of_nullable&lt;int16_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 2813</span>                                           field_kind::ARRAY_OF_INT16,</div>
<div class="line"><span class="lineno"> 2814</span>                                           field_kind::ARRAY_OF_NULLABLE_INT16);</div>
<div class="line"><span class="lineno"> 2815</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad1453eb890cb20d6981ae6b7ade28a1c" name="ad1453eb890cb20d6981ae6b7ade28a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1453eb890cb20d6981ae6b7ade28a1c">&#9670;&#160;</a></span>read_array_of_nullable_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; int32_t &gt; &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_nullable_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nullable array of nullable 32-bit two's complement signed integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02818">2818</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2819</span>{</div>
<div class="line"><span class="lineno"> 2820</span>    <span class="keywordflow">return</span> read_array_of_nullable&lt;int32_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 2821</span>                                           field_kind::ARRAY_OF_INT32,</div>
<div class="line"><span class="lineno"> 2822</span>                                           field_kind::ARRAY_OF_NULLABLE_INT32);</div>
<div class="line"><span class="lineno"> 2823</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac54ea218c8794dc47cf84d30c8a04a37" name="ac54ea218c8794dc47cf84d30c8a04a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54ea218c8794dc47cf84d30c8a04a37">&#9670;&#160;</a></span>read_array_of_nullable_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; int64_t &gt; &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_nullable_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nullable array of nullable 64-bit two's complement signed integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02826">2826</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2827</span>{</div>
<div class="line"><span class="lineno"> 2828</span>    <span class="keywordflow">return</span> read_array_of_nullable&lt;int64_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 2829</span>                                           field_kind::ARRAY_OF_INT64,</div>
<div class="line"><span class="lineno"> 2830</span>                                           field_kind::ARRAY_OF_NULLABLE_INT64);</div>
<div class="line"><span class="lineno"> 2831</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af81dd88579f37356d9169a57ee35e5af" name="af81dd88579f37356d9169a57ee35e5af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81dd88579f37356d9169a57ee35e5af">&#9670;&#160;</a></span>read_array_of_nullable_int8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; int8_t &gt; &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_nullable_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nullable array of nullable 8-bit two's complement signed integers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02802">2802</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2803</span>{</div>
<div class="line"><span class="lineno"> 2804</span>    <span class="keywordflow">return</span> read_array_of_nullable&lt;int8_t&gt;(field_name,</div>
<div class="line"><span class="lineno"> 2805</span>                                          field_kind::ARRAY_OF_INT8,</div>
<div class="line"><span class="lineno"> 2806</span>                                          field_kind::ARRAY_OF_NULLABLE_INT8);</div>
<div class="line"><span class="lineno"> 2807</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a64d653534706eef2f3117bc1b470f20b" name="a64d653534706eef2f3117bc1b470f20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d653534706eef2f3117bc1b470f20b">&#9670;&#160;</a></span>read_array_of_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; std::string &gt; &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of UTF-8 encoded strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02696">2696</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2697</span>{</div>
<div class="line"><span class="lineno"> 2698</span>    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; descriptor =</div>
<div class="line"><span class="lineno"> 2699</span>      get_field_descriptor(field_name, field_kind::ARRAY_OF_STRING);</div>
<div class="line"><span class="lineno"> 2700</span>    <span class="keywordflow">return</span> read_array_of_variable_size&lt;std::string&gt;(descriptor);</div>
<div class="line"><span class="lineno"> 2701</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a112debd7db56971ffc4c7945f9ff85be" name="a112debd7db56971ffc4c7945f9ff85be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112debd7db56971ffc4c7945f9ff85be">&#9670;&#160;</a></span>read_array_of_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_time </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of times consisting of hour, minute, second, and nanoseconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02712">2712</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2713</span>{</div>
<div class="line"><span class="lineno"> 2714</span>    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; descriptor =</div>
<div class="line"><span class="lineno"> 2715</span>      get_field_descriptor(field_name, field_kind::ARRAY_OF_TIME);</div>
<div class="line"><span class="lineno"> 2716</span>    <span class="keywordflow">return</span> read_array_of_variable_size&lt;local_time&gt;(descriptor);</div>
<div class="line"><span class="lineno"> 2717</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb765210798dd5e68e54ed3fa4e86dfb" name="aeb765210798dd5e68e54ed3fa4e86dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb765210798dd5e68e54ed3fa4e86dfb">&#9670;&#160;</a></span>read_array_of_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_timestamp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of timestamps consisting of date and time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02728">2728</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2729</span>{</div>
<div class="line"><span class="lineno"> 2730</span>    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; descriptor =</div>
<div class="line"><span class="lineno"> 2731</span>      get_field_descriptor(field_name, field_kind::ARRAY_OF_TIMESTAMP);</div>
<div class="line"><span class="lineno"> 2732</span>    <span class="keywordflow">return</span> read_array_of_variable_size&lt;local_date_time&gt;(descriptor);</div>
<div class="line"><span class="lineno"> 2733</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a11fe23b4179411591f0d9b4f2a0bf297" name="a11fe23b4179411591f0d9b4f2a0bf297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11fe23b4179411591f0d9b4f2a0bf297">&#9670;&#160;</a></span>read_array_of_timestamp_with_timezone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_array_of_timestamp_with_timezone </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of timestamps with timezone consisting of date, time and timezone offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02736">2736</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2738</span>{</div>
<div class="line"><span class="lineno"> 2739</span>    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; descriptor = get_field_descriptor(</div>
<div class="line"><span class="lineno"> 2740</span>      field_name, field_kind::ARRAY_OF_TIMESTAMP_WITH_TIMEZONE);</div>
<div class="line"><span class="lineno"> 2741</span>    <span class="keywordflow">return</span> read_array_of_variable_size&lt;offset_date_time&gt;(descriptor);</div>
<div class="line"><span class="lineno"> 2742</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a294f7d02d9807cd8225e9f512fd1c642" name="a294f7d02d9807cd8225e9f512fd1c642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294f7d02d9807cd8225e9f512fd1c642">&#9670;&#160;</a></span>read_boolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hazelcast::client::serialization::compact::compact_reader::read_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a boolean. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02538">2538</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2539</span>{</div>
<div class="line"><span class="lineno"> 2540</span>    <span class="keywordflow">return</span> read_primitive&lt;bool&gt;(</div>
<div class="line"><span class="lineno"> 2541</span>      fieldName, field_kind::BOOLEAN, field_kind::NULLABLE_BOOLEAN, <span class="stringliteral">&quot;boolean&quot;</span>);</div>
<div class="line"><span class="lineno"> 2542</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1b0c32d153cbb38bb7e70c6bc6537e94" name="a1b0c32d153cbb38bb7e70c6bc6537e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0c32d153cbb38bb7e70c6bc6537e94">&#9670;&#160;</a></span>read_compact()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; T &gt; hazelcast::client::serialization::compact::compact_reader::read_compact </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a compact object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d98/compact__impl_8h_source.html#l00394">394</a> of file <a class="el" href="../../dc/d98/compact__impl_8h_source.html">compact_impl.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  395</span>{</div>
<div class="line"><span class="lineno">  396</span>    <span class="keywordflow">return</span> read_variable_size&lt;T&gt;(field_name, field_kind::COMPACT);</div>
<div class="line"><span class="lineno">  397</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae4c337d0fefd6f768ecbf7d8bd6d1d92" name="ae4c337d0fefd6f768ecbf7d8bd6d1d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c337d0fefd6f768ecbf7d8bd6d1d92">&#9670;&#160;</a></span>read_date()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">hazelcast::client::local_date</a> &gt; hazelcast::client::serialization::compact::compact_reader::read_date </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a date consisting of year, month, and day. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02606">2606</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2607</span>{</div>
<div class="line"><span class="lineno"> 2608</span>    <span class="keywordflow">return</span> read_variable_size&lt;hazelcast::client::local_date&gt;(field_name,</div>
<div class="line"><span class="lineno"> 2609</span>                                                             field_kind::DATE);</div>
<div class="line"><span class="lineno"> 2610</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a67c62b05c9d993d94c34da460d2312de" name="a67c62b05c9d993d94c34da460d2312de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c62b05c9d993d94c34da460d2312de">&#9670;&#160;</a></span>read_decimal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; hazelcast::client::serialization::compact::compact_reader::read_decimal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an arbitrary precision and scale floating point number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02593">2593</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2594</span>{</div>
<div class="line"><span class="lineno"> 2595</span>    <span class="keywordflow">return</span> read_variable_size&lt;big_decimal&gt;(field_name, field_kind::DECIMAL);</div>
<div class="line"><span class="lineno"> 2596</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2a7f893fa35796b004c9933b2280308c" name="a2a7f893fa35796b004c9933b2280308c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7f893fa35796b004c9933b2280308c">&#9670;&#160;</a></span>read_float32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float hazelcast::client::serialization::compact::compact_reader::read_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 32-bit IEEE 754 floating point number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02573">2573</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2574</span>{</div>
<div class="line"><span class="lineno"> 2575</span>    <span class="keywordflow">return</span> read_primitive&lt;float&gt;(</div>
<div class="line"><span class="lineno"> 2576</span>      field_name, field_kind::FLOAT32, field_kind::NULLABLE_FLOAT32, <span class="stringliteral">&quot;float32&quot;</span>);</div>
<div class="line"><span class="lineno"> 2577</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7c63f5ea283c4f5fe31b7c860834a005" name="a7c63f5ea283c4f5fe31b7c860834a005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c63f5ea283c4f5fe31b7c860834a005">&#9670;&#160;</a></span>read_float64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double hazelcast::client::serialization::compact::compact_reader::read_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 64-bit IEEE 754 floating point number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02580">2580</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2581</span>{</div>
<div class="line"><span class="lineno"> 2582</span>    <span class="keywordflow">return</span> read_primitive&lt;double&gt;(</div>
<div class="line"><span class="lineno"> 2583</span>      field_name, field_kind::FLOAT64, field_kind::NULLABLE_FLOAT64, <span class="stringliteral">&quot;float64&quot;</span>);</div>
<div class="line"><span class="lineno"> 2584</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac8591fbad80871e5f2ffeee22e297ba8" name="ac8591fbad80871e5f2ffeee22e297ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8591fbad80871e5f2ffeee22e297ba8">&#9670;&#160;</a></span>read_int16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t hazelcast::client::serialization::compact::compact_reader::read_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 16-bit two's complement signed integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02552">2552</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2553</span>{</div>
<div class="line"><span class="lineno"> 2554</span>    <span class="keywordflow">return</span> read_primitive&lt;int16_t&gt;(</div>
<div class="line"><span class="lineno"> 2555</span>      field_name, field_kind::INT16, field_kind::NULLABLE_INT16, <span class="stringliteral">&quot;int16&quot;</span>);</div>
<div class="line"><span class="lineno"> 2556</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0a45e5606a8a7e74cae8f42bc530f96e" name="a0a45e5606a8a7e74cae8f42bc530f96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a45e5606a8a7e74cae8f42bc530f96e">&#9670;&#160;</a></span>read_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t hazelcast::client::serialization::compact::compact_reader::read_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 32-bit two's complement signed integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02559">2559</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2560</span>{</div>
<div class="line"><span class="lineno"> 2561</span>    <span class="keywordflow">return</span> read_primitive&lt;int32_t&gt;(</div>
<div class="line"><span class="lineno"> 2562</span>      field_name, field_kind::INT32, field_kind::NULLABLE_INT32, <span class="stringliteral">&quot;int32&quot;</span>);</div>
<div class="line"><span class="lineno"> 2563</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aaaf4c977e08236660627a5585a99807a" name="aaaf4c977e08236660627a5585a99807a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf4c977e08236660627a5585a99807a">&#9670;&#160;</a></span>read_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t hazelcast::client::serialization::compact::compact_reader::read_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 64-bit two's complement signed integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02566">2566</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2567</span>{</div>
<div class="line"><span class="lineno"> 2568</span>    <span class="keywordflow">return</span> read_primitive&lt;int64_t&gt;(</div>
<div class="line"><span class="lineno"> 2569</span>      field_name, field_kind::INT64, field_kind::NULLABLE_INT64, <span class="stringliteral">&quot;int64&quot;</span>);</div>
<div class="line"><span class="lineno"> 2570</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aaa0060a3cdb2514c61ac6c88bda056b5" name="aaa0060a3cdb2514c61ac6c88bda056b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0060a3cdb2514c61ac6c88bda056b5">&#9670;&#160;</a></span>read_int8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t hazelcast::client::serialization::compact::compact_reader::read_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an 8-bit two's complement signed integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02545">2545</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2546</span>{</div>
<div class="line"><span class="lineno"> 2547</span>    <span class="keywordflow">return</span> read_primitive&lt;int8_t&gt;(</div>
<div class="line"><span class="lineno"> 2548</span>      fieldName, field_kind::INT8, field_kind::NULLABLE_INT8, <span class="stringliteral">&quot;int8&quot;</span>);</div>
<div class="line"><span class="lineno"> 2549</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acd605dfa1e77c458328d72285d72c14e" name="acd605dfa1e77c458328d72285d72c14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd605dfa1e77c458328d72285d72c14e">&#9670;&#160;</a></span>read_nullable_boolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; bool &gt; hazelcast::client::serialization::compact::compact_reader::read_nullable_boolean </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nullable boolean. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02745">2745</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2746</span>{</div>
<div class="line"><span class="lineno"> 2747</span>    <span class="keywordflow">return</span> read_nullable_primitive&lt;bool&gt;(</div>
<div class="line"><span class="lineno"> 2748</span>      field_name, field_kind::BOOLEAN, field_kind::NULLABLE_BOOLEAN);</div>
<div class="line"><span class="lineno"> 2749</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a499751677405dddf21a6b5b56582b0d4" name="a499751677405dddf21a6b5b56582b0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499751677405dddf21a6b5b56582b0d4">&#9670;&#160;</a></span>read_nullable_float32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; float &gt; hazelcast::client::serialization::compact::compact_reader::read_nullable_float32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nullable 32-bit IEEE 754 floating point number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02780">2780</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2781</span>{</div>
<div class="line"><span class="lineno"> 2782</span>    <span class="keywordflow">return</span> read_nullable_primitive&lt;float&gt;(</div>
<div class="line"><span class="lineno"> 2783</span>      field_name, field_kind::FLOAT32, field_kind::NULLABLE_FLOAT32);</div>
<div class="line"><span class="lineno"> 2784</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aba62bcf0175f01ae4cf3ca68d083c93b" name="aba62bcf0175f01ae4cf3ca68d083c93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba62bcf0175f01ae4cf3ca68d083c93b">&#9670;&#160;</a></span>read_nullable_float64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; double &gt; hazelcast::client::serialization::compact::compact_reader::read_nullable_float64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nullable 64-bit IEEE 754 floating point number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02787">2787</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2788</span>{</div>
<div class="line"><span class="lineno"> 2789</span>    <span class="keywordflow">return</span> read_nullable_primitive&lt;double&gt;(</div>
<div class="line"><span class="lineno"> 2790</span>      field_name, field_kind::FLOAT64, field_kind::NULLABLE_FLOAT64);</div>
<div class="line"><span class="lineno"> 2791</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6a713300694369c456cc71be519d6fe6" name="a6a713300694369c456cc71be519d6fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a713300694369c456cc71be519d6fe6">&#9670;&#160;</a></span>read_nullable_int16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int16_t &gt; hazelcast::client::serialization::compact::compact_reader::read_nullable_int16 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nullable 16-bit two's complement signed integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02759">2759</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2760</span>{</div>
<div class="line"><span class="lineno"> 2761</span>    <span class="keywordflow">return</span> read_nullable_primitive&lt;int16_t&gt;(</div>
<div class="line"><span class="lineno"> 2762</span>      field_name, field_kind::INT16, field_kind::NULLABLE_INT16);</div>
<div class="line"><span class="lineno"> 2763</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7c98def2db8d4b8c0fa68eed73833811" name="a7c98def2db8d4b8c0fa68eed73833811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c98def2db8d4b8c0fa68eed73833811">&#9670;&#160;</a></span>read_nullable_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int32_t &gt; hazelcast::client::serialization::compact::compact_reader::read_nullable_int32 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nullable 32-bit two's complement signed integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02766">2766</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2767</span>{</div>
<div class="line"><span class="lineno"> 2768</span>    <span class="keywordflow">return</span> read_nullable_primitive&lt;int32_t&gt;(</div>
<div class="line"><span class="lineno"> 2769</span>      field_name, field_kind::INT32, field_kind::NULLABLE_INT32);</div>
<div class="line"><span class="lineno"> 2770</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3351fd3f6388c8d58801ffe2eb911c49" name="a3351fd3f6388c8d58801ffe2eb911c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3351fd3f6388c8d58801ffe2eb911c49">&#9670;&#160;</a></span>read_nullable_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int64_t &gt; hazelcast::client::serialization::compact::compact_reader::read_nullable_int64 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nullable 64-bit two's complement signed integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02773">2773</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2774</span>{</div>
<div class="line"><span class="lineno"> 2775</span>    <span class="keywordflow">return</span> read_nullable_primitive&lt;int64_t&gt;(</div>
<div class="line"><span class="lineno"> 2776</span>      field_name, field_kind::INT64, field_kind::NULLABLE_INT64);</div>
<div class="line"><span class="lineno"> 2777</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae2f45c34bb28c2af0ba65357d29e5c2d" name="ae2f45c34bb28c2af0ba65357d29e5c2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f45c34bb28c2af0ba65357d29e5c2d">&#9670;&#160;</a></span>read_nullable_int8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; int8_t &gt; hazelcast::client::serialization::compact::compact_reader::read_nullable_int8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nullable 8-bit two's complement signed integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02752">2752</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2753</span>{</div>
<div class="line"><span class="lineno"> 2754</span>    <span class="keywordflow">return</span> read_nullable_primitive&lt;int8_t&gt;(</div>
<div class="line"><span class="lineno"> 2755</span>      field_name, field_kind::INT8, field_kind::NULLABLE_INT8);</div>
<div class="line"><span class="lineno"> 2756</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad43224d1b457083d1af83a4c7ec3da9c" name="ad43224d1b457083d1af83a4c7ec3da9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43224d1b457083d1af83a4c7ec3da9c">&#9670;&#160;</a></span>read_primitive_array_as_nullable_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::vector&lt; boost::optional&lt; bool &gt; &gt; &gt; hazelcast::client::serialization::compact::compact_reader::read_primitive_array_as_nullable_array </td>
          <td>(</td>
          <td class="paramtype">const pimpl::field_descriptor &amp;&#160;</td>
          <td class="paramname"><em>field_descriptor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../dc/d98/compact__impl_8h_source.html#l00384">384</a> of file <a class="el" href="../../dc/d98/compact__impl_8h_source.html">compact_impl.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  387</span>{</div>
<div class="line"><span class="lineno">  388</span>    <span class="keywordflow">return</span> read_variable_size&lt;std::vector&lt;boost::optional&lt;bool&gt;&gt;&gt;(</div>
<div class="line"><span class="lineno">  389</span>      field_descriptor);</div>
<div class="line"><span class="lineno">  390</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af1a1ad41ba261f015276987bde0071d0" name="af1a1ad41ba261f015276987bde0071d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a1ad41ba261f015276987bde0071d0">&#9670;&#160;</a></span>read_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; std::string &gt; hazelcast::client::serialization::compact::compact_reader::read_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an UTF-8 encoded string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02587">2587</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2588</span>{</div>
<div class="line"><span class="lineno"> 2589</span>    <span class="keywordflow">return</span> read_variable_size&lt;std::string&gt;(field_name, field_kind::STRING);</div>
<div class="line"><span class="lineno"> 2590</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b5ce4b3546d4ec75120586c1c6a456c" name="a3b5ce4b3546d4ec75120586c1c6a456c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5ce4b3546d4ec75120586c1c6a456c">&#9670;&#160;</a></span>read_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">hazelcast::client::local_time</a> &gt; hazelcast::client::serialization::compact::compact_reader::read_time </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a time consisting of hour, minute, second, and nano seconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02599">2599</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2600</span>{</div>
<div class="line"><span class="lineno"> 2601</span>    <span class="keywordflow">return</span> read_variable_size&lt;hazelcast::client::local_time&gt;(field_name,</div>
<div class="line"><span class="lineno"> 2602</span>                                                             field_kind::TIME);</div>
<div class="line"><span class="lineno"> 2603</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a53251772efaa15d183f5b7858c755190" name="a53251772efaa15d183f5b7858c755190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53251772efaa15d183f5b7858c755190">&#9670;&#160;</a></span>read_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">hazelcast::client::local_date_time</a> &gt; hazelcast::client::serialization::compact::compact_reader::read_timestamp </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a timestamp consisting of date and time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02613">2613</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2614</span>{</div>
<div class="line"><span class="lineno"> 2615</span>    <span class="keywordflow">return</span> read_variable_size&lt;hazelcast::client::local_date_time&gt;(</div>
<div class="line"><span class="lineno"> 2616</span>      field_name, field_kind::TIMESTAMP);</div>
<div class="line"><span class="lineno"> 2617</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6b18da103cebe13f3b3e4fc690f020a0" name="a6b18da103cebe13f3b3e4fc690f020a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b18da103cebe13f3b3e4fc690f020a0">&#9670;&#160;</a></span>read_timestamp_with_timezone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">hazelcast::client::offset_date_time</a> &gt; hazelcast::client::serialization::compact::compact_reader::read_timestamp_with_timezone </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a timestamp with timezone consisting of date, time and timezone offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the field. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_serialization</td><td>if the field does not exist in the schema or the type of the field does not match with the one defined in the schema. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l02620">2620</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2621</span>{</div>
<div class="line"><span class="lineno"> 2622</span>    <span class="keywordflow">return</span> read_variable_size&lt;hazelcast::client::offset_date_time&gt;(</div>
<div class="line"><span class="lineno"> 2623</span>      field_name, field_kind::TIMESTAMP_WITH_TIMEZONE);</div>
<div class="line"><span class="lineno"> 2624</span>}</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>hazelcast/include/hazelcast/client/serialization/pimpl/compact/<a class="el" href="../../de/d0a/compact_8h_source.html">compact.h</a></li>
<li>hazelcast/include/hazelcast/client/serialization/pimpl/compact/<a class="el" href="../../dc/d98/compact__impl_8h_source.html">compact_impl.h</a></li>
<li>hazelcast/src/hazelcast/client/<a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../de/db5/namespacehazelcast.html">hazelcast</a></li><li class="navelem"><a class="el" href="../../da/d95/namespacehazelcast_1_1client.html">client</a></li><li class="navelem"><a class="el" href="../../db/dda/namespacehazelcast_1_1client_1_1serialization.html">serialization</a></li><li class="navelem"><b>compact</b></li><li class="navelem"><a class="el" href="../../d3/d17/classhazelcast_1_1client_1_1serialization_1_1compact_1_1compact__reader.html">compact_reader</a></li>
    <li class="footer">Generated on Wed Mar 15 2023 18:23:47 for Hazelcast C++ Client by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
