<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hazelcast C++ Client: hazelcast::cp::cp_subsystem Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hazelcast C++ Client
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>hazelcast</b></li><li class="navelem"><b>cp</b></li><li class="navelem"><a class="el" href="classhazelcast_1_1cp_1_1cp__subsystem.html">cp_subsystem</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classhazelcast_1_1cp_1_1cp__subsystem-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hazelcast::cp::cp_subsystem Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>CP Subsystem is a component of Hazelcast that builds a strongly consistent layer for a set of distributed data structures.  
 <a href="classhazelcast_1_1cp_1_1cp__subsystem.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cp_8h_source.html">cp.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a44dbc468f57306d2a93e5bb879ad1a0a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classhazelcast_1_1cp_1_1atomic__long.html">atomic_long</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1cp_1_1cp__subsystem.html#a44dbc468f57306d2a93e5bb879ad1a0a">get_atomic_long</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a44dbc468f57306d2a93e5bb879ad1a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a proxy for an <a class="el" href="classhazelcast_1_1cp_1_1atomic__long.html" title="Client-side Raft-based proxy implementation of atomic long. ">atomic_long</a> instance created on CP Subsystem.  <a href="#a44dbc468f57306d2a93e5bb879ad1a0a">More...</a><br /></td></tr>
<tr class="separator:a44dbc468f57306d2a93e5bb879ad1a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf95ea6ed154a06d1f132a3861b9c3ad"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; atomic_reference &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1cp_1_1cp__subsystem.html#abf95ea6ed154a06d1f132a3861b9c3ad">get_atomic_reference</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:abf95ea6ed154a06d1f132a3861b9c3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a proxy for an atomic_reference instance created on CP Subsystem.  <a href="#abf95ea6ed154a06d1f132a3861b9c3ad">More...</a><br /></td></tr>
<tr class="separator:abf95ea6ed154a06d1f132a3861b9c3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d9899d6fae44dbc7989cea4a6c02d6"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; latch &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1cp_1_1cp__subsystem.html#a52d9899d6fae44dbc7989cea4a6c02d6">get_latch</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a52d9899d6fae44dbc7989cea4a6c02d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a proxy for an count_down_latch instance created on CP Subsystem.  <a href="#a52d9899d6fae44dbc7989cea4a6c02d6">More...</a><br /></td></tr>
<tr class="separator:a52d9899d6fae44dbc7989cea4a6c02d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1161ade0c6bc1f340e63fef73d7dc99"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; fenced_lock &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1cp_1_1cp__subsystem.html#ac1161ade0c6bc1f340e63fef73d7dc99">get_lock</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ac1161ade0c6bc1f340e63fef73d7dc99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a proxy for an fenced_lock instance created on CP Subsystem.  <a href="#ac1161ade0c6bc1f340e63fef73d7dc99">More...</a><br /></td></tr>
<tr class="separator:ac1161ade0c6bc1f340e63fef73d7dc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50455d38e8c2993e07a763507fb121e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; counting_semaphore &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhazelcast_1_1cp_1_1cp__subsystem.html#ad50455d38e8c2993e07a763507fb121e">get_semaphore</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:ad50455d38e8c2993e07a763507fb121e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a proxy for an semaphore instance created on CP Subsystem.  <a href="#ad50455d38e8c2993e07a763507fb121e">More...</a><br /></td></tr>
<tr class="separator:ad50455d38e8c2993e07a763507fb121e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>CP Subsystem is a component of Hazelcast that builds a strongly consistent layer for a set of distributed data structures. </p>
<p>Its APIs can be used for implementing distributed coordination use cases, such as leader election, distributed locking, synchronization, and metadata management. It is accessed via hazelcast_client::get_cp_subsystem. Its data structures are CP with respect to the CAP principle, i.e., they always maintain linearizability and prefer consistency over availability during network partitions. Besides network partitions, CP Subsystem withstands server and client failures. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a44dbc468f57306d2a93e5bb879ad1a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44dbc468f57306d2a93e5bb879ad1a0a">&#9670;&nbsp;</a></span>get_atomic_long()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classhazelcast_1_1cp_1_1atomic__long.html">atomic_long</a> &gt; hazelcast::cp::cp_subsystem::get_atomic_long </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a proxy for an <a class="el" href="classhazelcast_1_1cp_1_1atomic__long.html" title="Client-side Raft-based proxy implementation of atomic long. ">atomic_long</a> instance created on CP Subsystem. </p>
<p>Hazelcast's <a class="el" href="classhazelcast_1_1cp_1_1atomic__long.html" title="Client-side Raft-based proxy implementation of atomic long. ">atomic_long</a> is a distributed version of <code>java.util.concurrent.atomic.AtomicLong</code>. If no group name is given within the "name" parameter, then the <a class="el" href="classhazelcast_1_1cp_1_1atomic__long.html" title="Client-side Raft-based proxy implementation of atomic long. ">atomic_long</a> instance will be created on the DEFAULT CP group. If a group name is given, like <a class="el" href="classhazelcast_1_1cp_1_1cp__subsystem.html#a44dbc468f57306d2a93e5bb879ad1a0a" title="Returns a proxy for an atomic_long instance created on CP Subsystem. ">cp_subsystem::get_atomic_long</a>("myint64_t@group1"), the given group will be initialized first, if not initialized already, and then the <a class="el" href="classhazelcast_1_1cp_1_1atomic__long.html" title="Client-side Raft-based proxy implementation of atomic long. ">atomic_long</a> instance will be created on this group. Returned <a class="el" href="classhazelcast_1_1cp_1_1atomic__long.html" title="Client-side Raft-based proxy implementation of atomic long. ">atomic_long</a> instance offers linearizability and behaves as a CP register. When a network partition occurs, proxies that exist on the minority side of its CP group lose availability. </p>
<p><b>Each call of this method performs a commit to the METADATA CP group. Hence, callers should cache the returned proxy.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the <a class="el" href="classhazelcast_1_1cp_1_1atomic__long.html" title="Client-side Raft-based proxy implementation of atomic long. ">atomic_long</a> proxy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhazelcast_1_1cp_1_1atomic__long.html" title="Client-side Raft-based proxy implementation of atomic long. ">atomic_long</a> proxy for the given name </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_</td><td>if CP Subsystem is not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf95ea6ed154a06d1f132a3861b9c3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf95ea6ed154a06d1f132a3861b9c3ad">&#9670;&nbsp;</a></span>get_atomic_reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; atomic_reference &gt; hazelcast::cp::cp_subsystem::get_atomic_reference </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a proxy for an atomic_reference instance created on CP Subsystem. </p>
<p>Hazelcast's atomic_reference is a distributed version of <code>java.util.concurrent.atomic.AtomicLong</code>. If no group name is given within the "name" parameter, then the atomic_reference instance will be created on the DEFAULT CP group. If a group name is given, like <a class="el" href="classhazelcast_1_1cp_1_1cp__subsystem.html#abf95ea6ed154a06d1f132a3861b9c3ad" title="Returns a proxy for an atomic_reference instance created on CP Subsystem. ">cp_subsystem::get_atomic_reference</a>("myRef@group1"), the given group will be initialized first, if not initialized already, and then the atomic_reference instance will be created on this group. Returned atomic_reference instance offers linearizability and behaves as a CP register. When a network partition occurs, proxies that exist on the minority side of its CP group lose availability. </p>
<p><b>Each call of this method performs a commit to the METADATA CP group. Hence, callers should cache the returned proxy.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the atomic_reference proxy </td></tr>
    <tr><td class="paramname">&lt;E&gt;</td><td>the type of object referred to by the reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>atomic_reference proxy for the given name </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_</td><td>if CP Subsystem is not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52d9899d6fae44dbc7989cea4a6c02d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d9899d6fae44dbc7989cea4a6c02d6">&#9670;&nbsp;</a></span>get_latch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; latch &gt; hazelcast::cp::cp_subsystem::get_latch </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a proxy for an count_down_latch instance created on CP Subsystem. </p>
<p>Hazelcast's count_down_latch is a distributed version of <code>java.util.concurrent.CountDownLatch</code>. If no group name is given within the "name" parameter, then the count_down_latch instance will be created on the DEFAULT CP group. If a group name is given, like <a class="el" href="classhazelcast_1_1cp_1_1cp__subsystem.html#abf95ea6ed154a06d1f132a3861b9c3ad" title="Returns a proxy for an atomic_reference instance created on CP Subsystem. ">cp_subsystem::get_atomic_reference</a>("myLatch@group1"), the given group will be initialized first, if not initialized already, and then the count_down_latch instance will be created on this group. Returned count_down_latch instance offers linearizability. When a network partition occurs, proxies that exist on the minority side of its CP group lose availability. </p>
<p><b>Each call of this method performs a commit to the METADATA CP group. Hence, callers should cache the returned proxy.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the count_down_latch proxy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>count_down_latch proxy for the given name </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_</td><td>if CP Subsystem is not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1161ade0c6bc1f340e63fef73d7dc99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1161ade0c6bc1f340e63fef73d7dc99">&#9670;&nbsp;</a></span>get_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; fenced_lock &gt; hazelcast::cp::cp_subsystem::get_lock </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a proxy for an fenced_lock instance created on CP Subsystem. </p>
<p>Hazelcast's fenced_lock is a distributed version of <code>java.util.concurrent.locks.Lock</code>. If no group name is given within the "name" parameter, then the fenced_lock instance will be created on the DEFAULT CP group. If a group name is given, like <a class="el" href="classhazelcast_1_1cp_1_1cp__subsystem.html#abf95ea6ed154a06d1f132a3861b9c3ad" title="Returns a proxy for an atomic_reference instance created on CP Subsystem. ">cp_subsystem::get_atomic_reference</a>("myLock@group1"), the given group will be initialized first, if not initialized already, and then the fenced_lock instance will be created on this group. Returned fenced_lock instance offers linearizability. When a network partition occurs, proxies that exist on the minority side of its CP group lose availability. </p>
<p><b>Each call of this method performs a commit to the METADATA CP group. Hence, callers should cache the returned proxy.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the fenced_lock proxy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fenced_lock proxy for the given name </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_</td><td>if CP Subsystem is not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad50455d38e8c2993e07a763507fb121e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50455d38e8c2993e07a763507fb121e">&#9670;&nbsp;</a></span>get_semaphore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; counting_semaphore &gt; hazelcast::cp::cp_subsystem::get_semaphore </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a proxy for an semaphore instance created on CP Subsystem. </p>
<p>Hazelcast's semaphore is a distributed version of <code>java.util.concurrent.Semaphore</code>. If no group name is given within the "name" parameter, then the semaphore instance will be created on the DEFAULT CP group. If a group name is given, like <a class="el" href="classhazelcast_1_1cp_1_1cp__subsystem.html#ad50455d38e8c2993e07a763507fb121e" title="Returns a proxy for an semaphore instance created on CP Subsystem. ">cp_subsystem::get_semaphore</a>("mySemaphore@group1"), the given group will be initialized first, if not initialized already, and then the semaphore instance will be created on this group. Returned semaphore instance offers linearizability. When a network partition occurs, proxies that exist on the minority side of its CP group lose availability. </p>
<p><b>Each call of this method performs a commit to the METADATA CP group. Hence, callers should cache the returned proxy.</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the semaphore proxy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>semaphore proxy for the given name </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">hazelcast_</td><td>if CP Subsystem is not enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>hazelcast/include/hazelcast/cp/<a class="el" href="cp_8h_source.html">cp.h</a></li>
<li>hazelcast/src/hazelcast/cp/cp.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Nov 25 2020 21:09:40 for Hazelcast C++ Client by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
