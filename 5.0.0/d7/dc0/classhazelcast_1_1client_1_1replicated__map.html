<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hazelcast C++ Client: hazelcast::client::replicated_map Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../IMDG_blue_logo_square_RGB-dark_200px.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hazelcast C++ Client
   </div>
   <div id="projectbrief">Hazelcast C++ Client Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d7/dc0/classhazelcast_1_1client_1_1replicated__map.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../dc/dc0/classhazelcast_1_1client_1_1replicated__map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hazelcast::client::replicated_map Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="../../dc/d32/replicated__map_8h_source.html">replicated_map.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="../../closed.png" alt="+"/> Inheritance diagram for hazelcast::client::replicated_map:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab8e0de2c71b4fcbcfa3502eaa3acc76f"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename R  = V&gt; </td></tr>
<tr class="memitem:ab8e0de2c71b4fcbcfa3502eaa3acc76f"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; boost::optional&lt; R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#ab8e0de2c71b4fcbcfa3502eaa3acc76f">put</a> (const K &amp;key, const V &amp;value, std::chrono::milliseconds ttl)</td></tr>
<tr class="separator:ab8e0de2c71b4fcbcfa3502eaa3acc76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2844990171e3539e605f6d44d1828d9f"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:a2844990171e3539e605f6d44d1828d9f"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#a2844990171e3539e605f6d44d1828d9f">put_all</a> (const std::unordered_map&lt; K, V &gt; &amp;entries)</td></tr>
<tr class="memdesc:a2844990171e3539e605f6d44d1828d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all of the mappings from the specified map to this map (optional operation).  <a href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#a2844990171e3539e605f6d44d1828d9f">More...</a><br /></td></tr>
<tr class="separator:a2844990171e3539e605f6d44d1828d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210c51fc20cff924f3e400c93e2a66a2"><td class="memItemLeft" align="right" valign="top">boost::future&lt; boost::uuids::uuid &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#a210c51fc20cff924f3e400c93e2a66a2">add_entry_listener</a> (<a class="el" href="../../d8/d8f/classhazelcast_1_1client_1_1entry__listener.html">entry_listener</a> &amp;&amp;listener)</td></tr>
<tr class="memdesc:a210c51fc20cff924f3e400c93e2a66a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an entry listener for this map.  <a href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#a210c51fc20cff924f3e400c93e2a66a2">More...</a><br /></td></tr>
<tr class="separator:a210c51fc20cff924f3e400c93e2a66a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e287ae43397571b97e73b35bf44c57"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:aa2e287ae43397571b97e73b35bf44c57"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_base_of&lt; <a class="el" href="../../d9/d01/classhazelcast_1_1client_1_1query_1_1predicate.html">query::predicate</a>, K &gt;::value, boost::future&lt; boost::uuids::uuid &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#aa2e287ae43397571b97e73b35bf44c57">add_entry_listener</a> (<a class="el" href="../../d8/d8f/classhazelcast_1_1client_1_1entry__listener.html">entry_listener</a> &amp;&amp;listener, const K &amp;key)</td></tr>
<tr class="memdesc:aa2e287ae43397571b97e73b35bf44c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the specified entry listener for the specified key.  <a href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#aa2e287ae43397571b97e73b35bf44c57">More...</a><br /></td></tr>
<tr class="separator:aa2e287ae43397571b97e73b35bf44c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d79882944ebb0c0f7119aa5a642f906"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a0d79882944ebb0c0f7119aa5a642f906"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="../../d9/d01/classhazelcast_1_1client_1_1query_1_1predicate.html">query::predicate</a>, P &gt;::value, boost::future&lt; boost::uuids::uuid &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#a0d79882944ebb0c0f7119aa5a642f906">add_entry_listener</a> (<a class="el" href="../../d8/d8f/classhazelcast_1_1client_1_1entry__listener.html">entry_listener</a> &amp;&amp;listener, const P &amp;predicate)</td></tr>
<tr class="memdesc:a0d79882944ebb0c0f7119aa5a642f906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an continuous entry listener for this map.  <a href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#a0d79882944ebb0c0f7119aa5a642f906">More...</a><br /></td></tr>
<tr class="separator:a0d79882944ebb0c0f7119aa5a642f906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf49222ee3f71dc3d2bf2edca1146833"><td class="memTemplParams" colspan="2">template&lt;typename K , typename P &gt; </td></tr>
<tr class="memitem:acf49222ee3f71dc3d2bf2edca1146833"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; <a class="el" href="../../d9/d01/classhazelcast_1_1client_1_1query_1_1predicate.html">query::predicate</a>, P &gt;::value, boost::future&lt; boost::uuids::uuid &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#acf49222ee3f71dc3d2bf2edca1146833">add_entry_listener</a> (<a class="el" href="../../d8/d8f/classhazelcast_1_1client_1_1entry__listener.html">entry_listener</a> &amp;&amp;listener, const P &amp;predicate, const K &amp;key)</td></tr>
<tr class="memdesc:acf49222ee3f71dc3d2bf2edca1146833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an continuous entry listener for this map.  <a href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#acf49222ee3f71dc3d2bf2edca1146833">More...</a><br /></td></tr>
<tr class="separator:acf49222ee3f71dc3d2bf2edca1146833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f3c8b0226c890e1071c2412bdd991c"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a82f3c8b0226c890e1071c2412bdd991c"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; std::vector&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#a82f3c8b0226c890e1071c2412bdd991c">values</a> ()</td></tr>
<tr class="memdesc:a82f3c8b0226c890e1071c2412bdd991c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Due to the lazy nature of the returned array, changes to the map (addition, removal, update) might be reflected on the collection.  <a href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#a82f3c8b0226c890e1071c2412bdd991c">More...</a><br /></td></tr>
<tr class="separator:a82f3c8b0226c890e1071c2412bdd991c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0208adba5a1ed1458e2b35d18a387a"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:aff0208adba5a1ed1458e2b35d18a387a"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; std::vector&lt; std::pair&lt; K, V &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#aff0208adba5a1ed1458e2b35d18a387a">entry_set</a> ()</td></tr>
<tr class="memdesc:aff0208adba5a1ed1458e2b35d18a387a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a view of the mappings contained in this map.  <a href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#aff0208adba5a1ed1458e2b35d18a387a">More...</a><br /></td></tr>
<tr class="separator:aff0208adba5a1ed1458e2b35d18a387a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b38206fb39e5142e581602a0515a77e"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:a5b38206fb39e5142e581602a0515a77e"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; std::vector&lt; K &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#a5b38206fb39e5142e581602a0515a77e">key_set</a> ()</td></tr>
<tr class="memdesc:a5b38206fb39e5142e581602a0515a77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a view of the keys contained in this map.  <a href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#a5b38206fb39e5142e581602a0515a77e">More...</a><br /></td></tr>
<tr class="separator:a5b38206fb39e5142e581602a0515a77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a9d86877d2e9f16eed7c7da6a0e1c1"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:ab3a9d86877d2e9f16eed7c7da6a0e1c1"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#ab3a9d86877d2e9f16eed7c7da6a0e1c1">contains_key</a> (const K &amp;key)</td></tr>
<tr class="separator:ab3a9d86877d2e9f16eed7c7da6a0e1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35456a88ab46981ab02305c133ee6a73"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a35456a88ab46981ab02305c133ee6a73"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#a35456a88ab46981ab02305c133ee6a73">contains_value</a> (const V &amp;value)</td></tr>
<tr class="separator:a35456a88ab46981ab02305c133ee6a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6511680340bcff3b2808c119a46c82a"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:aa6511680340bcff3b2808c119a46c82a"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; boost::optional&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#aa6511680340bcff3b2808c119a46c82a">get</a> (const K &amp;key)</td></tr>
<tr class="separator:aa6511680340bcff3b2808c119a46c82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b6f49eda4db1770d2faff2c8dfdfbd"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V , typename R  = V&gt; </td></tr>
<tr class="memitem:a91b6f49eda4db1770d2faff2c8dfdfbd"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; boost::optional&lt; R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#a91b6f49eda4db1770d2faff2c8dfdfbd">put</a> (const K &amp;key, const V &amp;value)</td></tr>
<tr class="separator:a91b6f49eda4db1770d2faff2c8dfdfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7eed6cade380b5b63c6ff5e22e32356"><td class="memTemplParams" colspan="2">template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:ab7eed6cade380b5b63c6ff5e22e32356"><td class="memTemplItemLeft" align="right" valign="top">boost::future&lt; boost::optional&lt; V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html#ab7eed6cade380b5b63c6ff5e22e32356">remove</a> (const K &amp;key)</td></tr>
<tr class="separator:ab7eed6cade380b5b63c6ff5e22e32356"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1b99a5f61aa30a77d05f1d0806ca744d"><td class="memItemLeft" align="right" valign="top"><a id="a1b99a5f61aa30a77d05f1d0806ca744d"></a>
static constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><b>SERVICE_NAME</b> = &quot;hz:impl:replicatedMapService&quot;</td></tr>
<tr class="separator:a1b99a5f61aa30a77d05f1d0806ca744d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0195b4df1fa489288a2a52fe5b0e23b7"><td class="memItemLeft" align="right" valign="top"><a id="a0195b4df1fa489288a2a52fe5b0e23b7"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>spi::ProxyManager</b></td></tr>
<tr class="separator:a0195b4df1fa489288a2a52fe5b0e23b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A ReplicatedMap is a map-like data structure with weak consistency and values locally stored on every node of the cluster. </p>
<p>Whenever a value is written asynchronously, the new value will be internally distributed to all existing cluster members, and eventually every node will have the new value.</p>
<p>When a new node joins the cluster, the new node initially will request existing values from older nodes and replicate them locally.</p>

<p class="definition">Definition at line <a class="el" href="../../dc/d32/replicated__map_8h_source.html#l00046">46</a> of file <a class="el" href="../../dc/d32/replicated__map_8h_source.html">replicated_map.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a210c51fc20cff924f3e400c93e2a66a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210c51fc20cff924f3e400c93e2a66a2">&#9670;&nbsp;</a></span>add_entry_listener() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;boost::uuids::uuid&gt; hazelcast::client::replicated_map::add_entry_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d8f/classhazelcast_1_1client_1_1entry__listener.html">entry_listener</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an entry listener for this map. </p>
<p>The listener will be notified for all map add/remove/update/evict events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>entry listener </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d32/replicated__map_8h_source.html#l00090">90</a> of file <a class="el" href="../../dc/d32/replicated__map_8h_source.html">replicated_map.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;                                                                                      {</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;                <span class="keywordflow">return</span> proxy::ReplicatedMapImpl::add_entry_listener(</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;                        std::shared_ptr&lt;impl::BaseEventHandler&gt;(</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;                                <span class="keyword">new</span> EntryEventHandler&lt;protocol::codec::replicatedmap_addentrylistener_handler&gt;(get_name(), get_context().get_client_cluster_service(),</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;                                        get_context().get_serialization_service(), std::move(listener), get_context().get_logger())));</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa2e287ae43397571b97e73b35bf44c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e287ae43397571b97e73b35bf44c57">&#9670;&nbsp;</a></span>add_entry_listener() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_base_of&lt;<a class="el" href="../../d9/d01/classhazelcast_1_1client_1_1query_1_1predicate.html">query::predicate</a>, K&gt;::value, boost::future&lt;boost::uuids::uuid&gt; &gt;::type hazelcast::client::replicated_map::add_entry_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d8f/classhazelcast_1_1client_1_1entry__listener.html">entry_listener</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the specified entry listener for the specified key. </p>
<p>The listener will be notified for all add/remove/update/evict events of the specified key only. </p>
<p><b>Warning:</b></p>
<p>This method uses <code>hashCode</code> and <code>equals</code> of the binary form of the <code>key</code>, not the actual implementations of <code>hashCode</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>the entry listener to add </td></tr>
    <tr><td class="paramname">key</td><td>the key to listen to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d32/replicated__map_8h_source.html#l00111">111</a> of file <a class="el" href="../../dc/d32/replicated__map_8h_source.html">replicated_map.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;                                                                        {</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;                <span class="keywordflow">return</span> proxy::ReplicatedMapImpl::add_entry_listener_to_key(</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;                        std::shared_ptr&lt;impl::BaseEventHandler&gt;(</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;                                <span class="keyword">new</span> EntryEventHandler&lt;protocol::codec::replicatedmap_addentrylistenertokey_handler&gt;(get_name(), get_context().get_client_cluster_service(),</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;                                                      get_context().get_serialization_service(), std::move(listener),</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                                                      get_context().get_logger())), to_data(key));</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d79882944ebb0c0f7119aa5a642f906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d79882944ebb0c0f7119aa5a642f906">&#9670;&nbsp;</a></span>add_entry_listener() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_base_of&lt;<a class="el" href="../../d9/d01/classhazelcast_1_1client_1_1query_1_1predicate.html">query::predicate</a>, P&gt;::value, boost::future&lt;boost::uuids::uuid&gt; &gt;::type hazelcast::client::replicated_map::add_entry_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d8f/classhazelcast_1_1client_1_1entry__listener.html">entry_listener</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an continuous entry listener for this map. </p>
<p>The listener will be notified for map add/remove/update/evict events filtered by the given predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>the entry listener to add </td></tr>
    <tr><td class="paramname">predicate</td><td>the predicate for filtering entries </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d32/replicated__map_8h_source.html#l00128">128</a> of file <a class="el" href="../../dc/d32/replicated__map_8h_source.html">replicated_map.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;                                                                              {</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;                <span class="keywordflow">return</span> proxy::ReplicatedMapImpl::add_entry_listener(</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                        std::shared_ptr&lt;impl::BaseEventHandler&gt;(</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;                                <span class="keyword">new</span> EntryEventHandler&lt;protocol::codec::replicatedmap_addentrylistenerwithpredicate_handler&gt;(get_name(), get_context().get_client_cluster_service(),</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;                                                      get_context().get_serialization_service(), std::move(listener),</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;                                                      get_context().get_logger())), to_data(predicate));</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="acf49222ee3f71dc3d2bf2edca1146833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf49222ee3f71dc3d2bf2edca1146833">&#9670;&nbsp;</a></span>add_entry_listener() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_base_of&lt;<a class="el" href="../../d9/d01/classhazelcast_1_1client_1_1query_1_1predicate.html">query::predicate</a>, P&gt;::value, boost::future&lt;boost::uuids::uuid&gt; &gt;::type hazelcast::client::replicated_map::add_entry_listener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d8/d8f/classhazelcast_1_1client_1_1entry__listener.html">entry_listener</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an continuous entry listener for this map. </p>
<p>The listener will be notified for map add/remove/update/evict events filtered by the given predicate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>the entry listener </td></tr>
    <tr><td class="paramname">predicate</td><td>the predicate for filtering entries </td></tr>
    <tr><td class="paramname">key</td><td>the key to listen to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d32/replicated__map_8h_source.html#l00146">146</a> of file <a class="el" href="../../dc/d32/replicated__map_8h_source.html">replicated_map.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;                                                                                            {</div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                <span class="keywordflow">return</span> proxy::ReplicatedMapImpl::add_entry_listener(</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;                        std::shared_ptr&lt;impl::BaseEventHandler&gt;(</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;                                <span class="keyword">new</span> EntryEventHandler&lt;protocol::codec::replicatedmap_addentrylistenertokeywithpredicate_handler&gt;(get_name(), get_context().get_client_cluster_service(),</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;                                                      get_context().get_serialization_service(), std::move(listener),</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;                                                      get_context().get_logger())), to_data(key), to_data(predicate));</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab3a9d86877d2e9f16eed7c7da6a0e1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a9d86877d2e9f16eed7c7da6a0e1c1">&#9670;&nbsp;</a></span>contains_key()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;bool&gt; hazelcast::client::replicated_map::contains_key </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to be checked for existence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entry with the key exist in the replicated map. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d32/replicated__map_8h_source.html#l00212">212</a> of file <a class="el" href="../../dc/d32/replicated__map_8h_source.html">replicated_map.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                                                         {</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                <span class="keywordflow">return</span> contains_key_data(to_data(key));</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a35456a88ab46981ab02305c133ee6a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35456a88ab46981ab02305c133ee6a73">&#9670;&nbsp;</a></span>contains_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;bool&gt; hazelcast::client::replicated_map::contains_value </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to check in the replicated map for existence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value exist in the replicated map. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d32/replicated__map_8h_source.html#l00222">222</a> of file <a class="el" href="../../dc/d32/replicated__map_8h_source.html">replicated_map.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;                                                             {</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                <span class="keywordflow">return</span> contains_value_data(to_data(value));</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aff0208adba5a1ed1458e2b35d18a387a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0208adba5a1ed1458e2b35d18a387a">&#9670;&nbsp;</a></span>entry_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;std::vector&lt;std::pair&lt;K, V&gt; &gt; &gt; hazelcast::client::replicated_map::entry_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a view of the mappings contained in this map. </p>
<p><br  />
 Due to the lazy nature of the returned array, changes to the map (addition, removal, update) might be reflected on the array.<br  />
 Changes on the map are <b>NOT</b> reflected on the set on the <b>CLIENT</b> or vice versa. The order of the elements is not guaranteed due to the internal asynchronous replication behavior.<br  />
 Changes to any returned object are <b>NOT</b> replicated back to other members.</p>
<dl class="section return"><dt>Returns</dt><dd>view of the mappings contained in this map. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d32/replicated__map_8h_source.html#l00185">185</a> of file <a class="el" href="../../dc/d32/replicated__map_8h_source.html">replicated_map.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;                                                              {</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                <span class="keywordflow">return</span> to_entry_object_vector&lt;K,V&gt;(entry_set_data());</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa6511680340bcff3b2808c119a46c82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6511680340bcff3b2808c119a46c82a">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;boost::optional&lt;V&gt; &gt; hazelcast::client::replicated_map::get </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to be used to query from replicated map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the key if the key exist, null pointer otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d32/replicated__map_8h_source.html#l00232">232</a> of file <a class="el" href="../../dc/d32/replicated__map_8h_source.html">replicated_map.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;                                                            {</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;                <span class="keywordflow">return</span> to_object&lt;V&gt;(get_data(to_data(key)));</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5b38206fb39e5142e581602a0515a77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b38206fb39e5142e581602a0515a77e">&#9670;&nbsp;</a></span>key_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;std::vector&lt;K&gt; &gt; hazelcast::client::replicated_map::key_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a view of the keys contained in this map. </p>
<p><br  />
 Due to the lazy nature of the returned array, changes to the map (addition, removal, update) might be reflected on the array.<br  />
 Changes on the map are <b>NOT</b> reflected on the set on the <b>CLIENT</b> or vice versa. The order of the elements is not guaranteed due to the internal asynchronous replication behavior.<br  />
 Changes to any returned object are <b>NOT</b> replicated back to other members.</p>
<dl class="section return"><dt>Returns</dt><dd>The keys contained in this map. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d32/replicated__map_8h_source.html#l00202">202</a> of file <a class="el" href="../../dc/d32/replicated__map_8h_source.html">replicated_map.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;                                                {</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;                <span class="keywordflow">return</span> to_object_vector&lt;K&gt;(key_set_data());</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a91b6f49eda4db1770d2faff2c8dfdfbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91b6f49eda4db1770d2faff2c8dfdfbd">&#9670;&nbsp;</a></span>put() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename R  = V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;boost::optional&lt;R&gt; &gt; hazelcast::client::replicated_map::put </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to be put into the replicated map. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous value if the key existed in the map or null pointer otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d32/replicated__map_8h_source.html#l00243">243</a> of file <a class="el" href="../../dc/d32/replicated__map_8h_source.html">replicated_map.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;                                                                            {</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;                <span class="keywordflow">return</span> put&lt;K, V, R&gt;(key, value, std::chrono::milliseconds(0));</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab8e0de2c71b4fcbcfa3502eaa3acc76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e0de2c71b4fcbcfa3502eaa3acc76f">&#9670;&nbsp;</a></span>put() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V , typename R  = V&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;boost::optional&lt;R&gt; &gt; hazelcast::client::replicated_map::put </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>ttl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Associates a given value to the specified key and replicates it to the cluster. If there is an old value, it will be replaced by the specified one and returned from the call.</p>
<p>In addition, you have to specify a ttl in milliseconds to define when the value is outdated and thus should be removed from the replicated map.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>key with which the specified value is to be associated. </td></tr>
    <tr><td class="paramname">value</td><td>value to be associated with the specified key. </td></tr>
    <tr><td class="paramname">ttl</td><td>ttl to be associated with the specified key-value pair. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous value associated with <code>key</code>, or <code>empty</code> if there was no mapping for <code>key</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d32/replicated__map_8h_source.html#l00065">65</a> of file <a class="el" href="../../dc/d32/replicated__map_8h_source.html">replicated_map.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;                                                                                                       {</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;                <span class="keywordflow">return</span> to_object&lt;R&gt;(put_data(to_data(key), to_data(value), ttl));</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2844990171e3539e605f6d44d1828d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2844990171e3539e605f6d44d1828d9f">&#9670;&nbsp;</a></span>put_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;void&gt; hazelcast::client::replicated_map::put_all </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; K, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>entries</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies all of the mappings from the specified map to this map (optional operation). </p>
<p>The effect of this call is equivalent to that of calling put(k, v) on this map once for each mapping from key <code>k</code> to value <code>v</code> in the specified map. The behavior of this operation is undefined if the specified map is modified while the operation is in progress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entries</td><td>mappings to be stored in this map </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d32/replicated__map_8h_source.html#l00080">80</a> of file <a class="el" href="../../dc/d32/replicated__map_8h_source.html">replicated_map.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;                                                                             {</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;                <span class="keywordflow">return</span> put_all_data(to_data_entries(entries));</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab7eed6cade380b5b63c6ff5e22e32356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7eed6cade380b5b63c6ff5e22e32356">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;boost::optional&lt;V&gt; &gt; hazelcast::client::replicated_map::remove </td>
          <td>(</td>
          <td class="paramtype">const K &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the entry to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value associated with the removed key. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d32/replicated__map_8h_source.html#l00253">253</a> of file <a class="el" href="../../dc/d32/replicated__map_8h_source.html">replicated_map.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;                                                               {</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;                <span class="keywordflow">return</span> to_object&lt;V&gt;(remove_data(to_data(key)));</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a82f3c8b0226c890e1071c2412bdd991c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f3c8b0226c890e1071c2412bdd991c">&#9670;&nbsp;</a></span>values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::future&lt;std::vector&lt;V&gt; &gt; hazelcast::client::replicated_map::values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Due to the lazy nature of the returned array, changes to the map (addition, removal, update) might be reflected on the collection. </p>
<p><br  />
 Changes on the map are <b>NOT</b> reflected on the collection on the <b>CLIENT</b> or vice versa. The order of the elements is not guaranteed due to the internal asynchronous replication behavior. If a specific order is needed, use <a class="el" href="../../">values(Comparator)</a> to force reordering of the elements before returning.<br  />
 Changes to any returned object are <b>NOT</b> replicated back to other members.</p>
<dl class="section return"><dt>Returns</dt><dd>A collection view of the values contained in this map. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../dc/d32/replicated__map_8h_source.html#l00168">168</a> of file <a class="el" href="../../dc/d32/replicated__map_8h_source.html">replicated_map.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;                                               {</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                <span class="keywordflow">return</span> to_object_vector&lt;V&gt;(values_data());</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;            }</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>hazelcast/include/hazelcast/client/<a class="el" href="../../dc/d32/replicated__map_8h_source.html">replicated_map.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>hazelcast</b></li><li class="navelem"><b>client</b></li><li class="navelem"><a class="el" href="../../d7/dc0/classhazelcast_1_1client_1_1replicated__map.html">replicated_map</a></li>
    <li class="footer">Generated on Thu Oct 14 2021 21:21:32 for Hazelcast C++ Client by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
