<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hazelcast C++ Client: hazelcast::client::serialization::generic_record::generic_record_builder Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../IMDG_blue_logo_square_RGB-dark_200px.png"/></td>
  <td id="projectalign">
   <div id="projectname">Hazelcast C++ Client
   </div>
   <div id="projectbrief">Hazelcast C++ Client Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../d7/dce/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">hazelcast::client::serialization::generic_record::generic_record_builder Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Concrete class for creating <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a></code> instances.  
 <a href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d9/da1/generic__record__builder_8h_source.html">generic_record_builder.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acee08c2846938d966e0c1ce460147aa2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#acee08c2846938d966e0c1ce460147aa2">generic_record_builder</a> (std::string type_name)</td></tr>
<tr class="memdesc:acee08c2846938d966e0c1ce460147aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Builder that will build a <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a></code> in Compact format with the given type name and schema:  <br /></td></tr>
<tr class="separator:acee08c2846938d966e0c1ce460147aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3c7a4a929dde035fdba415a5041942"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a2d3c7a4a929dde035fdba415a5041942">build</a> ()</td></tr>
<tr class="separator:a2d3c7a4a929dde035fdba415a5041942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e6d067bf48f5a435e14739ca55a5c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a82e6d067bf48f5a435e14739ca55a5c4">set_boolean</a> (std::string field_name, bool value)</td></tr>
<tr class="memdesc:a82e6d067bf48f5a435e14739ca55a5c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a82e6d067bf48f5a435e14739ca55a5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b67edeb81a1bb7bd756bdf49882addf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a2b67edeb81a1bb7bd756bdf49882addf">set_int8</a> (std::string field_name, int8_t value)</td></tr>
<tr class="memdesc:a2b67edeb81a1bb7bd756bdf49882addf"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a2b67edeb81a1bb7bd756bdf49882addf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361e26e89d3cf580e826f636147f5737"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a361e26e89d3cf580e826f636147f5737">set_int16</a> (std::string field_name, int16_t value)</td></tr>
<tr class="memdesc:a361e26e89d3cf580e826f636147f5737"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a361e26e89d3cf580e826f636147f5737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab965a70a0a60cbb9779fc1491e4c2a15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#ab965a70a0a60cbb9779fc1491e4c2a15">set_int32</a> (std::string field_name, int32_t value)</td></tr>
<tr class="memdesc:ab965a70a0a60cbb9779fc1491e4c2a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:ab965a70a0a60cbb9779fc1491e4c2a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26709d0da12d0705d0acc3d1189be2c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a26709d0da12d0705d0acc3d1189be2c3">set_int64</a> (std::string field_name, int64_t value)</td></tr>
<tr class="memdesc:a26709d0da12d0705d0acc3d1189be2c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a26709d0da12d0705d0acc3d1189be2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6670feaba2a929f56ebcb7c42e36b345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a6670feaba2a929f56ebcb7c42e36b345">set_float32</a> (std::string field_name, float value)</td></tr>
<tr class="memdesc:a6670feaba2a929f56ebcb7c42e36b345"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a6670feaba2a929f56ebcb7c42e36b345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4736a3261d7b1dcf3a15bba6bc6164b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#ab4736a3261d7b1dcf3a15bba6bc6164b">set_float64</a> (std::string field_name, double value)</td></tr>
<tr class="memdesc:ab4736a3261d7b1dcf3a15bba6bc6164b"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:ab4736a3261d7b1dcf3a15bba6bc6164b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c6bba1ea026de4630d38e152b5ca42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a63c6bba1ea026de4630d38e152b5ca42">set_nullable_boolean</a> (std::string field_name, boost::optional&lt; bool &gt; value)</td></tr>
<tr class="memdesc:a63c6bba1ea026de4630d38e152b5ca42"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a63c6bba1ea026de4630d38e152b5ca42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e863d9f34eab0ce68b880e8f26c46a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a33e863d9f34eab0ce68b880e8f26c46a">set_nullable_int8</a> (std::string field_name, boost::optional&lt; int8_t &gt; value)</td></tr>
<tr class="memdesc:a33e863d9f34eab0ce68b880e8f26c46a"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a33e863d9f34eab0ce68b880e8f26c46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa641756447950340066a298312ce66a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#afa641756447950340066a298312ce66a">set_nullable_int16</a> (std::string field_name, boost::optional&lt; int16_t &gt; value)</td></tr>
<tr class="memdesc:afa641756447950340066a298312ce66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:afa641756447950340066a298312ce66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af203aa17d2704b1bf5e9c21df575c548"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#af203aa17d2704b1bf5e9c21df575c548">set_nullable_int32</a> (std::string field_name, boost::optional&lt; int32_t &gt; value)</td></tr>
<tr class="memdesc:af203aa17d2704b1bf5e9c21df575c548"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:af203aa17d2704b1bf5e9c21df575c548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d46a90ecc102c5e0b5c194cef58914f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a5d46a90ecc102c5e0b5c194cef58914f">set_nullable_int64</a> (std::string field_name, boost::optional&lt; int64_t &gt; value)</td></tr>
<tr class="memdesc:a5d46a90ecc102c5e0b5c194cef58914f"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a5d46a90ecc102c5e0b5c194cef58914f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab902263ab1285c134cc9f0f34c7a0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a3ab902263ab1285c134cc9f0f34c7a0c">set_nullable_float32</a> (std::string field_name, boost::optional&lt; float &gt; value)</td></tr>
<tr class="memdesc:a3ab902263ab1285c134cc9f0f34c7a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a3ab902263ab1285c134cc9f0f34c7a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c20ce368f4bd599755b23414ba0258a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a7c20ce368f4bd599755b23414ba0258a">set_nullable_float64</a> (std::string field_name, boost::optional&lt; double &gt; value)</td></tr>
<tr class="memdesc:a7c20ce368f4bd599755b23414ba0258a"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a7c20ce368f4bd599755b23414ba0258a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a3fa8e39ee8f95671e07434cecaa00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#ae9a3fa8e39ee8f95671e07434cecaa00">set_string</a> (std::string field_name, boost::optional&lt; std::string &gt; value)</td></tr>
<tr class="memdesc:ae9a3fa8e39ee8f95671e07434cecaa00"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:ae9a3fa8e39ee8f95671e07434cecaa00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8946d5d49a2f7f61e28d51a45d7b090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#ab8946d5d49a2f7f61e28d51a45d7b090">set_string</a> (std::string field_name, const char *cstr)</td></tr>
<tr class="memdesc:ab8946d5d49a2f7f61e28d51a45d7b090"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:ab8946d5d49a2f7f61e28d51a45d7b090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bc179c66aedb6b757854bb0f2206d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a15bc179c66aedb6b757854bb0f2206d3">set_generic_record</a> (std::string field_name, boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt; value)</td></tr>
<tr class="memdesc:a15bc179c66aedb6b757854bb0f2206d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a15bc179c66aedb6b757854bb0f2206d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c92ec939bf71952ca4a5ac018a4dd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a31c92ec939bf71952ca4a5ac018a4dd4">set_decimal</a> (std::string field_name, boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; value)</td></tr>
<tr class="memdesc:a31c92ec939bf71952ca4a5ac018a4dd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a decimal which is arbitrary precision and scale floating-point number.  <br /></td></tr>
<tr class="separator:a31c92ec939bf71952ca4a5ac018a4dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11db0aef5a4ff2adffe3b395edaa4243"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a11db0aef5a4ff2adffe3b395edaa4243">set_time</a> (std::string field_name, boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; value)</td></tr>
<tr class="memdesc:a11db0aef5a4ff2adffe3b395edaa4243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a time field consisting of hour, minute, seconds, and nanos parts.  <br /></td></tr>
<tr class="separator:a11db0aef5a4ff2adffe3b395edaa4243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecce465e4243e41b10b4610cebc3cef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a8ecce465e4243e41b10b4610cebc3cef">set_date</a> (std::string field_name, boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; value)</td></tr>
<tr class="memdesc:a8ecce465e4243e41b10b4610cebc3cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a date field consisting of year, month of the year, and day of the month.  <br /></td></tr>
<tr class="separator:a8ecce465e4243e41b10b4610cebc3cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129faf5453205497eaa671385918063e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a129faf5453205497eaa671385918063e">set_timestamp</a> (std::string field_name, boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; value)</td></tr>
<tr class="memdesc:a129faf5453205497eaa671385918063e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a timestamp field consisting of year, month of the year, and day of the month, hour, minute, seconds, nanos parts.  <br /></td></tr>
<tr class="separator:a129faf5453205497eaa671385918063e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee9b8572a7a1cb1e310defab0b039d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a6ee9b8572a7a1cb1e310defab0b039d5">set_timestamp_with_timezone</a> (std::string field_name, boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; value)</td></tr>
<tr class="memdesc:a6ee9b8572a7a1cb1e310defab0b039d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a timestamp with timezone field consisting of year, month of the year and day of the month, offset seconds, hour, minute, seconds, nanos parts.  <br /></td></tr>
<tr class="separator:a6ee9b8572a7a1cb1e310defab0b039d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cbee392e842c27b5b47ee1886d7281"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a18cbee392e842c27b5b47ee1886d7281">set_array_of_boolean</a> (std::string field_name, boost::optional&lt; std::vector&lt; bool &gt; &gt; value)</td></tr>
<tr class="memdesc:a18cbee392e842c27b5b47ee1886d7281"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a18cbee392e842c27b5b47ee1886d7281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451345931b7cb0031d0a2e8bfe737d2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a451345931b7cb0031d0a2e8bfe737d2b">set_array_of_boolean</a> (std::string field_name, std::vector&lt; bool &gt; value)</td></tr>
<tr class="memdesc:a451345931b7cb0031d0a2e8bfe737d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a451345931b7cb0031d0a2e8bfe737d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844924355a13d3e5a6d10d854f45c9d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a844924355a13d3e5a6d10d854f45c9d1">set_array_of_boolean</a> (std::string field_name, std::initializer_list&lt; bool &gt; value)</td></tr>
<tr class="memdesc:a844924355a13d3e5a6d10d854f45c9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a844924355a13d3e5a6d10d854f45c9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07197b699f3068d17d5b0d9c70e3bb93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a07197b699f3068d17d5b0d9c70e3bb93">set_array_of_int8</a> (std::string field_name, boost::optional&lt; std::vector&lt; int8_t &gt; &gt; value)</td></tr>
<tr class="memdesc:a07197b699f3068d17d5b0d9c70e3bb93"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a07197b699f3068d17d5b0d9c70e3bb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3713bc46bfac43744fb1ea3d5165dbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#aa3713bc46bfac43744fb1ea3d5165dbf">set_array_of_int8</a> (std::string field_name, std::vector&lt; int8_t &gt; value)</td></tr>
<tr class="memdesc:aa3713bc46bfac43744fb1ea3d5165dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:aa3713bc46bfac43744fb1ea3d5165dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf92e8d1114c8771bb730c1bceb4d285"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#adf92e8d1114c8771bb730c1bceb4d285">set_array_of_int8</a> (std::string field_name, std::initializer_list&lt; int8_t &gt; value)</td></tr>
<tr class="memdesc:adf92e8d1114c8771bb730c1bceb4d285"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:adf92e8d1114c8771bb730c1bceb4d285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82178b787818945873bb0dd68c8ecd60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a82178b787818945873bb0dd68c8ecd60">set_array_of_int16</a> (std::string field_name, boost::optional&lt; std::vector&lt; int16_t &gt; &gt; value)</td></tr>
<tr class="memdesc:a82178b787818945873bb0dd68c8ecd60"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a82178b787818945873bb0dd68c8ecd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fc0c5bd0989c2b73f86f4e0b9d4ec1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#ab4fc0c5bd0989c2b73f86f4e0b9d4ec1">set_array_of_int16</a> (std::string field_name, std::vector&lt; int16_t &gt; value)</td></tr>
<tr class="memdesc:ab4fc0c5bd0989c2b73f86f4e0b9d4ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:ab4fc0c5bd0989c2b73f86f4e0b9d4ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4aa12c32f86d6a0b09cdae2fa7d782f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#af4aa12c32f86d6a0b09cdae2fa7d782f">set_array_of_int16</a> (std::string field_name, std::initializer_list&lt; int16_t &gt; value)</td></tr>
<tr class="memdesc:af4aa12c32f86d6a0b09cdae2fa7d782f"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:af4aa12c32f86d6a0b09cdae2fa7d782f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac72e7cac916c9ff42ef660b701ff6c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#aac72e7cac916c9ff42ef660b701ff6c2">set_array_of_int32</a> (std::string field_name, boost::optional&lt; std::vector&lt; int32_t &gt; &gt; value)</td></tr>
<tr class="memdesc:aac72e7cac916c9ff42ef660b701ff6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:aac72e7cac916c9ff42ef660b701ff6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0e602e03d4b6546fee7788a9bb0812"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#aeb0e602e03d4b6546fee7788a9bb0812">set_array_of_int32</a> (std::string field_name, std::vector&lt; int32_t &gt; value)</td></tr>
<tr class="memdesc:aeb0e602e03d4b6546fee7788a9bb0812"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:aeb0e602e03d4b6546fee7788a9bb0812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6f8b71cf04312cceb8ea72168daecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a7f6f8b71cf04312cceb8ea72168daecd">set_array_of_int32</a> (std::string field_name, std::initializer_list&lt; int32_t &gt; value)</td></tr>
<tr class="memdesc:a7f6f8b71cf04312cceb8ea72168daecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a7f6f8b71cf04312cceb8ea72168daecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad1ebb417d02e098d70223cd8bc76a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a5ad1ebb417d02e098d70223cd8bc76a3">set_array_of_int64</a> (std::string field_name, boost::optional&lt; std::vector&lt; int64_t &gt; &gt; value)</td></tr>
<tr class="memdesc:a5ad1ebb417d02e098d70223cd8bc76a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a5ad1ebb417d02e098d70223cd8bc76a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d30b795c582d16241b073fb6d97d019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a6d30b795c582d16241b073fb6d97d019">set_array_of_int64</a> (std::string field_name, std::vector&lt; int64_t &gt; value)</td></tr>
<tr class="memdesc:a6d30b795c582d16241b073fb6d97d019"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a6d30b795c582d16241b073fb6d97d019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4abb9abcd795fb8852864c0b7667b92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#aa4abb9abcd795fb8852864c0b7667b92">set_array_of_int64</a> (std::string field_name, std::initializer_list&lt; int64_t &gt; value)</td></tr>
<tr class="memdesc:aa4abb9abcd795fb8852864c0b7667b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:aa4abb9abcd795fb8852864c0b7667b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a0775d0ed4b600f96055bbe1399f90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a87a0775d0ed4b600f96055bbe1399f90">set_array_of_float32</a> (std::string field_name, boost::optional&lt; std::vector&lt; float &gt; &gt; value)</td></tr>
<tr class="memdesc:a87a0775d0ed4b600f96055bbe1399f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a87a0775d0ed4b600f96055bbe1399f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648850a712e411010f234587959142a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a648850a712e411010f234587959142a1">set_array_of_float32</a> (std::string field_name, std::vector&lt; float &gt; value)</td></tr>
<tr class="memdesc:a648850a712e411010f234587959142a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a648850a712e411010f234587959142a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc74a0c5e94e4221a30a8856cd263ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a8cc74a0c5e94e4221a30a8856cd263ee">set_array_of_float32</a> (std::string field_name, std::initializer_list&lt; float &gt; value)</td></tr>
<tr class="memdesc:a8cc74a0c5e94e4221a30a8856cd263ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a8cc74a0c5e94e4221a30a8856cd263ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a87b7095e594e7742ecdf77ff72ea4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a58a87b7095e594e7742ecdf77ff72ea4">set_array_of_float64</a> (std::string field_name, boost::optional&lt; std::vector&lt; double &gt; &gt; value)</td></tr>
<tr class="memdesc:a58a87b7095e594e7742ecdf77ff72ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a58a87b7095e594e7742ecdf77ff72ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32630ea67fba8a2a580cd150b4308d9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a32630ea67fba8a2a580cd150b4308d9a">set_array_of_float64</a> (std::string field_name, std::vector&lt; double &gt; value)</td></tr>
<tr class="memdesc:a32630ea67fba8a2a580cd150b4308d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a32630ea67fba8a2a580cd150b4308d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14418076a65f386c4ed0f76dba034018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a14418076a65f386c4ed0f76dba034018">set_array_of_float64</a> (std::string field_name, std::initializer_list&lt; double &gt; value)</td></tr>
<tr class="memdesc:a14418076a65f386c4ed0f76dba034018"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a14418076a65f386c4ed0f76dba034018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c56c2f2387424d471e0ef994f2e54a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a24c56c2f2387424d471e0ef994f2e54a">set_array_of_nullable_boolean</a> (std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; bool &gt; &gt; &gt; value)</td></tr>
<tr class="memdesc:a24c56c2f2387424d471e0ef994f2e54a"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a24c56c2f2387424d471e0ef994f2e54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990a0bde746eb6ad86adbcb44cb8b5dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a990a0bde746eb6ad86adbcb44cb8b5dd">set_array_of_nullable_boolean</a> (std::string field_name, std::vector&lt; bool &gt; value)</td></tr>
<tr class="memdesc:a990a0bde746eb6ad86adbcb44cb8b5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a990a0bde746eb6ad86adbcb44cb8b5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42b8efbdb300f771e95f41a72b24ebd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#ac42b8efbdb300f771e95f41a72b24ebd">set_array_of_nullable_boolean</a> (std::string field_name, std::initializer_list&lt; bool &gt; value)</td></tr>
<tr class="memdesc:ac42b8efbdb300f771e95f41a72b24ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:ac42b8efbdb300f771e95f41a72b24ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c50cca35b912ec4eb9cdf3c96df5e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a32c50cca35b912ec4eb9cdf3c96df5e6">set_array_of_nullable_int8</a> (std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; int8_t &gt; &gt; &gt; value)</td></tr>
<tr class="memdesc:a32c50cca35b912ec4eb9cdf3c96df5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a32c50cca35b912ec4eb9cdf3c96df5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a0fe89caea0d20c198ad57b978f748d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a1a0fe89caea0d20c198ad57b978f748d">set_array_of_nullable_int8</a> (std::string field_name, std::vector&lt; int8_t &gt; value)</td></tr>
<tr class="memdesc:a1a0fe89caea0d20c198ad57b978f748d"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a1a0fe89caea0d20c198ad57b978f748d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae22a25b07de03c373fbb7b20104dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#afae22a25b07de03c373fbb7b20104dae">set_array_of_nullable_int8</a> (std::string field_name, std::initializer_list&lt; int8_t &gt; value)</td></tr>
<tr class="memdesc:afae22a25b07de03c373fbb7b20104dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:afae22a25b07de03c373fbb7b20104dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4113b36ffb452109b4c5c55aa9324554"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a4113b36ffb452109b4c5c55aa9324554">set_array_of_nullable_int16</a> (std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; int16_t &gt; &gt; &gt; value)</td></tr>
<tr class="memdesc:a4113b36ffb452109b4c5c55aa9324554"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a4113b36ffb452109b4c5c55aa9324554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea852dc9a0284d5495a0d6df3410e22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a7ea852dc9a0284d5495a0d6df3410e22">set_array_of_nullable_int16</a> (std::string field_name, std::vector&lt; int16_t &gt; value)</td></tr>
<tr class="memdesc:a7ea852dc9a0284d5495a0d6df3410e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a7ea852dc9a0284d5495a0d6df3410e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551b5eea861df464399471c3cfb38f55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a551b5eea861df464399471c3cfb38f55">set_array_of_nullable_int16</a> (std::string field_name, std::initializer_list&lt; int16_t &gt; value)</td></tr>
<tr class="memdesc:a551b5eea861df464399471c3cfb38f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a551b5eea861df464399471c3cfb38f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398378f7a73a62833204cdfc086e03a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a398378f7a73a62833204cdfc086e03a5">set_array_of_nullable_int32</a> (std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; int32_t &gt; &gt; &gt; value)</td></tr>
<tr class="memdesc:a398378f7a73a62833204cdfc086e03a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a398378f7a73a62833204cdfc086e03a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790c3233608bcace0cbfc36896b26b1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a790c3233608bcace0cbfc36896b26b1a">set_array_of_nullable_int32</a> (std::string field_name, std::vector&lt; int32_t &gt; value)</td></tr>
<tr class="memdesc:a790c3233608bcace0cbfc36896b26b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a790c3233608bcace0cbfc36896b26b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c03cefe20b13b77bd9c9f344c6c7957"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a8c03cefe20b13b77bd9c9f344c6c7957">set_array_of_nullable_int32</a> (std::string field_name, std::initializer_list&lt; int32_t &gt; value)</td></tr>
<tr class="memdesc:a8c03cefe20b13b77bd9c9f344c6c7957"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a8c03cefe20b13b77bd9c9f344c6c7957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9a032f8ac8dcdc671a6ad04e881dfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a1f9a032f8ac8dcdc671a6ad04e881dfb">set_array_of_nullable_int64</a> (std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; int64_t &gt; &gt; &gt; value)</td></tr>
<tr class="memdesc:a1f9a032f8ac8dcdc671a6ad04e881dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a1f9a032f8ac8dcdc671a6ad04e881dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa993ad2be8794b85d0be448f2e4ff763"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#aa993ad2be8794b85d0be448f2e4ff763">set_array_of_nullable_int64</a> (std::string field_name, std::vector&lt; int64_t &gt; value)</td></tr>
<tr class="memdesc:aa993ad2be8794b85d0be448f2e4ff763"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:aa993ad2be8794b85d0be448f2e4ff763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed218c833339efa31aedb65225a049b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#aed218c833339efa31aedb65225a049b1">set_array_of_nullable_int64</a> (std::string field_name, std::initializer_list&lt; int64_t &gt; value)</td></tr>
<tr class="memdesc:aed218c833339efa31aedb65225a049b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:aed218c833339efa31aedb65225a049b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dcb6285bfa215470a67d1993ea64b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a41dcb6285bfa215470a67d1993ea64b9">set_array_of_nullable_float32</a> (std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; float &gt; &gt; &gt; value)</td></tr>
<tr class="memdesc:a41dcb6285bfa215470a67d1993ea64b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a41dcb6285bfa215470a67d1993ea64b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad843b871c8c22ece48dfe474fef2876b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#ad843b871c8c22ece48dfe474fef2876b">set_array_of_nullable_float32</a> (std::string field_name, std::vector&lt; float &gt; value)</td></tr>
<tr class="memdesc:ad843b871c8c22ece48dfe474fef2876b"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:ad843b871c8c22ece48dfe474fef2876b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552aff450eaa3c26e7e4c41850a3c406"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a552aff450eaa3c26e7e4c41850a3c406">set_array_of_nullable_float32</a> (std::string field_name, std::initializer_list&lt; float &gt; value)</td></tr>
<tr class="memdesc:a552aff450eaa3c26e7e4c41850a3c406"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a552aff450eaa3c26e7e4c41850a3c406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ef618d50289e9909e5b5003a94e913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a23ef618d50289e9909e5b5003a94e913">set_array_of_nullable_float64</a> (std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; double &gt; &gt; &gt; value)</td></tr>
<tr class="memdesc:a23ef618d50289e9909e5b5003a94e913"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a23ef618d50289e9909e5b5003a94e913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f6797cb3c0e88e7b5bb59f3218ba42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#aa7f6797cb3c0e88e7b5bb59f3218ba42">set_array_of_nullable_float64</a> (std::string field_name, std::vector&lt; double &gt; value)</td></tr>
<tr class="memdesc:aa7f6797cb3c0e88e7b5bb59f3218ba42"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:aa7f6797cb3c0e88e7b5bb59f3218ba42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc37842fef3f561fed3bb7d730d8c28b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#acc37842fef3f561fed3bb7d730d8c28b">set_array_of_nullable_float64</a> (std::string field_name, std::initializer_list&lt; double &gt; value)</td></tr>
<tr class="memdesc:acc37842fef3f561fed3bb7d730d8c28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:acc37842fef3f561fed3bb7d730d8c28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3fd11aba5f9ace4ea9805d6e08ea25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a1b3fd11aba5f9ace4ea9805d6e08ea25">set_array_of_string</a> (std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; std::string &gt; &gt; &gt; value)</td></tr>
<tr class="memdesc:a1b3fd11aba5f9ace4ea9805d6e08ea25"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a1b3fd11aba5f9ace4ea9805d6e08ea25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a313ef789bab15a12726a05f3c1609608"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a313ef789bab15a12726a05f3c1609608">set_array_of_decimal</a> (std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &gt; &gt; value)</td></tr>
<tr class="memdesc:a313ef789bab15a12726a05f3c1609608"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a313ef789bab15a12726a05f3c1609608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a51468e4d3adfb3c690011ef6e8812"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#ab2a51468e4d3adfb3c690011ef6e8812">set_array_of_time</a> (std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &gt; &gt; value)</td></tr>
<tr class="memdesc:ab2a51468e4d3adfb3c690011ef6e8812"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:ab2a51468e4d3adfb3c690011ef6e8812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6839658cfeca6105d1d1943cd459d4cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a6839658cfeca6105d1d1943cd459d4cb">set_array_of_date</a> (std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &gt; &gt; value)</td></tr>
<tr class="memdesc:a6839658cfeca6105d1d1943cd459d4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a6839658cfeca6105d1d1943cd459d4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc857fbeed9acb9840f510626a3bc5e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#afc857fbeed9acb9840f510626a3bc5e4">set_array_of_timestamp</a> (std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &gt; &gt; value)</td></tr>
<tr class="memdesc:afc857fbeed9acb9840f510626a3bc5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:afc857fbeed9acb9840f510626a3bc5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d31c8b48cd77433b8c84acade0ef7b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a5d31c8b48cd77433b8c84acade0ef7b7">set_array_of_timestamp_with_timezone</a> (std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &gt; &gt; value)</td></tr>
<tr class="memdesc:a5d31c8b48cd77433b8c84acade0ef7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:a5d31c8b48cd77433b8c84acade0ef7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb0fe9b6089aaa21d547053a690d381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#afeb0fe9b6089aaa21d547053a690d381">set_array_of_generic_record</a> (std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt; &gt; &gt; value)</td></tr>
<tr class="memdesc:afeb0fe9b6089aaa21d547053a690d381"><td class="mdescLeft">&#160;</td><td class="mdescRight">It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>.  <br /></td></tr>
<tr class="separator:afeb0fe9b6089aaa21d547053a690d381"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af247764fc5f749166ecf6e8d36dc0a82"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#af247764fc5f749166ecf6e8d36dc0a82">generic_record</a></td></tr>
<tr class="separator:af247764fc5f749166ecf6e8d36dc0a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a96bb9ebecd6d3a6506dffa0173d93"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a51a96bb9ebecd6d3a6506dffa0173d93">pimpl::compact_stream_serializer</a></td></tr>
<tr class="separator:a51a96bb9ebecd6d3a6506dffa0173d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Concrete class for creating <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a></code> instances. </p>
<p>It is not thread-safe. </p><dl class="section since"><dt>Since</dt><dd>5.2 </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d9/da1/generic__record__builder_8h_source.html#l00047">47</a> of file <a class="el" href="../../d9/da1/generic__record__builder_8h_source.html">generic_record_builder.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acee08c2846938d966e0c1ce460147aa2" name="acee08c2846938d966e0c1ce460147aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee08c2846938d966e0c1ce460147aa2">&#9670;&#160;</a></span>generic_record_builder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hazelcast::client::serialization::generic_record::generic_record_builder::generic_record_builder </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>type_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a Builder that will build a <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a></code> in Compact format with the given type name and schema: </p>
<pre><code class="JavaDocCode"><br/>
generic_record record = generic_record_builder{"typeName"}<br/>
                                .set_string("name", "foo")<br/>
                                .set_int32("id", 123)<br/>
                                .build();<br/>
</code></pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">typeName</td><td>of the schema </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html" title="Concrete class for creating generic_record instances.">generic_record_builder</a> for Compact format </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00084">84</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   85</span>  : strategy_{ strategy::default_builder }</div>
<div class="line"><span class="lineno">   86</span>  , already_built_{ <span class="keyword">false</span> }</div>
<div class="line"><span class="lineno">   87</span>  , writer_or_schema_{ pimpl::schema_writer{ move(type_name) } }</div>
<div class="line"><span class="lineno">   88</span>{</div>
<div class="line"><span class="lineno">   89</span>}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2d3c7a4a929dde035fdba415a5041942" name="a2d3c7a4a929dde035fdba415a5041942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d3c7a4a929dde035fdba415a5041942">&#9670;&#160;</a></span>build()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> hazelcast::client::serialization::generic_record::generic_record_builder::build </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a new constructed <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>when the <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> cannot be built. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00130">130</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  131</span>{</div>
<div class="line"><span class="lineno">  132</span>    <span class="keywordflow">if</span> (strategy_ == strategy::default_builder) {</div>
<div class="line"><span class="lineno">  133</span>        pimpl::schema_writer&amp; writer =</div>
<div class="line"><span class="lineno">  134</span>          boost::get&lt;pimpl::schema_writer&gt;(writer_or_schema_);</div>
<div class="line"><span class="lineno">  135</span> </div>
<div class="line"><span class="lineno">  136</span>        already_built_ = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  137</span>        <span class="keywordflow">return</span> generic_record{ std::make_shared&lt;pimpl::schema&gt;(std::move(writer).<a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a2d3c7a4a929dde035fdba415a5041942">build</a>()), std::move(objects_) };</div>
<div class="line"><span class="lineno">  138</span>    } <span class="keywordflow">else</span> {</div>
<div class="line"><span class="lineno">  139</span>        std::shared_ptr&lt;pimpl::schema&gt; schema = boost::get&lt;std::shared_ptr&lt;pimpl::schema&gt;&gt;(writer_or_schema_);</div>
<div class="line"><span class="lineno">  140</span> </div>
<div class="line"><span class="lineno">  141</span>        <span class="keywordflow">if</span> (strategy_ == strategy::schema_bounded) {</div>
<div class="line"><span class="lineno">  142</span>            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; fields = schema-&gt;fields();</div>
<div class="line"><span class="lineno">  143</span> </div>
<div class="line"><span class="lineno">  144</span>            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : fields) {</div>
<div class="line"><span class="lineno">  145</span>                <span class="keyword">const</span> std::string&amp; field_name = p.first;</div>
<div class="line"><span class="lineno">  146</span> </div>
<div class="line"><span class="lineno">  147</span>                <span class="keywordflow">if</span> (objects_.find(field_name) == end(objects_)) {</div>
<div class="line"><span class="lineno">  148</span>                    BOOST_THROW_EXCEPTION(exception::hazelcast_serialization{</div>
<div class="line"><span class="lineno">  149</span>                      <span class="stringliteral">&quot;Found an unset field &quot;</span> + field_name +</div>
<div class="line"><span class="lineno">  150</span>                      <span class="stringliteral">&quot;. All the fields must be set before build&quot;</span> });</div>
<div class="line"><span class="lineno">  151</span>                }</div>
<div class="line"><span class="lineno">  152</span>            }</div>
<div class="line"><span class="lineno">  153</span>        }</div>
<div class="line"><span class="lineno">  154</span> </div>
<div class="line"><span class="lineno">  155</span>        already_built_ = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  156</span>        <span class="keywordflow">return</span> generic_record{ move(schema), std::move(objects_) };</div>
<div class="line"><span class="lineno">  157</span>    }</div>
<div class="line"><span class="lineno">  158</span>}</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder_html_a2d3c7a4a929dde035fdba415a5041942"><div class="ttname"><a href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a2d3c7a4a929dde035fdba415a5041942">hazelcast::client::serialization::generic_record::generic_record_builder::build</a></div><div class="ttdeci">generic_record build()</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d82/compact_8cpp_source.html#l00130">compact.cpp:130</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a18cbee392e842c27b5b47ee1886d7281" name="a18cbee392e842c27b5b47ee1886d7281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18cbee392e842c27b5b47ee1886d7281">&#9670;&#160;</a></span>set_array_of_boolean() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_boolean </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; bool &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00303">303</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  306</span>{</div>
<div class="line"><span class="lineno">  307</span>    <span class="keywordflow">return</span> write(</div>
<div class="line"><span class="lineno">  308</span>      move(field_name), std::move(value), field_kind::ARRAY_OF_BOOLEAN);</div>
<div class="line"><span class="lineno">  309</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a844924355a13d3e5a6d10d854f45c9d1" name="a844924355a13d3e5a6d10d854f45c9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844924355a13d3e5a6d10d854f45c9d1">&#9670;&#160;</a></span>set_array_of_boolean() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_boolean </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00320">320</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  322</span>{</div>
<div class="line"><span class="lineno">  323</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a18cbee392e842c27b5b47ee1886d7281">set_array_of_boolean</a>(</div>
<div class="line"><span class="lineno">  324</span>        move(field_name), std::vector&lt;bool&gt;(value));</div>
<div class="line"><span class="lineno">  325</span>}</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder_html_a18cbee392e842c27b5b47ee1886d7281"><div class="ttname"><a href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a18cbee392e842c27b5b47ee1886d7281">hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_boolean</a></div><div class="ttdeci">generic_record_builder &amp; set_array_of_boolean(std::string field_name, boost::optional&lt; std::vector&lt; bool &gt; &gt; value)</div><div class="ttdoc">It is legal to set the field again only when Builder is created with generic_record::new_builder_with...</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d82/compact_8cpp_source.html#l00303">compact.cpp:303</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a451345931b7cb0031d0a2e8bfe737d2b" name="a451345931b7cb0031d0a2e8bfe737d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451345931b7cb0031d0a2e8bfe737d2b">&#9670;&#160;</a></span>set_array_of_boolean() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_boolean </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00312">312</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  314</span>{</div>
<div class="line"><span class="lineno">  315</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a18cbee392e842c27b5b47ee1886d7281">set_array_of_boolean</a>(</div>
<div class="line"><span class="lineno">  316</span>      move(field_name), boost::optional&lt;std::vector&lt;bool&gt;&gt;(move(value)));</div>
<div class="line"><span class="lineno">  317</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6839658cfeca6105d1d1943cd459d4cb" name="a6839658cfeca6105d1d1943cd459d4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6839658cfeca6105d1d1943cd459d4cb">&#9670;&#160;</a></span>set_array_of_date()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_date </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. Array items can not be null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a8ecce465e4243e41b10b4610cebc3cef" title="Sets a date field consisting of year, month of the year, and day of the month.">set_date()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00696">696</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  699</span>{</div>
<div class="line"><span class="lineno">  700</span>    <span class="keywordflow">return</span> write(move(field_name), std::move(value), field_kind::ARRAY_OF_DATE);</div>
<div class="line"><span class="lineno">  701</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a313ef789bab15a12726a05f3c1609608" name="a313ef789bab15a12726a05f3c1609608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a313ef789bab15a12726a05f3c1609608">&#9670;&#160;</a></span>set_array_of_decimal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_decimal </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. Array items can not be null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a31c92ec939bf71952ca4a5ac018a4dd4" title="Sets a decimal which is arbitrary precision and scale floating-point number.">set_decimal()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00679">679</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  682</span>{</div>
<div class="line"><span class="lineno">  683</span>    <span class="keywordflow">return</span> write(</div>
<div class="line"><span class="lineno">  684</span>      move(field_name), std::move(value), field_kind::ARRAY_OF_DECIMAL);</div>
<div class="line"><span class="lineno">  685</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a87a0775d0ed4b600f96055bbe1399f90" name="a87a0775d0ed4b600f96055bbe1399f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a0775d0ed4b600f96055bbe1399f90">&#9670;&#160;</a></span>set_array_of_float32() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_float32 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; float &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00427">427</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  430</span>{</div>
<div class="line"><span class="lineno">  431</span>    <span class="keywordflow">return</span> write(</div>
<div class="line"><span class="lineno">  432</span>      move(field_name), std::move(value), field_kind::ARRAY_OF_FLOAT32);</div>
<div class="line"><span class="lineno">  433</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8cc74a0c5e94e4221a30a8856cd263ee" name="a8cc74a0c5e94e4221a30a8856cd263ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc74a0c5e94e4221a30a8856cd263ee">&#9670;&#160;</a></span>set_array_of_float32() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_float32 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; float &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00444">444</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  446</span>{</div>
<div class="line"><span class="lineno">  447</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a87a0775d0ed4b600f96055bbe1399f90">set_array_of_float32</a>(</div>
<div class="line"><span class="lineno">  448</span>        move(field_name), std::vector&lt;float&gt;(value));</div>
<div class="line"><span class="lineno">  449</span>}</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder_html_a87a0775d0ed4b600f96055bbe1399f90"><div class="ttname"><a href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a87a0775d0ed4b600f96055bbe1399f90">hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_float32</a></div><div class="ttdeci">generic_record_builder &amp; set_array_of_float32(std::string field_name, boost::optional&lt; std::vector&lt; float &gt; &gt; value)</div><div class="ttdoc">It is legal to set the field again only when Builder is created with generic_record::new_builder_with...</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d82/compact_8cpp_source.html#l00427">compact.cpp:427</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a648850a712e411010f234587959142a1" name="a648850a712e411010f234587959142a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648850a712e411010f234587959142a1">&#9670;&#160;</a></span>set_array_of_float32() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_float32 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00436">436</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  438</span>{</div>
<div class="line"><span class="lineno">  439</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a87a0775d0ed4b600f96055bbe1399f90">set_array_of_float32</a>(</div>
<div class="line"><span class="lineno">  440</span>      move(field_name), boost::optional&lt;std::vector&lt;float&gt;&gt;(move(value)));</div>
<div class="line"><span class="lineno">  441</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a58a87b7095e594e7742ecdf77ff72ea4" name="a58a87b7095e594e7742ecdf77ff72ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a87b7095e594e7742ecdf77ff72ea4">&#9670;&#160;</a></span>set_array_of_float64() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_float64 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; double &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00452">452</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  455</span>{</div>
<div class="line"><span class="lineno">  456</span>    <span class="keywordflow">return</span> write(</div>
<div class="line"><span class="lineno">  457</span>      move(field_name), std::move(value), field_kind::ARRAY_OF_FLOAT64);</div>
<div class="line"><span class="lineno">  458</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a14418076a65f386c4ed0f76dba034018" name="a14418076a65f386c4ed0f76dba034018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14418076a65f386c4ed0f76dba034018">&#9670;&#160;</a></span>set_array_of_float64() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_float64 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; double &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00469">469</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  471</span>{</div>
<div class="line"><span class="lineno">  472</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a58a87b7095e594e7742ecdf77ff72ea4">set_array_of_float64</a>(</div>
<div class="line"><span class="lineno">  473</span>        move(field_name), std::vector&lt;double&gt;(value));</div>
<div class="line"><span class="lineno">  474</span>}</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder_html_a58a87b7095e594e7742ecdf77ff72ea4"><div class="ttname"><a href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a58a87b7095e594e7742ecdf77ff72ea4">hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_float64</a></div><div class="ttdeci">generic_record_builder &amp; set_array_of_float64(std::string field_name, boost::optional&lt; std::vector&lt; double &gt; &gt; value)</div><div class="ttdoc">It is legal to set the field again only when Builder is created with generic_record::new_builder_with...</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d82/compact_8cpp_source.html#l00452">compact.cpp:452</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a32630ea67fba8a2a580cd150b4308d9a" name="a32630ea67fba8a2a580cd150b4308d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32630ea67fba8a2a580cd150b4308d9a">&#9670;&#160;</a></span>set_array_of_float64() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_float64 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00461">461</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  463</span>{</div>
<div class="line"><span class="lineno">  464</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a58a87b7095e594e7742ecdf77ff72ea4">set_array_of_float64</a>(</div>
<div class="line"><span class="lineno">  465</span>      move(field_name), boost::optional&lt;std::vector&lt;double&gt;&gt;(move(value)));</div>
<div class="line"><span class="lineno">  466</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="afeb0fe9b6089aaa21d547053a690d381" name="afeb0fe9b6089aaa21d547053a690d381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb0fe9b6089aaa21d547053a690d381">&#9670;&#160;</a></span>set_array_of_generic_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_generic_record </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. This method allows nested structures. Subclasses should also be created as <code>GenericRecord</code>. </p>
<p>Array items can not be null. </p>
<p>For Compact objects, it is not allowed write an array containing different item types or a <code><a class="el" href="../../">exception::hazelcast_serialization</a></code> will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00723">723</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  726</span>{</div>
<div class="line"><span class="lineno">  727</span>    <span class="keywordflow">return</span> write(</div>
<div class="line"><span class="lineno">  728</span>      move(field_name), std::move(value), field_kind::ARRAY_OF_COMPACT);</div>
<div class="line"><span class="lineno">  729</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a82178b787818945873bb0dd68c8ecd60" name="a82178b787818945873bb0dd68c8ecd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82178b787818945873bb0dd68c8ecd60">&#9670;&#160;</a></span>set_array_of_int16() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_int16 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; int16_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00352">352</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  355</span>{</div>
<div class="line"><span class="lineno">  356</span>    <span class="keywordflow">return</span> write(</div>
<div class="line"><span class="lineno">  357</span>      move(field_name), std::move(value), field_kind::ARRAY_OF_INT16);</div>
<div class="line"><span class="lineno">  358</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af4aa12c32f86d6a0b09cdae2fa7d782f" name="af4aa12c32f86d6a0b09cdae2fa7d782f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4aa12c32f86d6a0b09cdae2fa7d782f">&#9670;&#160;</a></span>set_array_of_int16() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_int16 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; int16_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00369">369</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  371</span>{</div>
<div class="line"><span class="lineno">  372</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a82178b787818945873bb0dd68c8ecd60">set_array_of_int16</a>(</div>
<div class="line"><span class="lineno">  373</span>        move(field_name), std::vector&lt;int16_t&gt;(value));</div>
<div class="line"><span class="lineno">  374</span>}</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder_html_a82178b787818945873bb0dd68c8ecd60"><div class="ttname"><a href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a82178b787818945873bb0dd68c8ecd60">hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_int16</a></div><div class="ttdeci">generic_record_builder &amp; set_array_of_int16(std::string field_name, boost::optional&lt; std::vector&lt; int16_t &gt; &gt; value)</div><div class="ttdoc">It is legal to set the field again only when Builder is created with generic_record::new_builder_with...</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d82/compact_8cpp_source.html#l00352">compact.cpp:352</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab4fc0c5bd0989c2b73f86f4e0b9d4ec1" name="ab4fc0c5bd0989c2b73f86f4e0b9d4ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4fc0c5bd0989c2b73f86f4e0b9d4ec1">&#9670;&#160;</a></span>set_array_of_int16() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_int16 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int16_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00361">361</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  363</span>{</div>
<div class="line"><span class="lineno">  364</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a82178b787818945873bb0dd68c8ecd60">set_array_of_int16</a>(</div>
<div class="line"><span class="lineno">  365</span>      move(field_name), boost::optional&lt;std::vector&lt;int16_t&gt;&gt;(move(value)));</div>
<div class="line"><span class="lineno">  366</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aac72e7cac916c9ff42ef660b701ff6c2" name="aac72e7cac916c9ff42ef660b701ff6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac72e7cac916c9ff42ef660b701ff6c2">&#9670;&#160;</a></span>set_array_of_int32() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_int32 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; int32_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00377">377</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  380</span>{</div>
<div class="line"><span class="lineno">  381</span>    <span class="keywordflow">return</span> write(</div>
<div class="line"><span class="lineno">  382</span>      move(field_name), std::move(value), field_kind::ARRAY_OF_INT32);</div>
<div class="line"><span class="lineno">  383</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7f6f8b71cf04312cceb8ea72168daecd" name="a7f6f8b71cf04312cceb8ea72168daecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f6f8b71cf04312cceb8ea72168daecd">&#9670;&#160;</a></span>set_array_of_int32() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_int32 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; int32_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00394">394</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  396</span>{</div>
<div class="line"><span class="lineno">  397</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#aac72e7cac916c9ff42ef660b701ff6c2">set_array_of_int32</a>(</div>
<div class="line"><span class="lineno">  398</span>        move(field_name), std::vector&lt;int32_t&gt;(value));</div>
<div class="line"><span class="lineno">  399</span>}</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder_html_aac72e7cac916c9ff42ef660b701ff6c2"><div class="ttname"><a href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#aac72e7cac916c9ff42ef660b701ff6c2">hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_int32</a></div><div class="ttdeci">generic_record_builder &amp; set_array_of_int32(std::string field_name, boost::optional&lt; std::vector&lt; int32_t &gt; &gt; value)</div><div class="ttdoc">It is legal to set the field again only when Builder is created with generic_record::new_builder_with...</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d82/compact_8cpp_source.html#l00377">compact.cpp:377</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb0e602e03d4b6546fee7788a9bb0812" name="aeb0e602e03d4b6546fee7788a9bb0812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0e602e03d4b6546fee7788a9bb0812">&#9670;&#160;</a></span>set_array_of_int32() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_int32 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int32_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00386">386</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  388</span>{</div>
<div class="line"><span class="lineno">  389</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#aac72e7cac916c9ff42ef660b701ff6c2">set_array_of_int32</a>(</div>
<div class="line"><span class="lineno">  390</span>      move(field_name), boost::optional&lt;std::vector&lt;int32_t&gt;&gt;(move(value)));</div>
<div class="line"><span class="lineno">  391</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5ad1ebb417d02e098d70223cd8bc76a3" name="a5ad1ebb417d02e098d70223cd8bc76a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad1ebb417d02e098d70223cd8bc76a3">&#9670;&#160;</a></span>set_array_of_int64() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_int64 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; int64_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00402">402</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  405</span>{</div>
<div class="line"><span class="lineno">  406</span>    <span class="keywordflow">return</span> write(</div>
<div class="line"><span class="lineno">  407</span>      move(field_name), std::move(value), field_kind::ARRAY_OF_INT64);</div>
<div class="line"><span class="lineno">  408</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa4abb9abcd795fb8852864c0b7667b92" name="aa4abb9abcd795fb8852864c0b7667b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4abb9abcd795fb8852864c0b7667b92">&#9670;&#160;</a></span>set_array_of_int64() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_int64 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00419">419</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  421</span>{</div>
<div class="line"><span class="lineno">  422</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a5ad1ebb417d02e098d70223cd8bc76a3">set_array_of_int64</a>(</div>
<div class="line"><span class="lineno">  423</span>        move(field_name), std::vector&lt;int64_t&gt;(value));</div>
<div class="line"><span class="lineno">  424</span>}</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder_html_a5ad1ebb417d02e098d70223cd8bc76a3"><div class="ttname"><a href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a5ad1ebb417d02e098d70223cd8bc76a3">hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_int64</a></div><div class="ttdeci">generic_record_builder &amp; set_array_of_int64(std::string field_name, boost::optional&lt; std::vector&lt; int64_t &gt; &gt; value)</div><div class="ttdoc">It is legal to set the field again only when Builder is created with generic_record::new_builder_with...</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d82/compact_8cpp_source.html#l00402">compact.cpp:402</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6d30b795c582d16241b073fb6d97d019" name="a6d30b795c582d16241b073fb6d97d019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d30b795c582d16241b073fb6d97d019">&#9670;&#160;</a></span>set_array_of_int64() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_int64 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00411">411</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  413</span>{</div>
<div class="line"><span class="lineno">  414</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a5ad1ebb417d02e098d70223cd8bc76a3">set_array_of_int64</a>(</div>
<div class="line"><span class="lineno">  415</span>      move(field_name), boost::optional&lt;std::vector&lt;int64_t&gt;&gt;(move(value)));</div>
<div class="line"><span class="lineno">  416</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a07197b699f3068d17d5b0d9c70e3bb93" name="a07197b699f3068d17d5b0d9c70e3bb93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07197b699f3068d17d5b0d9c70e3bb93">&#9670;&#160;</a></span>set_array_of_int8() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_int8 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; int8_t &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00328">328</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  331</span>{</div>
<div class="line"><span class="lineno">  332</span>    <span class="keywordflow">return</span> write(move(field_name), std::move(value), field_kind::ARRAY_OF_INT8);</div>
<div class="line"><span class="lineno">  333</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="adf92e8d1114c8771bb730c1bceb4d285" name="adf92e8d1114c8771bb730c1bceb4d285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf92e8d1114c8771bb730c1bceb4d285">&#9670;&#160;</a></span>set_array_of_int8() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_int8 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; int8_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00344">344</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  346</span>{</div>
<div class="line"><span class="lineno">  347</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a07197b699f3068d17d5b0d9c70e3bb93">set_array_of_int8</a>(move(field_name),</div>
<div class="line"><span class="lineno">  348</span>        std::vector&lt;int8_t&gt;(value));</div>
<div class="line"><span class="lineno">  349</span>}</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder_html_a07197b699f3068d17d5b0d9c70e3bb93"><div class="ttname"><a href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a07197b699f3068d17d5b0d9c70e3bb93">hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_int8</a></div><div class="ttdeci">generic_record_builder &amp; set_array_of_int8(std::string field_name, boost::optional&lt; std::vector&lt; int8_t &gt; &gt; value)</div><div class="ttdoc">It is legal to set the field again only when Builder is created with generic_record::new_builder_with...</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d82/compact_8cpp_source.html#l00328">compact.cpp:328</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa3713bc46bfac43744fb1ea3d5165dbf" name="aa3713bc46bfac43744fb1ea3d5165dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3713bc46bfac43744fb1ea3d5165dbf">&#9670;&#160;</a></span>set_array_of_int8() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_int8 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int8_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00336">336</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  338</span>{</div>
<div class="line"><span class="lineno">  339</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a07197b699f3068d17d5b0d9c70e3bb93">set_array_of_int8</a>(move(field_name),</div>
<div class="line"><span class="lineno">  340</span>                             boost::optional&lt;std::vector&lt;int8_t&gt;&gt;(move(value)));</div>
<div class="line"><span class="lineno">  341</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a24c56c2f2387424d471e0ef994f2e54a" name="a24c56c2f2387424d471e0ef994f2e54a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c56c2f2387424d471e0ef994f2e54a">&#9670;&#160;</a></span>set_array_of_nullable_boolean() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_boolean </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; boost::optional&lt; bool &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00492">492</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  495</span>{</div>
<div class="line"><span class="lineno">  496</span>    <span class="keywordflow">return</span> write(move(field_name),</div>
<div class="line"><span class="lineno">  497</span>                 std::move(value),</div>
<div class="line"><span class="lineno">  498</span>                 field_kind::ARRAY_OF_NULLABLE_BOOLEAN);</div>
<div class="line"><span class="lineno">  499</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac42b8efbdb300f771e95f41a72b24ebd" name="ac42b8efbdb300f771e95f41a72b24ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42b8efbdb300f771e95f41a72b24ebd">&#9670;&#160;</a></span>set_array_of_nullable_boolean() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_boolean </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact. Note that, array will be copied to transform values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00510">510</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  512</span>{</div>
<div class="line"><span class="lineno">  513</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a24c56c2f2387424d471e0ef994f2e54a">set_array_of_nullable_boolean</a>(move(field_name),</div>
<div class="line"><span class="lineno">  514</span>        std::vector&lt;bool&gt;(value));</div>
<div class="line"><span class="lineno">  515</span>}</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder_html_a24c56c2f2387424d471e0ef994f2e54a"><div class="ttname"><a href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a24c56c2f2387424d471e0ef994f2e54a">hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_boolean</a></div><div class="ttdeci">generic_record_builder &amp; set_array_of_nullable_boolean(std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; bool &gt; &gt; &gt; value)</div><div class="ttdoc">It is legal to set the field again only when Builder is created with generic_record::new_builder_with...</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d82/compact_8cpp_source.html#l00492">compact.cpp:492</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a990a0bde746eb6ad86adbcb44cb8b5dd" name="a990a0bde746eb6ad86adbcb44cb8b5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990a0bde746eb6ad86adbcb44cb8b5dd">&#9670;&#160;</a></span>set_array_of_nullable_boolean() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_boolean </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact. Note that, array will be copied to transform values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00502">502</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  504</span>{</div>
<div class="line"><span class="lineno">  505</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a24c56c2f2387424d471e0ef994f2e54a">set_array_of_nullable_boolean</a>(move(field_name),</div>
<div class="line"><span class="lineno">  506</span>                                         to_nullable(std::move(value)));</div>
<div class="line"><span class="lineno">  507</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a41dcb6285bfa215470a67d1993ea64b9" name="a41dcb6285bfa215470a67d1993ea64b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41dcb6285bfa215470a67d1993ea64b9">&#9670;&#160;</a></span>set_array_of_nullable_float32() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_float32 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; boost::optional&lt; float &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00618">618</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  621</span>{</div>
<div class="line"><span class="lineno">  622</span>    <span class="keywordflow">return</span> write(move(field_name),</div>
<div class="line"><span class="lineno">  623</span>                 std::move(value),</div>
<div class="line"><span class="lineno">  624</span>                 field_kind::ARRAY_OF_NULLABLE_FLOAT32);</div>
<div class="line"><span class="lineno">  625</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a552aff450eaa3c26e7e4c41850a3c406" name="a552aff450eaa3c26e7e4c41850a3c406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a552aff450eaa3c26e7e4c41850a3c406">&#9670;&#160;</a></span>set_array_of_nullable_float32() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_float32 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; float &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact Note that, array will be copied to transform values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00636">636</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  638</span>{</div>
<div class="line"><span class="lineno">  639</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a41dcb6285bfa215470a67d1993ea64b9">set_array_of_nullable_float32</a>(move(field_name),</div>
<div class="line"><span class="lineno">  640</span>        std::vector&lt;float&gt;(value));</div>
<div class="line"><span class="lineno">  641</span>}</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder_html_a41dcb6285bfa215470a67d1993ea64b9"><div class="ttname"><a href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a41dcb6285bfa215470a67d1993ea64b9">hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_float32</a></div><div class="ttdeci">generic_record_builder &amp; set_array_of_nullable_float32(std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; float &gt; &gt; &gt; value)</div><div class="ttdoc">It is legal to set the field again only when Builder is created with generic_record::new_builder_with...</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d82/compact_8cpp_source.html#l00618">compact.cpp:618</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad843b871c8c22ece48dfe474fef2876b" name="ad843b871c8c22ece48dfe474fef2876b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad843b871c8c22ece48dfe474fef2876b">&#9670;&#160;</a></span>set_array_of_nullable_float32() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_float32 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact Note that, array will be copied to transform values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00628">628</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  630</span>{</div>
<div class="line"><span class="lineno">  631</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a41dcb6285bfa215470a67d1993ea64b9">set_array_of_nullable_float32</a>(move(field_name),</div>
<div class="line"><span class="lineno">  632</span>                                         to_nullable(std::move(value)));</div>
<div class="line"><span class="lineno">  633</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a23ef618d50289e9909e5b5003a94e913" name="a23ef618d50289e9909e5b5003a94e913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ef618d50289e9909e5b5003a94e913">&#9670;&#160;</a></span>set_array_of_nullable_float64() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_float64 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; boost::optional&lt; double &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00644">644</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  647</span>{</div>
<div class="line"><span class="lineno">  648</span>    <span class="keywordflow">return</span> write(move(field_name),</div>
<div class="line"><span class="lineno">  649</span>                 std::move(value),</div>
<div class="line"><span class="lineno">  650</span>                 field_kind::ARRAY_OF_NULLABLE_FLOAT64);</div>
<div class="line"><span class="lineno">  651</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acc37842fef3f561fed3bb7d730d8c28b" name="acc37842fef3f561fed3bb7d730d8c28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc37842fef3f561fed3bb7d730d8c28b">&#9670;&#160;</a></span>set_array_of_nullable_float64() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_float64 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; double &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact Note that, array will be copied to transform values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00662">662</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  664</span>{</div>
<div class="line"><span class="lineno">  665</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a23ef618d50289e9909e5b5003a94e913">set_array_of_nullable_float64</a>(move(field_name),</div>
<div class="line"><span class="lineno">  666</span>        std::vector&lt;double&gt;(value));</div>
<div class="line"><span class="lineno">  667</span>}</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder_html_a23ef618d50289e9909e5b5003a94e913"><div class="ttname"><a href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a23ef618d50289e9909e5b5003a94e913">hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_float64</a></div><div class="ttdeci">generic_record_builder &amp; set_array_of_nullable_float64(std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; double &gt; &gt; &gt; value)</div><div class="ttdoc">It is legal to set the field again only when Builder is created with generic_record::new_builder_with...</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d82/compact_8cpp_source.html#l00644">compact.cpp:644</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa7f6797cb3c0e88e7b5bb59f3218ba42" name="aa7f6797cb3c0e88e7b5bb59f3218ba42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7f6797cb3c0e88e7b5bb59f3218ba42">&#9670;&#160;</a></span>set_array_of_nullable_float64() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_float64 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact Note that, array will be copied to transform values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00654">654</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  656</span>{</div>
<div class="line"><span class="lineno">  657</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a23ef618d50289e9909e5b5003a94e913">set_array_of_nullable_float64</a>(move(field_name),</div>
<div class="line"><span class="lineno">  658</span>                                         to_nullable(std::move(value)));</div>
<div class="line"><span class="lineno">  659</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4113b36ffb452109b4c5c55aa9324554" name="a4113b36ffb452109b4c5c55aa9324554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4113b36ffb452109b4c5c55aa9324554">&#9670;&#160;</a></span>set_array_of_nullable_int16() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_int16 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; boost::optional&lt; int16_t &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00543">543</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  546</span>{</div>
<div class="line"><span class="lineno">  547</span>    <span class="keywordflow">return</span> write(</div>
<div class="line"><span class="lineno">  548</span>      move(field_name), std::move(value), field_kind::ARRAY_OF_NULLABLE_INT16);</div>
<div class="line"><span class="lineno">  549</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a551b5eea861df464399471c3cfb38f55" name="a551b5eea861df464399471c3cfb38f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551b5eea861df464399471c3cfb38f55">&#9670;&#160;</a></span>set_array_of_nullable_int16() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_int16 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; int16_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact Note that, array will be copied to transform values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00560">560</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  562</span>{</div>
<div class="line"><span class="lineno">  563</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a4113b36ffb452109b4c5c55aa9324554">set_array_of_nullable_int16</a>(move(field_name),</div>
<div class="line"><span class="lineno">  564</span>        std::vector&lt;int16_t&gt;(value));</div>
<div class="line"><span class="lineno">  565</span>}</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder_html_a4113b36ffb452109b4c5c55aa9324554"><div class="ttname"><a href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a4113b36ffb452109b4c5c55aa9324554">hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_int16</a></div><div class="ttdeci">generic_record_builder &amp; set_array_of_nullable_int16(std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; int16_t &gt; &gt; &gt; value)</div><div class="ttdoc">It is legal to set the field again only when Builder is created with generic_record::new_builder_with...</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d82/compact_8cpp_source.html#l00543">compact.cpp:543</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7ea852dc9a0284d5495a0d6df3410e22" name="a7ea852dc9a0284d5495a0d6df3410e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea852dc9a0284d5495a0d6df3410e22">&#9670;&#160;</a></span>set_array_of_nullable_int16() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_int16 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int16_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact Note that, array will be copied to transform values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00552">552</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  554</span>{</div>
<div class="line"><span class="lineno">  555</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a4113b36ffb452109b4c5c55aa9324554">set_array_of_nullable_int16</a>(move(field_name),</div>
<div class="line"><span class="lineno">  556</span>                                       to_nullable(std::move(value)));</div>
<div class="line"><span class="lineno">  557</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a398378f7a73a62833204cdfc086e03a5" name="a398378f7a73a62833204cdfc086e03a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398378f7a73a62833204cdfc086e03a5">&#9670;&#160;</a></span>set_array_of_nullable_int32() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_int32 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; boost::optional&lt; int32_t &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00568">568</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  571</span>{</div>
<div class="line"><span class="lineno">  572</span>    <span class="keywordflow">return</span> write(</div>
<div class="line"><span class="lineno">  573</span>      move(field_name), std::move(value), field_kind::ARRAY_OF_NULLABLE_INT32);</div>
<div class="line"><span class="lineno">  574</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8c03cefe20b13b77bd9c9f344c6c7957" name="a8c03cefe20b13b77bd9c9f344c6c7957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c03cefe20b13b77bd9c9f344c6c7957">&#9670;&#160;</a></span>set_array_of_nullable_int32() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_int32 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; int32_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact Note that, array will be copied to transform values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00585">585</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  587</span>{</div>
<div class="line"><span class="lineno">  588</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a398378f7a73a62833204cdfc086e03a5">set_array_of_nullable_int32</a>(move(field_name),</div>
<div class="line"><span class="lineno">  589</span>        std::vector&lt;int32_t&gt;(value));</div>
<div class="line"><span class="lineno">  590</span>}</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder_html_a398378f7a73a62833204cdfc086e03a5"><div class="ttname"><a href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a398378f7a73a62833204cdfc086e03a5">hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_int32</a></div><div class="ttdeci">generic_record_builder &amp; set_array_of_nullable_int32(std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; int32_t &gt; &gt; &gt; value)</div><div class="ttdoc">It is legal to set the field again only when Builder is created with generic_record::new_builder_with...</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d82/compact_8cpp_source.html#l00568">compact.cpp:568</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a790c3233608bcace0cbfc36896b26b1a" name="a790c3233608bcace0cbfc36896b26b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790c3233608bcace0cbfc36896b26b1a">&#9670;&#160;</a></span>set_array_of_nullable_int32() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_int32 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int32_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact Note that, array will be copied to transform values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00577">577</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  579</span>{</div>
<div class="line"><span class="lineno">  580</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a398378f7a73a62833204cdfc086e03a5">set_array_of_nullable_int32</a>(move(field_name),</div>
<div class="line"><span class="lineno">  581</span>                                       to_nullable(std::move(value)));</div>
<div class="line"><span class="lineno">  582</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1f9a032f8ac8dcdc671a6ad04e881dfb" name="a1f9a032f8ac8dcdc671a6ad04e881dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9a032f8ac8dcdc671a6ad04e881dfb">&#9670;&#160;</a></span>set_array_of_nullable_int64() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_int64 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; boost::optional&lt; int64_t &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00593">593</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  596</span>{</div>
<div class="line"><span class="lineno">  597</span>    <span class="keywordflow">return</span> write(</div>
<div class="line"><span class="lineno">  598</span>      move(field_name), std::move(value), field_kind::ARRAY_OF_NULLABLE_INT64);</div>
<div class="line"><span class="lineno">  599</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aed218c833339efa31aedb65225a049b1" name="aed218c833339efa31aedb65225a049b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed218c833339efa31aedb65225a049b1">&#9670;&#160;</a></span>set_array_of_nullable_int64() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_int64 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact Note that, array will be copied to transform values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00610">610</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  612</span>{</div>
<div class="line"><span class="lineno">  613</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a1f9a032f8ac8dcdc671a6ad04e881dfb">set_array_of_nullable_int64</a>(move(field_name),</div>
<div class="line"><span class="lineno">  614</span>        std::vector&lt;int64_t&gt;(value));</div>
<div class="line"><span class="lineno">  615</span>}</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder_html_a1f9a032f8ac8dcdc671a6ad04e881dfb"><div class="ttname"><a href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a1f9a032f8ac8dcdc671a6ad04e881dfb">hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_int64</a></div><div class="ttdeci">generic_record_builder &amp; set_array_of_nullable_int64(std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; int64_t &gt; &gt; &gt; value)</div><div class="ttdoc">It is legal to set the field again only when Builder is created with generic_record::new_builder_with...</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d82/compact_8cpp_source.html#l00593">compact.cpp:593</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa993ad2be8794b85d0be448f2e4ff763" name="aa993ad2be8794b85d0be448f2e4ff763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa993ad2be8794b85d0be448f2e4ff763">&#9670;&#160;</a></span>set_array_of_nullable_int64() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_int64 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact Note that, array will be copied to transform values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00602">602</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  604</span>{</div>
<div class="line"><span class="lineno">  605</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a1f9a032f8ac8dcdc671a6ad04e881dfb">set_array_of_nullable_int64</a>(move(field_name),</div>
<div class="line"><span class="lineno">  606</span>                                       to_nullable(std::move(value)));</div>
<div class="line"><span class="lineno">  607</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a32c50cca35b912ec4eb9cdf3c96df5e6" name="a32c50cca35b912ec4eb9cdf3c96df5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c50cca35b912ec4eb9cdf3c96df5e6">&#9670;&#160;</a></span>set_array_of_nullable_int8() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_int8 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; boost::optional&lt; int8_t &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00518">518</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  521</span>{</div>
<div class="line"><span class="lineno">  522</span>    <span class="keywordflow">return</span> write(</div>
<div class="line"><span class="lineno">  523</span>      move(field_name), std::move(value), field_kind::ARRAY_OF_NULLABLE_INT8);</div>
<div class="line"><span class="lineno">  524</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="afae22a25b07de03c373fbb7b20104dae" name="afae22a25b07de03c373fbb7b20104dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae22a25b07de03c373fbb7b20104dae">&#9670;&#160;</a></span>set_array_of_nullable_int8() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_int8 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; int8_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact Note that, array will be copied to transform values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00535">535</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  537</span>{</div>
<div class="line"><span class="lineno">  538</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a32c50cca35b912ec4eb9cdf3c96df5e6">set_array_of_nullable_int8</a>(move(field_name),</div>
<div class="line"><span class="lineno">  539</span>        std::vector&lt;int8_t&gt;(value));</div>
<div class="line"><span class="lineno">  540</span>}</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder_html_a32c50cca35b912ec4eb9cdf3c96df5e6"><div class="ttname"><a href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a32c50cca35b912ec4eb9cdf3c96df5e6">hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_int8</a></div><div class="ttdeci">generic_record_builder &amp; set_array_of_nullable_int8(std::string field_name, boost::optional&lt; std::vector&lt; boost::optional&lt; int8_t &gt; &gt; &gt; value)</div><div class="ttdoc">It is legal to set the field again only when Builder is created with generic_record::new_builder_with...</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d82/compact_8cpp_source.html#l00518">compact.cpp:518</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1a0fe89caea0d20c198ad57b978f748d" name="a1a0fe89caea0d20c198ad57b978f748d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a0fe89caea0d20c198ad57b978f748d">&#9670;&#160;</a></span>set_array_of_nullable_int8() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_nullable_int8 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int8_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact Note that, array will be copied to transform values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00527">527</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  529</span>{</div>
<div class="line"><span class="lineno">  530</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a32c50cca35b912ec4eb9cdf3c96df5e6">set_array_of_nullable_int8</a>(move(field_name),</div>
<div class="line"><span class="lineno">  531</span>                                      to_nullable(std::move(value)));</div>
<div class="line"><span class="lineno">  532</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1b3fd11aba5f9ace4ea9805d6e08ea25" name="a1b3fd11aba5f9ace4ea9805d6e08ea25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3fd11aba5f9ace4ea9805d6e08ea25">&#9670;&#160;</a></span>set_array_of_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_string </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; boost::optional&lt; std::string &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. Array items can not be null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00670">670</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  673</span>{</div>
<div class="line"><span class="lineno">  674</span>    <span class="keywordflow">return</span> write(</div>
<div class="line"><span class="lineno">  675</span>      move(field_name), std::move(value), field_kind::ARRAY_OF_STRING);</div>
<div class="line"><span class="lineno">  676</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab2a51468e4d3adfb3c690011ef6e8812" name="ab2a51468e4d3adfb3c690011ef6e8812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a51468e4d3adfb3c690011ef6e8812">&#9670;&#160;</a></span>set_array_of_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_time </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. Array items can not be null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a11db0aef5a4ff2adffe3b395edaa4243" title="Sets a time field consisting of hour, minute, seconds, and nanos parts.">set_time()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00688">688</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  691</span>{</div>
<div class="line"><span class="lineno">  692</span>    <span class="keywordflow">return</span> write(move(field_name), std::move(value), field_kind::ARRAY_OF_TIME);</div>
<div class="line"><span class="lineno">  693</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="afc857fbeed9acb9840f510626a3bc5e4" name="afc857fbeed9acb9840f510626a3bc5e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc857fbeed9acb9840f510626a3bc5e4">&#9670;&#160;</a></span>set_array_of_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_timestamp </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. Array items can not be null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a129faf5453205497eaa671385918063e" title="Sets a timestamp field consisting of year, month of the year, and day of the month,...">set_timestamp()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00704">704</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  707</span>{</div>
<div class="line"><span class="lineno">  708</span>    <span class="keywordflow">return</span> write(</div>
<div class="line"><span class="lineno">  709</span>      move(field_name), std::move(value), field_kind::ARRAY_OF_TIMESTAMP);</div>
<div class="line"><span class="lineno">  710</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5d31c8b48cd77433b8c84acade0ef7b7" name="a5d31c8b48cd77433b8c84acade0ef7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d31c8b48cd77433b8c84acade0ef7b7">&#9670;&#160;</a></span>set_array_of_timestamp_with_timezone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_array_of_timestamp_with_timezone </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::vector&lt; boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt; &gt; &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. Array items can not be null.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#a6ee9b8572a7a1cb1e310defab0b039d5" title="Sets a timestamp with timezone field consisting of year, month of the year and day of the month,...">set_timestamp_with_timezone()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00713">713</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  716</span>{</div>
<div class="line"><span class="lineno">  717</span>    <span class="keywordflow">return</span> write(move(field_name),</div>
<div class="line"><span class="lineno">  718</span>                 std::move(value),</div>
<div class="line"><span class="lineno">  719</span>                 field_kind::ARRAY_OF_TIMESTAMP_WITH_TIMEZONE);</div>
<div class="line"><span class="lineno">  720</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a82e6d067bf48f5a435e14739ca55a5c4" name="a82e6d067bf48f5a435e14739ca55a5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e6d067bf48f5a435e14739ca55a5c4">&#9670;&#160;</a></span>set_boolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_boolean </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00161">161</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  162</span>{</div>
<div class="line"><span class="lineno">  163</span>    <span class="keywordflow">return</span> write(move(field_name), value, field_kind::BOOLEAN);</div>
<div class="line"><span class="lineno">  164</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8ecce465e4243e41b10b4610cebc3cef" name="a8ecce465e4243e41b10b4610cebc3cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecce465e4243e41b10b4610cebc3cef">&#9670;&#160;</a></span>set_date()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_date </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; <a class="el" href="../../de/dcd/structhazelcast_1_1client_1_1local__date.html">local_date</a> &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a date field consisting of year, month of the year, and day of the month. </p>
<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00274">274</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  276</span>{</div>
<div class="line"><span class="lineno">  277</span>    <span class="keywordflow">return</span> write(move(field_name), value, field_kind::DATE);</div>
<div class="line"><span class="lineno">  278</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a31c92ec939bf71952ca4a5ac018a4dd4" name="a31c92ec939bf71952ca4a5ac018a4dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c92ec939bf71952ca4a5ac018a4dd4">&#9670;&#160;</a></span>set_decimal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_decimal </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; <a class="el" href="../../d8/d7d/structhazelcast_1_1client_1_1big__decimal.html">big_decimal</a> &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a decimal which is arbitrary precision and scale floating-point number. </p>
<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00260">260</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  262</span>{</div>
<div class="line"><span class="lineno">  263</span>    <span class="keywordflow">return</span> write(move(field_name), value, field_kind::DECIMAL);</div>
<div class="line"><span class="lineno">  264</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6670feaba2a929f56ebcb7c42e36b345" name="a6670feaba2a929f56ebcb7c42e36b345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6670feaba2a929f56ebcb7c42e36b345">&#9670;&#160;</a></span>set_float32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_float32 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00191">191</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  192</span>{</div>
<div class="line"><span class="lineno">  193</span>    <span class="keywordflow">return</span> write(move(field_name), value, field_kind::FLOAT32);</div>
<div class="line"><span class="lineno">  194</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab4736a3261d7b1dcf3a15bba6bc6164b" name="ab4736a3261d7b1dcf3a15bba6bc6164b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4736a3261d7b1dcf3a15bba6bc6164b">&#9670;&#160;</a></span>set_float64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_float64 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00197">197</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  198</span>{</div>
<div class="line"><span class="lineno">  199</span>    <span class="keywordflow">return</span> write(move(field_name), value, field_kind::FLOAT64);</div>
<div class="line"><span class="lineno">  200</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a15bc179c66aedb6b757854bb0f2206d3" name="a15bc179c66aedb6b757854bb0f2206d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bc179c66aedb6b757854bb0f2206d3">&#9670;&#160;</a></span>set_generic_record()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_generic_record </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a> &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. This method allows nested structures. Subclass should also be created as <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema/class definition or the type of the field does not match the one in the schema/class definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00252">252</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  255</span>{</div>
<div class="line"><span class="lineno">  256</span>    <span class="keywordflow">return</span> write(move(field_name), std::move(value), field_kind::COMPACT);</div>
<div class="line"><span class="lineno">  257</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a361e26e89d3cf580e826f636147f5737" name="a361e26e89d3cf580e826f636147f5737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361e26e89d3cf580e826f636147f5737">&#9670;&#160;</a></span>set_int16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_int16 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00173">173</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  174</span>{</div>
<div class="line"><span class="lineno">  175</span>    <span class="keywordflow">return</span> write(move(field_name), value, field_kind::INT16);</div>
<div class="line"><span class="lineno">  176</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab965a70a0a60cbb9779fc1491e4c2a15" name="ab965a70a0a60cbb9779fc1491e4c2a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab965a70a0a60cbb9779fc1491e4c2a15">&#9670;&#160;</a></span>set_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_int32 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00179">179</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  180</span>{</div>
<div class="line"><span class="lineno">  181</span>    <span class="keywordflow">return</span> write(move(field_name), value, field_kind::INT32);</div>
<div class="line"><span class="lineno">  182</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a26709d0da12d0705d0acc3d1189be2c3" name="a26709d0da12d0705d0acc3d1189be2c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26709d0da12d0705d0acc3d1189be2c3">&#9670;&#160;</a></span>set_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_int64 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00185">185</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  186</span>{</div>
<div class="line"><span class="lineno">  187</span>    <span class="keywordflow">return</span> write(move(field_name), value, field_kind::INT64);</div>
<div class="line"><span class="lineno">  188</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2b67edeb81a1bb7bd756bdf49882addf" name="a2b67edeb81a1bb7bd756bdf49882addf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b67edeb81a1bb7bd756bdf49882addf">&#9670;&#160;</a></span>set_int8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_int8 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema/class definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00167">167</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  168</span>{</div>
<div class="line"><span class="lineno">  169</span>    <span class="keywordflow">return</span> write(move(field_name), value, field_kind::INT8);</div>
<div class="line"><span class="lineno">  170</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a63c6bba1ea026de4630d38e152b5ca42" name="a63c6bba1ea026de4630d38e152b5ca42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c6bba1ea026de4630d38e152b5ca42">&#9670;&#160;</a></span>set_nullable_boolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_nullable_boolean </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00203">203</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  205</span>{</div>
<div class="line"><span class="lineno">  206</span>    <span class="keywordflow">return</span> write(move(field_name), value, field_kind::NULLABLE_BOOLEAN);</div>
<div class="line"><span class="lineno">  207</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3ab902263ab1285c134cc9f0f34c7a0c" name="a3ab902263ab1285c134cc9f0f34c7a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab902263ab1285c134cc9f0f34c7a0c">&#9670;&#160;</a></span>set_nullable_float32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_nullable_float32 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; float &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00238">238</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  240</span>{</div>
<div class="line"><span class="lineno">  241</span>    <span class="keywordflow">return</span> write(move(field_name), value, field_kind::NULLABLE_FLOAT32);</div>
<div class="line"><span class="lineno">  242</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7c20ce368f4bd599755b23414ba0258a" name="a7c20ce368f4bd599755b23414ba0258a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c20ce368f4bd599755b23414ba0258a">&#9670;&#160;</a></span>set_nullable_float64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_nullable_float64 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; double &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00245">245</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  247</span>{</div>
<div class="line"><span class="lineno">  248</span>    <span class="keywordflow">return</span> write(move(field_name), value, field_kind::NULLABLE_FLOAT64);</div>
<div class="line"><span class="lineno">  249</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="afa641756447950340066a298312ce66a" name="afa641756447950340066a298312ce66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa641756447950340066a298312ce66a">&#9670;&#160;</a></span>set_nullable_int16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_nullable_int16 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; int16_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00217">217</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  219</span>{</div>
<div class="line"><span class="lineno">  220</span>    <span class="keywordflow">return</span> write(move(field_name), value, field_kind::NULLABLE_INT16);</div>
<div class="line"><span class="lineno">  221</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af203aa17d2704b1bf5e9c21df575c548" name="af203aa17d2704b1bf5e9c21df575c548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af203aa17d2704b1bf5e9c21df575c548">&#9670;&#160;</a></span>set_nullable_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_nullable_int32 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; int32_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00224">224</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  226</span>{</div>
<div class="line"><span class="lineno">  227</span>    <span class="keywordflow">return</span> write(move(field_name), value, field_kind::NULLABLE_INT32);</div>
<div class="line"><span class="lineno">  228</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5d46a90ecc102c5e0b5c194cef58914f" name="a5d46a90ecc102c5e0b5c194cef58914f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d46a90ecc102c5e0b5c194cef58914f">&#9670;&#160;</a></span>set_nullable_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_nullable_int64 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00231">231</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  233</span>{</div>
<div class="line"><span class="lineno">  234</span>    <span class="keywordflow">return</span> write(move(field_name), value, field_kind::NULLABLE_INT64);</div>
<div class="line"><span class="lineno">  235</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a33e863d9f34eab0ce68b880e8f26c46a" name="a33e863d9f34eab0ce68b880e8f26c46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e863d9f34eab0ce68b880e8f26c46a">&#9670;&#160;</a></span>set_nullable_int8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_nullable_int8 </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; int8_t &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice. </p>
<p>Supported only for Compact</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema or the type of the field does not match the one in the schema or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00210">210</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  212</span>{</div>
<div class="line"><span class="lineno">  213</span>    <span class="keywordflow">return</span> write(move(field_name), value, field_kind::NULLABLE_INT8);</div>
<div class="line"><span class="lineno">  214</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae9a3fa8e39ee8f95671e07434cecaa00" name="ae9a3fa8e39ee8f95671e07434cecaa00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a3fa8e39ee8f95671e07434cecaa00">&#9670;&#160;</a></span>set_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_string </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00296">296</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  298</span>{</div>
<div class="line"><span class="lineno">  299</span>    <span class="keywordflow">return</span> write(move(field_name), std::move(value), field_kind::STRING);</div>
<div class="line"><span class="lineno">  300</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab8946d5d49a2f7f61e28d51a45d7b090" name="ab8946d5d49a2f7f61e28d51a45d7b090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8946d5d49a2f7f61e28d51a45d7b090">&#9670;&#160;</a></span>set_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_string </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </p>
<p>Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema/class definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00077">77</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   78</span>{</div>
<div class="line"><span class="lineno">   79</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#ae9a3fa8e39ee8f95671e07434cecaa00">set_string</a>(field_name,</div>
<div class="line"><span class="lineno">   80</span>                      cstr ? boost::optional&lt;std::string&gt;{ std::string{ cstr } }</div>
<div class="line"><span class="lineno">   81</span>                           : boost::none);</div>
<div class="line"><span class="lineno">   82</span>}</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder_html_ae9a3fa8e39ee8f95671e07434cecaa00"><div class="ttname"><a href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html#ae9a3fa8e39ee8f95671e07434cecaa00">hazelcast::client::serialization::generic_record::generic_record_builder::set_string</a></div><div class="ttdeci">generic_record_builder &amp; set_string(std::string field_name, boost::optional&lt; std::string &gt; value)</div><div class="ttdoc">It is legal to set the field again only when Builder is created with generic_record::new_builder_with...</div><div class="ttdef"><b>Definition:</b> <a href="../../df/d82/compact_8cpp_source.html#l00296">compact.cpp:296</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a11db0aef5a4ff2adffe3b395edaa4243" name="a11db0aef5a4ff2adffe3b395edaa4243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11db0aef5a4ff2adffe3b395edaa4243">&#9670;&#160;</a></span>set_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_time </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; <a class="el" href="../../d4/de5/structhazelcast_1_1client_1_1local__time.html">local_time</a> &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a time field consisting of hour, minute, seconds, and nanos parts. </p>
<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00267">267</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  269</span>{</div>
<div class="line"><span class="lineno">  270</span>    <span class="keywordflow">return</span> write(move(field_name), value, field_kind::TIME);</div>
<div class="line"><span class="lineno">  271</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a129faf5453205497eaa671385918063e" name="a129faf5453205497eaa671385918063e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a129faf5453205497eaa671385918063e">&#9670;&#160;</a></span>set_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_timestamp </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; <a class="el" href="../../d2/da1/structhazelcast_1_1client_1_1local__date__time.html">local_date_time</a> &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a timestamp field consisting of year, month of the year, and day of the month, hour, minute, seconds, nanos parts. </p>
<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00281">281</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  283</span>{</div>
<div class="line"><span class="lineno">  284</span>    <span class="keywordflow">return</span> write(move(field_name), value, field_kind::TIMESTAMP);</div>
<div class="line"><span class="lineno">  285</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6ee9b8572a7a1cb1e310defab0b039d5" name="a6ee9b8572a7a1cb1e310defab0b039d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee9b8572a7a1cb1e310defab0b039d5">&#9670;&#160;</a></span>set_timestamp_with_timezone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a> &amp; hazelcast::client::serialization::generic_record::generic_record_builder::set_timestamp_with_timezone </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; <a class="el" href="../../db/d9c/structhazelcast_1_1client_1_1offset__date__time.html">offset_date_time</a> &gt;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a timestamp with timezone field consisting of year, month of the year and day of the month, offset seconds, hour, minute, seconds, nanos parts. </p>
<p>It is legal to set the field again only when Builder is created with <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. Otherwise, it is illegal to set to the same field twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field_name</td><td>name of the field as it is defined in its schema definition. </td></tr>
    <tr><td class="paramname">value</td><td>to set to <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html" title="A generic object interface that is returned to the user when the domain class can not be created from...">generic_record</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>itself for chaining </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception::hazelcast_serialization</td><td>if the field name does not exist in the schema definition or the type of the field does not match the one in the schema definition or the same field is trying to be set without using <code><a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html#a9be4ec9ba393576c4ec4607cc42eafbd">generic_record::new_builder_with_clone()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../df/d82/compact_8cpp_source.html#l00288">288</a> of file <a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  291</span>{</div>
<div class="line"><span class="lineno">  292</span>    <span class="keywordflow">return</span> write(move(field_name), value, field_kind::TIMESTAMP_WITH_TIMEZONE);</div>
<div class="line"><span class="lineno">  293</span>}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="af247764fc5f749166ecf6e8d36dc0a82" name="af247764fc5f749166ecf6e8d36dc0a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af247764fc5f749166ecf6e8d36dc0a82">&#9670;&#160;</a></span>generic_record</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="../../de/db1/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record.html">generic_record</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d9/da1/generic__record__builder_8h_source.html#l01469">1469</a> of file <a class="el" href="../../d9/da1/generic__record__builder_8h_source.html">generic_record_builder.h</a>.</p>

</div>
</div>
<a id="a51a96bb9ebecd6d3a6506dffa0173d93" name="a51a96bb9ebecd6d3a6506dffa0173d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a96bb9ebecd6d3a6506dffa0173d93">&#9670;&#160;</a></span>pimpl::compact_stream_serializer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class pimpl::compact_stream_serializer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d9/da1/generic__record__builder_8h_source.html#l01470">1470</a> of file <a class="el" href="../../d9/da1/generic__record__builder_8h_source.html">generic_record_builder.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>hazelcast/include/hazelcast/client/serialization/<a class="el" href="../../d9/da1/generic__record__builder_8h_source.html">generic_record_builder.h</a></li>
<li>hazelcast/src/hazelcast/client/<a class="el" href="../../df/d82/compact_8cpp_source.html">compact.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../de/db5/namespacehazelcast.html">hazelcast</a></li><li class="navelem"><a class="el" href="../../da/d95/namespacehazelcast_1_1client.html">client</a></li><li class="navelem"><a class="el" href="../../db/dda/namespacehazelcast_1_1client_1_1serialization.html">serialization</a></li><li class="navelem"><b>generic_record</b></li><li class="navelem"><a class="el" href="../../dc/dab/classhazelcast_1_1client_1_1serialization_1_1generic__record_1_1generic__record__builder.html">generic_record_builder</a></li>
    <li class="footer">Generated on Wed Mar 15 2023 18:23:47 for Hazelcast C++ Client by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
