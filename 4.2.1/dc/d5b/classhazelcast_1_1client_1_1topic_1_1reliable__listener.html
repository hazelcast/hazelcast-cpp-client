<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hazelcast C++ Client: hazelcast::client::topic::reliable_listener Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../IMDG_blue_logo_square_RGB-dark_200px.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Hazelcast C++ Client
   </div>
   <div id="projectbrief">Hazelcast C++ Client Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="../../da/da5/classhazelcast_1_1client_1_1topic_1_1reliable__listener-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hazelcast::client::topic::reliable_listener Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Listen to messages from a <a class="el" href="../../d4/d91/classhazelcast_1_1client_1_1reliable__topic.html" title="Hazelcast provides distribution mechanism for publishing messages that are delivered to multiple subs...">reliable_topic</a>.  
 <a href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d0/dea/reliable__listener_8h_source.html">reliable_listener.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab95364d47f11f51406674bbcbe348422"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#ab95364d47f11f51406674bbcbe348422">reliable_listener</a> (bool loss_tolerant, int64_t initial_sequence_id=-1)</td></tr>
<tr class="separator:ab95364d47f11f51406674bbcbe348422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0928388c44745e1251cf1d0070deb5a"><td class="memTemplParams" colspan="2">template&lt;typename Handler , typename  = util::enable_if_rvalue_ref_t&lt;Handler &amp;&amp;&gt;&gt; </td></tr>
<tr class="memitem:af0928388c44745e1251cf1d0070deb5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html">reliable_listener</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#af0928388c44745e1251cf1d0070deb5a">on_received</a> (Handler &amp;&amp;h) &amp;</td></tr>
<tr class="memdesc:af0928388c44745e1251cf1d0070deb5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an handler function to be invoked when a message is received for the added topic.  <a href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#af0928388c44745e1251cf1d0070deb5a">More...</a><br /></td></tr>
<tr class="separator:af0928388c44745e1251cf1d0070deb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fb738febb3f53cee2e9c73007f09a2"><td class="memTemplParams" colspan="2">template&lt;typename Handler , typename  = util::enable_if_rvalue_ref_t&lt;Handler &amp;&amp;&gt;&gt; </td></tr>
<tr class="memitem:a99fb738febb3f53cee2e9c73007f09a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html">reliable_listener</a> &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#a99fb738febb3f53cee2e9c73007f09a2">on_received</a> (Handler &amp;&amp;h) &amp;&amp;</td></tr>
<tr class="memdesc:a99fb738febb3f53cee2e9c73007f09a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an handler function to be invoked when a message is received for the added topic.  <a href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#a99fb738febb3f53cee2e9c73007f09a2">More...</a><br /></td></tr>
<tr class="separator:a99fb738febb3f53cee2e9c73007f09a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ead7e11fad23228c484eba92d31d44"><td class="memTemplParams" colspan="2">template&lt;typename Handler , typename  = util::enable_if_rvalue_ref_t&lt;Handler &amp;&amp;&gt;&gt; </td></tr>
<tr class="memitem:a41ead7e11fad23228c484eba92d31d44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html">reliable_listener</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#a41ead7e11fad23228c484eba92d31d44">on_store_sequence_id</a> (Handler &amp;&amp;h) &amp;</td></tr>
<tr class="memdesc:a41ead7e11fad23228c484eba92d31d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an handler function to be invoked to informs the listener that it should store the sequence.  <a href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#a41ead7e11fad23228c484eba92d31d44">More...</a><br /></td></tr>
<tr class="separator:a41ead7e11fad23228c484eba92d31d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17983a0fab6b5b4685bfc31ba937f32b"><td class="memTemplParams" colspan="2">template&lt;typename Handler , typename  = util::enable_if_rvalue_ref_t&lt;Handler &amp;&amp;&gt;&gt; </td></tr>
<tr class="memitem:a17983a0fab6b5b4685bfc31ba937f32b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html">reliable_listener</a> &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#a17983a0fab6b5b4685bfc31ba937f32b">on_store_sequence_id</a> (Handler &amp;&amp;h) &amp;&amp;</td></tr>
<tr class="separator:a17983a0fab6b5b4685bfc31ba937f32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af2c8673479c4057a6c26a0f9a4afdb"><td class="memTemplParams" colspan="2">template&lt;typename Handler , typename  = util::enable_if_rvalue_ref_t&lt;Handler &amp;&amp;&gt;&gt; </td></tr>
<tr class="memitem:a0af2c8673479c4057a6c26a0f9a4afdb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html">reliable_listener</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#a0af2c8673479c4057a6c26a0f9a4afdb">terminate_on_exception</a> (Handler &amp;&amp;h) &amp;</td></tr>
<tr class="memdesc:a0af2c8673479c4057a6c26a0f9a4afdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an handler function that checks if the listener should be terminated based on an exception thrown while calling the function set by <a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#af0928388c44745e1251cf1d0070deb5a" title="Set an handler function to be invoked when a message is received for the added topic.">reliable_listener::on_received</a>.  <a href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#a0af2c8673479c4057a6c26a0f9a4afdb">More...</a><br /></td></tr>
<tr class="separator:a0af2c8673479c4057a6c26a0f9a4afdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ee11117f65f157e7e60e75a65fec54"><td class="memTemplParams" colspan="2">template&lt;typename Handler , typename  = util::enable_if_rvalue_ref_t&lt;Handler &amp;&amp;&gt;&gt; </td></tr>
<tr class="memitem:a12ee11117f65f157e7e60e75a65fec54"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html">reliable_listener</a> &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#a12ee11117f65f157e7e60e75a65fec54">terminate_on_exception</a> (Handler &amp;&amp;h) &amp;&amp;</td></tr>
<tr class="memdesc:a12ee11117f65f157e7e60e75a65fec54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an handler function that checks if the listener should be terminated based on an exception thrown while calling the function set by <a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#af0928388c44745e1251cf1d0070deb5a" title="Set an handler function to be invoked when a message is received for the added topic.">reliable_listener::on_received</a>.  <a href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#a12ee11117f65f157e7e60e75a65fec54">More...</a><br /></td></tr>
<tr class="separator:a12ee11117f65f157e7e60e75a65fec54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab1f357868e7433b0799a75ec73706c13"><td class="memItemLeft" align="right" valign="top"><a id="ab1f357868e7433b0799a75ec73706c13"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>client::reliable_topic</b></td></tr>
<tr class="separator:ab1f357868e7433b0799a75ec73706c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Listen to messages from a <a class="el" href="../../d4/d91/classhazelcast_1_1client_1_1reliable__topic.html" title="Hazelcast provides distribution mechanism for publishing messages that are delivered to multiple subs...">reliable_topic</a>. </p>
<h1>Durable Subscription</h1>
<p><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html" title="Listen to messages from a reliable_topic.">reliable_listener</a> allows you to control where you want to start processing a message when the listener is registered. This makes it possible to create a durable subscription by storing the sequence-id of the last message and using this id as the id to start from.</p>
<h1>Exception handling</h1>
<p><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html" title="Listen to messages from a reliable_topic.">reliable_listener</a> also gives the ability to deal with exceptions via the method <a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#a0af2c8673479c4057a6c26a0f9a4afdb" title="Set an handler function that checks if the listener should be terminated based on an exception thrown...">reliable_listener::terminate_on_exception</a>.</p>
<h1>Global order</h1>
<p>The <a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html" title="Listen to messages from a reliable_topic.">reliable_listener</a> will always get all events in order (global order). It will not get duplicates and there will only be gaps if it is too slow. For more information see <a class="el" href="../../">isLossTolerant()</a>.</p>
<h1>Delivery guarantees</h1>
<p>Because the <a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html" title="Listen to messages from a reliable_topic.">reliable_listener</a> controls which item it wants to continue from upon restart, it is very easy to provide an at-least-once or at-most-once delivery guarantee. The function set via <a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#a41ead7e11fad23228c484eba92d31d44" title="Set an handler function to be invoked to informs the listener that it should store the sequence.">reliable_listener::on_store_sequence_id</a> is always called before a message is processed; so the id can be persisted on some non-volatile storage. When the the stored sequence-id is then passed to <a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#ab95364d47f11f51406674bbcbe348422">reliable_listener::reliable_listener</a>, an at-least-once delivery is implemented since the same item is now being processed twice. To implement an at-most-once delivery guarantee, add 1 to the stored sequence-id before passing it to <a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#ab95364d47f11f51406674bbcbe348422">reliable_listener::reliable_listener</a>. </p>

<p class="definition">Definition at line <a class="el" href="../../d0/dea/reliable__listener_8h_source.html#l00058">58</a> of file <a class="el" href="../../d0/dea/reliable__listener_8h_source.html">reliable_listener.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab95364d47f11f51406674bbcbe348422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95364d47f11f51406674bbcbe348422">&#9670;&nbsp;</a></span>reliable_listener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">hazelcast::client::topic::reliable_listener::reliable_listener </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loss_tolerant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>initial_sequence_id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loss_tolerant</td><td>true if this listener is able to deal with message loss. Even though the reliable topic promises to be reliable, it can be that the listener is too slow. Eventually the message won't be available anymore. If the <a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html" title="Listen to messages from a reliable_topic.">reliable_listener</a> is not loss tolerant and the topic detects that there are missing messages, it will terminate the <a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html" title="Listen to messages from a reliable_topic.">reliable_listener</a>. </td></tr>
    <tr><td class="paramname">initial_sequence_id</td><td>the initial sequence-id from which this listener should start. -1 if there is no initial sequence-id and you want to start from the next published message. If you intent to create a durable subscriber so you continue from where you stopped the previous time, load the previous sequence-id and add 1. If you don't add one, then you will be receiving the same message twice. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/dbe/proxy_8cpp_source.html#l00083">83</a> of file <a class="el" href="../../da/dbe/proxy_8cpp_source.html">proxy.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;                    : loss_tolerant_(loss_tolerant)</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;                    , initial_sequence_id_(initial_sequence_id) {}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af0928388c44745e1251cf1d0070deb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0928388c44745e1251cf1d0070deb5a">&#9670;&nbsp;</a></span>on_received() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handler , typename  = util::enable_if_rvalue_ref_t&lt;Handler &amp;&amp;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html">reliable_listener</a>&amp; hazelcast::client::topic::reliable_listener::on_received </td>
          <td>(</td>
          <td class="paramtype">Handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an handler function to be invoked when a message is received for the added topic. </p>
<p>Note that topic guarantees message ordering. Therefore there is only one thread invoking the function. The user should not keep the thread busy, but preferably should dispatch it via an Executor. This will increase the performance of the topic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>a <code>void</code> function object that is callable with a single parameter of type <code>Message &amp;&amp;</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dea/reliable__listener_8h_source.html#l00084">84</a> of file <a class="el" href="../../d0/dea/reliable__listener_8h_source.html">reliable_listener.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;                                                              {</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;                    received_ = std::move(h);</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;                    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a99fb738febb3f53cee2e9c73007f09a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99fb738febb3f53cee2e9c73007f09a2">&#9670;&nbsp;</a></span>on_received() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handler , typename  = util::enable_if_rvalue_ref_t&lt;Handler &amp;&amp;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html">reliable_listener</a>&amp;&amp; hazelcast::client::topic::reliable_listener::on_received </td>
          <td>(</td>
          <td class="paramtype">Handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an handler function to be invoked when a message is received for the added topic. </p>
<p>Note that topic guarantees message ordering. Therefore there is only one thread invoking the function. The user should not keep the thread busy, but preferably should dispatch it via an Executor. This will increase the performance of the topic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>a <code>void</code> function object that is callable with a single parameter of type <code>Message &amp;&amp;</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dea/reliable__listener_8h_source.html#l00094">94</a> of file <a class="el" href="../../d0/dea/reliable__listener_8h_source.html">reliable_listener.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;                                                                {</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;                    <a class="code" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#af0928388c44745e1251cf1d0070deb5a">on_received</a>(std::move(h));</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;                    <span class="keywordflow">return</span> std::move(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;                }</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1topic_1_1reliable__listener_html_af0928388c44745e1251cf1d0070deb5a"><div class="ttname"><a href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#af0928388c44745e1251cf1d0070deb5a">hazelcast::client::topic::reliable_listener::on_received</a></div><div class="ttdeci">reliable_listener &amp; on_received(Handler &amp;&amp;h) &amp;</div><div class="ttdoc">Set an handler function to be invoked when a message is received for the added topic.</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/dea/reliable__listener_8h_source.html#l00084">reliable_listener.h:84</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a41ead7e11fad23228c484eba92d31d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ead7e11fad23228c484eba92d31d44">&#9670;&nbsp;</a></span>on_store_sequence_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handler , typename  = util::enable_if_rvalue_ref_t&lt;Handler &amp;&amp;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html">reliable_listener</a>&amp; hazelcast::client::topic::reliable_listener::on_store_sequence_id </td>
          <td>(</td>
          <td class="paramtype">Handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an handler function to be invoked to informs the listener that it should store the sequence. </p>
<p>This method is called before the message is processed. Can be used to make a durable subscription.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>a <code>void</code> function object that is callable with a single parameter of type <code>int64_t</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> <br  />
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dea/reliable__listener_8h_source.html#l00108">108</a> of file <a class="el" href="../../d0/dea/reliable__listener_8h_source.html">reliable_listener.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;                                                                       {</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;                    store_sequence_id_ = std::move(h);</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;                    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;                }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a17983a0fab6b5b4685bfc31ba937f32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17983a0fab6b5b4685bfc31ba937f32b">&#9670;&nbsp;</a></span>on_store_sequence_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handler , typename  = util::enable_if_rvalue_ref_t&lt;Handler &amp;&amp;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html">reliable_listener</a>&amp;&amp; hazelcast::client::topic::reliable_listener::on_store_sequence_id </td>
          <td>(</td>
          <td class="paramtype">Handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p></p>

<p class="definition">Definition at line <a class="el" href="../../d0/dea/reliable__listener_8h_source.html#l00118">118</a> of file <a class="el" href="../../d0/dea/reliable__listener_8h_source.html">reliable_listener.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                                                                         {</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;                    <a class="code" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#a41ead7e11fad23228c484eba92d31d44">on_store_sequence_id</a>(std::move(h));</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;                    <span class="keywordflow">return</span> std::move(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;                }</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1topic_1_1reliable__listener_html_a41ead7e11fad23228c484eba92d31d44"><div class="ttname"><a href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#a41ead7e11fad23228c484eba92d31d44">hazelcast::client::topic::reliable_listener::on_store_sequence_id</a></div><div class="ttdeci">reliable_listener &amp; on_store_sequence_id(Handler &amp;&amp;h) &amp;</div><div class="ttdoc">Set an handler function to be invoked to informs the listener that it should store the sequence.</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/dea/reliable__listener_8h_source.html#l00108">reliable_listener.h:108</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0af2c8673479c4057a6c26a0f9a4afdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af2c8673479c4057a6c26a0f9a4afdb">&#9670;&nbsp;</a></span>terminate_on_exception() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handler , typename  = util::enable_if_rvalue_ref_t&lt;Handler &amp;&amp;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html">reliable_listener</a>&amp; hazelcast::client::topic::reliable_listener::terminate_on_exception </td>
          <td>(</td>
          <td class="paramtype">Handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an handler function that checks if the listener should be terminated based on an exception thrown while calling the function set by <a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#af0928388c44745e1251cf1d0070deb5a" title="Set an handler function to be invoked when a message is received for the added topic.">reliable_listener::on_received</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>a <code>void</code> function object that is callable with a single parameter of type <code>const IException &amp;</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dea/reliable__listener_8h_source.html#l00132">132</a> of file <a class="el" href="../../d0/dea/reliable__listener_8h_source.html">reliable_listener.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;                                                                         {</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;                    terminal_ = std::move(h);</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;                    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;                }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a12ee11117f65f157e7e60e75a65fec54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ee11117f65f157e7e60e75a65fec54">&#9670;&nbsp;</a></span>terminate_on_exception() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Handler , typename  = util::enable_if_rvalue_ref_t&lt;Handler &amp;&amp;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html">reliable_listener</a>&amp;&amp; hazelcast::client::topic::reliable_listener::terminate_on_exception </td>
          <td>(</td>
          <td class="paramtype">Handler &amp;&amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an handler function that checks if the listener should be terminated based on an exception thrown while calling the function set by <a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#af0928388c44745e1251cf1d0070deb5a" title="Set an handler function to be invoked when a message is received for the added topic.">reliable_listener::on_received</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>a <code>void</code> function object that is callable with a single parameter of type <code>const IException &amp;</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>*this</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d0/dea/reliable__listener_8h_source.html#l00142">142</a> of file <a class="el" href="../../d0/dea/reliable__listener_8h_source.html">reliable_listener.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;                                                                           {</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;                    <a class="code" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#a0af2c8673479c4057a6c26a0f9a4afdb">terminate_on_exception</a>(std::move(h));</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;                    <span class="keywordflow">return</span> std::move(*<span class="keyword">this</span>);</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;                }</div>
<div class="ttc" id="aclasshazelcast_1_1client_1_1topic_1_1reliable__listener_html_a0af2c8673479c4057a6c26a0f9a4afdb"><div class="ttname"><a href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html#a0af2c8673479c4057a6c26a0f9a4afdb">hazelcast::client::topic::reliable_listener::terminate_on_exception</a></div><div class="ttdeci">reliable_listener &amp; terminate_on_exception(Handler &amp;&amp;h) &amp;</div><div class="ttdoc">Set an handler function that checks if the listener should be terminated based on an exception thrown...</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/dea/reliable__listener_8h_source.html#l00132">reliable_listener.h:132</a></div></div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>hazelcast/include/hazelcast/client/topic/<a class="el" href="../../d0/dea/reliable__listener_8h_source.html">reliable_listener.h</a></li>
<li>hazelcast/src/hazelcast/client/<a class="el" href="../../da/dbe/proxy_8cpp_source.html">proxy.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>hazelcast</b></li><li class="navelem"><b>client</b></li><li class="navelem"><b>topic</b></li><li class="navelem"><a class="el" href="../../dc/d5b/classhazelcast_1_1client_1_1topic_1_1reliable__listener.html">reliable_listener</a></li>
    <li class="footer">Generated on Thu Aug 11 2022 13:14:28 for Hazelcast C++ Client by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
