/*
 * Copyright (c) 2008-2019, Hazelcast, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "HazelcastServerFactory.h"
#include "HazelcastServer.h"
#include "ClientTestSupport.h"
#include <regex>
#include <vector>
#include "ringbuffer/StartsWithStringFilter.h"
#include "serialization/Employee.h"
#include "ClientTestSupportBase.h"
#include <hazelcast/client/ClientConfig.h>
#include <hazelcast/client/exception/IllegalStateException.h>
#include <hazelcast/client/HazelcastClient.h>
#include <hazelcast/client/serialization/pimpl/SerializationService.h>
#include <hazelcast/util/UuidUtil.h>
#include <hazelcast/client/impl/Partition.h>
#include <gtest/gtest.h>
#include <thread>
#include <hazelcast/client/spi/ClientContext.h>
#include <hazelcast/client/connection/ClientConnectionManagerImpl.h>
#include <hazelcast/client/protocol/Principal.h>
#include <hazelcast/client/connection/Connection.h>
#include <ClientTestSupport.h>
#include <memory>
#include <hazelcast/client/proxy/ClientPNCounterProxy.h>
#include <hazelcast/client/serialization/pimpl/DataInput.h>
#include <hazelcast/util/AddressUtil.h>
#include <hazelcast/util/RuntimeAvailableProcessors.h>
#include <hazelcast/client/serialization/pimpl/DataOutput.h>
#include <hazelcast/util/AddressHelper.h>
#include <hazelcast/client/exception/IOException.h>
#include <hazelcast/client/protocol/ClientExceptionFactory.h>
#include <hazelcast/util/IOUtil.h>
#include <hazelcast/util/CountDownLatch.h>
#include <ClientTestSupportBase.h>
#include <hazelcast/util/Executor.h>
#include <hazelcast/util/Util.h>
#include <hazelcast/util/impl/SimpleExecutorService.h>
#include <TestHelperFunctions.h>
#include <ostream>
#include <hazelcast/util/ILogger.h>
#include <ctime>
#include <errno.h>
#include <hazelcast/client/LifecycleListener.h>
#include "serialization/TestRawDataPortable.h"
#include "serialization/TestSerializationConstants.h"
#include "serialization/TestMainPortable.h"
#include "serialization/TestNamedPortable.h"
#include "serialization/TestInvalidReadPortable.h"
#include "serialization/TestInvalidWritePortable.h"
#include "serialization/TestInnerPortable.h"
#include "serialization/TestNamedPortableV2.h"
#include "serialization/TestNamedPortableV3.h"
#include <hazelcast/client/SerializationConfig.h>
#include <hazelcast/client/HazelcastJsonValue.h>
#include <stdint.h>
#include "customSerialization/TestCustomSerializerX.h"
#include "customSerialization/TestCustomXSerializable.h"
#include "customSerialization/TestCustomPersonSerializer.h"
#include "serialization/ChildTemplatedPortable2.h"
#include "serialization/ParentTemplatedPortable.h"
#include "serialization/ChildTemplatedPortable1.h"
#include "serialization/ObjectCarryingPortable.h"
#include "serialization/TestDataSerializable.h"
#include <hazelcast/client/internal/nearcache/impl/NearCacheRecordStore.h>
#include <hazelcast/client/internal/nearcache/impl/store/NearCacheDataRecordStore.h>
#include <hazelcast/client/internal/nearcache/impl/store/NearCacheObjectRecordStore.h>
#include <hazelcast/client/query/FalsePredicate.h>
#include <set>
#include <hazelcast/client/query/EqualPredicate.h>
#include <hazelcast/client/query/QueryConstants.h>
#include <HazelcastServer.h>
#include "TestHelperFunctions.h"
#include <cmath>
#include <hazelcast/client/spi/impl/sequence/CallIdSequenceWithoutBackpressure.h>
#include <hazelcast/util/Thread.h>
#include <hazelcast/client/spi/impl/sequence/CallIdSequenceWithBackpressure.h>
#include <hazelcast/client/spi/impl/sequence/FailFastCallIdSequence.h>
#include <iostream>
#include <string>
#include "executor/tasks/SelectAllMembers.h"
#include "executor/tasks/IdentifiedFactory.h"
#include <hazelcast/client/serialization/ObjectDataOutput.h>
#include <hazelcast/client/serialization/ObjectDataInput.h>
#include "executor/tasks/CancellationAwareTask.h"
#include "executor/tasks/NullCallable.h"
#include "executor/tasks/SerializedCounterCallable.h"
#include "executor/tasks/MapPutPartitionAwareCallable.h"
#include "executor/tasks/SelectNoMembers.h"
#include "executor/tasks/GetMemberUuidTask.h"
#include "executor/tasks/FailingCallable.h"
#include "executor/tasks/AppendCallable.h"
#include "executor/tasks/TaskWithUnserializableResponse.h"
#include <executor/tasks/CancellationAwareTask.h>
#include <executor/tasks/FailingCallable.h>
#include <executor/tasks/SelectNoMembers.h>
#include <executor/tasks/SerializedCounterCallable.h>
#include <executor/tasks/TaskWithUnserializableResponse.h>
#include <executor/tasks/GetMemberUuidTask.h>
#include <executor/tasks/AppendCallable.h>
#include <executor/tasks/SelectAllMembers.h>
#include <executor/tasks/MapPutPartitionAwareCallable.h>
#include <executor/tasks/NullCallable.h>
#include <stdlib.h>
#include <fstream>
#include <boost/asio.hpp>
#include <cassert>

#ifdef HZ_BUILD_WITH_SSL
#include <openssl/crypto.h>
#endif

#include "hazelcast/client/config/ClientAwsConfig.h"
#include "hazelcast/client/aws/impl/DescribeInstances.h"
#include "hazelcast/client/ClientConfig.h"
#include "hazelcast/client/HazelcastClient.h"
#include "hazelcast/client/connection/ClientConnectionManagerImpl.h"
#include "hazelcast/client/serialization/ObjectDataOutput.h"
#include "hazelcast/client/serialization/ObjectDataInput.h"
#include "hazelcast/client/exception/ProtocolExceptions.h"
#include "hazelcast/client/internal/socket/SSLSocket.h"
#include "hazelcast/client/connection/Connection.h"
#include "hazelcast/util/CountDownLatch.h"
#include "hazelcast/client/MembershipListener.h"
#include "hazelcast/client/InitialMembershipEvent.h"
#include "hazelcast/client/InitialMembershipListener.h"
#include "hazelcast/client/MemberAttributeEvent.h"
#include "hazelcast/client/EntryAdapter.h"
#include "hazelcast/client/LifecycleListener.h"
#include "hazelcast/client/SocketInterceptor.h"
#include "hazelcast/client/Socket.h"
#include "hazelcast/client/Cluster.h"
#include "hazelcast/util/Sync.h"
#include "hazelcast/client/query/SqlPredicate.h"
#include "hazelcast/util/Util.h"
#include "hazelcast/util/Runnable.h"
#include "hazelcast/util/Thread.h"
#include "hazelcast/util/ILogger.h"
#include "hazelcast/client/IMap.h"
#include "hazelcast/util/Bits.h"
#include "hazelcast/util/SyncHttpsClient.h"
#include "hazelcast/client/exception/IOException.h"
#include "hazelcast/util/AtomicInt.h"
#include "hazelcast/util/BlockingConcurrentQueue.h"
#include "hazelcast/util/UTFUtil.h"
#include "hazelcast/util/ConcurrentQueue.h"
#include "hazelcast/util/impl/SimpleExecutorService.h"
#include "hazelcast/util/Future.h"
#include "hazelcast/util/concurrent/locks/LockSupport.h"
#include "hazelcast/client/ExecutionCallback.h"
#include "hazelcast/client/Pipelining.h"
#include "hazelcast/client/exception/IllegalArgumentException.h"
#include "hazelcast/client/serialization/PortableWriter.h"
#include "hazelcast/client/serialization/PortableReader.h"
#include "hazelcast/client/serialization/pimpl/SerializationService.h"
#include "hazelcast/client/SerializationConfig.h"
#include "hazelcast/util/MurmurHash3.h"
#include "hazelcast/client/ILock.h"
#include "hazelcast/client/ITopic.h"
#include "hazelcast/client/protocol/ClientMessage.h"
#include "hazelcast/client/protocol/ClientProtocolErrorCodes.h"
#include "hazelcast/client/adaptor/RawPointerSet.h"
#include "hazelcast/client/query/OrPredicate.h"
#include "hazelcast/client/query/RegexPredicate.h"
#include "hazelcast/client/query/PagingPredicate.h"
#include "hazelcast/client/query/QueryConstants.h"
#include "hazelcast/client/query/NotPredicate.h"
#include "hazelcast/client/query/InstanceOfPredicate.h"
#include "hazelcast/client/query/NotEqualPredicate.h"
#include "hazelcast/client/query/InPredicate.h"
#include "hazelcast/client/query/ILikePredicate.h"
#include "hazelcast/client/query/LikePredicate.h"
#include "hazelcast/client/query/GreaterLessPredicate.h"
#include "hazelcast/client/query/AndPredicate.h"
#include "hazelcast/client/query/BetweenPredicate.h"
#include "hazelcast/client/query/EqualPredicate.h"
#include "hazelcast/client/query/TruePredicate.h"
#include "hazelcast/client/query/FalsePredicate.h"
#include "hazelcast/client/adaptor/RawPointerMap.h"
#include "hazelcast/client/serialization/IdentifiedDataSerializable.h"
#include "hazelcast/client/adaptor/RawPointerList.h"
#include "hazelcast/client/adaptor/RawPointerTransactionalQueue.h"
#include "hazelcast/client/ItemListener.h"
#include "hazelcast/client/adaptor/RawPointerQueue.h"
#include "hazelcast/client/adaptor/RawPointerTransactionalMap.h"
#include "hazelcast/client/MultiMap.h"
#include "hazelcast/client/adaptor/RawPointerMultiMap.h"
#include "hazelcast/client/adaptor/RawPointerTransactionalMultiMap.h"
#include "hazelcast/util/LittleEndianBufferWrapper.h"
#include "hazelcast/client/exception/IllegalStateException.h"
#include "hazelcast/client/EntryEvent.h"
#include "hazelcast/client/HazelcastJsonValue.h"
#include "hazelcast/client/ISemaphore.h"
#include "hazelcast/client/IAtomicLong.h"
#include "hazelcast/client/mixedtype/MultiMap.h"
#include "hazelcast/client/mixedtype/IList.h"
#include "hazelcast/client/IList.h"
#include "hazelcast/client/IQueue.h"
#include "hazelcast/client/mixedtype/IQueue.h"
#include "hazelcast/client/ClientProperties.h"
#include "hazelcast/client/config/ClientAwsConfig.h"
#include "hazelcast/client/aws/utility/CloudUtility.h"
#include "hazelcast/client/ISet.h"
#include "hazelcast/client/mixedtype/ISet.h"
#include "hazelcast/client/ICountDownLatch.h"
#include "hazelcast/client/ReliableTopic.h"
#include "hazelcast/client/IdGenerator.h"

#if  defined(WIN32) || defined(_WIN32) || defined(WIN64) || defined(_WIN64)
#pragma warning(disable: 4996) //for unsafe getenv
#endif

namespace hazelcast {
    namespace client {
        namespace test {
            /**
            class ClientStatisticsTest : public ClientTestSupport {
            protected:
                static const int STATS_PERIOD_SECONDS = 1;

                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                }

                static void TearDownTestCase() {
                    delete instance;

                    instance = NULL;
                }

                Response getClientStatsFromServer() {
                    const char *script = "client0=instance_0.getClientService().getConnectedClients()."
                                         "toArray()[0]\nresult=client0.getClientStatistics();";

                    Response response;
                    RemoteControllerClient &controllerClient = g_srvFactory->getRemoteController();
                    controllerClient.executeOnController(response, g_srvFactory->getClusterId(), script, Lang::PYTHON);
                    return response;
                }

                std::string unescapeSpecialCharacters(const std::string &value) {
                    std::regex reBackslah("\\,");
                    auto escapedValue = std::regex_replace(value, reBackslah, ",");
                    std::regex reEqual("\\=");
                    escapedValue = std::regex_replace(escapedValue, reEqual, "=");
                    std::regex reDoubleBackslash("\\\\");
                    escapedValue = std::regex_replace(escapedValue, reDoubleBackslash, "\\");
                    return escapedValue;
                }

                std::map<std::string, std::string>
                getStatsFromResponse(const Response &statsResponse) {
                    std::map<std::string, std::string> statsMap;
                    if (statsResponse.success && !statsResponse.result.empty()) {
                        // passing -1 as the submatch index parameter performs splitting
                        std::regex re(",");
                        std::sregex_token_iterator first{statsResponse.result.begin(), statsResponse.result.end(), re,
                                                         -1}, last;

                        while (first != last) {
                            string input = unescapeSpecialCharacters(*first);
                            std::regex reEqual("=");
                            std::sregex_token_iterator tokenIt{input.begin(), input.end(), reEqual,
                                                             -1}, tokenLast;

                            if (tokenIt->length() > 1) {
                                auto pair = *tokenIt;
                                pair.
                                statsMap[keyValuePair[0]] = keyValuePair[1];
                            } else {
                                statsMap[keyValuePair[0]] = "";
                            }
                        }
                    }

                    return statsMap;
                }

                std::map<std::string, std::string> getStats() {
                    HazelcastServerFactory::Response statsResponse = getClientStatsFromServer();

                    return getStatsFromResponse(statsResponse);
                }

                bool verifyClientStatsFromServerIsNotEmpty() {
                    HazelcastServerFactory::Response response = getClientStatsFromServer();
                    return response.success && !response.result.empty();
                }

                std::unique_ptr<HazelcastClient> createHazelcastClient() {
                    ClientConfig clientConfig;
                    clientConfig.setProperty(ClientProperties::STATISTICS_ENABLED, "true")
                            .setProperty(ClientProperties::STATISTICS_PERIOD_SECONDS,
                                         hazelcast::util::IOUtil::to_string<int>(STATS_PERIOD_SECONDS))
                                    // add IMap Near Cache config
                            .addNearCacheConfig(std::shared_ptr<config::NearCacheConfig<int, int> >(
                                    new config::NearCacheConfig<int, int>(getTestName())));

                    clientConfig.getNetworkConfig().setConnectionAttemptLimit(20);

                    return std::unique_ptr<HazelcastClient>(new HazelcastClient(clientConfig));
                }

                void waitForFirstStatisticsCollection() {
                    ASSERT_TRUE_EVENTUALLY_WITH_TIMEOUT(verifyClientStatsFromServerIsNotEmpty(),
                                                        3 * STATS_PERIOD_SECONDS);
                }

                std::string getClientLocalAddress(HazelcastClient &client) {
                    spi::ClientContext clientContext(client);
                    connection::ClientConnectionManagerImpl &connectionManager = clientContext.getConnectionManager();
                    std::shared_ptr<connection::Connection> ownerConnection = connectionManager.getOwnerConnection();
                    std::unique_ptr<Address> localSocketAddress = ownerConnection->getLocalSocketAddress();
                    std::ostringstream localAddressString;
                    localAddressString << localSocketAddress->getHost() << ":" << localSocketAddress->getPort();
                    return localAddressString.str();
                }

                bool isStatsUpdated(const std::string &lastStatisticsCollectionTime) {
                    std::map<string, string> stats = getStats();
                    if (stats["lastStatisticsCollectionTime"] != lastStatisticsCollectionTime) {
                        return true;
                    }
                    return false;
                }

                void produceSomeStats(HazelcastClient &client) {
                    IMap<int, int> map = client.getMap<int, int>(getTestName());
                    produceSomeStats(map);
                }

                void produceSomeStats(IMap<int, int> &map) {
                    map.put(5, 10);
                    ASSERT_EQ(10, *map.get(5));
                    ASSERT_EQ(10, *map.get(5));
                }

                std::string toString(const std::map<std::string, std::string> &map) {
                    std::ostringstream out;
                    typedef std::map<std::string, std::string> StringMap;
                    out << "Map {" << std::endl;
                    for (const StringMap::value_type &entry : map) {
                        out << "\t\t(" << entry.first << " , " << entry.second << ")" << std::endl;
                    }
                    out << "}" << std::endl;

                    return out.str();
                }

                static HazelcastServer *instance;
            };

            HazelcastServer *ClientStatisticsTest::instance = NULL;

            TEST_F(ClientStatisticsTest, testClientStatisticsDisabledByDefault) {

                ClientConfig clientConfig;
                clientConfig.setProperty(ClientProperties::STATISTICS_PERIOD_SECONDS, "1");

                HazelcastClient client(clientConfig);

                // sleep twice the collection period
                sleepSeconds(2);

                HazelcastServerFactory::Response statsFromServer = getClientStatsFromServer();
                ASSERT_TRUE(statsFromServer.success);
                ASSERT_TRUE(statsFromServer.message.empty()) << "Statistics should be disabled by default.";
            }

            TEST_F(ClientStatisticsTest, testNoUpdateWhenDisabled) {
                ClientConfig clientConfig;
                clientConfig.setProperty(ClientProperties::STATISTICS_ENABLED, "false").setProperty(
                        ClientProperties::STATISTICS_PERIOD_SECONDS, "1");

                HazelcastClient client(clientConfig);

                ASSERT_TRUE_ALL_THE_TIME(getStats().empty(), 2);
            }

            TEST_F(ClientStatisticsTest, testClientStatisticsDisabledWithWrongValue) {

                ClientConfig clientConfig;
                clientConfig.setProperty(ClientProperties::STATISTICS_ENABLED, "trueee");

                HazelcastClient client(clientConfig);

                // sleep twice the collection period
                sleepSeconds(2);

                HazelcastServerFactory::Response statsFromServer = getClientStatsFromServer();
                ASSERT_TRUE(statsFromServer.success);
                ASSERT_TRUE(statsFromServer.message.empty()) << "Statistics should not be enabled with wrong value.";
            }

            TEST_F(ClientStatisticsTest, testClientStatisticsContent) {
                ClientConfig clientConfig;
                std::string mapName = getTestName();
                clientConfig.addNearCacheConfig(
                        std::shared_ptr<config::NearCacheConfig<int, int> >(new config::NearCacheConfig<int, int>(
                                mapName.c_str())));
                clientConfig.setProperty(ClientProperties::STATISTICS_ENABLED, "true").setProperty(
                        ClientProperties::STATISTICS_PERIOD_SECONDS, "1");

                HazelcastClient client(clientConfig);

                // initialize near cache
                client.getMap<int, int>(mapName);

                // sleep twice the collection period
                sleepSeconds(2);

                HazelcastServerFactory::Response statsFromServer = getClientStatsFromServer();
                ASSERT_TRUE(statsFromServer.success);
                ASSERT_FALSE(statsFromServer.result.empty());

                std::string localAddress = getClientLocalAddress(client);

                ASSERT_NE(std::string::npos,
                          statsFromServer.result.find(std::string("clientName=") + client.getName()));
                ASSERT_NE(std::string::npos, statsFromServer.result.find("lastStatisticsCollectionTime="));
                ASSERT_NE(std::string::npos, statsFromServer.result.find("enterprise=false"));
                ASSERT_NE(std::string::npos, statsFromServer.result.find("clientType=CPP"));
                ASSERT_NE(std::string::npos,
                          statsFromServer.result.find(std::string("clientVersion=") + HAZELCAST_VERSION));
                ASSERT_NE(std::string::npos, statsFromServer.result.find("clusterConnectionTimestamp="));
                ASSERT_NE(std::string::npos,
                          statsFromServer.result.find(std::string("clientAddress=") + localAddress));

                ASSERT_NE(std::string::npos,
                          statsFromServer.result.find(std::string("nc.") + mapName + "." + "creationTime"));
                ASSERT_NE(std::string::npos,
                          statsFromServer.result.find(std::string("nc.") + mapName + "." + "evictions"));
                ASSERT_NE(std::string::npos,
                          statsFromServer.result.find(std::string("nc.") + mapName + "." + "hits"));
                ASSERT_NE(std::string::npos,
                          statsFromServer.result.find(std::string("nc.") + mapName + "." + "lastPersistenceDuration"));
                ASSERT_NE(std::string::npos,
                          statsFromServer.result.find(std::string("nc.") + mapName + "." + "lastPersistenceKeyCount"));
                ASSERT_NE(std::string::npos,
                          statsFromServer.result.find(std::string("nc.") + mapName + "." + "lastPersistenceTime"));
                ASSERT_NE(std::string::npos,
                          statsFromServer.result.find(
                                  std::string("nc.") + mapName + "." + "lastPersistenceWrittenBytes"));
                ASSERT_NE(std::string::npos,
                          statsFromServer.result.find(std::string("nc.") + mapName + "." + "misses"));
                ASSERT_NE(std::string::npos,
                          statsFromServer.result.find(std::string("nc.") + mapName + "." + "ownedEntryCount"));
                ASSERT_NE(std::string::npos,
                          statsFromServer.result.find(std::string("nc.") + mapName + "." + "expirations"));
                ASSERT_NE(std::string::npos,
                          statsFromServer.result.find(std::string("nc.") + mapName + "." + "invalidations"));
                ASSERT_NE(std::string::npos,
                          statsFromServer.result.find(std::string("nc.") + mapName + "." + "invalidationRequests"));
                ASSERT_NE(std::string::npos,
                          statsFromServer.result.find(std::string("nc.") + mapName + "." + "ownedEntryMemoryCost"));
                ASSERT_NE(std::string::npos,
                          statsFromServer.result.find(std::string("nc.") + mapName + "." + "creationTime"));
                ASSERT_NE(std::string::npos,
                          statsFromServer.result.find(std::string("nc.") + mapName + "." + "creationTime"));
            }

            TEST_F(ClientStatisticsTest, testStatisticsCollectionNonDefaultPeriod) {
                std::unique_ptr<HazelcastClient> client = createHazelcastClient();

                int64_t clientConnectionTime = hazelcast::util::currentTimeMillis();

                // wait enough time for statistics collection
                waitForFirstStatisticsCollection();

                Response statsResponse = getClientStatsFromServer();
                ASSERT_TRUE(statsResponse.success);
                string &stats = statsResponse.result;
                ASSERT_TRUE(!stats.empty());

                std::map<std::string, std::string> statsMap = getStatsFromResponse(statsResponse);

                ASSERT_EQ(1U, statsMap.count("clusterConnectionTimestamp"))
                                            << "clusterConnectionTimestamp stat should exist (" << stats << ")";
                int64_t connectionTimeStat;
                ASSERT_NO_THROW(
                        (connectionTimeStat = std::stoll(statsMap["clusterConnectionTimestamp"])))
                                            << "connectionTimeStat value is not in correct (" << stats << ")";

                ASSERT_EQ(1U, statsMap.count("clientAddress")) << "clientAddress stat should exist (" << stats << ")";
                std::string expectedClientAddress = getClientLocalAddress(*client);
                ASSERT_EQ(expectedClientAddress, statsMap["clientAddress"]);

                ASSERT_EQ(1U, statsMap.count("clientVersion")) << "clientVersion stat should exist (" << stats << ")";
                ASSERT_EQ(HAZELCAST_VERSION, statsMap["clientVersion"]);

                // time measured by us after client connection should be greater than the connection time reported by the statistics
                ASSERT_GE(clientConnectionTime, connectionTimeStat) << "connectionTimeStat was " << connectionTimeStat
                                                                    << ", clientConnectionTime was "
                                                                    << clientConnectionTime << "(" << stats << ")";

                std::string mapHitsKey = "nc." + getTestName() + ".hits";
                ASSERT_EQ(0U, statsMap.count(mapHitsKey)) << mapHitsKey << " stat should not exist (" << stats << ")";

                ASSERT_EQ(1U, statsMap.count("lastStatisticsCollectionTime"))
                                            << "lastStatisticsCollectionTime stat should exist (" << stats << ")";
                std::string lastStatisticsCollectionTimeString = statsMap["lastStatisticsCollectionTime"];
                ASSERT_NO_THROW((std::stoll(lastStatisticsCollectionTimeString)))
                                            << "lastStatisticsCollectionTime value is not in correct (" << stats << ")";

                // this creates empty map statistics
                IMap<int, int> map = client->getMap<int, int>(getTestName());

                statsMap = getStats();
                lastStatisticsCollectionTimeString = statsMap["lastStatisticsCollectionTime"];

                // wait enough time for statistics collection
                ASSERT_TRUE_EVENTUALLY(isStatsUpdated(lastStatisticsCollectionTimeString));

                statsMap = getStats();
                ASSERT_EQ(1U, statsMap.count(mapHitsKey))
                                            << mapHitsKey << " stat should exist (" << toString(statsMap) << ")";
                ASSERT_EQ("0", statsMap[mapHitsKey]) << "Expected 0 map hits (" << toString(statsMap) << ")";

                // produce map stat
                produceSomeStats(map);

                statsMap = getStats();
                lastStatisticsCollectionTimeString = statsMap["lastStatisticsCollectionTime"];

                // wait enough time for statistics collection
                ASSERT_TRUE_EVENTUALLY(isStatsUpdated(lastStatisticsCollectionTimeString));

                statsMap = getStats();
                ASSERT_EQ(1U, statsMap.count(mapHitsKey))
                                            << mapHitsKey << " stat should exist (" << toString(statsMap) << ")";
                ASSERT_EQ("1", statsMap[mapHitsKey]) << "Expected 1 map hits (" << toString(statsMap) << ")";
            }

            TEST_F(ClientStatisticsTest, testStatisticsPeriod) {
                std::unique_ptr<HazelcastClient> client = createHazelcastClient();

                // wait enough time for statistics collection
                waitForFirstStatisticsCollection();

                std::map<std::string, std::string> initialStats = getStats();

                // produce map stat
                produceSomeStats(*client);

                // wait enough time for statistics collection
                ASSERT_TRUE_EVENTUALLY(isStatsUpdated(initialStats["lastStatisticsCollectionTime"]));

                ASSERT_NE(initialStats, getStats()) << "initial statistics should not be the same as current stats";
            }
*/
        }
    }
}





namespace hazelcast {
    namespace client {
        namespace test {
            namespace ringbuffer {
                StartsWithStringFilter::StartsWithStringFilter(const std::string &startString) : startString(
                        startString) {}

                int StartsWithStringFilter::getFactoryId() const {
                    return 666;
                }

                int StartsWithStringFilter::getClassId() const {
                    return 14;
                }

                void StartsWithStringFilter::writeData(serialization::ObjectDataOutput &writer) const {
                    writer.writeUTF(&startString);
                }

                void StartsWithStringFilter::readData(serialization::ObjectDataInput &reader) {
                    startString = *reader.readUTF();
                }
            }
        }
    }
}




using namespace hazelcast::client::mixedtype;

namespace hazelcast {
    namespace client {
        namespace test {
            class MixedRingbufferTest : public ClientTestSupport {
            public:
                MixedRingbufferTest() : rb(client->toMixedType().getRingbuffer(getTestName())) {
                }

            protected:
                virtual void TearDown() {
                }

                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    client = new HazelcastClient;
                }

                static void TearDownTestCase() {
                    delete client;
                    delete instance;

                    client = NULL;
                    instance = NULL;
                }

                mixedtype::Ringbuffer rb;
                static HazelcastServer *instance;
                static HazelcastClient *client;

                static const int64_t CAPACITY;
            };

            const int64_t MixedRingbufferTest::CAPACITY = 10;

            HazelcastServer *MixedRingbufferTest::instance = NULL;
            HazelcastClient *MixedRingbufferTest::client = NULL;

            TEST_F(MixedRingbufferTest, testAPI) {
                ASSERT_EQ(CAPACITY, rb.capacity());
                ASSERT_EQ(0, rb.headSequence());
                ASSERT_EQ(-1, rb.tailSequence());
                ASSERT_EQ(0, rb.size());
                ASSERT_EQ(CAPACITY, rb.remainingCapacity());
                ASSERT_THROW(rb.readOne(-1), exception::IllegalArgumentException);
                ASSERT_THROW(rb.readOne(1), exception::IllegalArgumentException);

                Employee employee1("First", 10);
                Employee employee2("Second", 20);

                ASSERT_EQ(0, rb.add<Employee>(employee1));
                ASSERT_EQ(CAPACITY, rb.capacity());
                ASSERT_EQ(CAPACITY, rb.remainingCapacity());
                ASSERT_EQ(0, rb.headSequence());
                ASSERT_EQ(0, rb.tailSequence());
                ASSERT_EQ(1, rb.size());
                ASSERT_EQ(employee1, *rb.readOne(0).get<Employee>());
                ASSERT_THROW(rb.readOne(2), exception::IllegalArgumentException);

                ASSERT_EQ(1, rb.add<Employee>(employee2));
                ASSERT_EQ(CAPACITY, rb.capacity());
                ASSERT_EQ(CAPACITY, rb.remainingCapacity());
                ASSERT_EQ(0, rb.headSequence());
                ASSERT_EQ(1, rb.tailSequence());
                ASSERT_EQ(2, rb.size());
                ASSERT_EQ(employee1, *rb.readOne(0).get<Employee>());
                ASSERT_EQ(employee2, *rb.readOne(1).get<Employee>());
                ASSERT_THROW(rb.readOne(3), exception::IllegalArgumentException);

                // insert many employees to fill the ringbuffer capacity
                for (int i = 0; i < CAPACITY - 2; ++i) {
                    Employee eleman("name", 10 * (i + 2));
                    ASSERT_EQ(i + 2, rb.add<Employee>(eleman));
                    ASSERT_EQ(CAPACITY, rb.capacity());
                    ASSERT_EQ(CAPACITY, rb.remainingCapacity());
                    ASSERT_EQ(0, rb.headSequence());
                    ASSERT_EQ(i + 2, rb.tailSequence());
                    ASSERT_EQ(i + 3, rb.size());
                    ASSERT_EQ(eleman, *rb.readOne(i + 2).get<Employee>());
                }

                // verify that the head element is overriden on the first add
                Employee latestEmployee("latest employee", 100);
                ASSERT_EQ(CAPACITY, rb.add<Employee>(latestEmployee));
                ASSERT_EQ(CAPACITY, rb.capacity());
                ASSERT_EQ(CAPACITY, rb.remainingCapacity());
                ASSERT_EQ(1, rb.headSequence());
                ASSERT_EQ(CAPACITY, rb.tailSequence());
                ASSERT_EQ(CAPACITY, rb.size());
                ASSERT_EQ(latestEmployee, *rb.readOne(CAPACITY).get<Employee>());
            }
        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            namespace ringbuffer {
                class RingbufferTest : public ClientTestSupport {
                public:
                    RingbufferTest() {
                        for (int i = 0; i < 11; ++i) {
                            std::ostringstream out;
                            out << i;
                            items.push_back(out.str());
                        }
                    }

                protected:
                    class ReadOneWithLatchTask : public hazelcast::util::Runnable {
                    public:
                        ReadOneWithLatchTask(const std::shared_ptr<Ringbuffer<std::string> > &clientRingbuffer,
                                             const std::shared_ptr<CountDownLatch> &latch) : clientRingbuffer(
                                clientRingbuffer), latch(latch) {}

                        virtual const string getName() const {
                            return "ReadOneWithLatchTask";
                        }

                        virtual void run() {
                            try {
                                clientRingbuffer->readOne(0);
                            } catch (exception::InterruptedException &e) {
                                std::cerr << e;
                            } catch (exception::StaleSequenceException &) {
                                latch->countDown();
                            }
                        }

                    private:
                        const std::shared_ptr<Ringbuffer<std::string> > clientRingbuffer;
                        const std::shared_ptr<hazelcast::util::CountDownLatch> latch;
                        static const int CAPACITY;
                    };

                    virtual void SetUp() {
                        std::string testName = getTestName();
                        clientRingbuffer = client->getRingbuffer<std::string>(testName);
                        client2Ringbuffer = client2->getRingbuffer<std::string>(testName);
                    }

                    static void SetUpTestCase() {
                        instance = new HazelcastServer(*g_srvFactory);
                        client = new HazelcastClient(getConfig());
                        client2 = new HazelcastClient(getConfig());
                    }

                    static void TearDownTestCase() {
                        delete client;
                        delete client2;
                        delete instance;

                        client = NULL;
                        client2 = NULL;
                        instance = NULL;
                    }

                    static HazelcastServer *instance;
                    static HazelcastClient *client;
                    static HazelcastClient *client2;
                    std::shared_ptr<Ringbuffer<std::string> > clientRingbuffer;
                    std::shared_ptr<Ringbuffer<std::string> > client2Ringbuffer;
                    std::vector<std::string> items;

                    static const int64_t CAPACITY;
                };

                const int64_t RingbufferTest::CAPACITY = 10;

                HazelcastServer *RingbufferTest::instance = NULL;
                HazelcastClient *RingbufferTest::client = NULL;
                HazelcastClient *RingbufferTest::client2 = NULL;

                TEST_F(RingbufferTest, testAPI) {
                    std::shared_ptr<Ringbuffer<Employee> > rb = client->getRingbuffer<Employee>(getTestName() + "2");
                    ASSERT_EQ(CAPACITY, rb->capacity());
                    ASSERT_EQ(0, rb->headSequence());
                    ASSERT_EQ(-1, rb->tailSequence());
                    ASSERT_EQ(0, rb->size());
                    ASSERT_EQ(CAPACITY, rb->remainingCapacity());
                    ASSERT_THROW(rb->readOne(-1), exception::IllegalArgumentException);
                    ASSERT_THROW(rb->readOne(1), exception::IllegalArgumentException);

                    Employee employee1("First", 10);
                    Employee employee2("Second", 20);

                    ASSERT_EQ(0, rb->add(employee1));
                    ASSERT_EQ(CAPACITY, rb->capacity());
                    ASSERT_EQ(CAPACITY, rb->remainingCapacity());
                    ASSERT_EQ(0, rb->headSequence());
                    ASSERT_EQ(0, rb->tailSequence());
                    ASSERT_EQ(1, rb->size());
                    ASSERT_EQ(employee1, *rb->readOne(0));
                    ASSERT_THROW(rb->readOne(2), exception::IllegalArgumentException);

                    ASSERT_EQ(1, rb->add(employee2));
                    ASSERT_EQ(CAPACITY, rb->capacity());
                    ASSERT_EQ(CAPACITY, rb->remainingCapacity());
                    ASSERT_EQ(0, rb->headSequence());
                    ASSERT_EQ(1, rb->tailSequence());
                    ASSERT_EQ(2, rb->size());
                    ASSERT_EQ(employee1, *rb->readOne(0));
                    ASSERT_EQ(employee2, *rb->readOne(1));
                    ASSERT_THROW(*rb->readOne(3), exception::IllegalArgumentException);

                    // insert many employees to fill the ringbuffer capacity
                    for (int i = 0; i < CAPACITY - 2; ++i) {
                        Employee eleman("name", 10 * (i + 2));
                        ASSERT_EQ(i + 2, rb->add(eleman));
                        ASSERT_EQ(CAPACITY, rb->capacity());
                        ASSERT_EQ(CAPACITY, rb->remainingCapacity());
                        ASSERT_EQ(0, rb->headSequence());
                        ASSERT_EQ(i + 2, rb->tailSequence());
                        ASSERT_EQ(i + 3, rb->size());
                        ASSERT_EQ(eleman, *rb->readOne(i + 2));
                    }

                    // verify that the head element is overriden on the first add
                    Employee latestEmployee("latest employee", 100);
                    ASSERT_EQ(CAPACITY, rb->add(latestEmployee));
                    ASSERT_EQ(CAPACITY, rb->capacity());
                    ASSERT_EQ(CAPACITY, rb->remainingCapacity());
                    ASSERT_EQ(1, rb->headSequence());
                    ASSERT_EQ(CAPACITY, rb->tailSequence());
                    ASSERT_EQ(CAPACITY, rb->size());
                    ASSERT_EQ(latestEmployee, *rb->readOne(CAPACITY));
                }

                TEST_F(RingbufferTest, readManyAsync_whenHitsStale_shouldNotBeBlocked) {
                    std::shared_ptr<ICompletableFuture<client::ringbuffer::ReadResultSet<std::string> > > f = clientRingbuffer->readManyAsync<void>(
                            0, 1, 10, NULL);
                    client2Ringbuffer->addAllAsync(items, Ringbuffer<std::string>::OVERWRITE);
                    try {
                        f->get();
                    } catch (exception::ExecutionException &e) {
                        std::shared_ptr<exception::IException> cause = e.getCause();
                        ASSERT_NOTNULL(cause.get(), exception::IException);
                        ASSERT_THROW(cause->raise(), exception::StaleSequenceException);
                    }
                }

                TEST_F(RingbufferTest, readOne_whenHitsStale_shouldNotBeBlocked) {
                    std::shared_ptr<hazelcast::util::CountDownLatch> latch = std::make_shared<hazelcast::util::CountDownLatch>(
                            1);
                    hazelcast::util::Thread consumer(std::make_shared<ReadOneWithLatchTask>(clientRingbuffer, latch),
                                                     getLogger());
                    consumer.start();
                    client2Ringbuffer->addAllAsync(items, Ringbuffer<std::string>::OVERWRITE);
                    ASSERT_OPEN_EVENTUALLY(*latch);
                }

                TEST_F(RingbufferTest, headSequence) {
                    for (int k = 0; k < 2 * CAPACITY; k++) {
                        client2Ringbuffer->add("foo");
                    }

                    ASSERT_EQ(client2Ringbuffer->headSequence(), clientRingbuffer->headSequence());
                }

                TEST_F(RingbufferTest, tailSequence) {
                    for (int k = 0; k < 2 * CAPACITY; k++) {
                        client2Ringbuffer->add("foo");
                    }

                    ASSERT_EQ(client2Ringbuffer->tailSequence(), clientRingbuffer->tailSequence());
                }

                TEST_F(RingbufferTest, size) {
                    client2Ringbuffer->add("foo");

                    ASSERT_EQ(client2Ringbuffer->tailSequence(), clientRingbuffer->tailSequence());
                }

                TEST_F(RingbufferTest, capacity) {
                    ASSERT_EQ(client2Ringbuffer->capacity(), clientRingbuffer->capacity());
                }

                TEST_F(RingbufferTest, remainingCapacity) {
                    client2Ringbuffer->add("foo");

                    ASSERT_EQ(client2Ringbuffer->remainingCapacity(), clientRingbuffer->remainingCapacity());
                }

                TEST_F(RingbufferTest, add) {
                    clientRingbuffer->add("foo");

                    std::unique_ptr<std::string> value = client2Ringbuffer->readOne(0);
                    ASSERT_EQ_PTR("foo", value.get(), std::string);
                }

                TEST_F(RingbufferTest, addAsync) {
                    std::shared_ptr<ICompletableFuture<int64_t> > f = clientRingbuffer->addAsync("foo",
                                                                                                 Ringbuffer<std::string>::OVERWRITE);
                    std::shared_ptr<int64_t> result = f->get();

                    ASSERT_EQ_PTR(client2Ringbuffer->headSequence(), result.get(), int64_t);
                    ASSERT_EQ_PTR("foo", client2Ringbuffer->readOne(0).get(), std::string);
                    ASSERT_EQ(0, client2Ringbuffer->headSequence());
                    ASSERT_EQ(0, client2Ringbuffer->tailSequence());
                }

                TEST_F(RingbufferTest, addAllAsync) {
                    std::vector<std::string> items;
                    items.push_back("foo");
                    items.push_back("bar");
                    std::shared_ptr<ICompletableFuture<int64_t> > f = clientRingbuffer->addAllAsync(items,
                                                                                                    Ringbuffer<std::string>::OVERWRITE);
                    std::shared_ptr<int64_t> result = f->get();

                    ASSERT_EQ_PTR(client2Ringbuffer->tailSequence(), result.get(), int64_t);
                    ASSERT_EQ_PTR("foo", client2Ringbuffer->readOne(0).get(), std::string);
                    ASSERT_EQ_PTR("bar", client2Ringbuffer->readOne(1).get(), std::string);
                    ASSERT_EQ(0, client2Ringbuffer->headSequence());
                    ASSERT_EQ(1, client2Ringbuffer->tailSequence());
                }

                TEST_F(RingbufferTest, readOne) {
                    client2Ringbuffer->add("foo");
                    ASSERT_EQ_PTR("foo", clientRingbuffer->readOne(0).get(), std::string);
                }

                TEST_F(RingbufferTest, readManyAsync_noFilter) {
                    client2Ringbuffer->add("1");
                    client2Ringbuffer->add("2");
                    client2Ringbuffer->add("3");

                    std::shared_ptr<ICompletableFuture<client::ringbuffer::ReadResultSet<std::string> > > f = clientRingbuffer->readManyAsync<void>(
                            0, 3, 3, NULL);
                    std::shared_ptr<client::ringbuffer::ReadResultSet<std::string> > rs = f->get();

                    ASSERT_EQ(3, rs->readCount());
                    ASSERT_EQ_PTR("1", rs->getItems().get(0), std::string);
                    ASSERT_EQ_PTR("2", rs->getItems().get(1), std::string);
                    ASSERT_EQ_PTR("3", rs->getItems().get(2), std::string);
                }

// checks if the max count works. So if more results are available than needed, the surplus results should not be read.
                TEST_F(RingbufferTest, readManyAsync_maxCount) {
                    client2Ringbuffer->add("1");
                    client2Ringbuffer->add("2");
                    client2Ringbuffer->add("3");
                    client2Ringbuffer->add("4");
                    client2Ringbuffer->add("5");
                    client2Ringbuffer->add("6");

                    std::shared_ptr<ICompletableFuture<client::ringbuffer::ReadResultSet<std::string> > > f = clientRingbuffer->readManyAsync<void>(
                            0, 3, 3, NULL);
                    std::shared_ptr<client::ringbuffer::ReadResultSet<std::string> > rs = f->get();

                    ASSERT_EQ(3, rs->readCount());
                    DataArray<string> &items1 = rs->getItems();
                    ASSERT_EQ_PTR("1", items1.get(0), std::string);
                    ASSERT_EQ_PTR("2", items1.get(1), std::string);
                    ASSERT_EQ_PTR("3", items1.get(2), std::string);
                }

                TEST_F(RingbufferTest, readManyAsync_withFilter) {
                    client2Ringbuffer->add("good1");
                    client2Ringbuffer->add("bad1");
                    client2Ringbuffer->add("good2");
                    client2Ringbuffer->add("bad2");
                    client2Ringbuffer->add("good3");
                    client2Ringbuffer->add("bad3");

                    StartsWithStringFilter filter("good");
                    std::shared_ptr<ICompletableFuture<client::ringbuffer::ReadResultSet<std::string> > > f = clientRingbuffer->readManyAsync<StartsWithStringFilter>(
                            0, 3, 3, &filter);

                    std::shared_ptr<client::ringbuffer::ReadResultSet<std::string> > rs = f->get();

                    ASSERT_EQ(5, rs->readCount());
                    DataArray<string> &items = rs->getItems();
                    ASSERT_EQ_PTR("good1", items.get(0), std::string);
                    ASSERT_EQ_PTR("good2", items.get(1), std::string);
                    ASSERT_EQ_PTR("good3", items.get(2), std::string);
                }
            }
        }
    }
}


//
// Created by sancar koyunlu on 9/13/13.



namespace hazelcast {
    namespace client {
        namespace test {
            class PolymorphicDataSerializableRingbufferTest : public ClientTestSupport {
            protected:
                class BaseDataSerializable : public serialization::IdentifiedDataSerializable {
                public:
                    virtual ~BaseDataSerializable() {}

                    virtual int getFactoryId() const {
                        return 666;
                    }

                    virtual int getClassId() const {
                        return 10;
                    }

                    virtual void writeData(serialization::ObjectDataOutput &writer) const {
                    }

                    virtual void readData(serialization::ObjectDataInput &reader) {
                    }

                    virtual bool operator<(const BaseDataSerializable &rhs) const {
                        return getClassId() < rhs.getClassId();
                    }
                };

                class Derived1DataSerializable : public BaseDataSerializable {
                public:
                    virtual int getClassId() const {
                        return 11;
                    }
                };

                class Derived2DataSerializable : public Derived1DataSerializable {
                public:
                    virtual int getClassId() const {
                        return 12;
                    }
                };

                class PolymorphicDataSerializableFactory : public serialization::DataSerializableFactory {
                public:
                    virtual std::unique_ptr<serialization::IdentifiedDataSerializable> create(int32_t typeId) {
                        switch (typeId) {
                            case 10:
                                return std::unique_ptr<serialization::IdentifiedDataSerializable>(new BaseDataSerializable);
                            case 11:
                                return std::unique_ptr<serialization::IdentifiedDataSerializable>(new Derived1DataSerializable);
                            case 12:
                                return std::unique_ptr<serialization::IdentifiedDataSerializable>(new Derived2DataSerializable);
                            default:
                                return std::unique_ptr<serialization::IdentifiedDataSerializable>();
                        }
                    }
                };

                virtual void TearDown() {
                }

                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    ClientConfig clientConfig = getConfig();
                    SerializationConfig &serializationConfig = clientConfig.getSerializationConfig();
                    serializationConfig.addDataSerializableFactory(666,
                                                                   std::shared_ptr<serialization::DataSerializableFactory>(
                                                                           new PolymorphicDataSerializableFactory()));
                    client = new HazelcastClient(clientConfig);
                    rb = client->getRingbuffer<BaseDataSerializable>("rb-1");
                }

                static void TearDownTestCase() {
                    delete client;
                    delete instance;

                    client = NULL;
                    instance = NULL;
                }

                static HazelcastServer *instance;
                static HazelcastClient *client;
                static std::shared_ptr<Ringbuffer<BaseDataSerializable> > rb;
            };


            HazelcastServer *PolymorphicDataSerializableRingbufferTest::instance = NULL;
            HazelcastClient *PolymorphicDataSerializableRingbufferTest::client = NULL;
            std::shared_ptr<Ringbuffer<PolymorphicDataSerializableRingbufferTest::BaseDataSerializable> > PolymorphicDataSerializableRingbufferTest::rb;

            TEST_F(PolymorphicDataSerializableRingbufferTest, testPolymorhism) {
                BaseDataSerializable base;
                Derived1DataSerializable derived1;
                Derived2DataSerializable derived2;
                rb->add(base);
                rb->add(derived1);
                rb->add(derived2);

                int64_t sequence = rb->headSequence();
                std::unique_ptr<BaseDataSerializable> value = rb->readOne(sequence);
                ASSERT_NE((BaseDataSerializable *) NULL, value.get());
                ASSERT_EQ(base.getClassId(), value->getClassId());

                value = rb->readOne(sequence + 1);
                ASSERT_NE((BaseDataSerializable *) NULL, value.get());
                ASSERT_EQ(derived1.getClassId(), value->getClassId());

                value = rb->readOne(sequence + 2);
                ASSERT_NE((BaseDataSerializable *) NULL, value.get());
                ASSERT_EQ(derived2.getClassId(), value->getClassId());
            }
        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            std::string ClientTestSupportBase::getCAFilePath() {
                return "hazelcast/test/resources/cpp_client.crt";
            }

            hazelcast::client::ClientConfig ClientTestSupportBase::getConfig() {
                ClientConfig clientConfig;
                clientConfig.addAddress(Address(g_srvFactory->getServerAddress(), 5701));
                return clientConfig;
            }

            HazelcastClient ClientTestSupportBase::getNewClient() {
                return HazelcastClient(getConfig());
            }

            const std::string ClientTestSupportBase::getSslFilePath() {
                return "hazelcast/test/resources/hazelcast-ssl.xml";
            }

            std::string ClientTestSupportBase::randomMapName() {
                return randomString();
            }

            std::string ClientTestSupportBase::randomString() {
                // TODO: Change with secure uuid generator as in Java
                return hazelcast::util::UuidUtil::newUnsecureUuidString();
            }

            void ClientTestSupportBase::sleepSeconds(int32_t seconds) {
                hazelcast::util::sleep(seconds);
            }

            ClientTestSupportBase::ClientTestSupportBase() {
            }

            std::string ClientTestSupportBase::generateKeyOwnedBy(spi::ClientContext &context, const Member &member) {
                spi::ClientPartitionService &partitionService = context.getPartitionService();
                serialization::pimpl::SerializationService &serializationService = context.getSerializationService();
                while (true) {
                    std::string id = randomString();
                    int partitionId = partitionService.getPartitionId(serializationService.toData<std::string>(&id));
                    std::shared_ptr<impl::Partition> partition = partitionService.getPartition(partitionId);
                    if (*partition->getOwner() == member) {
                        return id;
                    }
                }
            }
        }
    }

    namespace util {
        StartedThread::StartedThread(const std::string &name, void (*func)(ThreadArgs &),
                                     void *arg0, void *arg1, void *arg2, void *arg3)
                : name(name), logger(new hazelcast::util::ILogger("StartedThread", "StartedThread", "testversion",
                                                                  client::config::LoggerConfig())) {
            init(func, arg0, arg1, arg2, arg3);
        }

        StartedThread::StartedThread(void (func)(ThreadArgs &),
                                     void *arg0,
                                     void *arg1,
                                     void *arg2,
                                     void *arg3)
                : name("hz.unnamed"),
                  logger(new hazelcast::util::ILogger("StartedThread", "StartedThread", "testversion",
                                                      client::config::LoggerConfig())) {
            init(func, arg0, arg1, arg2, arg3);
        }

        void StartedThread::init(void (func)(ThreadArgs &), void *arg0, void *arg1, void *arg2, void *arg3) {
            threadArgs.arg0 = arg0;
            threadArgs.arg1 = arg1;
            threadArgs.arg2 = arg2;
            threadArgs.arg3 = arg3;
            threadArgs.func = func;
            if (!logger->start()) {
                throw (client::exception::ExceptionBuilder<client::exception::IllegalStateException>(
                        "StartedThread::init") << "Could not start logger " << logger->getInstanceName()).build();
            }

            thread.reset(
                    new hazelcast::util::Thread(std::shared_ptr<hazelcast::util::Runnable>(new hazelcast::util::RunnableDelegator(*this)), *logger));
            threadArgs.currentThread = thread.get();
            thread->start();
        }

        void StartedThread::run() {
            threadArgs.func(threadArgs);
        }

        const std::string StartedThread::getName() const {
            return name;
        }

        bool StartedThread::join() {
            return thread->join();
        }

        StartedThread::~StartedThread() {
        }

        void StartedThread::cancel() {
            thread->cancel();
        }

    }
}


#ifdef HZ_BUILD_WITH_SSL
#endif

namespace hazelcast {
    namespace client {
        namespace test {
            class ClientConnectionTest : public ClientTestSupport {
            protected:
#ifdef HZ_BUILD_WITH_SSL
                std::vector<hazelcast::client::internal::socket::SSLSocket::CipherInfo> getCiphers(ClientConfig &config) {
                    HazelcastClient client(config);
                    spi::ClientContext context(client);
                    std::vector<std::shared_ptr<connection::Connection> > conns = context.getConnectionManager().getActiveConnections();
                    EXPECT_GT(conns.size(), (size_t) 0);
                    std::shared_ptr<connection::Connection> aConnection = conns[0];
                    hazelcast::client::internal::socket::SSLSocket &socket = (hazelcast::client::internal::socket::SSLSocket &) aConnection->getSocket();
                    return socket.getCiphers();
                }

#endif
            };

            TEST_F(ClientConnectionTest, testTcpSocketTimeoutToOutsideNetwork) {
                HazelcastServer instance(*g_srvFactory);
                ClientConfig config;
                config.getNetworkConfig().setConnectionAttemptPeriod(1000).setConnectionTimeout(2000).addAddress(
                        Address("8.8.8.8", 5701));
                ASSERT_THROW(HazelcastClient client(config), exception::IllegalStateException);
            }

#ifdef HZ_BUILD_WITH_SSL
            TEST_F(ClientConnectionTest, testSslSocketTimeoutToOutsideNetwork) {
                HazelcastServerFactory sslFactory(g_srvFactory->getServerAddress(), getSslFilePath());
                HazelcastServer instance(sslFactory);
                ClientConfig config;
                config.getNetworkConfig().setConnectionAttemptPeriod(1000).setConnectionTimeout(2000).addAddress(
                        Address("8.8.8.8", 5701)).getSSLConfig().setEnabled(true).addVerifyFile(getCAFilePath());
                ASSERT_THROW(HazelcastClient client(config), exception::IllegalStateException);
            }

            TEST_F(ClientConnectionTest, testSSLWrongCAFilePath) {
                HazelcastServerFactory sslFactory(g_srvFactory->getServerAddress(), getSslFilePath());
                HazelcastServer instance(sslFactory);
                ClientConfig config = getConfig();
                config.getNetworkConfig().getSSLConfig().setEnabled(true).addVerifyFile("abc");
                ASSERT_THROW(HazelcastClient client(config), exception::IllegalStateException);
            }

            TEST_F(ClientConnectionTest, testExcludedCipher) {
                HazelcastServerFactory sslFactory(g_srvFactory->getServerAddress(), getSslFilePath());
                HazelcastServer instance(sslFactory);

                ClientConfig config = getConfig();
                config.getNetworkConfig().getSSLConfig().setEnabled(true).addVerifyFile(getCAFilePath()).setCipherList(
                        "HIGH");
                std::vector<hazelcast::client::internal::socket::SSLSocket::CipherInfo> supportedCiphers = getCiphers(
                        config);

                std::string unsupportedCipher = supportedCiphers[supportedCiphers.size() - 1].name;
                config = getConfig();
                config.getNetworkConfig().getSSLConfig().setEnabled(true).addVerifyFile(getCAFilePath()).
                        setCipherList(std::string("HIGH:!") + unsupportedCipher);

                std::vector<hazelcast::client::internal::socket::SSLSocket::CipherInfo> newCiphers = getCiphers(config);

                for (std::vector<hazelcast::client::internal::socket::SSLSocket::CipherInfo>::const_iterator it = newCiphers.begin();
                     it != newCiphers.end(); ++it) {
                    ASSERT_NE(unsupportedCipher, it->name) << ", expected ciphers list lis:" << supportedCiphers.size()
                                                           << ", actual size of new ciphers:" << newCiphers.size();
                }

                ASSERT_EQ(supportedCiphers.size() - 1, newCiphers.size());
            }

#endif
        }
    }
}






namespace hazelcast {
    namespace client {
        namespace test {
            class ClusterTest : public ClientTestSupportBase, public ::testing::TestWithParam<ClientConfig *> {
            public:
                ClusterTest() : sslFactory(g_srvFactory->getServerAddress(), getSslFilePath()) {}

            protected:
                class ClientAllStatesListener : public LifecycleListener {
                public:

                    ClientAllStatesListener(hazelcast::util::CountDownLatch *startingLatch,
                                            hazelcast::util::CountDownLatch *startedLatch = NULL,
                                            hazelcast::util::CountDownLatch *connectedLatch = NULL,
                                            hazelcast::util::CountDownLatch *disconnectedLatch = NULL,
                                            hazelcast::util::CountDownLatch *shuttingDownLatch = NULL,
                                            hazelcast::util::CountDownLatch *shutdownLatch = NULL)
                            : startingLatch(startingLatch), startedLatch(startedLatch), connectedLatch(connectedLatch),
                              disconnectedLatch(disconnectedLatch), shuttingDownLatch(shuttingDownLatch),
                              shutdownLatch(shutdownLatch) {}

                    virtual void stateChanged(const LifecycleEvent &lifecycleEvent) {
                        switch (lifecycleEvent.getState()) {
                            case LifecycleEvent::STARTING:
                                if (startingLatch) {
                                    startingLatch->countDown();
                                }
                                break;
                            case LifecycleEvent::STARTED:
                                if (startedLatch) {
                                    startedLatch->countDown();
                                }
                                break;
                            case LifecycleEvent::CLIENT_CONNECTED:
                                if (connectedLatch) {
                                    connectedLatch->countDown();
                                }
                                break;
                            case LifecycleEvent::CLIENT_DISCONNECTED:
                                if (disconnectedLatch) {
                                    disconnectedLatch->countDown();
                                }
                                break;
                            case LifecycleEvent::SHUTTING_DOWN:
                                if (shuttingDownLatch) {
                                    shuttingDownLatch->countDown();
                                }
                                break;
                            case LifecycleEvent::SHUTDOWN:
                                if (shutdownLatch) {
                                    shutdownLatch->countDown();
                                }
                                break;
                            default:
                                FAIL() << "No such state expected:" << lifecycleEvent.getState();
                        }
                    }

                private:
                    hazelcast::util::CountDownLatch *startingLatch;
                    hazelcast::util::CountDownLatch *startedLatch;
                    hazelcast::util::CountDownLatch *connectedLatch;
                    hazelcast::util::CountDownLatch *disconnectedLatch;
                    hazelcast::util::CountDownLatch *shuttingDownLatch;
                    hazelcast::util::CountDownLatch *shutdownLatch;
                };

                std::unique_ptr<HazelcastServer> startServer(ClientConfig &clientConfig) {
                    if (clientConfig.getNetworkConfig().getSSLConfig().isEnabled()) {
                        return std::unique_ptr<HazelcastServer>(new HazelcastServer(sslFactory));
                    } else {
                        return std::unique_ptr<HazelcastServer>(new HazelcastServer(*g_srvFactory));
                    }
                }

            private:
                HazelcastServerFactory sslFactory;
            };

            class SmartTcpClientConfig : public ClientConfig {
            };

            class SmartSSLClientConfig : public ClientConfig {
            public:
                SmartSSLClientConfig() {
                    this->getNetworkConfig().getSSLConfig().setEnabled(true).addVerifyFile(
                            ClientTestSupportBase::getCAFilePath());
                }
            };

            TEST_P(ClusterTest, testBehaviourWhenClusterNotFound) {
                ClientConfig &clientConfig = *const_cast<ParamType &>(GetParam());
                ASSERT_THROW(HazelcastClient client(clientConfig), exception::IllegalStateException);
            }

            TEST_P(ClusterTest, testDummyClientBehaviourWhenClusterNotFound) {
                ClientConfig &clientConfig = *const_cast<ParamType &>(GetParam());
                clientConfig.setSmart(false);
                ASSERT_THROW(HazelcastClient client(clientConfig), exception::IllegalStateException);
            }

            TEST_P(ClusterTest, testAllClientStates) {
                ClientConfig &clientConfig = *const_cast<ParamType &>(GetParam());

                std::unique_ptr<HazelcastServer> instance = startServer(clientConfig);

                clientConfig.setAttemptPeriod(1000);
                clientConfig.setConnectionAttemptLimit(1);
                hazelcast::util::CountDownLatch startingLatch(1);
                hazelcast::util::CountDownLatch startedLatch(1);
                hazelcast::util::CountDownLatch connectedLatch(1);
                hazelcast::util::CountDownLatch disconnectedLatch(1);
                hazelcast::util::CountDownLatch shuttingDownLatch(1);
                hazelcast::util::CountDownLatch shutdownLatch(1);
                ClientAllStatesListener listener(&startingLatch, &startedLatch, &connectedLatch, &disconnectedLatch,
                                                 &shuttingDownLatch, &shutdownLatch);
                clientConfig.addListener(&listener);

                HazelcastClient client(clientConfig);

                ASSERT_TRUE(startingLatch.await(0));
                ASSERT_TRUE(startedLatch.await(0));
                ASSERT_TRUE(connectedLatch.await(0));

                instance->shutdown();

                ASSERT_OPEN_EVENTUALLY(disconnectedLatch);
                ASSERT_OPEN_EVENTUALLY(shuttingDownLatch);
                ASSERT_OPEN_EVENTUALLY(shutdownLatch);
            }

            TEST_P(ClusterTest, testConnectionAttemptPeriod) {
                ClientConfig &clientConfig = *const_cast<ParamType &>(GetParam());
                clientConfig.getNetworkConfig().setConnectionAttemptPeriod(900).
                        setConnectionTimeout(2000).setConnectionAttemptLimit(2);
                clientConfig.getNetworkConfig().addAddress(Address("8.8.8.8", 8000));

                int64_t startTimeMillis = hazelcast::util::currentTimeMillis();
                try {
                    HazelcastClient client(clientConfig);
                } catch (exception::IllegalStateException &) {
// this is expected
                }
                ASSERT_GE(hazelcast::util::currentTimeMillis() - startTimeMillis, 2 * 900);
            }

            TEST_P(ClusterTest, testAllClientStatesWhenUserShutdown) {
                ClientConfig &clientConfig = *const_cast<ParamType &>(GetParam());
                std::unique_ptr<HazelcastServer> instance = startServer(clientConfig);

                hazelcast::util::CountDownLatch startingLatch(1);
                hazelcast::util::CountDownLatch startedLatch(1);
                hazelcast::util::CountDownLatch connectedLatch(1);
                hazelcast::util::CountDownLatch disconnectedLatch(1);
                hazelcast::util::CountDownLatch shuttingDownLatch(1);
                hazelcast::util::CountDownLatch shutdownLatch(1);
                ClientAllStatesListener listener(&startingLatch, &startedLatch, &connectedLatch, &disconnectedLatch,
                                                 &shuttingDownLatch, &shutdownLatch);
                clientConfig.addListener(&listener);

                HazelcastClient client(clientConfig);

                ASSERT_TRUE(startingLatch.await(0));
                ASSERT_TRUE(startedLatch.await(0));
                ASSERT_TRUE(connectedLatch.await(0));

                client.shutdown();

                ASSERT_OPEN_EVENTUALLY(shuttingDownLatch);
                ASSERT_OPEN_EVENTUALLY(shutdownLatch);
            }

#ifdef HZ_BUILD_WITH_SSL

            INSTANTIATE_TEST_SUITE_P(All,
                                     ClusterTest,
                                     ::testing::Values(new SmartTcpClientConfig(), new SmartSSLClientConfig()));
#else
                                                                                                                                    INSTANTIATE_TEST_SUITE_P(All,
                                    ClusterTest,
                                    ::testing::Values(new SmartTcpClientConfig()));
#endif
        }
    }
}





namespace hazelcast {
    namespace client {
        namespace test {
            class HeartbeatTest : public ClientTestSupport {
            };

            TEST_F(HeartbeatTest, testPing) {
                HazelcastServer instance(*g_srvFactory);
                ClientConfig config = getConfig();
                config.setProperty("hazelcast_client_heartbeat_interval", "1");

                HazelcastClient client(config);

                // sleep enough time so that the client ping is sent to the server
                hazelcast::util::sleep(3);
            }
        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {
            class SocketInterceptorTest : public ClientTestSupport {
            };

            class MySocketInterceptor : public SocketInterceptor {
            public:
                MySocketInterceptor(hazelcast::util::CountDownLatch &latch) : interceptorLatch(latch) {
                }

                void onConnect(const hazelcast::client::Socket &connectedSocket) {
                    ASSERT_EQ("127.0.0.1", connectedSocket.getAddress().getHost());
                    ASSERT_NE(0, connectedSocket.getAddress().getPort());
                    interceptorLatch.countDown();
                }

            private:
                hazelcast::util::CountDownLatch &interceptorLatch;
            };

#ifdef HZ_BUILD_WITH_SSL
            TEST_F(SocketInterceptorTest, interceptSSLBasic) {
                HazelcastServerFactory sslFactory(g_srvFactory->getServerAddress(), getSslFilePath());
                HazelcastServer instance(sslFactory);
                ClientConfig config = getConfig();
                hazelcast::util::CountDownLatch interceptorLatch(1);
                MySocketInterceptor interceptor(interceptorLatch);
                config.setSocketInterceptor(&interceptor);
                config::SSLConfig sslConfig;
                sslConfig.setEnabled(true).addVerifyFile(getCAFilePath());
                config.getNetworkConfig().setSSLConfig(sslConfig);
                HazelcastClient client(config);
                interceptorLatch.await(2);
            }

#endif

            TEST_F(SocketInterceptorTest, interceptBasic) {
                HazelcastServer instance(*g_srvFactory);
                ClientConfig config = getConfig();
                hazelcast::util::CountDownLatch interceptorLatch(1);
                MySocketInterceptor interceptor(interceptorLatch);
                config.setSocketInterceptor(&interceptor);
                HazelcastClient client(config);
                interceptorLatch.await(2);
            }
        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            class SocketOptionsTest : public ClientTestSupport {
            };

            TEST_F(SocketOptionsTest, testConfiguration) {
                HazelcastServer instance(*g_srvFactory);

                const int bufferSize = 2 * 1024;
                ClientConfig clientConfig;
                clientConfig.getNetworkConfig().getSocketOptions().setKeepAlive(false).setReuseAddress(
                        true).setTcpNoDelay(false).setLingerSeconds(5).setBufferSizeInBytes(bufferSize);

                HazelcastClient client(clientConfig);

                config::SocketOptions &socketOptions = client.getClientConfig().getNetworkConfig().getSocketOptions();
                ASSERT_FALSE(socketOptions.isKeepAlive());
                ASSERT_FALSE(socketOptions.isTcpNoDelay());
                ASSERT_EQ(5, socketOptions.getLingerSeconds());
                ASSERT_EQ(bufferSize, socketOptions.getBufferSizeInBytes());
            }
        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            class ClientAuthenticationTest : public ClientTestSupport {
            };

            TEST_F(ClientAuthenticationTest, testSetGroupConfig) {
                HazelcastServer instance(*g_srvFactory);
                ClientConfig config;
                config.setGroupConfig(GroupConfig("dev", "dev-pass"));

                HazelcastClient client(config);
            }

            TEST_F(ClientAuthenticationTest, testIncorrectGroupName) {
                HazelcastServer instance(*g_srvFactory);
                ClientConfig config;
                config.getGroupConfig().setName("invalid cluster");

                ASSERT_THROW((HazelcastClient(config)), exception::IllegalStateException);
            }
        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {
            class ClientEnpointTest : public ClientTestSupport {
            };

            TEST_F(ClientEnpointTest, testConnectedClientEnpoint) {
                HazelcastServer instance(*g_srvFactory);

                HazelcastClient client;
                const Client endpoint = client.getLocalEndpoint();
                spi::ClientContext context(client);
                ASSERT_EQ(context.getName(), endpoint.getName());

                std::shared_ptr<Address> endpointAddress = endpoint.getSocketAddress();
                ASSERT_NOTNULL(endpointAddress.get(), Address);
                connection::ClientConnectionManagerImpl &connectionManager = context.getConnectionManager();
                std::shared_ptr<connection::Connection> connection = connectionManager.getOwnerConnection();
                ASSERT_NOTNULL(connection.get(), connection::Connection);
                std::unique_ptr<Address> localAddress = connection->getLocalSocketAddress();
                ASSERT_NOTNULL(localAddress.get(), Address);
                ASSERT_EQ(*localAddress, *endpointAddress);

                std::shared_ptr<protocol::Principal> principal = connectionManager.getPrincipal();
                ASSERT_NOTNULL(principal.get(), protocol::Principal);
                ASSERT_NOTNULL(principal->getUuid(), std::string);
                ASSERT_EQ_PTR((*principal->getUuid()), endpoint.getUuid().get(), std::string);
            }
        }
    }
}






namespace hazelcast {
    namespace client {

        class HazelcastClient;

        namespace test {
            class MemberAttributeTest : public ClientTestSupport
            {};

            TEST_F(MemberAttributeTest, testInitialValues) {
                HazelcastServer instance(*g_srvFactory);
                ASSERT_TRUE(instance.setAttributes(0));
                HazelcastClient hazelcastClient(getNewClient());
                Cluster cluster = hazelcastClient.getCluster();
                std::vector<Member> members = cluster.getMembers();
                ASSERT_EQ(1U, members.size());
                Member &member = members[0];
                ASSERT_TRUE(member.lookupAttribute("intAttr"));
                ASSERT_EQ("211", *member.getAttribute("intAttr"));

                ASSERT_TRUE(member.lookupAttribute("boolAttr"));
                ASSERT_EQ("true", *member.getAttribute("boolAttr"));

                ASSERT_TRUE(member.lookupAttribute("byteAttr"));
                ASSERT_EQ("7", *member.getAttribute("byteAttr"));

                ASSERT_TRUE(member.lookupAttribute("doubleAttr"));
                ASSERT_EQ("2.0", *member.getAttribute("doubleAttr"));

                ASSERT_TRUE(member.lookupAttribute("floatAttr"));
                ASSERT_EQ("1.2", *member.getAttribute("floatAttr"));

                ASSERT_TRUE(member.lookupAttribute("shortAttr"));
                ASSERT_EQ("3", *member.getAttribute("shortAttr"));

                ASSERT_TRUE(member.lookupAttribute("strAttr"));
                ASSERT_EQ(std::string("strAttr"), *member.getAttribute("strAttr"));

                instance.shutdown();
            }

            class AttributeListener : public MembershipListener {
            public:
                AttributeListener(hazelcast::util::CountDownLatch &_attributeLatch)
                        : _attributeLatch(_attributeLatch) {

                }

                void memberAdded(const MembershipEvent &event) {
                }

                void memberRemoved(const MembershipEvent &event) {
                }

                void memberAttributeChanged(const MemberAttributeEvent &memberAttributeEvent) {
                    if (memberAttributeEvent.getOperationType() != MemberAttributeEvent::PUT) {
                        return;
                    }
                    const std::string &key = memberAttributeEvent.getKey();

                    if (key == "intAttr") {
                        const std::string &value = memberAttributeEvent.getValue();
                        if ("211" == value) {
                            _attributeLatch.countDown();
                        }
                    } else if (key == "boolAttr") {
                        const std::string &value = memberAttributeEvent.getValue();
                        if ("true" == value) {
                            _attributeLatch.countDown();
                        }
                    } else if (key == "byteAttr") {
                        const std::string &value = memberAttributeEvent.getValue();
                        if ("7" == value) {
                            _attributeLatch.countDown();
                        }
                    } else if (key == "doubleAttr") {
                        const std::string &value = memberAttributeEvent.getValue();
                        if ("2.0" == value) {
                            _attributeLatch.countDown();
                        }
                    } else if (key == "floatAttr") {
                        const std::string &value = memberAttributeEvent.getValue();
                        if ("1.2" == value) {
                            _attributeLatch.countDown();
                        }
                    } else if (key == "shortAttr") {
                        const std::string &value = memberAttributeEvent.getValue();
                        if ("3" == value) {
                            _attributeLatch.countDown();
                        }
                    } else if (key == "strAttr") {
                        const std::string &value = memberAttributeEvent.getValue();
                        if (std::string("strAttr") == value) {
                            _attributeLatch.countDown();
                        }
                    }
                }

            private:
                hazelcast::util::CountDownLatch &_attributeLatch;
            };

            TEST_F(MemberAttributeTest, testChangeWithListeners) {
                hazelcast::util::CountDownLatch attributeLatch(7);
                AttributeListener sampleListener(attributeLatch);

                ClientConfig clientConfig(getConfig());
                clientConfig.addListener(&sampleListener);

                HazelcastServer instance(*g_srvFactory);
                HazelcastClient hazelcastClient(clientConfig);

                HazelcastServer instance2(*g_srvFactory);
                ASSERT_TRUE(instance2.setAttributes(1));

                ASSERT_TRUE(attributeLatch.await(30));

                instance2.shutdown();

                instance.shutdown();
            }

        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            namespace crdt {
                namespace pncounter {
                    class BasicPnCounterAPITest : public ClientTestSupport {
                    public:
                        static void SetUpTestCase() {
                            instance = new HazelcastServer(*g_srvFactory);
                            client = new HazelcastClient(getConfig());
                        }

                        static void TearDownTestCase() {
                            delete client;
                            delete instance;

                            client = NULL;
                            instance = NULL;
                        }

                        static HazelcastServer *instance;
                        static HazelcastClient *client;
                    };

                    HazelcastServer *BasicPnCounterAPITest::instance = NULL;
                    HazelcastClient *BasicPnCounterAPITest::client = NULL;

                    TEST_F(BasicPnCounterAPITest, testGetStart) {
                        std::shared_ptr<client::crdt::pncounter::PNCounter> pnCounter = client->getPNCounter(
                                testing::UnitTest::GetInstance()->current_test_info()->name());
                                assertEquals(0, pnCounter->get());
                    }

                    TEST_F(BasicPnCounterAPITest, testGetAndAdd) {
                        std::shared_ptr<client::crdt::pncounter::PNCounter> pnCounter = client->getPNCounter(
                                testing::UnitTest::GetInstance()->current_test_info()->name());
                                assertEquals(0, pnCounter->getAndAdd(5));
                    }

                    TEST_F(BasicPnCounterAPITest, testAddAndGet) {
                        std::shared_ptr<client::crdt::pncounter::PNCounter> pnCounter = client->getPNCounter(
                                testing::UnitTest::GetInstance()->current_test_info()->name());
                                assertEquals(5, pnCounter->addAndGet(5));
                    }

                    TEST_F(BasicPnCounterAPITest, testGetAndAddExisting) {
                        std::shared_ptr<client::crdt::pncounter::PNCounter> pnCounter = client->getPNCounter(
                                testing::UnitTest::GetInstance()->current_test_info()->name());

                                assertEquals(0, pnCounter->getAndAdd(2));
                                assertEquals(2, pnCounter->getAndAdd(3));
                                assertEquals(5, pnCounter->get());
                    }

                    TEST_F(BasicPnCounterAPITest, testGetAndIncrement) {
                        std::shared_ptr<client::crdt::pncounter::PNCounter> pnCounter = client->getPNCounter(
                                testing::UnitTest::GetInstance()->current_test_info()->name());
                                assertEquals(0, pnCounter->getAndIncrement());
                                assertEquals(1, pnCounter->getAndIncrement());
                                assertEquals(2, pnCounter->get());
                    }

                    TEST_F(BasicPnCounterAPITest, testIncrementAndGet) {
                        std::shared_ptr<client::crdt::pncounter::PNCounter> pnCounter = client->getPNCounter(
                                testing::UnitTest::GetInstance()->current_test_info()->name());
                                assertEquals(1, pnCounter->incrementAndGet());
                                assertEquals(1, pnCounter->get());
                    }

                    TEST_F(BasicPnCounterAPITest, testGetAndDecrementFromDefault) {
                        std::shared_ptr<client::crdt::pncounter::PNCounter> pnCounter = client->getPNCounter(
                                testing::UnitTest::GetInstance()->current_test_info()->name());
                                assertEquals(0, pnCounter->getAndDecrement());
                                assertEquals(-1, pnCounter->get());
                    }

                    TEST_F(BasicPnCounterAPITest, testGetAndDecrement) {
                        std::shared_ptr<client::crdt::pncounter::PNCounter> pnCounter = client->getPNCounter(
                                testing::UnitTest::GetInstance()->current_test_info()->name());
                                assertEquals(1, pnCounter->incrementAndGet());
                                assertEquals(1, pnCounter->getAndDecrement());
                                assertEquals(0, pnCounter->get());
                    }

                    TEST_F(BasicPnCounterAPITest, testGetAndSubtract) {
                        std::shared_ptr<client::crdt::pncounter::PNCounter> pnCounter = client->getPNCounter(
                                testing::UnitTest::GetInstance()->current_test_info()->name());
                                assertEquals(0, pnCounter->getAndSubtract(2));
                                assertEquals(-2, pnCounter->get());
                    }

                    TEST_F(BasicPnCounterAPITest, testSubtractAndGet) {
                        std::shared_ptr<client::crdt::pncounter::PNCounter> pnCounter = client->getPNCounter(
                                testing::UnitTest::GetInstance()->current_test_info()->name());
                                assertEquals(-3, pnCounter->subtractAndGet(3));
                    }

                    TEST_F(BasicPnCounterAPITest, testReset) {
                        std::shared_ptr<client::crdt::pncounter::PNCounter> pnCounter = client->getPNCounter(
                                testing::UnitTest::GetInstance()->current_test_info()->name());
                        pnCounter->reset();
                    }
                }
            }

        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {
            namespace crdt {
                namespace pncounter {
                    /**
                     * Client implementation for testing behaviour of {@link ConsistencyLostException}
                     */
                    class ClientPNCounterConsistencyLostTest : public ClientTestSupport {
                    protected:
                        std::shared_ptr<Address> getCurrentTargetReplicaAddress(
                                const std::shared_ptr<client::crdt::pncounter::PNCounter> &pnCounter) {
                            return std::static_pointer_cast<proxy::ClientPNCounterProxy>(pnCounter)->getCurrentTargetReplicaAddress();
                        }

                        void terminateMember(const Address &address, HazelcastServer &server1, HazelcastServer &server2) {
                            auto member1 = server1.getMember();
                            if (address == Address(member1.host, member1.port)) {
                                server1.terminate();
                                return;
                            }

                            auto member2 = server2.getMember();
                            if (address == Address(member2.host, member2.port)) {
                                server2.terminate();
                                return;
                            }
                        }
                    };

                    TEST_F(ClientPNCounterConsistencyLostTest, consistencyLostExceptionIsThrownWhenTargetReplicaDisappears) {
                        HazelcastServerFactory factory(
                                "hazelcast/test/resources/hazelcast-pncounter-consistency-lost-test.xml");
                        HazelcastServer instance(factory);
                        HazelcastServer instance2(factory);

                        HazelcastClient client;

                        std::shared_ptr<client::crdt::pncounter::PNCounter> pnCounter = client.getPNCounter(
                                testing::UnitTest::GetInstance()->current_test_info()->name());

                        pnCounter->addAndGet(5);

                                assertEquals(5, pnCounter->get());

                        std::shared_ptr<Address> currentTarget = getCurrentTargetReplicaAddress(pnCounter);

                        terminateMember(*currentTarget, instance, instance2);

                        ASSERT_THROW(pnCounter->addAndGet(5), exception::ConsistencyLostException);
                    }

                    TEST_F(ClientPNCounterConsistencyLostTest, driverCanContinueSessionByCallingReset) {
                        HazelcastServerFactory factory(
                                "hazelcast/test/resources/hazelcast-pncounter-consistency-lost-test.xml");
                        HazelcastServer instance(factory);
                        HazelcastServer instance2(factory);

                        HazelcastClient client;

                        std::shared_ptr<client::crdt::pncounter::PNCounter> pnCounter = client.getPNCounter(
                                testing::UnitTest::GetInstance()->current_test_info()->name());

                        pnCounter->addAndGet(5);

                                assertEquals(5, pnCounter->get());

                        std::shared_ptr<Address> currentTarget = getCurrentTargetReplicaAddress(pnCounter);

                        terminateMember(*currentTarget, instance, instance2);

                        pnCounter->reset();

                        pnCounter->addAndGet(5);
                    }
                }
            }

        }
    }
}





namespace hazelcast {
    namespace client {
        namespace test {
            namespace crdt {
                namespace pncounter {
                    class PnCounterFunctionalityTest : public ClientTestSupport {
                    public:
                        static void SetUpTestCase() {
                            instance = new HazelcastServer(*g_srvFactory);
                            client = new HazelcastClient;
                        }

                        static void TearDownTestCase() {
                            delete client;
                            delete instance;

                            client = NULL;
                            instance = NULL;
                        }

                    protected:
                        class IncrementerTask : public hazelcast::util::Runnable {
                        public:
                            IncrementerTask(int loopsPerThread, std::atomic<int64_t> &finalValue,
                                            const std::shared_ptr<client::crdt::pncounter::PNCounter> &counter1,
                                            const std::shared_ptr<client::crdt::pncounter::PNCounter> &counter2)
                                    : loopsPerThread(loopsPerThread), finalValue(finalValue), counter1(counter1),
                                      counter2(counter2) {}

                            virtual const string getName() const {
                                return "IncrementerTask";
                            }

                            virtual void run() {
                                for (int j = 0; j < loopsPerThread; j++) {
                                    counter1->addAndGet(5);
                                    finalValue += 5;
                                    counter2->addAndGet(-2);
                                    finalValue += -2;
                                }
                            }

                        private:
                            int loopsPerThread;
                            std::atomic<int64_t> &finalValue;
                            std::shared_ptr<client::crdt::pncounter::PNCounter> counter1;
                            std::shared_ptr<client::crdt::pncounter::PNCounter> counter2;
                        };

                        static HazelcastServer *instance;
                        static HazelcastClient *client;
                    };

                    HazelcastServer *PnCounterFunctionalityTest::instance = NULL;
                    HazelcastClient *PnCounterFunctionalityTest::client = NULL;

                    TEST_F(PnCounterFunctionalityTest, testSimpleReplication) {
                        const char *name = testing::UnitTest::GetInstance()->current_test_info()->name();
                        std::shared_ptr<client::crdt::pncounter::PNCounter> counter1 = client->getPNCounter(name);
                        std::shared_ptr<client::crdt::pncounter::PNCounter> counter2 = client->getPNCounter(name);

                                assertEquals(5, counter1->addAndGet(5));

                        ASSERT_EQ_EVENTUALLY(5, counter1->get());
                        ASSERT_EQ_EVENTUALLY(5, counter2->get());
                    }

                    TEST_F(PnCounterFunctionalityTest, testParallelism) {
                        const char *name = testing::UnitTest::GetInstance()->current_test_info()->name();
                        std::shared_ptr<client::crdt::pncounter::PNCounter> counter1 = client->getPNCounter(name);
                        std::shared_ptr<client::crdt::pncounter::PNCounter> counter2 = client->getPNCounter(name);

                        int parallelism = 5;
                        int loopsPerThread = 100;
                        std::atomic<int64_t> finalValue(0);

                        std::vector<std::shared_ptr<hazelcast::util::Thread> > futures;
                        for (int i = 0; i < parallelism; i++) {
                            std::shared_ptr<Thread> thread = std::shared_ptr<hazelcast::util::Thread>(
                                    new hazelcast::util::Thread(std::shared_ptr<hazelcast::util::Runnable>(
                                            new IncrementerTask(loopsPerThread, finalValue, counter1, counter2)),
                                                                getLogger()));
                            thread->start();
                            futures.push_back(thread);
                        }

                        for (const std::shared_ptr<hazelcast::util::Thread> &future  : futures) {
                            future->join();
                        }

                        int64_t finalExpectedValue = 3 * (int64_t) loopsPerThread * parallelism;
                        ASSERT_EQ_EVENTUALLY(finalExpectedValue, counter1->get());
                        ASSERT_EQ_EVENTUALLY(finalExpectedValue, counter2->get());
                    }

                }
            }

        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {
            namespace crdt {
                namespace pncounter {
                    class ClientPNCounterNoDataMemberTest : public ClientTestSupport {
                    };

                    TEST_F(ClientPNCounterNoDataMemberTest, noDataMemberExceptionIsThrown) {
                        HazelcastServerFactory factory("hazelcast/test/resources/hazelcast-lite-member.xml");
                        HazelcastServer instance(factory);

                        HazelcastClient client;

                        std::shared_ptr<client::crdt::pncounter::PNCounter> pnCounter = client.getPNCounter(
                                testing::UnitTest::GetInstance()->current_test_info()->name());

                        ASSERT_THROW(pnCounter->addAndGet(5), exception::NoDataMemberInClusterException);
                    }

                }
            }

        }
    }
}





namespace hazelcast {
    namespace client {
        namespace test {
            class SimpleListenerTest : public ClientTestSupportBase, public ::testing::TestWithParam<ClientConfig *> {
            public:
                SimpleListenerTest() {}

            protected:
                class MyEntryListener : public EntryListener<int, int> {
                public:
                    MyEntryListener(hazelcast::util::CountDownLatch &mapClearedLatch) : mapClearedLatch(mapClearedLatch) {}

                    virtual void entryAdded(const EntryEvent<int, int> &event) {
                    }

                    virtual void entryRemoved(const EntryEvent<int, int> &event) {
                    }

                    virtual void entryUpdated(const EntryEvent<int, int> &event) {
                    }

                    virtual void entryEvicted(const EntryEvent<int, int> &event) {
                    }

                    virtual void entryExpired(const EntryEvent<int, int> &event) {
                    }

                    virtual void entryMerged(const EntryEvent<int, int> &event) {
                    }

                    virtual void mapEvicted(const MapEvent &event) {
                    }

                    virtual void mapCleared(const MapEvent &event) {
                        assertEquals("testDeregisterListener", event.getName());
                        assertEquals(EntryEventType::CLEAR_ALL, event.getEventType());
                        std::string hostName = event.getMember().getAddress().getHost();
                        assertTrue(hostName == "127.0.0.1" || hostName == "localhost");
                        assertEquals(5701, event.getMember().getAddress().getPort());
                        assertEquals(1, event.getNumberOfEntriesAffected());
                        std::cout << "Map cleared event received:" << event << std::endl;
                        mapClearedLatch.countDown();
                    }

                private:
                    hazelcast::util::CountDownLatch &mapClearedLatch;
                };

                class SampleInitialListener : public InitialMembershipListener {
                public:
                    SampleInitialListener(hazelcast::util::CountDownLatch &_memberAdded, hazelcast::util::CountDownLatch &_attributeLatch,
                                          hazelcast::util::CountDownLatch &_memberRemoved)
                            : _memberAdded(_memberAdded), _attributeLatch(_attributeLatch),
                              _memberRemoved(_memberRemoved) {

                    }

                    void init(const InitialMembershipEvent &event) {
                        std::vector<Member> const &members = event.getMembers();
                        if (members.size() == 1) {
                            _memberAdded.countDown();
                        }
                    }

                    void memberAdded(const MembershipEvent &event) {
                        _memberAdded.countDown();
                    }

                    void memberRemoved(const MembershipEvent &event) {
                        _memberRemoved.countDown();
                    }


                    void memberAttributeChanged(const MemberAttributeEvent &memberAttributeEvent) {
                        _attributeLatch.countDown();
                    }

                private:
                    hazelcast::util::CountDownLatch &_memberAdded;
                    hazelcast::util::CountDownLatch &_attributeLatch;
                    hazelcast::util::CountDownLatch &_memberRemoved;
                };

                class SampleListenerInSimpleListenerTest : public MembershipListener {
                public:
                    SampleListenerInSimpleListenerTest(hazelcast::util::CountDownLatch &_memberAdded,
                                                       hazelcast::util::CountDownLatch &_attributeLatch,
                                                       hazelcast::util::CountDownLatch &_memberRemoved)
                            : _memberAdded(_memberAdded), _attributeLatch(_attributeLatch),
                              _memberRemoved(_memberRemoved) {

                    }

                    void memberAdded(const MembershipEvent &event) {
                        _memberAdded.countDown();
                    }

                    void memberRemoved(const MembershipEvent &event) {
                        _memberRemoved.countDown();
                    }

                    void memberAttributeChanged(const MemberAttributeEvent &memberAttributeEvent) {
                        memberAttributeEvent.getKey();
                        _attributeLatch.countDown();
                    }

                private:
                    hazelcast::util::CountDownLatch &_memberAdded;
                    hazelcast::util::CountDownLatch &_attributeLatch;
                    hazelcast::util::CountDownLatch &_memberRemoved;
                };
            };

            class NonSmartTcpClientConfig : public ClientConfig {
            public:
                NonSmartTcpClientConfig() {
                    getNetworkConfig().setSmartRouting(false);
                }
            };

            TEST_P(SimpleListenerTest, testSharedClusterListeners) {
                HazelcastServer instance(*g_srvFactory);
                HazelcastClient hazelcastClient(*const_cast<ParamType &>(GetParam()));
                Cluster cluster = hazelcastClient.getCluster();
                hazelcast::util::CountDownLatch memberAdded(1);
                hazelcast::util::CountDownLatch memberAddedInit(2);
                hazelcast::util::CountDownLatch memberRemoved(1);
                hazelcast::util::CountDownLatch memberRemovedInit(1);
                hazelcast::util::CountDownLatch attributeLatch(7);
                hazelcast::util::CountDownLatch attributeLatchInit(7);

                std::shared_ptr<MembershipListener> sampleInitialListener(
                        new SampleInitialListener(memberAddedInit, attributeLatchInit, memberRemovedInit));
                std::shared_ptr<MembershipListener> sampleListener(
                        new SampleListenerInSimpleListenerTest(memberAdded, attributeLatch, memberRemoved));

                std::string initialListenerRegistrationId = cluster.addMembershipListener(sampleInitialListener);
                std::string sampleListenerRegistrationId = cluster.addMembershipListener(sampleListener);

                HazelcastServer instance2(*g_srvFactory);

                ASSERT_TRUE(memberAdded.await(30));
                ASSERT_TRUE(memberAddedInit.await(30));

                ASSERT_TRUE(instance2.setAttributes(1));

                ASSERT_TRUE(attributeLatchInit.await(30));
                ASSERT_TRUE(attributeLatch.await(30));

                instance2.shutdown();

                ASSERT_TRUE(memberRemoved.await(30));
                ASSERT_TRUE(memberRemovedInit.await(30));

                instance.shutdown();

                ASSERT_TRUE(cluster.removeMembershipListener(initialListenerRegistrationId));
                ASSERT_TRUE(cluster.removeMembershipListener(sampleListenerRegistrationId));
            }

            TEST_P(SimpleListenerTest, testClusterListeners) {
                HazelcastServer instance(*g_srvFactory);
                HazelcastClient hazelcastClient(*const_cast<ParamType &>(GetParam()));
                Cluster cluster = hazelcastClient.getCluster();
                hazelcast::util::CountDownLatch memberAdded(1);
                hazelcast::util::CountDownLatch memberAddedInit(2);
                hazelcast::util::CountDownLatch memberRemoved(1);
                hazelcast::util::CountDownLatch memberRemovedInit(1);
                hazelcast::util::CountDownLatch attributeLatch(7);
                hazelcast::util::CountDownLatch attributeLatchInit(7);

                SampleInitialListener sampleInitialListener(memberAddedInit, attributeLatchInit, memberRemovedInit);
                SampleListenerInSimpleListenerTest sampleListener(memberAdded, attributeLatch, memberRemoved);

                cluster.addMembershipListener(&sampleInitialListener);
                cluster.addMembershipListener(&sampleListener);

                HazelcastServer instance2(*g_srvFactory);

                ASSERT_TRUE(memberAdded.await(30));
                ASSERT_TRUE(memberAddedInit.await(30));

                ASSERT_TRUE(instance2.setAttributes(1));

                ASSERT_OPEN_EVENTUALLY(attributeLatchInit);
                ASSERT_OPEN_EVENTUALLY(attributeLatch);

                instance2.shutdown();

                ASSERT_OPEN_EVENTUALLY(memberRemoved);
                ASSERT_OPEN_EVENTUALLY(memberRemovedInit);

                instance.shutdown();

                ASSERT_TRUE(cluster.removeMembershipListener(&sampleInitialListener));
                ASSERT_TRUE(cluster.removeMembershipListener(&sampleListener));
            }

            TEST_P(SimpleListenerTest, testClusterListenersFromConfig) {
                hazelcast::util::CountDownLatch memberAdded(1);
                hazelcast::util::CountDownLatch memberAddedInit(1);
                hazelcast::util::CountDownLatch memberRemoved(1);
                hazelcast::util::CountDownLatch memberRemovedInit(1);
                hazelcast::util::CountDownLatch attributeLatch(7);
                hazelcast::util::CountDownLatch attributeLatchInit(7);
                SampleInitialListener sampleInitialListener(memberAddedInit, attributeLatchInit, memberRemovedInit);
                SampleListenerInSimpleListenerTest sampleListener(memberAdded, attributeLatch, memberRemoved);

                ClientConfig &clientConfig = *const_cast<ParamType &>(GetParam());
                clientConfig.addListener(&sampleListener);
                clientConfig.addListener(&sampleInitialListener);

                HazelcastServer instance(*g_srvFactory);
                HazelcastClient hazelcastClient(clientConfig);

                HazelcastServer instance2(*g_srvFactory);

                ASSERT_OPEN_EVENTUALLY(memberAdded);
                ASSERT_OPEN_EVENTUALLY(memberAddedInit);

                ASSERT_TRUE(instance2.setAttributes(1));

                ASSERT_OPEN_EVENTUALLY(attributeLatchInit);
                ASSERT_OPEN_EVENTUALLY(attributeLatch);

                instance2.shutdown();

                ASSERT_OPEN_EVENTUALLY(memberRemoved);
                ASSERT_OPEN_EVENTUALLY(memberRemovedInit);

                instance.shutdown();
            }

            TEST_P(SimpleListenerTest, testDeregisterListener) {
                HazelcastServer instance(*g_srvFactory);
                ClientConfig &clientConfig = *const_cast<ParamType &>(GetParam());
                HazelcastClient hazelcastClient(clientConfig);

                IMap<int, int> map = hazelcastClient.getMap<int, int>("testDeregisterListener");

                ASSERT_FALSE(map.removeEntryListener("Unknown"));

                hazelcast::util::CountDownLatch mapClearedLatch(1);
                MyEntryListener listener(mapClearedLatch);
                std::string listenerRegistrationId = map.addEntryListener(listener, true);

                map.put(1, 1);

                map.clear();

                        assertOpenEventually(mapClearedLatch);

                        assertTrue(map.removeEntryListener(listenerRegistrationId));
            }

            INSTANTIATE_TEST_SUITE_P(All,
                                     SimpleListenerTest,
                                     ::testing::Values(new SmartTcpClientConfig(), new NonSmartTcpClientConfig()));
        }
    }
}







namespace hazelcast {
    namespace client {
        namespace test {
            class FlakeIdGeneratorApiTest : public ClientTestSupport {
            public:
                FlakeIdGeneratorApiTest() : flakeIdGenerator(
                        client->getFlakeIdGenerator(testing::UnitTest::GetInstance()->current_test_info()->name())) {
                }

                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    ClientConfig clientConfig = getConfig();
                    std::shared_ptr<config::ClientFlakeIdGeneratorConfig> flakeIdConfig(
                            new config::ClientFlakeIdGeneratorConfig("test*"));
                    flakeIdConfig->setPrefetchCount(10).setPrefetchValidityMillis(20000);
                    clientConfig.addFlakeIdGeneratorConfig(flakeIdConfig);
                    client = new HazelcastClient(clientConfig);
                }

                static void TearDownTestCase() {
                    delete client;
                    delete instance;

                    client = NULL;
                    instance = NULL;
                }

            protected:
                class SmokeRunner : public hazelcast::util::Runnable {
                public:
                    SmokeRunner(FlakeIdGenerator &flakeIdGenerator,
                                hazelcast::util::CountDownLatch &startLatch,
                                hazelcast::util::Sync<std::shared_ptr<set<int64_t> > > &ids)
                            : flakeIdGenerator(flakeIdGenerator), startLatch(startLatch), ids(ids) {}

                    virtual const string getName() const {
                        return "SmokeRunner";
                    }

                    virtual void run() {
                        std::shared_ptr<std::set<int64_t> > localIds = ids;
                        startLatch.await();
                        for (int j = 0; j < 100000; ++j) {
                            localIds->insert(flakeIdGenerator.newId());
                        }

                        ids = localIds;
                    }

                private:
                    FlakeIdGenerator &flakeIdGenerator;
                    hazelcast::util::CountDownLatch &startLatch;
                    hazelcast::util::Sync<std::shared_ptr<std::set<int64_t> > > &ids;
                };

                static HazelcastServer *instance;
                static HazelcastClient *client;

                FlakeIdGenerator flakeIdGenerator;
            };

            HazelcastServer *FlakeIdGeneratorApiTest::instance = NULL;
            HazelcastClient *FlakeIdGeneratorApiTest::client = NULL;

            TEST_F (FlakeIdGeneratorApiTest, testStartingValue) {
                flakeIdGenerator.newId();
            }

            TEST_F (FlakeIdGeneratorApiTest, testInit) {
                int64_t currentId = flakeIdGenerator.newId();
                        assertTrue(flakeIdGenerator.init(currentId / 2));
                        assertFalse(flakeIdGenerator.init(currentId * 2));
            }

            TEST_F (FlakeIdGeneratorApiTest, testSmoke) {
                hazelcast::util::CountDownLatch startLatch(1);
                std::vector<std::shared_ptr<hazelcast::util::Thread> > threads(4);
                hazelcast::util::Sync<std::shared_ptr<std::set<int64_t> > > ids[4];

                for (int i = 0; i < 4; ++i) {
                    ids[i] = std::shared_ptr<std::set<int64_t> >(new std::set<int64_t>());
                    std::shared_ptr<hazelcast::util::Thread> t(
                            new hazelcast::util::Thread(std::shared_ptr<hazelcast::util::Runnable>(
                                    new SmokeRunner(flakeIdGenerator, startLatch, ids[i])), getLogger()));
                    t->start();
                    threads[i] = t;
                }

                startLatch.countDown();

                for (int i = 0; i < 4; ++i) {
                    threads[i]->join();
                }

                std::set<int64_t> allIds;
                for (int i = 0; i < 4; ++i) {
                    std::shared_ptr<std::set<int64_t> > threadIdSet = ids[i];
                    for (const int64_t &value : *threadIdSet) {
                        allIds.insert(value);
                    }
                }

// if there were duplicate IDs generated, there will be less items in the set than expected
                        assertEquals(4 * 100000, (int) allIds.size());
            }
        }
    }
}

//
// Created by sancar koyunlu on 9/18/13.



namespace hazelcast {
    namespace client {
        namespace test {
            class ClientTxnMapTest : public ClientTestSupport {
            public:
                ClientTxnMapTest();

                ~ClientTxnMapTest();

            protected:
                HazelcastServer instance;
                ClientConfig clientConfig;
                HazelcastClient client;
            };

            ClientTxnMapTest::ClientTxnMapTest() : instance(*g_srvFactory), client(getNewClient()) {
            }

            ClientTxnMapTest::~ClientTxnMapTest() {
            }

            TEST_F(ClientTxnMapTest, testPutGet) {
                std::string name = "testPutGet";

                TransactionContext context = client.newTransactionContext();
                context.beginTransaction();

                TransactionalMap<std::string, std::string> map = context.getMap<std::string, std::string>(name);

                ASSERT_EQ(map.put("key1", "value1").get(), (std::string *) NULL);
                ASSERT_EQ("value1", *(map.get("key1")));
                std::shared_ptr<std::string> val = client.getMap<std::string, std::string>(name).get("key1");
                ASSERT_EQ(val.get(), (std::string *) NULL);

                context.commitTransaction();

                ASSERT_EQ("value1", *(client.getMap<std::string, std::string>(name).get("key1")));
            }

            TEST_F(ClientTxnMapTest, testRemove) {
                std::string name = "testRemove";

                TransactionContext context = client.newTransactionContext();
                context.beginTransaction();

                TransactionalMap<std::string, std::string> map = context.getMap<std::string, std::string>(name);

                ASSERT_EQ(map.put("key1", "value1").get(), (std::string *) NULL);
                ASSERT_EQ("value1", *(map.get("key1")));
                std::shared_ptr<std::string> val = client.getMap<std::string, std::string>(name).get("key1");
                ASSERT_EQ(val.get(), (std::string *) NULL);

                ASSERT_EQ((std::string *) NULL, map.remove("key2").get());
                val = map.remove("key1");
                ASSERT_NE((std::string *) NULL, val.get());
                ASSERT_EQ("value1", *val);

                context.commitTransaction();

                IMap<std::string, std::string> regularMap = client.getMap<std::string, std::string>(name);
                ASSERT_TRUE(regularMap.isEmpty());
            }

            TEST_F(ClientTxnMapTest, testRemoveIfSame) {
                std::string name = "testRemoveIfSame";

                TransactionContext context = client.newTransactionContext();
                context.beginTransaction();

                TransactionalMap<std::string, std::string> map = context.getMap<std::string, std::string>(name);

                ASSERT_EQ(map.put("key1", "value1").get(), (std::string *) NULL);
                ASSERT_EQ("value1", *(map.get("key1")));
                std::shared_ptr<std::string> val = client.getMap<std::string, std::string>(name).get("key1");
                ASSERT_EQ(val.get(), (std::string *) NULL);

                ASSERT_EQ((std::string *) NULL, map.remove("key2").get());
                ASSERT_TRUE(map.remove("key1", "value1"));

                context.commitTransaction();

                IMap<std::string, std::string> regularMap = client.getMap<std::string, std::string>(name);
                ASSERT_TRUE(regularMap.isEmpty());
            }

            TEST_F(ClientTxnMapTest, testDeleteEntry) {
                std::string name = "testDeleteEntry";

                TransactionContext context = client.newTransactionContext();
                context.beginTransaction();

                TransactionalMap<std::string, std::string> map = context.getMap<std::string, std::string>(name);

                ASSERT_NO_THROW(map.deleteEntry("key1"));

                ASSERT_EQ(map.put("key1", "value1").get(), (std::string *) NULL);
                ASSERT_EQ("value1", *(map.get("key1")));
                std::shared_ptr<std::string> val = client.getMap<std::string, std::string>(name).get("key1");
                ASSERT_EQ(val.get(), (std::string *) NULL);

                ASSERT_NO_THROW(map.deleteEntry("key1"));
                val = map.get("key1");
                ASSERT_EQ((std::string *) NULL, val.get());

                context.commitTransaction();

                IMap<std::string, std::string> regularMap = client.getMap<std::string, std::string>(name);
                ASSERT_TRUE(regularMap.isEmpty());
            }

            TEST_F(ClientTxnMapTest, testReplace) {
                std::string name = "testReplace";

                TransactionContext context = client.newTransactionContext();
                context.beginTransaction();

                TransactionalMap<std::string, std::string> map = context.getMap<std::string, std::string>(name);

                ASSERT_EQ(map.put("key1", "value1").get(), (std::string *) NULL);
                ASSERT_EQ("value1", *(map.get("key1")));
                std::shared_ptr<std::string> val = client.getMap<std::string, std::string>(name).get("key1");
                ASSERT_EQ(val.get(), (std::string *) NULL);

                ASSERT_EQ("value1", *map.replace("key1", "myNewValue"));

                context.commitTransaction();

                ASSERT_EQ("myNewValue", *(client.getMap<std::string, std::string>(name).get("key1")));
            }

            TEST_F(ClientTxnMapTest, testSet) {
                std::string name = "testSet";

                TransactionContext context = client.newTransactionContext();
                context.beginTransaction();

                TransactionalMap<std::string, std::string> map = context.getMap<std::string, std::string>(name);

                ASSERT_NO_THROW(map.set("key1", "value1"));

                std::shared_ptr<std::string> val = map.get("key1");
                ASSERT_NE((std::string *) NULL, val.get());
                ASSERT_EQ("value1", *val);

                val = client.getMap<std::string, std::string>(name).get("key1");
                ASSERT_EQ(val.get(), (std::string *) NULL);

                ASSERT_NO_THROW(map.set("key1", "myNewValue"));

                val = map.get("key1");
                ASSERT_NE((std::string *) NULL, val.get());
                ASSERT_EQ("myNewValue", *val);

                context.commitTransaction();

                val = client.getMap<std::string, std::string>(name).get("key1");
                ASSERT_NE((std::string *) NULL, val.get());
                ASSERT_EQ("myNewValue", *val);
            }

            TEST_F(ClientTxnMapTest, testContains) {
                std::string name = "testContains";

                TransactionContext context = client.newTransactionContext();
                context.beginTransaction();

                TransactionalMap<std::string, std::string> map = context.getMap<std::string, std::string>(name);

                ASSERT_FALSE(map.containsKey("key1"));

                ASSERT_NO_THROW(map.set("key1", "value1"));

                std::shared_ptr<std::string> val = map.get("key1");
                ASSERT_NE((std::string *) NULL, val.get());
                ASSERT_EQ("value1", *val);

                ASSERT_TRUE(map.containsKey("key1"));

                context.commitTransaction();

                IMap<std::string, std::string> regularMap = client.getMap<std::string, std::string>(name);
                ASSERT_TRUE(regularMap.containsKey("key1"));
            }

            TEST_F(ClientTxnMapTest, testReplaceIfSame) {
                std::string name = "testReplaceIfSame";

                TransactionContext context = client.newTransactionContext();
                context.beginTransaction();

                TransactionalMap<std::string, std::string> map = context.getMap<std::string, std::string>(name);

                ASSERT_EQ(map.put("key1", "value1").get(), (std::string *) NULL);
                ASSERT_EQ("value1", *(map.get("key1")));
                std::shared_ptr<std::string> val = client.getMap<std::string, std::string>(name).get("key1");
                ASSERT_EQ(val.get(), (std::string *) NULL);

                ASSERT_FALSE(map.replace("key1", "valueNonExistent", "myNewValue"));
                ASSERT_TRUE(map.replace("key1", "value1", "myNewValue"));

                context.commitTransaction();

                ASSERT_EQ("myNewValue", *(client.getMap<std::string, std::string>(name).get("key1")));
            }

            TEST_F(ClientTxnMapTest, testPutIfSame) {
                std::string name = "testPutIfSame";

                TransactionContext context = client.newTransactionContext();
                context.beginTransaction();

                TransactionalMap<std::string, std::string> map = context.getMap<std::string, std::string>(name);

                std::shared_ptr<std::string> val = map.putIfAbsent("key1", "value1");
                ASSERT_EQ((std::string *) NULL, val.get());
                val = map.get("key1");
                ASSERT_NE((std::string *) NULL, val.get());
                ASSERT_EQ("value1", *val);
                val = client.getMap<std::string, std::string>(name).get("key1");
                ASSERT_EQ(val.get(), (std::string *) NULL);

                val = map.putIfAbsent("key1", "value1");
                ASSERT_NE((std::string *) NULL, val.get());
                ASSERT_EQ("value1", *val);

                context.commitTransaction();

                val = client.getMap<std::string, std::string>(name).get("key1");
                ASSERT_NE((std::string *) NULL, val.get());
                ASSERT_EQ("value1", *val);
            }

//            @Test MTODO
//            public void testGetForUpdate() throws TransactionException {
//            final IMap<String, Integer> map = hz.getMap("testTxnGetForUpdate");
//            final CountDownLatch latch1 = new CountDownLatch(1);
//            final CountDownLatch latch2 = new CountDownLatch(1);
//            map.put("var", 0);
//            final AtomicBoolean pass = new AtomicBoolean(true);
//
//
//            Runnable incrementor = new Runnable() {
//                public void run() {
//                    try {
//                        latch1.await(100, TimeUnit.SECONDS);
//                        pass.set(map.tryPut("var", 1, 0, TimeUnit.SECONDS) == false);
//                        latch2.countDown();
//                    } catch (Exception e) {
//                    }
//                }
//            }
//            new Thread(incrementor).start();
//            boolean b = hz.executeTransaction(new TransactionalTask<Boolean>() {
//                public Boolean execute(TransactionalTaskContext context) throws TransactionException {
//                    try {
//                        final TransactionalMap<String, Integer> txMap = context.getMap("testTxnGetForUpdate");
//                        txMap.getForUpdate("var");
//                        latch1.countDown();
//                        latch2.await(100, TimeUnit.SECONDS);
//                    } catch (Exception e) {
//                    }
//                    return true;
//                }
//            });
//            assertTrue(b);
//            assertTrue(pass.get());
//            assertTrue(map.tryPut("var", 1, 0, TimeUnit.SECONDS));
//        }

            TEST_F(ClientTxnMapTest, testKeySetValues) {
                std::string name = "testKeySetValues";
                IMap<std::string, std::string> map = client.getMap<std::string, std::string>(name);
                map.put("key1", "value1");
                map.put("key2", "value2");

                TransactionContext context = client.newTransactionContext();
                context.beginTransaction();
                TransactionalMap<std::string, std::string> txMap = context.getMap<std::string, std::string>(name);
                ASSERT_EQ(txMap.put("key3", "value3").get(), (std::string *) NULL);


                ASSERT_EQ(3, (int) txMap.size());
                ASSERT_EQ(3, (int) txMap.keySet().size());
                ASSERT_EQ(3, (int) txMap.values().size());
                context.commitTransaction();

                ASSERT_EQ(3, (int) map.size());
                ASSERT_EQ(3, (int) map.keySet().size());
                ASSERT_EQ(3, (int) map.values().size());

            }

            TEST_F(ClientTxnMapTest, testKeySetAndValuesWithPredicates) {
                std::string name = "testKeysetAndValuesWithPredicates";
                IMap<Employee, Employee> map = client.getMap<Employee, Employee>(name);

                Employee emp1("abc-123-xvz", 34);
                Employee emp2("abc-123-xvz", 20);

                map.put(emp1, emp1);

                TransactionContext context = client.newTransactionContext();
                context.beginTransaction();

                TransactionalMap<Employee, Employee> txMap = context.getMap<Employee, Employee>(name);
                ASSERT_EQ(txMap.put(emp2, emp2).get(), (Employee *) NULL);

                ASSERT_EQ(2, (int) txMap.size());
                ASSERT_EQ(2, (int) txMap.keySet().size());
                query::SqlPredicate predicate("a = 10");
                ASSERT_EQ(0, (int) txMap.keySet(&predicate).size());
                ASSERT_EQ(0, (int) txMap.values(&predicate).size());
                query::SqlPredicate predicate2("a >= 10");
                ASSERT_EQ(2, (int) txMap.keySet(&predicate2).size());
                ASSERT_EQ(2, (int) txMap.values(&predicate2).size());

                context.commitTransaction();

                ASSERT_EQ(2, (int) map.size());
                ASSERT_EQ(2, (int) map.values().size());
            }

            TEST_F(ClientTxnMapTest, testIsEmpty) {
                std::string name = "testIsEmpty";

                TransactionContext context = client.newTransactionContext();
                context.beginTransaction();

                TransactionalMap<std::string, std::string> map = context.getMap<std::string, std::string>(name);

                ASSERT_TRUE(map.isEmpty());

                std::shared_ptr<std::string> oldValue = map.put("key1", "value1");
                ASSERT_NULL("old value should be null", oldValue.get(), std::string);

                ASSERT_FALSE(map.isEmpty());

                context.commitTransaction();

                IMap<std::string, std::string> regularMap = client.getMap<std::string, std::string>(name);
                ASSERT_FALSE(regularMap.isEmpty());
            }

        }
    }
}


//
// Created by sancar koyunlu on 9/18/13.




namespace hazelcast {
    namespace client {
        namespace test {
            class ClientTxnSetTest : public ClientTestSupport {
            public:
                ClientTxnSetTest();

                ~ClientTxnSetTest();

            protected:
                HazelcastServer instance;
                HazelcastClient client;
            };

            ClientTxnSetTest::ClientTxnSetTest() : instance(*g_srvFactory), client(getNewClient()) {
            }

            ClientTxnSetTest::~ClientTxnSetTest() {
            }

            TEST_F(ClientTxnSetTest, testAddRemove) {
                ISet<std::string> s = client.getSet<std::string>("testAddRemove");
                s.add("item1");

                TransactionContext context = client.newTransactionContext();
                context.beginTransaction();
                TransactionalSet<std::string> set = context.getSet<std::string>("testAddRemove");
                ASSERT_TRUE(set.add("item2"));
                ASSERT_EQ(2, set.size());
                ASSERT_EQ(1, s.size());
                ASSERT_FALSE(set.remove("item3"));
                ASSERT_TRUE(set.remove("item1"));

                context.commitTransaction();

                ASSERT_EQ(1, s.size());
            }
        }
    }
}


//
// Created by sancar koyunlu on 9/18/13.




namespace hazelcast {
    namespace client {
        namespace test {
            class ClientTxnTest : public ClientTestSupport {
            public:
                ClientTxnTest();

                ~ClientTxnTest();

            protected:
                HazelcastServerFactory & hazelcastInstanceFactory;
                std::unique_ptr<HazelcastServer> server;
                std::unique_ptr<HazelcastServer> second;
                std::unique_ptr<HazelcastClient> client;
                std::unique_ptr<LoadBalancer> loadBalancer;
            };

            class MyLoadBalancer : public impl::AbstractLoadBalancer {
            public:
                const Member next() {
                    std::vector<Member> members = getMembers();
                    size_t len = members.size();
                    if (len == 0) {
                        throw exception::IOException("const Member& RoundRobinLB::next()", "No member in member list!!");
                    }
                    for (size_t i = 0; i < len; i++) {
                        if (members[i].getAddress().getPort() == 5701) {
                            return members[i];
                        }
                    }
                    return members[0];
                }

            };

            class MyMembershipListener : public MembershipListener {
            public:
                MyMembershipListener(hazelcast::util::CountDownLatch &countDownLatch)
                        : countDownLatch(countDownLatch) {

                }

                void memberAdded(const MembershipEvent &membershipEvent) {

                }

                void memberRemoved(const MembershipEvent &membershipEvent) {
                    countDownLatch.countDown();
                }

                void memberAttributeChanged(const MemberAttributeEvent& memberAttributeEvent) {

                }

            private:
                hazelcast::util::CountDownLatch& countDownLatch;
            };

            ClientTxnTest::ClientTxnTest()
                    : hazelcastInstanceFactory(*g_srvFactory) {
                server.reset(new HazelcastServer(hazelcastInstanceFactory));
                ClientConfig clientConfig = getConfig();
                clientConfig.setRedoOperation(true);
                //always start the txn on first member
                loadBalancer.reset(new MyLoadBalancer());
                clientConfig.setLoadBalancer(loadBalancer.get());
                client.reset(new HazelcastClient(clientConfig));
                second.reset(new HazelcastServer(hazelcastInstanceFactory));
            }

            ClientTxnTest::~ClientTxnTest() {
                client->shutdown();
                client.reset();
            }

            TEST_F(ClientTxnTest, testTxnConnectAfterClientShutdown) {
                client->shutdown();
                ASSERT_THROW(client->newTransactionContext(), exception::HazelcastClientNotActiveException);
            }

            TEST_F(ClientTxnTest, testTxnCommitAfterClusterShutdown) {
                TransactionContext context = client->newTransactionContext();
                context.beginTransaction();

                server->shutdown();
                second->shutdown();

                ASSERT_THROW(context.commitTransaction(), exception::TransactionException);
            }

            TEST_F(ClientTxnTest, testTxnCommit) {
                std::string queueName = randomString();
                TransactionContext context = client->newTransactionContext();
                context.beginTransaction();
                ASSERT_FALSE(context.getTxnId().empty());
                TransactionalQueue<std::string> queue = context.getQueue<std::string>(queueName);
                string value = randomString();
                queue.offer(value);

                context.commitTransaction();

                IQueue<string> q = client->getQueue<std::string>(queueName);
                std::shared_ptr<std::string> retrievedElement = q.poll();
                ASSERT_NOTNULL(retrievedElement.get(), std::string);
                ASSERT_EQ(value, *retrievedElement);
            }

            TEST_F(ClientTxnTest, testTxnCommitUniSocket) {
                ClientConfig clientConfig;
                clientConfig.getNetworkConfig().setSmartRouting(false);
                HazelcastClient uniSocketClient(clientConfig);

                std::string queueName = randomString();
                TransactionContext context = uniSocketClient.newTransactionContext();
                context.beginTransaction();
                ASSERT_FALSE(context.getTxnId().empty());
                TransactionalQueue<std::string> queue = context.getQueue<std::string>(queueName);
                string value = randomString();
                queue.offer(value);

                context.commitTransaction();

                IQueue<string> q = uniSocketClient.getQueue<std::string>(queueName);
                std::shared_ptr<std::string> retrievedElement = q.poll();
                ASSERT_NOTNULL(retrievedElement.get(), std::string);
                ASSERT_EQ(value, *retrievedElement);
            }

            TEST_F(ClientTxnTest, testTxnCommitWithOptions) {
                std::string queueName = randomString();
                TransactionOptions transactionOptions;
                transactionOptions.setTransactionType(TransactionType::TWO_PHASE);
                transactionOptions.setTimeout(60);
                transactionOptions.setDurability(2);
                TransactionContext context = client->newTransactionContext(transactionOptions);

                context.beginTransaction();
                ASSERT_FALSE(context.getTxnId().empty());
                TransactionalQueue<std::string> queue = context.getQueue<std::string>(queueName);
                string value = randomString();
                queue.offer(value);

                context.commitTransaction();

                IQueue<string> q = client->getQueue<std::string>(queueName);
                std::shared_ptr<std::string> retrievedElement = q.poll();
                ASSERT_NOTNULL(retrievedElement.get(), std::string);
                ASSERT_EQ(value, *retrievedElement);
            }

            TEST_F(ClientTxnTest, testTxnCommitAfterClientShutdown) {
                std::string queueName = randomString();
                TransactionContext context = client->newTransactionContext();
                context.beginTransaction();
                TransactionalQueue<std::string> queue = context.getQueue<std::string>(queueName);
                string value = randomString();
                queue.offer(value);

                client->shutdown();

                ASSERT_THROW(context.commitTransaction(), exception::HazelcastClientNotActiveException);
            }


            TEST_F(ClientTxnTest, testTxnRollback) {
                std::string queueName = randomString();
                TransactionContext context = client->newTransactionContext();
                hazelcast::util::CountDownLatch txnRollbackLatch(1);
                hazelcast::util::CountDownLatch memberRemovedLatch(1);
                MyMembershipListener myLifecycleListener(memberRemovedLatch);
                client->getCluster().addMembershipListener(&myLifecycleListener);

                try {
                    context.beginTransaction();
                    ASSERT_FALSE(context.getTxnId().empty());
                    TransactionalQueue<std::string> queue = context.getQueue<std::string>(queueName);
                    queue.offer(randomString());

                    server->shutdown();

                    context.commitTransaction();
                    FAIL();
                } catch (exception::TransactionException &) {
                    context.rollbackTransaction();
                    txnRollbackLatch.countDown();
                }

                ASSERT_OPEN_EVENTUALLY(txnRollbackLatch);
                ASSERT_OPEN_EVENTUALLY(memberRemovedLatch);

                IQueue<string> q = client->getQueue<std::string>(queueName);
                ASSERT_NULL("Poll result should be null since it is rolled back", q.poll().get(), std::string);
                ASSERT_EQ(0, q.size());
            }

            TEST_F(ClientTxnTest, testTxnRollbackOnServerCrash) {
                std::string queueName = randomString();
                TransactionContext context = client->newTransactionContext();
                hazelcast::util::CountDownLatch txnRollbackLatch(1);
                hazelcast::util::CountDownLatch memberRemovedLatch(1);

                context.beginTransaction();

                TransactionalQueue<std::string> queue = context.getQueue<std::string>(queueName);
                queue.offer("str");

                MyMembershipListener myLifecycleListener(memberRemovedLatch);
                client->getCluster().addMembershipListener(&myLifecycleListener);

                server->shutdown();

                ASSERT_THROW(context.commitTransaction(), exception::TransactionException);

                context.rollbackTransaction();
                txnRollbackLatch.countDown();

                ASSERT_OPEN_EVENTUALLY(txnRollbackLatch);
                ASSERT_OPEN_EVENTUALLY(memberRemovedLatch);

                IQueue<std::string> q = client->getQueue<std::string>(queueName);
                ASSERT_NULL("queue poll should return null", q.poll().get(), std::string);
                ASSERT_EQ(0, q.size());
            }
        }
    }
}

//
// Created by sancar koyunlu on 9/18/13.




namespace hazelcast {
    namespace client {
        class HazelcastClient;

        namespace test {
            class ClientTxnListTest : public ClientTestSupport {
            public:
                ClientTxnListTest();

                ~ClientTxnListTest();

            protected:
                HazelcastServer instance;
                ClientConfig clientConfig;
                HazelcastClient client;
            };

            ClientTxnListTest::ClientTxnListTest() : instance(*g_srvFactory), client(getNewClient()) {
            }

            ClientTxnListTest::~ClientTxnListTest() {
            }

            TEST_F(ClientTxnListTest, testAddRemove) {
                IList<std::string> l = client.getList<std::string>("testAddRemove");
                l.add("item1");

                TransactionContext context = client.newTransactionContext();
                context.beginTransaction();
                TransactionalList<std::string> list = context.getList<std::string>("testAddRemove");
                ASSERT_TRUE(list.add("item2"));
                ASSERT_EQ(2, list.size());
                ASSERT_EQ(1, l.size());
                ASSERT_FALSE(list.remove("item3"));
                ASSERT_TRUE(list.remove("item1"));

                context.commitTransaction();

                ASSERT_EQ(1, l.size());
            }
        }
    }
}


//
// Created by sancar koyunlu on 9/18/13.



namespace hazelcast {
    namespace client {
        namespace test {
            class ClientTxnMultiMapTest : public ClientTestSupport {
            public:
                ClientTxnMultiMapTest();

                ~ClientTxnMultiMapTest();

            protected:
                class PutGetRemoveTestTask : public hazelcast::util::Runnable {
                public:
                    PutGetRemoveTestTask(HazelcastClient &client, MultiMap<std::string, std::string> &mm,
                                         hazelcast::util::CountDownLatch &latch) : client(client), mm(mm), latch(latch) {}

                    virtual void run() {
                        std::string key = hazelcast::util::IOUtil::to_string(hazelcast::util::getCurrentThreadId());
                        std::string key2 = key + "2";
                        client.getMultiMap<std::string, std::string>("testPutGetRemove").put(key, "value");
                        TransactionContext context = client.newTransactionContext();
                        context.beginTransaction();
                        TransactionalMultiMap<std::string, std::string> multiMap = context.getMultiMap<std::string, std::string>(
                                "testPutGetRemove");
                        ASSERT_FALSE(multiMap.put(key, "value"));
                        ASSERT_TRUE(multiMap.put(key, "value1"));
                        ASSERT_TRUE(multiMap.put(key, "value2"));
                        ASSERT_TRUE(multiMap.put(key2, "value21"));
                        ASSERT_TRUE(multiMap.put(key2, "value22"));
                        ASSERT_EQ(3, (int) multiMap.get(key).size());
                        ASSERT_EQ(3, (int) multiMap.valueCount(key));
                        vector<std::string> removedValues = multiMap.remove(key2);
                        ASSERT_EQ(2U, removedValues.size())  ;
                        ASSERT_TRUE((removedValues[0] == "value21" && removedValues[1] == "value22") ||
                                    (removedValues[1] == "value21" && removedValues[0] == "value22"));
                        context.commitTransaction();

                        ASSERT_EQ(3, (int) mm.get(key).size());

                        latch.countDown();
                    }

                    virtual const string getName() const {
                        return "PutGetRemoveTestTask";
                    }

                private:
                    HazelcastClient &client;
                    MultiMap<std::string, std::string> &mm;
                    hazelcast::util::CountDownLatch &latch;
                };

                HazelcastServer instance;
                HazelcastClient client;
            };

            ClientTxnMultiMapTest::ClientTxnMultiMapTest()
                    : instance(*g_srvFactory), client(getNewClient()) {
            }

            ClientTxnMultiMapTest::~ClientTxnMultiMapTest() {
            }

            TEST_F(ClientTxnMultiMapTest, testRemoveIfExists) {
                TransactionContext context = client.newTransactionContext();
                context.beginTransaction();
                TransactionalMultiMap<std::string, std::string> multiMap = context.getMultiMap<std::string, std::string>(
                        "testRemoveIfExists");
                std::string key("MyKey");
                ASSERT_TRUE(multiMap.put(key, "value"));
                ASSERT_TRUE(multiMap.put(key, "value1"));
                ASSERT_TRUE(multiMap.put(key, "value2"));
                ASSERT_EQ(3, (int) multiMap.get(key).size());

                ASSERT_FALSE(multiMap.remove(key, "NonExistentValue"));
                ASSERT_TRUE(multiMap.remove(key, "value1"));

                ASSERT_EQ(2, multiMap.size());
                ASSERT_EQ(2, (int) multiMap.valueCount(key));

                context.commitTransaction();

                MultiMap<std::string, std::string> mm = client.getMultiMap<std::string, std::string>(
                        "testRemoveIfExists");
                ASSERT_EQ(2, (int) mm.get(key).size());
            }

            TEST_F(ClientTxnMultiMapTest, testPutGetRemove) {
                MultiMap<std::string, std::string> mm = client.getMultiMap<std::string, std::string>(
                        "testPutGetRemove");
                int n = 10;
                hazelcast::util::CountDownLatch latch(n);

                std::vector<std::shared_ptr<hazelcast::util::Thread> > allThreads;
                for (int i = 0; i < n; i++) {
                    std::shared_ptr<hazelcast::util::Thread> t(
                            new hazelcast::util::Thread(
                                    std::shared_ptr<hazelcast::util::Runnable>(
                                            new PutGetRemoveTestTask(client, mm, latch)),
                                    getLogger()));
                    t->start();
                    allThreads.push_back(t);
                }
                ASSERT_OPEN_EVENTUALLY(latch);
            }
        }
    }
}


//
// Created by sancar koyunlu on 9/18/13.




namespace hazelcast {
    namespace client {
        namespace test {
            class ClientTxnQueueTest : public ClientTestSupport {
            public:
                ClientTxnQueueTest();

                ~ClientTxnQueueTest();

            protected:
                HazelcastServer instance;
                HazelcastClient client;
            };

            ClientTxnQueueTest::ClientTxnQueueTest() : instance(*g_srvFactory), client(getNewClient()) {
            }

            ClientTxnQueueTest::~ClientTxnQueueTest() {
            }

            TEST_F(ClientTxnQueueTest, testTransactionalOfferPoll1) {
                std::string name = "defQueue";

                TransactionContext context = client.newTransactionContext();
                context.beginTransaction();
                TransactionalQueue<std::string> q = context.getQueue<std::string>(name);
                ASSERT_TRUE(q.offer("ali"));
                ASSERT_EQ(1, q.size());
                ASSERT_EQ("ali", *(q.poll()));
                ASSERT_EQ(0, q.size());
                context.commitTransaction();
                ASSERT_EQ(0, client.getQueue<std::string>(name).size());
            }

            TEST_F(ClientTxnQueueTest, testTransactionalOfferPollByteVector) {
                std::string name = "defQueue";

                TransactionContext context = client.newTransactionContext();
                context.beginTransaction();
                TransactionalQueue<std::vector<byte> > q = context.getQueue<std::vector<byte> >(name);
                std::vector<byte> value(3);
                ASSERT_TRUE(q.offer(value));
                ASSERT_EQ(1, q.size());
                ASSERT_EQ(value, *(q.poll()));
                ASSERT_EQ(0, q.size());
                context.commitTransaction();
                ASSERT_EQ(0, client.getQueue<std::vector<byte> >(name).size());
            }

            void testTransactionalOfferPoll2Thread(hazelcast::util::ThreadArgs &args) {
                hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                HazelcastClient *client = (HazelcastClient *) args.arg1;
                latch->await();
                client->getQueue<std::string>("defQueue0").offer("item0");
            }

            TEST_F(ClientTxnQueueTest, testTransactionalOfferPoll2) {
                hazelcast::util::CountDownLatch latch(1);
                hazelcast::util::StartedThread t(testTransactionalOfferPoll2Thread, &latch, &client);
                TransactionContext context = client.newTransactionContext();
                context.beginTransaction();
                TransactionalQueue<std::string> q0 = context.getQueue<std::string>("defQueue0");
                TransactionalQueue<std::string> q1 = context.getQueue<std::string>("defQueue1");
                std::shared_ptr<std::string> s;
                latch.countDown();
                s = q0.poll(10 * 1000);
                ASSERT_EQ("item0", *s);
                ASSERT_TRUE(q1.offer(*s));

                ASSERT_NO_THROW(context.commitTransaction());

                ASSERT_EQ(0, client.getQueue<std::string>("defQueue0").size());
                ASSERT_EQ("item0", *(client.getQueue<std::string>("defQueue1").poll()));
            }
        }
    }
}






namespace hazelcast {
    namespace client {
        namespace test {
            namespace faulttolerance {
                class LoadTest : public ClientTestSupport {
                public:
                    hazelcast::client::ClientConfig getLoadTestConfig() {
                        ClientConfig config = ClientTestSupport::getConfig();
                        config.setRedoOperation(true);
                        config.setLogLevel(FINEST);
                        return config;
                    }

                    class LoadClientTask : public hazelcast::util::Runnable {
                    public:
                        LoadClientTask(IMap<int, int> &map, int numberOfOps, hazelcast::util::CountDownLatch &latch)
                                : map(map),
                                  numberOfOps(
                                          numberOfOps),
                                  latch(latch) {}

                        virtual void run() {
                            latch.countDown();

                            latch.await(20);

                            for (int i = 0; i < numberOfOps; ++i) {
                                int mod = rand() % 3;
                                switch (mod) {
                                    case 0:
                                        ASSERT_NO_THROW(map.put(i, i));
                                        break;
                                    case 1:
                                        ASSERT_NO_THROW(map.remove(i));
                                    case 2: {
                                        std::shared_ptr<int> val;
                                        ASSERT_NO_THROW(val = map.get(i));
                                        if ((int *) NULL != val.get()) {
                                            ASSERT_EQ(*val, i);
                                        }
                                        break;
                                    }
                                    default:
                                        abort();
                                }
                            }
                        }

                        virtual const string getName() const {
                            return "LoadClientTask";
                        }

                    private:
                        IMap<int, int> &map;
                        int numberOfOps;
                        hazelcast::util::CountDownLatch &latch;
                    };

                    void addThread(IMap<int, int> &map, int numberOfOps, hazelcast::util::CountDownLatch &latch) {
                        std::shared_ptr<hazelcast::util::Runnable> task(new LoadClientTask(map, numberOfOps, latch));
                        threads.push_back(std::shared_ptr<hazelcast::util::Thread>(new hazelcast::util::Thread(task, getLogger())));
                    }

                    void startThreads() {
                        for (std::shared_ptr<hazelcast::util::Thread> &t : threads) {
                            t->start();
                        }
                    }

                    void waitForThreadsToFinish() {
                        for (std::shared_ptr<hazelcast::util::Thread> &t : threads) {
                            t->join();
                        }
                    }

                protected:
                    std::vector<std::shared_ptr<hazelcast::util::Thread> > threads;
                };

                void loadIntMapTestWithConfig(ClientConfig &config, LoadTest &test) {
                    HazelcastServer instance1(*g_srvFactory);
                    HazelcastServer instance2(*g_srvFactory);
                    HazelcastServer instance3(*g_srvFactory);
                    HazelcastServer instance4(*g_srvFactory);
                    HazelcastClient client(config);
                    IMap<int, int> imap = client.getMap<int, int>("loadtest");

                    int numThreads = 40;
                    int numOps = 5000;

                    hazelcast::util::CountDownLatch startLatch(numThreads);

                    for (int i = 0; i < numThreads; ++i) {
                        test.addThread(imap, numOps, startLatch);
                    }

                    test.startThreads();

                    startLatch.await(20);

                    instance1.shutdown();
                    instance2.shutdown();
                    instance3.shutdown();

                    HazelcastServer instance5(*g_srvFactory);

                    /*Note: Could not shutdown instance 5 here, since there may be some incomplete synchronization
                     * between instance 5 and instance 4. This caused problems in Linux environment. */

                    test.waitForThreadsToFinish();

                }

                TEST_F(LoadTest, DISABLED_testIntMapSmartClientServerRestart) {
                    ClientConfig config = getLoadTestConfig();
                    config.setSmart(true);

                    loadIntMapTestWithConfig(config, *this);
                }

                TEST_F(LoadTest, DISABLED_testIntMapDummyClientServerRestart) {
                    ClientConfig config = getLoadTestConfig();
                    config.setSmart(false);

                    loadIntMapTestWithConfig(config, *this);
                }
            }
        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {
            namespace util {
                class DataInputTest : public ::testing::Test
                {};

                TEST_F(DataInputTest, testReadByte) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x01);
                    bytes.push_back(0x12);
                    serialization::pimpl::DataInput dataInput(bytes);
                    ASSERT_EQ(0x01, dataInput.readByte());
                    ASSERT_EQ(0x12, dataInput.readByte());
                }

                TEST_F(DataInputTest, testReadBoolean) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x00);
                    bytes.push_back(0x10);
                    serialization::pimpl::DataInput dataInput(bytes);
                    ASSERT_FALSE(dataInput.readBoolean());
                    ASSERT_TRUE(dataInput.readBoolean());
                }

                TEST_F(DataInputTest, testReadChar) {
                    std::vector<byte> bytes;
                    bytes.push_back('a');
                    bytes.push_back('b');
                    serialization::pimpl::DataInput dataInput(bytes);
                    ASSERT_EQ('b', dataInput.readChar());
                }

                TEST_F(DataInputTest, testReadShort) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x12);
                    bytes.push_back(0x34);
                    bytes.push_back(0x56);
                    serialization::pimpl::DataInput dataInput(bytes);
                    ASSERT_EQ(0x1234, dataInput.readShort());
                }

                TEST_F(DataInputTest, testReadInteger) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x12);
                    bytes.push_back(0x34);
                    bytes.push_back(0x56);
                    bytes.push_back(0x78);
                    bytes.push_back(0x90);
                    serialization::pimpl::DataInput dataInput(bytes);
                    ASSERT_EQ(INT32_C(0x12345678), dataInput.readInt());
                }

                TEST_F(DataInputTest, testReadLong) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x12);
                    bytes.push_back(0x34);
                    bytes.push_back(0x56);
                    bytes.push_back(0x78);
                    bytes.push_back(0x90);
                    bytes.push_back(0x9A);
                    bytes.push_back(0x9B);
                    bytes.push_back(0x9C);
                    serialization::pimpl::DataInput dataInput(bytes);
                    ASSERT_EQ(INT64_C(0x12345678909A9B9C), dataInput.readLong());
                }

                TEST_F(DataInputTest, testReadUTF) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x04);
                    bytes.push_back('b');
                    bytes.push_back('d');
                    bytes.push_back('f');
                    bytes.push_back('h');
                    serialization::pimpl::DataInput dataInput(bytes);
                    std::unique_ptr<std::string> utf = dataInput.readUTF();
                    ASSERT_NE((std::string *) NULL, utf.get());
                    ASSERT_EQ("bdfh", *utf);
                }

                TEST_F(DataInputTest, testReadByteArray) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x02);
                    std::vector<byte> actualDataBytes;
                    actualDataBytes.push_back(0x12);
                    actualDataBytes.push_back(0x34);
                    bytes.insert(bytes.end(), actualDataBytes.begin(), actualDataBytes.end());
                    serialization::pimpl::DataInput dataInput(bytes);
                    std::unique_ptr<std::vector<byte> > readBytes = dataInput.readByteArray();
                    ASSERT_NE((std::vector<byte> *) NULL, readBytes.get());
                    ASSERT_EQ(actualDataBytes, *readBytes);
                }

                TEST_F(DataInputTest, testReadBooleanArray) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x02);
                    bytes.push_back(0x00);
                    bytes.push_back(0x01);
                    serialization::pimpl::DataInput dataInput(bytes);
                    std::unique_ptr<std::vector<bool> > booleanArray = dataInput.readBooleanArray();
                    ASSERT_NE((std::vector<bool> *) NULL, booleanArray.get());
                    ASSERT_EQ(2U, booleanArray->size());
                    ASSERT_FALSE((*booleanArray)[0]);
                    ASSERT_TRUE((*booleanArray)[1]);
                }

                TEST_F(DataInputTest, testReadCharArray) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x02);
                    bytes.push_back(0);
                    bytes.push_back('f');
                    bytes.push_back(0);
                    bytes.push_back('h');
                    serialization::pimpl::DataInput dataInput(bytes);
                    std::unique_ptr<std::vector<char> > charArray = dataInput.readCharArray();
                    ASSERT_NE((std::vector<char> *) NULL, charArray.get());
                    ASSERT_EQ(2U, charArray->size());
                    ASSERT_EQ('f', (*charArray)[0]);
                    ASSERT_EQ('h', (*charArray)[1]);
                }

                TEST_F(DataInputTest, testReadShortArray) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x02);
                    bytes.push_back(0x12);
                    bytes.push_back(0x34);
                    bytes.push_back(0x56);
                    bytes.push_back(0x78);
                    serialization::pimpl::DataInput dataInput(bytes);
                    std::unique_ptr<std::vector<int16_t> > array = dataInput.readShortArray();
                    ASSERT_NE((std::vector<int16_t> *) NULL, array.get());
                    ASSERT_EQ(2U, array->size());
                    ASSERT_EQ(0x1234, (*array)[0]);
                    ASSERT_EQ(0x5678, (*array)[1]);
                }

                TEST_F(DataInputTest, testReadIntegerArray) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x02);
                    bytes.push_back(0x12);
                    bytes.push_back(0x34);
                    bytes.push_back(0x56);
                    bytes.push_back(0x78);
                    bytes.push_back(0x1A);
                    bytes.push_back(0xBC);
                    bytes.push_back(0xDE);
                    bytes.push_back(0xEF);
                    serialization::pimpl::DataInput dataInput(bytes);
                    std::unique_ptr<std::vector<int32_t> > array = dataInput.readIntArray();
                    ASSERT_NE((std::vector<int32_t> *) NULL, array.get());
                    ASSERT_EQ(2U, array->size());
                    ASSERT_EQ(INT32_C(0x12345678), (*array)[0]);
                    ASSERT_EQ(INT32_C(0x1ABCDEEF), (*array)[1]);
                }

                TEST_F(DataInputTest, testReadLongArray) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x02);
                    bytes.push_back(0x12);
                    bytes.push_back(0x34);
                    bytes.push_back(0x56);
                    bytes.push_back(0x78);
                    bytes.push_back(0x9A);
                    bytes.push_back(0xBC);
                    bytes.push_back(0xDE);
                    bytes.push_back(0xEF);
                    bytes.push_back(0x11);
                    bytes.push_back(0xA2);
                    bytes.push_back(0xA3);
                    bytes.push_back(0xA4);
                    bytes.push_back(0xA5);
                    bytes.push_back(0xA6);
                    bytes.push_back(0xA7);
                    bytes.push_back(0xA8);
                    serialization::pimpl::DataInput dataInput(bytes);
                    std::unique_ptr<std::vector<int64_t> > array = dataInput.readLongArray();
                    ASSERT_NE((std::vector<int64_t> *) NULL, array.get());
                    ASSERT_EQ(2U, array->size());
                    ASSERT_EQ(INT64_C(0x123456789ABCDEEF), (*array)[0]);
                    ASSERT_EQ(INT64_C(0x11A2A3A4A5A6A7A8), (*array)[1]);
                }
            }
        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {
            class AddressUtilTest : public ::testing::Test {
            };

            TEST_F(AddressUtilTest, testParsingHostAndPort) {
                AddressHolder addressHolder = AddressUtil::getAddressHolder(
                        "[fe80::62c5:*:fe05:480a%en0]:8080");
                ASSERT_EQ("fe80::62c5:*:fe05:480a", addressHolder.getAddress());
                ASSERT_EQ(8080, addressHolder.getPort());
                ASSERT_EQ("en0", addressHolder.getScopeId());

                addressHolder = AddressUtil::getAddressHolder("[::ffff:192.0.2.128]:5700");
                ASSERT_EQ("::ffff:192.0.2.128", addressHolder.getAddress());
                ASSERT_EQ(5700, addressHolder.getPort());

                addressHolder = AddressUtil::getAddressHolder("192.168.1.1:5700");
                ASSERT_EQ("192.168.1.1", addressHolder.getAddress());
                ASSERT_EQ(5700, addressHolder.getPort());

                addressHolder = AddressUtil::getAddressHolder("hazelcast.com:80");
                ASSERT_EQ("hazelcast.com", addressHolder.getAddress());
                ASSERT_EQ(80, addressHolder.getPort());
            }

            TEST_F(AddressUtilTest, testGetByNameIpV4) {
                std::string addrString("127.0.0.1");
                boost::asio::ip::address address = AddressUtil::getByName(addrString);
                ASSERT_TRUE(address.is_v4());
                ASSERT_FALSE(address.is_v6());
                ASSERT_EQ(addrString, address.to_string());
            }
        }
    }
}




using namespace hazelcast::util;

namespace hazelcast {
    namespace client {
        namespace test {
            class RuntimeAvailableProcessorsTest : public ::testing::Test {
            protected:
                virtual void TearDown() {
                    RuntimeAvailableProcessors::resetOverride();
                }
            };

            TEST_F(RuntimeAvailableProcessorsTest, getAvailableProcessors_withoutOverride) {
                int availableProcessors = RuntimeAvailableProcessors::getNumberOfProcessors();
                ASSERT_EQ(availableProcessors, RuntimeAvailableProcessors::get());
            }

            TEST_F(RuntimeAvailableProcessorsTest, getAvailableProcessors_withOverride) {
                int customAvailableProcessors = 1234;
                RuntimeAvailableProcessors::override(customAvailableProcessors);
                try {
                    ASSERT_EQ(customAvailableProcessors, RuntimeAvailableProcessors::get());
                } catch (...) {
                    RuntimeAvailableProcessors::resetOverride();
                }
            }
        }
    }
}

//
// Created by hsan Demir on 18/05/15.
//


namespace hazelcast {
    namespace client {
        namespace test {
            namespace util {
                class BitsTest : public ::testing::Test
                {};

                TEST_F(BitsTest, testLittleEndian) {
                    uint64_t ONE = 1;
                    uint64_t oneByteFactor = ONE << 8;
                    uint64_t twoBytesFactor = ONE << 16;
                    uint64_t threeBytesFactor = ONE << 24;
                    uint64_t fourBytesFactor = ONE << 32;
                    uint64_t fiveBytesFactor = ONE << 40;
                    uint64_t sixBytesFactor = ONE << 48;
                    uint64_t sevenBytesFactor = ONE << 56;

                    {
                        int16_t expected = 0x7A * 256 + 0xBC;
                        int16_t actual;
                        byte *resBytes = (byte *) &actual;
                        hazelcast::util::Bits::nativeToLittleEndian2(&expected, &actual);
                        ASSERT_EQ(0xBC, resBytes[0]);
                        ASSERT_EQ(0x7A, resBytes[1]);
                    }

                    {
                        int32_t expected = 0x1A * (int32_t) threeBytesFactor +
                                           0x9A * (int32_t) twoBytesFactor + 0xAA * (int32_t) oneByteFactor + 0xBA;
                        int32_t actual;
                        byte *resBytes = (byte *) &actual;
                        hazelcast::util::Bits::nativeToLittleEndian4(&expected, &actual);
                        ASSERT_EQ(0xBA, resBytes[0]);
                        ASSERT_EQ(0xAA, resBytes[1]);
                        ASSERT_EQ(0x9A, resBytes[2]);
                        ASSERT_EQ(0x1A, resBytes[3]);
                    }

                    {
                        int64_t expected =
                                0x1A * sevenBytesFactor +
                                0x2A * sixBytesFactor +
                                0x3A * fiveBytesFactor +
                                0x4A * fourBytesFactor +
                                0x5A * threeBytesFactor +
                                0x6A * twoBytesFactor +
                                0x7A * oneByteFactor +
                                0x8A;

                        int64_t actual;
                        byte *resBytes = (byte *) &actual;
                        hazelcast::util::Bits::nativeToLittleEndian8(&expected, &actual);
                        ASSERT_EQ(0x8A, resBytes[0]);
                        ASSERT_EQ(0x7A, resBytes[1]);
                        ASSERT_EQ(0x6A, resBytes[2]);
                        ASSERT_EQ(0x5A, resBytes[3]);
                        ASSERT_EQ(0x4A, resBytes[4]);
                        ASSERT_EQ(0x3A, resBytes[5]);
                        ASSERT_EQ(0x2A, resBytes[6]);
                        ASSERT_EQ(0x1A, resBytes[7]);
                    }

                    // Little to Native tests
                    {
                        byte source[2] = {0xAB, 0xBC};
                        uint16_t actual;
                        hazelcast::util::Bits::littleEndianToNative2(&source, &actual);
                        ASSERT_EQ(0xBC * oneByteFactor + 0xAB, actual);
                    }

                    {
                        byte source[4] = {0xAB, 0xBC, 0xDE, 0xA1};
                        uint32_t actual;
                        hazelcast::util::Bits::littleEndianToNative4(&source, &actual);
                        ASSERT_EQ(0xA1 * threeBytesFactor +
                                  0xDE * twoBytesFactor +
                                  0xBC * oneByteFactor +
                                  0xAB, actual);
                    }

                    {
                        byte source[8] = {0xAB, 0x9B, 0x8B, 0x7B, 0x6B, 0x5B, 0x4B, 0xA1};
                        uint64_t actual;
                        hazelcast::util::Bits::littleEndianToNative8(&source, &actual);
                        ASSERT_EQ(0xA1 * sevenBytesFactor +
                                  0x4B * sixBytesFactor +
                                  0x5B * fiveBytesFactor +
                                  0x6B * fourBytesFactor +
                                  0x7B * threeBytesFactor +
                                  0x8B * twoBytesFactor +
                                  0x9B * oneByteFactor +
                                  0xAB, actual);
                    }
                }
            }
        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {
            namespace util {
                class DataOutputTest : public ::testing::Test
                {};

                TEST_F(DataOutputTest, testWriteByte) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x01);
                    bytes.push_back(0x12);
                    serialization::pimpl::DataOutput dataOutput;
                    dataOutput.writeByte((byte) 0x01);
                    dataOutput.writeByte(0x12);
                    ASSERT_EQ(bytes, *dataOutput.toByteArray());
                }

                TEST_F(DataOutputTest, testWriteBoolean) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x00);
                    bytes.push_back(0x01);
                    serialization::pimpl::DataOutput dataOutput;
                    dataOutput.writeBoolean(false);
                    dataOutput.writeBoolean(true);
                    ASSERT_EQ(bytes, *dataOutput.toByteArray());
                }

                TEST_F(DataOutputTest, testWriteChar) {
                    std::vector<byte> bytes;
                    bytes.push_back(0);
                    bytes.push_back('b');
                    serialization::pimpl::DataOutput dataOutput;
                    dataOutput.writeChar('b');
                    ASSERT_EQ(bytes, *dataOutput.toByteArray());
                }

                TEST_F(DataOutputTest, testWriteShort) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x12);
                    bytes.push_back(0x34);
                    serialization::pimpl::DataOutput dataOutput;
                    dataOutput.writeShort(0x1234);
                    ASSERT_EQ(bytes, *dataOutput.toByteArray());
                }

                TEST_F(DataOutputTest, testWriteInteger) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x12);
                    bytes.push_back(0x34);
                    bytes.push_back(0x56);
                    bytes.push_back(0x78);
                    serialization::pimpl::DataOutput dataOutput;
                    dataOutput.writeInt(INT32_C(0x12345678));
                    ASSERT_EQ(bytes, *dataOutput.toByteArray());
                }

                TEST_F(DataOutputTest, testWriteLong) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x12);
                    bytes.push_back(0x34);
                    bytes.push_back(0x56);
                    bytes.push_back(0x78);
                    bytes.push_back(0x90);
                    bytes.push_back(0x9A);
                    bytes.push_back(0x9B);
                    bytes.push_back(0x9C);
                    serialization::pimpl::DataOutput dataOutput;
                    dataOutput.writeLong(INT64_C(0x12345678909A9B9C));
                    ASSERT_EQ(bytes, *dataOutput.toByteArray());
                }

                TEST_F(DataOutputTest, testWriteUTF) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x04);
                    bytes.push_back('b');
                    bytes.push_back('d');
                    bytes.push_back('f');
                    bytes.push_back('h');
                    serialization::pimpl::DataOutput dataOutput;
                    std::string value("bdfh");
                    dataOutput.writeUTF(&value);
                    ASSERT_EQ(bytes, *dataOutput.toByteArray());
                }

                TEST_F(DataOutputTest, testWriteByteArray) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x02);
                    std::vector<byte> actualDataBytes;
                    actualDataBytes.push_back(0x12);
                    actualDataBytes.push_back(0x34);
                    bytes.insert(bytes.end(), actualDataBytes.begin(), actualDataBytes.end());
                    serialization::pimpl::DataOutput dataOutput;
                    dataOutput.writeByteArray(&actualDataBytes);
                    ASSERT_EQ(bytes, *dataOutput.toByteArray());
                }

                TEST_F(DataOutputTest, testWriteBooleanArray) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x02);
                    bytes.push_back(0x00);
                    bytes.push_back(0x01);
                    std::vector<bool> actualValues;
                    actualValues.push_back(false);
                    actualValues.push_back(true);
                    serialization::pimpl::DataOutput dataOutput;
                    dataOutput.writeBooleanArray(&actualValues);
                    ASSERT_EQ(bytes, *dataOutput.toByteArray());
                }

                TEST_F(DataOutputTest, testWriteCharArray) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x02);
                    std::vector<char> actualChars;
                    bytes.push_back(0);
                    bytes.push_back('f');
                    actualChars.push_back('f');
                    bytes.push_back(0);
                    bytes.push_back('h');
                    actualChars.push_back('h');
                    serialization::pimpl::DataOutput dataOutput;
                    dataOutput.writeCharArray(&actualChars);
                    ASSERT_EQ(bytes, *dataOutput.toByteArray());
                }

                TEST_F(DataOutputTest, testWriteShortArray) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x02);
                    std::vector<int16_t> actualValues;
                    bytes.push_back(0x12);
                    bytes.push_back(0x34);
                    actualValues.push_back(0x1234);
                    bytes.push_back(0x56);
                    bytes.push_back(0x78);
                    actualValues.push_back(0x5678);
                    serialization::pimpl::DataOutput dataOutput;
                    dataOutput.writeShortArray(&actualValues);
                    ASSERT_EQ(bytes, *dataOutput.toByteArray());
                }

                TEST_F(DataOutputTest, testWriteIntegerArray) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x02);
                    std::vector<int32_t> actualValues;
                    bytes.push_back(0x12);
                    bytes.push_back(0x34);
                    bytes.push_back(0x56);
                    bytes.push_back(0x78);
                    actualValues.push_back(INT32_C(0x12345678));
                    bytes.push_back(0x9A);
                    bytes.push_back(0xBC);
                    bytes.push_back(0xDE);
                    bytes.push_back(0xEF);
                    actualValues.push_back(INT32_C(0x9ABCDEEF));
                    serialization::pimpl::DataOutput dataOutput;
                    dataOutput.writeIntArray(&actualValues);
                    ASSERT_EQ(bytes, *dataOutput.toByteArray());
                }

                TEST_F(DataOutputTest, testWriteLongArray) {
                    std::vector<byte> bytes;
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x00);
                    bytes.push_back(0x02);
                    bytes.push_back(0x12);
                    bytes.push_back(0x34);
                    bytes.push_back(0x56);
                    bytes.push_back(0x78);
                    bytes.push_back(0x9A);
                    bytes.push_back(0xBC);
                    bytes.push_back(0xDE);
                    bytes.push_back(0xEF);
                    bytes.push_back(0xA1);
                    bytes.push_back(0xA2);
                    bytes.push_back(0xA3);
                    bytes.push_back(0xA4);
                    bytes.push_back(0xA5);
                    bytes.push_back(0xA6);
                    bytes.push_back(0xA7);
                    bytes.push_back(0xA8);
                    std::vector<int64_t> actualValues;
                    actualValues.push_back(INT64_C(0x123456789ABCDEEF));
                    actualValues.push_back(INT64_C(0xA1A2A3A4A5A6A7A8));
                    serialization::pimpl::DataOutput dataOutput;
                    dataOutput.writeLongArray(&actualValues);
                    ASSERT_EQ(bytes, *dataOutput.toByteArray());
                }
            }
        }
    }
}

#ifdef HZ_BUILD_WITH_SSL



namespace hazelcast {
    namespace client {
        namespace test {
            class HttpsClientTest : public ::testing::Test {
            };

            TEST_F(HttpsClientTest, testConnect) {
                SyncHttpsClient httpsClient("localhost", "non_existentURL/no_page");
                ASSERT_THROW(httpsClient.openConnection(), client::exception::IOException);
            }

            TEST_F(HttpsClientTest, testConnectToGithub) {
                SyncHttpsClient httpsClient("ec2.us-east-1.amazonaws.com",
                                            "/?Action=DescribeInstances&Version=2014-06-15&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIU5IAVNR6X75ARYQ%2F20170413%2Fus-east-1%2Fec2%2Faws4_request&X-Amz-Date=20170413T083821Z&X-Amz-Expires=30&X-Amz-Signature=dff261333170c81ecb21f3a0d5820147233197a32c&X-Amz-SignedHeaders=host");
                try {
                    httpsClient.openConnection();
                } catch (exception::IException &e) {
                    const std::string &msg = e.getMessage();
                    ASSERT_NE(std::string::npos, msg.find("status: 401"));
                }
                ASSERT_THROW(httpsClient.openConnection(), exception::IOException);
            }
        }
    }
}

#endif // HZ_BUILD_WITH_SSL



namespace hazelcast {
    namespace client {
        namespace test {
            class AddressHelperTest : public ClientTestSupport {
            };

            TEST_F(AddressHelperTest, testGetPossibleSocketAddresses) {
                std::string address("10.2.3.1");
                std::vector<Address> addresses = AddressHelper::getSocketAddresses(address, getLogger());
                ASSERT_EQ(3U, addresses.size());
                std::set<Address> socketAddresses;
                socketAddresses.insert(addresses.begin(), addresses.end());
                ASSERT_NE(socketAddresses.end(), socketAddresses.find(Address(address, 5701)));
                ASSERT_NE(socketAddresses.end(), socketAddresses.find(Address(address, 5702)));
                ASSERT_NE(socketAddresses.end(), socketAddresses.find(Address(address, 5703)));
            }

            TEST_F(AddressHelperTest, testAddressHolder) {
                AddressHolder holder("127.0.0.1", "en0", 8000);
                ASSERT_EQ("127.0.0.1", holder.getAddress());
                ASSERT_EQ(8000, holder.getPort());
                ASSERT_EQ("en0", holder.getScopeId());
            }
        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {
            namespace util {
                class ExceptionTest : public ::testing::Test {
                protected:
                };

                TEST_F(ExceptionTest, testExceptionCause) {
                    std::shared_ptr<exception::IException> cause = std::shared_ptr<exception::IException>(
                            new exception::IOException("testExceptionCause test", "this is a test exception"));
                    exception::TargetDisconnectedException targetDisconnectedException("testExceptionCause",
                                                                                       "test message", cause);

                    std::shared_ptr<exception::IException> exceptionCause = targetDisconnectedException.getCause();
                    ASSERT_NE(static_cast<exception::IException *>(NULL), exceptionCause.get());
                    ASSERT_THROW((exceptionCause->raise()), exception::IOException);
                    ASSERT_EQ(exceptionCause->getMessage(), cause->getMessage());
                    ASSERT_EQ(exceptionCause->getSource(), cause->getSource());
                    ASSERT_EQ((exception::IException *) NULL, exceptionCause->getCause().get());
                }

                TEST_F(ExceptionTest, testExceptionDetail) {
                    std::string details("A lot of details");
                    exception::TargetDisconnectedException targetDisconnectedException("testExceptionCause",
                                                                                       "test message", details,
                                                                                       protocol::IO);


                    ASSERT_EQ(details, targetDisconnectedException.getDetails());
                }

                TEST_F(ExceptionTest, testExceptionBuilderBuildShared) {
                    std::shared_ptr<exception::IOException> sharedException = exception::ExceptionBuilder<exception::IOException>(
                            "Exception from testExceptionBuilderBuildShared").buildShared();
                    ASSERT_THROW(throw *sharedException, exception::IOException);
                }

                TEST_F(ExceptionTest, testExceptionStreaming) {
                    std::string source("testException");
                    std::string originalMessage("original message");
                    exception::IOException e(source, originalMessage);

                    ASSERT_EQ(source, e.getSource());
                    ASSERT_EQ(originalMessage, e.getMessage());
                    ASSERT_EQ(static_cast<exception::IException *>(NULL), e.getCause().get());

                    std::string extendedMessage(" this is an extension message");
                    int messageNumber = 1;
                    exception::IOException ioException = (exception::ExceptionBuilder<exception::IOException>(source)
                            << originalMessage << extendedMessage << messageNumber).build();

                    ASSERT_EQ(source, ioException.getSource());
                    ASSERT_EQ(
                            originalMessage + extendedMessage + hazelcast::util::IOUtil::to_string<int>(messageNumber),
                            ioException.getMessage());
                    ASSERT_EQ(static_cast<exception::IException *>(NULL), e.getCause().get());
                }

                TEST_F(ExceptionTest, testRaiseException) {
                    std::string source("testException");
                    std::unique_ptr<std::string> originalMessage(new std::string("original message"));
                    std::string details("detail message");
                    int32_t code = protocol::IO;
                    int32_t causeCode = protocol::ILLEGAL_STATE;

                    protocol::ExceptionFactoryImpl<exception::IOException> ioExceptionFactory;
                    std::shared_ptr<exception::IException> exception(ioExceptionFactory.createException(source,
                                                                                                        originalMessage,
                                                                                                        details,
                                                                                                        causeCode));

                    try {
                        exception->raise();
                    } catch (exception::IOException &e) {
                        ASSERT_EQ(source, e.getSource());
                        ASSERT_EQ(*originalMessage + ". Details:" + details, e.getMessage());
                        ASSERT_EQ(code, e.getErrorCode());
                        ASSERT_EQ(causeCode, e.getCauseErrorCode());
                    }
                }
            }
        }
    }
}

//
// Created by hsan Demir on 6 June 2016.
//


namespace hazelcast {
    namespace client {
        namespace test {
            namespace util {
                class BlockingConcurrentQueueTest : public ::testing::Test
                {
                protected:
                    static void PushDelayed(hazelcast::util::ThreadArgs &args) {
                        hazelcast::util::BlockingConcurrentQueue<int> *q = (hazelcast::util::BlockingConcurrentQueue<int> *)args.arg0;
                        int *val = (int *)args.arg1;
                        unsigned long *milliseconds = (unsigned long *)args.arg2;
                        hazelcast::util::sleepmillis(*milliseconds);
                        q->push(*val);
                    }
                    static void Pop(hazelcast::util::ThreadArgs &args) {
                        hazelcast::util::BlockingConcurrentQueue<int> *q = (hazelcast::util::BlockingConcurrentQueue<int> *)args.arg0;
                        hazelcast::util::AtomicInt *val = (hazelcast::util::AtomicInt *)args.arg1;
                        val->store(q->pop());
                    }

                    static void Interrupt(hazelcast::util::ThreadArgs &args) {
                        hazelcast::util::BlockingConcurrentQueue<int> *q = (hazelcast::util::BlockingConcurrentQueue<int> *)args.arg0;
                        hazelcast::util::sleep(1);
                        q->interrupt();
                    }
                };

                TEST_F(BlockingConcurrentQueueTest, testPushDelyaed) {
                    size_t capacity = 3;

                    hazelcast::util::BlockingConcurrentQueue<int> q(capacity);

                    for (size_t i = 0; i < capacity; ++i) {
                        ASSERT_NO_THROW(q.push(i));
                    }

                    for (size_t i = 0; i < capacity; ++i) {
                        ASSERT_EQ((int) i, q.pop());
                    }

                    int val = 7;

                    unsigned long sleepTime = 3000U;
                    hazelcast::util::StartedThread t(PushDelayed, &q, &val, &sleepTime);

                    int64_t start = hazelcast::util::currentTimeMillis();
                    ASSERT_EQ(val, q.pop());
                    int64_t diff = hazelcast::util::currentTimeMillis() - start;
                    ASSERT_TRUE(diff > 1000);
                }

                TEST_F(BlockingConcurrentQueueTest, testPop) {
                    size_t capacity = 3;

                    hazelcast::util::BlockingConcurrentQueue<int> q(capacity);

                    for (size_t i = 0; i < capacity; ++i) {
                        ASSERT_NO_THROW(q.push(i));
                    }

                    for (size_t i = 0; i < capacity; ++i) {
                        ASSERT_EQ((int) i, q.pop());
                    }

                    hazelcast::util::AtomicInt val(-1);
                    int testValue = 7;
                    unsigned long sleepTime = 3000U;
                    hazelcast::util::StartedThread t(Pop, &q, &val, &sleepTime);

                    hazelcast::util::sleepmillis(2000);
                    ASSERT_NO_THROW(q.push(testValue));
                    hazelcast::util::sleepmillis(1000);
                    ASSERT_EQ(testValue, (int) val);
                }

                TEST_F(BlockingConcurrentQueueTest, testInterrupt) {
                    size_t capacity = 3;

                    hazelcast::util::BlockingConcurrentQueue<int> q(capacity);

                    hazelcast::util::CountDownLatch latch(1);
                    hazelcast::util::StartedThread t(Interrupt, &q);
// Note that this test is time sensitive, this thread shoulc be waiting at blocking pop when the
// other thread executes the interrup call.
                    ASSERT_THROW(q.pop(), client::exception::InterruptedException);
                }
            }
        }
    }
}




using namespace hazelcast::util;

namespace hazelcast {
    namespace client {
        namespace test {
            namespace util {
                namespace executor {
                    class ExecutorTest : public ClientTestSupport {
                    protected:
                        class StripedIntRunable : public StripedRunnable {
                        public:
                            StripedIntRunable(int32_t key, CountDownLatch &latch, std::atomic<int64_t> &threadId,
                                              bool controlThread)
                                    : key(key), latch(latch), threadId(threadId), isControlThread(controlThread) {}

                            virtual void run() {
                                if (isControlThread) {
                                    if (threadId.load() == hazelcast::util::getCurrentThreadId()) {
                                        latch.countDown();
                                    }
                                } else {
                                    threadId = hazelcast::util::getCurrentThreadId();
                                    latch.countDown();
                                }
                            }

                            virtual int32_t getKey() {
                                return key;
                            }

                            virtual const std::string getName() const {
                                return "StripedIntRunable";
                            }

                        private:
                            int32_t key;
                            CountDownLatch &latch;
                            std::atomic<int64_t> &threadId;
                            bool isControlThread;
                        };

                        class ValueReflector : public Callable<int> {
                        public:
                            ValueReflector(int returnValue) : returnValue(new int(returnValue)) {}

                            virtual std::shared_ptr<int> call() {
                                return returnValue;
                            }

                            virtual const std::string getName() const {
                                return "Multiplier";
                            }

                        protected:
                            std::shared_ptr<int> returnValue;
                        };

                        class LatchDecrementer : public Runnable {
                        public:
                            LatchDecrementer(CountDownLatch &latch) : latch(latch) {}

                            virtual void run() {
                                latch.countDown();
                            }

                            virtual const std::string getName() const {
                                return "LatchDecrementer";
                            }

                        protected:
                            CountDownLatch &latch;
                        };

                        class SequentialLatchDecrementer : public LatchDecrementer {
                        public:
                            SequentialLatchDecrementer(CountDownLatch &latch, int threadIndex, int totalNumberOfThreads)
                                    : LatchDecrementer(latch),
                                      threadIndex(threadIndex),
                                      totalNumberOfThreads(totalNumberOfThreads) {}

                            virtual void run() {
                                if (latch.get() == totalNumberOfThreads - threadIndex) {
                                    latch.countDown();
                                }
                            }

                            virtual const std::string getName() const {
                                return "SequentialLatchDecrementer";
                            }

                        private:
                            int threadIndex;
                            int totalNumberOfThreads;
                        };

                    };

                    TEST_F(ExecutorTest, testSingleThreadSequentialExecution) {
                        hazelcast::util::impl::SimpleExecutorService singleThreadExecutor(getLogger(),
                                                                                          "testGetPossibleSocketAddresses",
                                                                                          1);

                        singleThreadExecutor.start();

                        int numThreads = 10;
                        CountDownLatch latch(numThreads);

                        for (int i = 0; i < numThreads; ++i) {
                            singleThreadExecutor.execute(
                                    std::shared_ptr<Runnable>(new SequentialLatchDecrementer(latch, i, numThreads)));
                        }

                        ASSERT_OPEN_EVENTUALLY(latch);
                    }

                    TEST_F(ExecutorTest, testMultiThreadExecution) {
                        int32_t numThreads = 10;
                        hazelcast::util::impl::SimpleExecutorService executorService(getLogger(),
                                                                                     "testMultiThreadExecution",
                                                                                     numThreads);

                        executorService.start();

                        CountDownLatch latch(numThreads);

                        for (int i = 0; i < numThreads; ++i) {
                            executorService.execute(std::shared_ptr<Runnable>(new LatchDecrementer(latch)));
                        }

                        ASSERT_OPEN_EVENTUALLY(latch);

                        executorService.shutdown();
                    }

                    TEST_F(ExecutorTest, testRejectExecuteAfterShutdown) {
                        int32_t numThreads = 10;
                        hazelcast::util::impl::SimpleExecutorService executorService(getLogger(),
                                                                                     "testRejectExecuteAfterShutdown",
                                                                                     numThreads);
                        executorService.start();

                        executorService.shutdown();
                        CountDownLatch latch(numThreads);
                        ASSERT_THROW(executorService.execute(std::shared_ptr<Runnable>(new LatchDecrementer(latch))),
                                     client::exception::RejectedExecutionException);
                        ASSERT_THROW(
                                executorService.submit<int>(std::shared_ptr<Callable<int> >(new ValueReflector(1))),
                                client::exception::RejectedExecutionException);
                    }

                    TEST_F(ExecutorTest, testExecutorSubmit) {
                        int32_t numThreads = 10;
                        int32_t numJobs = 5 * numThreads;
                        hazelcast::util::impl::SimpleExecutorService executorService(getLogger(),
                                                                                     "testExecutorSubmit",
                                                                                     numThreads);

                        executorService.start();

                        std::vector<std::shared_ptr<hazelcast::util::Future<int> > > futures;
                        for (int i = 0; i < numJobs; ++i) {
                            futures.push_back(
                                    executorService.submit<int>(
                                            std::shared_ptr<Callable<int> >(new ValueReflector(i))));
                        }

                        for (int i = 0; i < numJobs; ++i) {
                            ASSERT_EQ(i, *futures[i]->get());
                        }
                    }

                    TEST_F(ExecutorTest, testStripedExecutorAlwaysRunsAtTheSameThread) {
                        int32_t numThreads = 10;
                        hazelcast::util::impl::SimpleExecutorService executorService(getLogger(),
                                                                                     "testMultiThreadExecution",
                                                                                     numThreads);

                        executorService.start();

                        CountDownLatch latch(1);
                        std::atomic<int64_t> threadId(0);
                        int32_t key = 5;
// the following gets the thread id fr the key
                        executorService.execute(
                                std::shared_ptr<StripedRunnable>(new StripedIntRunable(key, latch, threadId, false)));
                        ASSERT_OPEN_EVENTUALLY(latch);

                        CountDownLatch latch2(1);
// this makes sure that the execution occured at the same thread as the previous runnable
                        executorService.execute(std::shared_ptr<StripedRunnable>(
                                new StripedIntRunable(key, latch2, threadId, true)));
                        ASSERT_OPEN_EVENTUALLY(latch2);
                    }

                }
            }
        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            class UuidUtilTest : public ::testing::Test {
            };

            TEST_F(UuidUtilTest, testUnsecureUuid) {
                hazelcast::util::UUID uuid1 = hazelcast::util::UuidUtil::newUnsecureUUID();
                hazelcast::util::UUID uuid2 = hazelcast::util::UuidUtil::newUnsecureUUID();
                ASSERT_NE(uuid1, uuid2);

                std::string uuid1String = uuid1.toString();
                std::string uuid2String = uuid2.toString();
                ASSERT_NE(uuid1String, uuid2String);
                ASSERT_EQ(36U, uuid1String.length());
                ASSERT_EQ(36U, uuid2String.length());

                std::stringstream ss(uuid1String);
                std::string token;
                ASSERT_TRUE(std::getline(ss, token, '-'));
                ASSERT_EQ(8U, token.length());
                ASSERT_TRUE(std::getline(ss, token, '-'));
                ASSERT_EQ(4U, token.length());
                ASSERT_TRUE(std::getline(ss, token, '-'));
                ASSERT_EQ(4U, token.length());
                ASSERT_TRUE(std::getline(ss, token, '-'));
                ASSERT_EQ(4U, token.length());
                ASSERT_TRUE(std::getline(ss, token, '-'));
                ASSERT_EQ(12U, token.length());
                ASSERT_FALSE(std::getline(ss, token, '-'));
            }

            TEST_F(UuidUtilTest, testUuidToString) {
                int64_t msb = static_cast<int64_t>(0xfb34567812345678LL);
                int64_t lsb = static_cast<int64_t>(0xabcd123412345678LL);
                hazelcast::util::UUID uuid(msb, lsb);
                std::string uuidString = uuid.toString();
                ASSERT_EQ("fb345678-1234-5678-abcd-123412345678", uuidString);
            }
        }
    }
}






namespace hazelcast {
    namespace client {
        namespace test {
            namespace util {
                class UTFUtilTest : public ::testing::Test {
                protected:
                    // includes one, two three and 4 byte code points
                    static const std::string VALID_UTF_STRING;

                    static const std::string INVALID_UTF_STRING_INSUFFICIENT_BYTES;
                };

                const std::string UTFUtilTest::VALID_UTF_STRING = "a \xc3\xa9 \xe5\x92\xa7 \xf6\xa7\x93\xb5";
                const std::string UTFUtilTest::INVALID_UTF_STRING_INSUFFICIENT_BYTES = "a \xc3\xa9 \xe5\x92 \xf6\xa7\x93\xb5";

                TEST_F(UTFUtilTest, validUTF8) {
                    ASSERT_GT(hazelcast::util::UTFUtil::isValidUTF8(VALID_UTF_STRING), 0);
                }

                TEST_F(UTFUtilTest, invalidUTF8) {
                    ASSERT_EQ(-1, hazelcast::util::UTFUtil::isValidUTF8(INVALID_UTF_STRING_INSUFFICIENT_BYTES));
                }

                TEST_F(UTFUtilTest, readValidUTF8) {
                    std::vector<byte> strBytes;
                    for (char b : VALID_UTF_STRING) {
                        strBytes.push_back((byte) b);
                    }
                    serialization::pimpl::DataInput in(strBytes);
                    std::vector<char> utfBuffer;
                    utfBuffer.reserve(
                            client::serialization::pimpl::DataInput::MAX_UTF_CHAR_SIZE * VALID_UTF_STRING.size());
                    int numberOfUtfChars = hazelcast::util::UTFUtil::isValidUTF8(VALID_UTF_STRING);
                    for (int i = 0; i < numberOfUtfChars; ++i) {
                        byte c = in.readByte();
                        hazelcast::util::UTFUtil::readUTF8Char(in, c, utfBuffer);
                    }

                    std::string result(utfBuffer.begin(), utfBuffer.end());
                    ASSERT_EQ(VALID_UTF_STRING, result);
                }

                TEST_F(UTFUtilTest, readInvalidUTF8) {
                    std::vector<byte> strBytes;
                    for (char b : INVALID_UTF_STRING_INSUFFICIENT_BYTES) {
                        strBytes.push_back((byte) b);
                    }
                    serialization::pimpl::DataInput in(strBytes);
                    std::vector<char> utfBuffer;
                    utfBuffer.reserve(
                            client::serialization::pimpl::DataInput::MAX_UTF_CHAR_SIZE * VALID_UTF_STRING.size());
                    for (int i = 0; i < 5; ++i) {
                        byte c = in.readByte();
// The 4th utf character is missing one byte intentionally in the invalid utf string
                        if (i == 4) {
                            ASSERT_THROW(hazelcast::util::UTFUtil::readUTF8Char(in, c, utfBuffer),
                                         exception::UTFDataFormatException);
                        } else {
                            hazelcast::util::UTFUtil::readUTF8Char(in, c, utfBuffer);
                        }
                    }
                }
            }
        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {
            class LoggerConfigFromFileTest : public ClientTestSupport {
            public:
                LoggerConfigFromFileTest() {
                    // Clear file content before test starts
                    std::ofstream logOutFile("testLog.txt", std::ifstream::trunc);

                    config::LoggerConfig loggerConfig;
                    loggerConfig.setConfigurationFileName("hazelcast/test/resources/logger-config.txt");

                    testLogger.reset(new hazelcast::util::ILogger("testConfigureFromFile", "testConfigureFromFile",
                                                                  "testversion",
                                                                  loggerConfig));

                }

            protected:
                virtual void SetUp() {
                    ASSERT_TRUE(testLogger->start());

                    originalStdout = std::cout.rdbuf();
                    std::cout.rdbuf(buffer.rdbuf());
                }

                virtual void TearDown() {
                    std::cout.rdbuf(originalStdout);
                }

                std::vector<std::string> getLogLines() {
                    std::string logFileName("testLog.txt");

                    std::ifstream logFile(logFileName.c_str());
                    std::vector<std::string> lines;
                    std::string line;
                    while (std::getline(logFile, line)) {
                        lines.push_back(line);
                    }

                    return lines;
                }

            protected:
                std::streambuf *originalStdout;
                std::stringstream buffer;
                std::unique_ptr<hazelcast::util::ILogger> testLogger;
            };

            TEST_F(LoggerConfigFromFileTest, testFinest) {
                const std::string log("First finest log");
                testLogger->finest(log);
                std::vector<std::string> lines = getLogLines();
                ASSERT_EQ(1U, lines.size());
                ASSERT_NE(std::string::npos, lines[0].find(log));
                // make sure that nothing is printed to stdout
                ASSERT_TRUE(buffer.str().empty());
            }

            TEST_F(LoggerConfigFromFileTest, testFinest2) {
                const std::string log("First finest log");
                testLogger->info(log);
                std::vector<std::string> lines = getLogLines();
                ASSERT_EQ(1U, lines.size());
                ASSERT_NE(std::string::npos, lines[0].find(log));
                // make sure that nothing is printed to stdout
                ASSERT_TRUE(buffer.str().empty());
            }

            TEST_F(LoggerConfigFromFileTest, testInfo) {
                const std::string log("First info log");
                testLogger->info(log);
                std::vector<std::string> lines = getLogLines();
                ASSERT_EQ(1U, lines.size());
                ASSERT_NE(std::string::npos, lines[0].find(log));
                // make sure that nothing is printed to stdout
                ASSERT_TRUE(buffer.str().empty());
            }

            TEST_F(LoggerConfigFromFileTest, testInfo2) {
                const std::string log("First info log");
                testLogger->info(log);
                std::vector<std::string> lines = getLogLines();
                ASSERT_EQ(1U, lines.size());
                ASSERT_NE(std::string::npos, lines[0].find(log));
// make sure that nothing is printed to stdout
                ASSERT_TRUE(buffer.str().empty());
            }

            TEST_F(LoggerConfigFromFileTest, testWarning) {
                const std::string log("First warning log");
                testLogger->warning(log);
                std::vector<std::string> lines = getLogLines();
                ASSERT_EQ(0U, lines.size());
            }

            TEST_F(LoggerConfigFromFileTest, testWarning2) {
                const std::string log("First warning log");
                testLogger->warning(log);

                std::vector<std::string> lines = getLogLines();
                ASSERT_EQ(0U, lines.size());
            }

            TEST_F(LoggerConfigFromFileTest, testMultipleLinesLog) {
                const std::string infoLog("First Info log");
                testLogger->info(infoLog);

                const std::string debugLog("First debug log");
                testLogger->finest(debugLog);

                const std::string firstFatalLog("First fatal log");
                testLogger->severe(firstFatalLog);

                std::vector<std::string> lines = getLogLines();
                ASSERT_EQ(3U, lines.size());

                ASSERT_NE(std::string::npos, lines[0].find(infoLog));

                ASSERT_NE(std::string::npos, lines[1].find(debugLog));

                ASSERT_NE(std::string::npos, lines[2].find(firstFatalLog));

                testLogger->warning("This log should not be printed");

                lines = getLogLines();
                ASSERT_EQ(3U, lines.size());

                testLogger->warning("This log should not be printed");
                lines = getLogLines();
                ASSERT_EQ(3U, lines.size());

// make sure that nothing is printed to stdout
                ASSERT_TRUE(buffer.str().empty());

            }

            TEST_F(LoggerConfigFromFileTest, testNonExistingConfigurationFileFailFast) {
                ClientConfig clientConfig;
                clientConfig.getLoggerConfig().setConfigurationFileName("NonExistent");
                ASSERT_THROW(HazelcastClient client(clientConfig), exception::IllegalStateException);
            }

        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {
            class LoggerTest : public ClientTestSupport {
            public:
                LoggerTest() : logger(getLogger()) {
                }

            protected:
                virtual void SetUp() {
                    originalStdout = std::cout.rdbuf();

                    std::cout.rdbuf(buffer.rdbuf());
                }

                virtual void TearDown() {
                    std::cout.rdbuf(originalStdout);
                }

                class TestObject {
                public:
                    TestObject(int objectCount) : objectCount(objectCount) {}

                    friend std::ostream &operator<<(std::ostream &os, const TestObject &object) {
                        os << "objectCount: " << object.objectCount;
                        return os;
                    }

                private:
                    int objectCount;
                };

                hazelcast::util::ILogger &logger;
                std::stringstream buffer;
                std::streambuf *originalStdout;
            };

            TEST_F(LoggerTest, testPrintObject) {
                logger.info("This is an info message. ", TestObject(5));

                const std::string &printedString = buffer.str();
                size_t index = printedString.find("This is an info message. objectCount: 5");

                ASSERT_NE(printedString.npos, index);
            }

            TEST_F(LoggerTest, testDefaultLogLevel) {
                ASSERT_FALSE(logger.isFinestEnabled());
                ASSERT_FALSE(logger.isEnabled(client::LoggerLevel::FINEST));
                ASSERT_TRUE(logger.isEnabled(client::LoggerLevel::INFO));
                ASSERT_TRUE(logger.isEnabled(client::LoggerLevel::WARNING));
                ASSERT_TRUE(logger.isEnabled(client::LoggerLevel::SEVERE));

                logger.finest("Warning level message");
                ASSERT_TRUE(buffer.str().empty());

                logger.info("info message");
                std::string value = buffer.str();
                ASSERT_NE(std::string::npos, value.find("info message"));

                logger.warning("warning message");
                ASSERT_NE(std::string::npos, buffer.str().find("warning message"));

                logger.severe("severe message");
                ASSERT_NE(std::string::npos, buffer.str().find("severe message"));
            }

            TEST_F(LoggerTest, testLogLevel) {
                const char *testName = testing::UnitTest::GetInstance()->current_test_info()->name();
                config::LoggerConfig loggerConfig;
                loggerConfig.setLogLevel(client::LoggerLevel::WARNING);
                std::shared_ptr<hazelcast::util::ILogger> logger(
                        new hazelcast::util::ILogger(testName, testName, "TestVersion", loggerConfig));
                ASSERT_TRUE(logger->start());

                ASSERT_FALSE(logger->isFinestEnabled());
                ASSERT_FALSE(logger->isEnabled(client::LoggerLevel::FINEST));
                ASSERT_FALSE(logger->isEnabled(client::LoggerLevel::INFO));
                ASSERT_TRUE(logger->isEnabled(client::LoggerLevel::WARNING));
                ASSERT_TRUE(logger->isEnabled(client::LoggerLevel::SEVERE));

                logger->finest("Warning level message");
                ASSERT_TRUE(buffer.str().empty());

                logger->info("info message");
                ASSERT_TRUE(buffer.str().empty());

                logger->warning("warning message");
                ASSERT_NE(std::string::npos, buffer.str().find("warning message"));

                logger->severe("severe message");
                ASSERT_NE(std::string::npos, buffer.str().find("severe message"));
            }
        }
    }
}


//
// Created by hsan Demir on Mar 6 2016.
//



namespace hazelcast {
    namespace client {
        namespace test {
            namespace util {
                class ConcurentQueueTest : public ClientTestSupport
                {
                protected:
                    class ConcurrentQueueTask : public hazelcast::util::Runnable {
                    public:
                        ConcurrentQueueTask(hazelcast::util::ConcurrentQueue<int> &q,
                                            hazelcast::util::CountDownLatch &startLatch,
                                            hazelcast::util::CountDownLatch &startRemoveLatch, int removalValue) : q(q),
                                                                                                                   startLatch(
                                                                                                                           startLatch),
                                                                                                                   startRemoveLatch(
                                                                                                                           startRemoveLatch),
                                                                                                                   removalValue(
                                                                                                                           removalValue) {}

                    private:
                        virtual void run() {
                            int numItems = 1000;

                            std::vector<int> values((size_t)numItems);

                            startLatch.countDown();

                            ASSERT_TRUE(startLatch.await(10));

                            // insert items
                            for (int i = 0; i < numItems; ++i) {
                                values[i] = i;
                                q.offer(&values[i]);
                            }

                            q.offer(&removalValue);
                            startRemoveLatch.countDown();

                            // poll items
                            for (int i = 0; i < numItems; ++i) {
                                values[i] = i;
                                ASSERT_NE((int *)NULL, q.poll());
                            }
                        }

                        virtual const std::string getName() const {
                            return "ConcurrentQueueTask";
                        }

                    private:
                        hazelcast::util::ConcurrentQueue<int> &q;
                        hazelcast::util::CountDownLatch &startLatch;
                        hazelcast::util::CountDownLatch &startRemoveLatch;
                        int removalValue;
                    };
                };

                TEST_F(ConcurentQueueTest, testSingleThread) {
                    hazelcast::util::ConcurrentQueue<int> q;

                    ASSERT_EQ((int *) NULL, q.poll());

                    int val1, val2;

                    q.offer(&val1);

                    ASSERT_EQ(&val1, q.poll());

                    ASSERT_EQ((int *) NULL, q.poll());

                    q.offer(&val1);
                    q.offer(&val2);
                    q.offer(&val2);
                    q.offer(&val1);

                    ASSERT_EQ(2, q.removeAll(&val2));
                    ASSERT_EQ(0, q.removeAll(&val2));

                    ASSERT_EQ(&val1, q.poll());
                    ASSERT_EQ(&val1, q.poll());

                    ASSERT_EQ((int *) NULL, q.poll());
                }

                TEST_F(ConcurentQueueTest, testMultiThread) {
                    int numThreads = 40;

                    hazelcast::util::CountDownLatch startLatch(numThreads);

                    hazelcast::util::CountDownLatch startRemoveLatch(numThreads);

                    hazelcast::util::ConcurrentQueue<int> q;

                    int removalValue = 10;

                    std::vector<std::shared_ptr<hazelcast::util::Thread> > allThreads;
                    for (int i = 0; i < numThreads; i++) {
                        std::shared_ptr<hazelcast::util::Thread> t(
                                new hazelcast::util::Thread(std::shared_ptr<hazelcast::util::Runnable>(
                                        new ConcurrentQueueTask(q, startLatch, startRemoveLatch, removalValue)),
                                                            getLogger()));
                        t->start();
                        allThreads.push_back(t);
                    }

                    // wait for the remove start
                    ASSERT_TRUE(startRemoveLatch.await(30));

                    int numRemoved = q.removeAll(&removalValue);

                    int numRemaining = numThreads - numRemoved;

                    for (int j = 0; j < numRemaining; ++j) {
                        ASSERT_NE((int *) NULL, q.poll());
                    }
                    ASSERT_EQ(0, q.removeAll(&removalValue));

                }
            }
        }
    }
}

//
// Created by sancar koyunlu on 22/08/14.
//




namespace hazelcast {
    namespace client {
        namespace test {
            class ClientUtilTest : public ClientTestSupport {
            protected:
                class LatchExecutionCallback : public ExecutionCallback<int> {
                public:
                    LatchExecutionCallback(hazelcast::util::CountDownLatch &successLatch, hazelcast::util::CountDownLatch &failLatch)
                            : successLatch(successLatch), failLatch(failLatch) {}

                    virtual void onResponse(const std::shared_ptr<int> &response) {
                        successLatch.countDown();
                    }

                    virtual void onFailure(const std::shared_ptr<exception::IException> &e) {
                        failLatch.countDown();
                    }

                private:
                    hazelcast::util::CountDownLatch &successLatch;
                    hazelcast::util::CountDownLatch &failLatch;
                };

                static void wakeTheConditionUp(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::Mutex *mutex = (hazelcast::util::Mutex *) args.arg0;
                    hazelcast::util::ConditionVariable *cv = (hazelcast::util::ConditionVariable *) args.arg1;
                    int wakeUpTime = *(int *) args.arg2;
                    hazelcast::util::sleep(wakeUpTime);

                    hazelcast::util::LockGuard lockGuard(*mutex);
                    cv->notify();
                }

                static void setValueToFuture(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::Future<int> *future = (hazelcast::util::Future<int> *) args.arg0;
                    std::shared_ptr<int> value = *(std::shared_ptr<int> *) args.arg1;
                    int wakeUpTime = *(int *) args.arg2;
                    hazelcast::util::sleep(wakeUpTime);
                    future->set_value(value);
                }

                static void setExceptionToFuture(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::Future<int> *future = (hazelcast::util::Future<int> *) args.arg0;
                    int wakeUpTime = *(int *) args.arg1;
                    hazelcast::util::sleep(wakeUpTime);
                    std::unique_ptr<client::exception::IException> exception(
                            new exception::IOException("exceptionName", "details"));
                    future->set_exception(exception);
                }

                static void cancelJoinFromRunningThread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::Thread *currentThread = args.currentThread;
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    currentThread->cancel();
                    ASSERT_FALSE(currentThread->join());
                    latch->countDown();
                }

                static void notifyExitingThread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    latch->countDown();
                }
            };

            TEST_F(ClientUtilTest, testConditionWaitTimeout) {
                hazelcast::util::Mutex mutex;
                hazelcast::util::ConditionVariable conditionVariable;
                int wakeUpTime = 3;
                hazelcast::util::StartedThread thread(wakeTheConditionUp, &mutex, &conditionVariable, &wakeUpTime);
                int waitSeconds = 30;
                {
                    hazelcast::util::LockGuard lockGuard(mutex);
                    time_t beg = time(NULL);
                    time_t end = 0;
                    bool wokenUpByInterruption = conditionVariable.waitFor(mutex, waitSeconds * 1000);
                    if (wokenUpByInterruption) {
                        end = time(NULL);
                    }
                    ASSERT_NEAR((double) (end - beg), (double) wakeUpTime, 1);
                }

            }

            TEST_F(ClientUtilTest, testConditionWaitMillisTimeout) {
                hazelcast::util::Mutex mutex;
                hazelcast::util::ConditionVariable conditionVariable;
                ASSERT_FALSE(conditionVariable.waitFor(mutex, 100));
            }

            TEST_F(ClientUtilTest, testConditionWaitNanosTimeout) {
                hazelcast::util::Mutex mutex;
                hazelcast::util::ConditionVariable conditionVariable;
                ASSERT_FALSE(conditionVariable.waitNanos(mutex, 1000));
            }

            TEST_F(ClientUtilTest, testConditionVariableForEINVAL) {
                hazelcast::util::Mutex mutex;
                hazelcast::util::ConditionVariable conditionVariable;
                int wakeUpTime = 1;
                hazelcast::util::StartedThread thread(wakeTheConditionUp, &mutex, &conditionVariable, &wakeUpTime);
                {
                    hazelcast::util::LockGuard lockGuard(mutex);
// the following call should not fail with assertion for EINVAL
                    conditionVariable.waitFor(mutex, 19999);
                }
            }

            TEST_F (ClientUtilTest, testFutureWaitTimeout) {
                hazelcast::util::Future<int> future(getLogger());
                int waitSeconds = 3;
                time_t beg = time(NULL);
                ASSERT_FALSE(future.waitFor(waitSeconds * 1000));
                ASSERT_NEAR((double) (time(NULL) - beg), (double) waitSeconds, 1);
            }

            TEST_F (ClientUtilTest, testFutureSetValue) {
                hazelcast::util::Future<int> future(getLogger());
                int waitSeconds = 3;
                std::shared_ptr<int> expectedValue(new int(2));
                future.set_value(expectedValue);
                ASSERT_TRUE(future.waitFor(waitSeconds * 1000));
                int value = *future.get();
                ASSERT_EQ(*expectedValue, value);
            }

            TEST_F (ClientUtilTest, testFutureSetException) {
                hazelcast::util::Future<int> future(getLogger());

                std::unique_ptr<client::exception::IException> exception(
                        new client::exception::IOException("testFutureSetException", "details"));
                future.set_exception(exception);

                ASSERT_THROW(future.get(), client::exception::IOException);
            }

            TEST_F (ClientUtilTest, testFutureCancel) {
                hazelcast::util::Future<int> future(getLogger());

                ASSERT_FALSE(future.isCancelled());

                future.cancel();

                ASSERT_TRUE(future.isCancelled());

                ASSERT_THROW(future.get(), hazelcast::util::concurrent::CancellationException);
            }

            TEST_F (ClientUtilTest, testFutureSetUnclonedIOException) {
                hazelcast::util::Future<int> future(getLogger());

                std::unique_ptr<client::exception::IException> ioe(
                        new client::exception::IOException("testFutureSetUnclonedIOException", "details"));
                future.set_exception(ioe);

                try {
                    future.get();
                } catch (client::exception::IOException &) {
// success
                } catch (client::exception::IException &) {
                    FAIL();
                }
            }

            TEST_F (ClientUtilTest, testFutureSetValue_afterSomeTime) {
                hazelcast::util::Future<int> future(getLogger());
                int waitSeconds = 30;
                int wakeUpTime = 3;
                std::shared_ptr<int> expectedValue(new int(2));
                hazelcast::util::StartedThread thread(ClientUtilTest::setValueToFuture, &future, &expectedValue,
                                                      &wakeUpTime);
                ASSERT_TRUE(future.waitFor(waitSeconds * 1000));
                std::shared_ptr<int> value = future.get();
                ASSERT_EQ(*expectedValue, *value);

            }

            TEST_F (ClientUtilTest, testFutureSetException_afterSomeTime) {
                hazelcast::util::Future<int> future(getLogger());
                int waitSeconds = 30;
                int wakeUpTime = 3;
                hazelcast::util::StartedThread thread(ClientUtilTest::setExceptionToFuture, &future, &wakeUpTime);
                ASSERT_TRUE(future.waitFor(waitSeconds * 1000));

                try {
                    future.get();
                    FAIL();
                } catch (exception::IException &) {
// expect exception here
                }
            }

            TEST_F (ClientUtilTest, testFutureSetValueAndThen) {
                hazelcast::util::Future<int> future(getLogger());
                hazelcast::util::CountDownLatch successLatch(1);
                hazelcast::util::CountDownLatch failLatch(1);
                hazelcast::util::impl::SimpleExecutorService executorService(getLogger(), "testFutureAndThen", 3);
                executorService.start();
                future.andThen(std::shared_ptr<ExecutionCallback<int> >(
                        new LatchExecutionCallback(successLatch, failLatch)), executorService);

                int wakeUpTime = 0;
                std::shared_ptr<int> expectedValue(new int(2));
                hazelcast::util::StartedThread thread(ClientUtilTest::setValueToFuture, &future, &expectedValue,
                                                      &wakeUpTime);

                ASSERT_OPEN_EVENTUALLY(successLatch);
            }

            TEST_F (ClientUtilTest, testFutureSetValueBeforeAndThen) {
                hazelcast::util::Future<int> future(getLogger());
                hazelcast::util::CountDownLatch successLatch(1);
                hazelcast::util::CountDownLatch failLatch(1);
                hazelcast::util::impl::SimpleExecutorService executorService(getLogger(), "testFutureAndThen", 3);
                executorService.start();
                std::shared_ptr<int> value(new int(5));
                future.set_value(value);
                future.andThen(std::shared_ptr<ExecutionCallback<int> >(
                        new LatchExecutionCallback(successLatch, failLatch)), executorService);

                ASSERT_OPEN_EVENTUALLY(successLatch);
            }

            TEST_F (ClientUtilTest, testFutureSetExceptionAndThen) {
                hazelcast::util::Future<int> future(getLogger());
                hazelcast::util::CountDownLatch successLatch(1);
                hazelcast::util::CountDownLatch failLatch(1);
                hazelcast::util::impl::SimpleExecutorService executorService(getLogger(), "testFutureAndThen", 3);
                executorService.start();
                future.andThen(std::shared_ptr<ExecutionCallback<int> >(
                        new LatchExecutionCallback(successLatch, failLatch)), executorService);

                int wakeUpTime = 0;
                hazelcast::util::StartedThread thread(ClientUtilTest::setExceptionToFuture, &future, &wakeUpTime);

                ASSERT_OPEN_EVENTUALLY(failLatch);
                ASSERT_THROW(future.get(), exception::IOException);
            }

            TEST_F (ClientUtilTest, testFutureSetExceptionBeforeAndThen) {
                hazelcast::util::Future<int> future(getLogger());
                hazelcast::util::CountDownLatch successLatch(1);
                hazelcast::util::CountDownLatch failLatch(1);
                hazelcast::util::impl::SimpleExecutorService executorService(getLogger(), "testFutureAndThen", 3);
                executorService.start();
                future.set_exception(std::unique_ptr<client::exception::IException>(
                        new exception::IOException("exceptionName", "details")));
                future.andThen(std::shared_ptr<ExecutionCallback<int> >(
                        new LatchExecutionCallback(successLatch, failLatch)), executorService);

                ASSERT_OPEN_EVENTUALLY(failLatch);
                ASSERT_THROW(future.get(), exception::IOException);
            }

            TEST_F (ClientUtilTest, testThreadName) {
                std::string threadName = "myThreadName";
// We use latch so that we guarantee that the object instance thread is not destructed at the time when
// StartedThread::run is being executed.
                hazelcast::util::CountDownLatch latch(1);
                hazelcast::util::StartedThread thread(threadName, notifyExitingThread, &latch);
                ASSERT_EQ(threadName, thread.getName());
                ASSERT_TRUE(latch.await(120));
            }

            TEST_F (ClientUtilTest, testThreadJoinAfterThreadExited) {
                std::string threadName = "myThreadName";
                hazelcast::util::CountDownLatch latch(1);
                hazelcast::util::StartedThread thread(threadName, notifyExitingThread, &latch);
                ASSERT_TRUE(latch.await(2));
// guarantee that the thread exited
                hazelcast::util::sleep(1);

// call join after thread exit
                thread.join();
            }

            TEST_F (ClientUtilTest, testCancelJoinItselfFromTheRunningThread) {
                std::string threadName = "myThreadName";
                hazelcast::util::CountDownLatch latch(1);
                hazelcast::util::StartedThread thread(threadName, cancelJoinFromRunningThread, &latch);
                ASSERT_TRUE(latch.await(1000));
            }

            void sleepyThread(hazelcast::util::ThreadArgs &args) {
                int sleepTime = *(int *) args.arg0;
                args.currentThread->interruptibleSleep(sleepTime);
            }

            TEST_F (ClientUtilTest, testThreadInterruptibleSleep) {
                int sleepTime = 30;
                int wakeUpTime = 3;
                time_t beg = time(NULL);
                hazelcast::util::StartedThread thread(sleepyThread, &sleepTime);
                hazelcast::util::sleep(wakeUpTime);
                thread.cancel();
                thread.join();
                ASSERT_NEAR((double) (time(NULL) - beg), (double) wakeUpTime, 1);
            }

            TEST_F (ClientUtilTest, testDateConversion) {
                std::string date("2016-04-20");
                hazelcast::util::gitDateToHazelcastLogDate(date);
                ASSERT_EQ("20160420", date);

                date = "NOT_FOUND";
                hazelcast::util::gitDateToHazelcastLogDate(date);
                ASSERT_EQ("NOT_FOUND", date);
            }

            TEST_F (ClientUtilTest, testStrError) {
#if  defined(WIN32) || defined(_WIN32) || defined(WIN64) || defined(_WIN64)
                                                                                                                                        int error = WSAEINPROGRESS;
                std::string expectedErrorString("A blocking operation is currently executing.\r\n");
#else
                int error = EINPROGRESS;
                std::string expectedErrorString("Operation now in progress");
#endif

                char msg[100];
                const std::string prefix = "testStrError prefix message";
                ASSERT_EQ(0, hazelcast::util::strerror_s(error, msg, 100, prefix.c_str()));
                ASSERT_STREQ((prefix + " " + expectedErrorString).c_str(), msg);

                ASSERT_EQ(0, hazelcast::util::strerror_s(error, msg, prefix.length() + 1, prefix.c_str()));
                ASSERT_STREQ(prefix.c_str(), msg);

                ASSERT_EQ(0, hazelcast::util::strerror_s(error, msg, 100));
                ASSERT_STREQ(expectedErrorString.c_str(), msg);
            }

            TEST_F (ClientUtilTest, testAvailableCoreCount) {
                ASSERT_GT(hazelcast::util::getAvailableCoreCount(), 0);
            }

            TEST_F (ClientUtilTest, testStringUtilTimeToString) {
                std::string timeString = hazelcast::util::StringUtil::timeToString(
                        hazelcast::util::currentTimeMillis());
//expected format is "%Y-%m-%d %H:%M:%S.%f" it will be something like 2018-03-20 15:36:07.280
                ASSERT_EQ((size_t) 23, timeString.length());
                ASSERT_EQ(timeString[0], '2');
                ASSERT_EQ(timeString[1], '0');
                ASSERT_EQ(timeString[4], '-');
                ASSERT_EQ(timeString[7], '-');
            }

            TEST_F (ClientUtilTest, testStringUtilTimeToStringFriendly) {
                ASSERT_EQ("never", hazelcast::util::StringUtil::timeToStringFriendly(0));
            }

            TEST_F (ClientUtilTest, testLockSupport) {
                int64_t parkDurationNanos = 100;
                int64_t start = hazelcast::util::currentTimeNanos();
                hazelcast::util::concurrent::locks::LockSupport::parkNanos(parkDurationNanos);
                int64_t end = hazelcast::util::currentTimeNanos();
                int64_t actualDuration = end - start;
                ASSERT_GE(actualDuration, parkDurationNanos);
            }
        }
    }
}




namespace hazelcast {
    namespace client {

        class HazelcastClient;

        namespace test {
            class ClientConfigTest : public ClientTestSupport
            {};

            TEST_F(ClientConfigTest, testGetAddresses) {
                ClientConfig clientConfig;
                Address address("localhost", 5555);
                clientConfig.getNetworkConfig().addAddress(address);

                std::set<Address, addressComparator> addresses = clientConfig.getAddresses();
                ASSERT_EQ(1U, addresses.size());
                ASSERT_EQ(address, *addresses.begin());
            }

            TEST_F(ClientConfigTest, testAddresseses) {
                ClientConfig clientConfig;
                std::vector<Address> addresses;
                addresses.push_back(Address("localhost", 5555));
                addresses.push_back(Address("localhost", 6666));
                clientConfig.getNetworkConfig().addAddresses(addresses);

                std::set<Address, addressComparator> configuredAddresses = clientConfig.getAddresses();
                ASSERT_EQ(2U, addresses.size());
                std::vector<Address> configuredAddressVector(configuredAddresses.begin(), configuredAddresses.end());
                ASSERT_EQ(addresses, configuredAddressVector);
            }

            TEST_F(ClientConfigTest, testSetGetGroupConfig) {
                ClientConfig clientConfig;
                std::string groupName("myGroup");
                std::string password("myPass");
                GroupConfig groupConfig(groupName, password);
                clientConfig.setGroupConfig(groupConfig);
                GroupConfig &clientGroupConfig = clientConfig.getGroupConfig();
                ASSERT_EQ(groupName, clientGroupConfig.getName());
                ASSERT_EQ(password, clientGroupConfig.getPassword());
            }
        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            namespace connectionstrategy {

                class ConfiguredBehaviourTest : public ClientTestSupport {
                public:
                    ConfiguredBehaviourTest() {
                        clientConfig.getNetworkConfig().setConnectionTimeout(2000).setConnectionAttemptLimit(2).
                                setConnectionAttemptPeriod(1000);
                    }

                protected:
                    class LifecycleStateListener : public LifecycleListener {
                    public:
                        LifecycleStateListener(hazelcast::util::CountDownLatch &connectedLatch,
                                               const LifecycleEvent::LifeCycleState expectedState)
                                : connectedLatch(connectedLatch), expectedState(expectedState) {}

                        virtual void stateChanged(const LifecycleEvent &event) {
                            if (event.getState() == expectedState) {
                                connectedLatch.countDown();
                            }
                        }

                    private:
                        hazelcast::util::CountDownLatch &connectedLatch;
                        const LifecycleEvent::LifeCycleState expectedState;
                    };

                    ClientConfig clientConfig;
                };

                TEST_F(ConfiguredBehaviourTest, testAsyncStartTrueNoCluster) {
                    clientConfig.getConnectionStrategyConfig().setAsyncStart(true);
                    HazelcastClient client(clientConfig);

                    ASSERT_THROW((client.getMap<int, int>(randomMapName())),
                                 exception::HazelcastClientOfflineException);

                    client.shutdown();
                }

                TEST_F(ConfiguredBehaviourTest, testAsyncStartTrueNoCluster_thenShutdown) {
                    clientConfig.getConnectionStrategyConfig().setAsyncStart(true);
                    HazelcastClient client(clientConfig);
                    client.shutdown();
                    ASSERT_THROW((client.getMap<int, int>(randomMapName())),
                                 exception::HazelcastClientOfflineException);

                    client.shutdown();
                }

                TEST_F(ConfiguredBehaviourTest, testAsyncStartTrue) {
                    hazelcast::util::CountDownLatch connectedLatch(1);

                    // trying 8.8.8.8 address will delay the initial connection since no such server exist
                    clientConfig.getNetworkConfig().addAddress(Address("8.8.8.8", 5701))
                            .addAddress(Address("127.0.0.1", 5701)).setConnectionAttemptLimit(INT32_MAX);
                    clientConfig.setProperty("hazelcast.client.shuffle.member.list", "false");
                    LifecycleStateListener lifecycleListener(connectedLatch, LifecycleEvent::CLIENT_CONNECTED);
                    clientConfig.addListener(&lifecycleListener);
                    clientConfig.getConnectionStrategyConfig().setAsyncStart(true);

                    HazelcastClient client(clientConfig);

                    ASSERT_TRUE(client.getLifecycleService().isRunning());

                    HazelcastServer server(*g_srvFactory);

                    ASSERT_OPEN_EVENTUALLY(connectedLatch);

                    IMap<int, int> map = client.getMap<int, int>(randomMapName());
                    map.size();

                    client.shutdown();
                }

                TEST_F(ConfiguredBehaviourTest, testReconnectModeOFFSingleMember) {
                    HazelcastServer hazelcastInstance(*g_srvFactory);

                    clientConfig.getConnectionStrategyConfig().setReconnectMode(
                            config::ClientConnectionStrategyConfig::OFF);
                    HazelcastClient client(clientConfig);
                    hazelcast::util::CountDownLatch shutdownLatch(1);
                    LifecycleStateListener lifecycleListener(shutdownLatch, LifecycleEvent::SHUTDOWN);
                    client.addLifecycleListener(&lifecycleListener);

                    // no exception at this point
                    IMap<int, int> map = client.getMap<int, int>(randomMapName());
                    map.put(1, 5);

                    hazelcastInstance.shutdown();
                    ASSERT_OPEN_EVENTUALLY(shutdownLatch);

                    ASSERT_THROW(map.put(1, 5), exception::HazelcastClientNotActiveException);

                    client.shutdown();
                }

                TEST_F(ConfiguredBehaviourTest, testReconnectModeOFFTwoMembers) {
                    HazelcastServer ownerServer(*g_srvFactory);

                    clientConfig.getConnectionStrategyConfig().setReconnectMode(
                            config::ClientConnectionStrategyConfig::OFF);
                    HazelcastClient client(clientConfig);
                    HazelcastServer hazelcastInstance2(*g_srvFactory);
                    hazelcast::util::CountDownLatch shutdownLatch(1);
                    LifecycleStateListener lifecycleListener(shutdownLatch, LifecycleEvent::SHUTDOWN);
                    client.addLifecycleListener(&lifecycleListener);

// no exception at this point
                    IMap<int, int> map = client.getMap<int, int>(randomMapName());
                    map.put(1, 5);

                    ownerServer.shutdown();
                    ASSERT_OPEN_EVENTUALLY(shutdownLatch);

                    ASSERT_THROW(map.put(1, 5), exception::HazelcastClientNotActiveException);

                    client.shutdown();
                }

                TEST_F(ConfiguredBehaviourTest, testReconnectModeASYNCSingleMemberInitiallyOffline) {
                    HazelcastServer hazelcastInstance(*g_srvFactory);

                    clientConfig.getConnectionStrategyConfig().setReconnectMode(
                            config::ClientConnectionStrategyConfig::OFF);
                    HazelcastClient client(clientConfig);
                    hazelcast::util::CountDownLatch shutdownLatch(1);
                    LifecycleStateListener lifecycleListener(shutdownLatch, LifecycleEvent::SHUTDOWN);
                    client.addLifecycleListener(&lifecycleListener);

// no exception at this point
                    IMap<int, int> map = client.getMap<int, int>(randomMapName());
                    map.put(1, 5);

                    hazelcastInstance.shutdown();
                    ASSERT_OPEN_EVENTUALLY(shutdownLatch);

                    ASSERT_THROW(map.put(1, 5), exception::HazelcastClientNotActiveException);

                    client.shutdown();
                }

                TEST_F(ConfiguredBehaviourTest, testReconnectModeASYNCSingleMember) {
                    HazelcastServer hazelcastInstance(*g_srvFactory);

                    hazelcast::util::CountDownLatch connectedLatch(1);

                    LifecycleStateListener listener(connectedLatch, LifecycleEvent::CLIENT_CONNECTED);
                    clientConfig.addListener(&listener);
                    clientConfig.getConnectionStrategyConfig().setReconnectMode(
                            config::ClientConnectionStrategyConfig::ASYNC);
                    HazelcastClient client(clientConfig);

                            assertTrue(client.getLifecycleService().isRunning());

                            assertOpenEventually(connectedLatch);

                    IMap<int, int> map = client.getMap<int, int>(randomMapName());
                    map.size();
                }

                TEST_F(ConfiguredBehaviourTest, testReconnectModeASYNCSingleMemberStartLate) {
                    HazelcastServer hazelcastInstance(*g_srvFactory);

                    hazelcast::util::CountDownLatch initialConnectionLatch(1);
                    hazelcast::util::CountDownLatch reconnectedLatch(1);

                    clientConfig.getNetworkConfig().setConnectionAttemptLimit(10);
                    LifecycleStateListener listener(initialConnectionLatch, LifecycleEvent::CLIENT_CONNECTED);
                    clientConfig.addListener(&listener);
                    clientConfig.getConnectionStrategyConfig().setReconnectMode(
                            config::ClientConnectionStrategyConfig::ASYNC);
                    HazelcastClient client(clientConfig);

                    hazelcastInstance.shutdown();

                    LifecycleStateListener reconnectListener(reconnectedLatch, LifecycleEvent::CLIENT_CONNECTED);
                    client.addLifecycleListener(&reconnectListener);

                    HazelcastServer hazelcastInstance2(*g_srvFactory);

                            assertTrue(client.getLifecycleService().isRunning());
                            assertOpenEventually(reconnectedLatch);

                    IMap<int, int> map = client.getMap<int, int>(randomMapName());
                    map.size();

                    client.shutdown();
                }

                TEST_F(ConfiguredBehaviourTest, testReconnectModeASYNCTwoMembers) {
                    HazelcastServer ownerServer(*g_srvFactory);

                    hazelcast::util::CountDownLatch connectedLatch(1);
                    hazelcast::util::CountDownLatch disconnectedLatch(1);
                    hazelcast::util::CountDownLatch reconnectedLatch(1);

                    clientConfig.getNetworkConfig().setConnectionAttemptLimit(10);
                    LifecycleStateListener listener(connectedLatch, LifecycleEvent::CLIENT_CONNECTED);
                    clientConfig.addListener(&listener);
                    clientConfig.getConnectionStrategyConfig().setReconnectMode(
                            config::ClientConnectionStrategyConfig::ASYNC);
                    HazelcastClient client(clientConfig);

                            assertTrue(client.getLifecycleService().isRunning());

                            assertOpenEventually(connectedLatch);

                    HazelcastServer hazelcastInstance2(*g_srvFactory);

                    IMap<int, int> map = client.getMap<int, int>(randomMapName());
                    map.put(1, 5);

                    LifecycleStateListener disconnectListener(disconnectedLatch, LifecycleEvent::CLIENT_DISCONNECTED);
                    client.addLifecycleListener(&disconnectListener);

                    LifecycleStateListener reconnectListener(reconnectedLatch, LifecycleEvent::CLIENT_CONNECTED);
                    client.addLifecycleListener(&reconnectListener);

                    ownerServer.shutdown();

                            assertOpenEventually(disconnectedLatch);
                            assertOpenEventually(reconnectedLatch);

                    map.get(1);

                    client.shutdown();
                }
            }
        }
    }
}




using namespace std;

namespace hazelcast {
    namespace client {
        namespace test {
            class PipeliningTest : public ClientTestSupport {
            public:
                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    client = new HazelcastClient(ClientConfig());

                    map = new IMap<int, int>(client->getMap<int, int>(MAP_NAME));
                    expected = new std::vector<int>;
                    for (int k = 0; k < MAP_SIZE; ++k) {
                        int item = rand();
                        expected->push_back(item);
                        map->put(k, item);
                    }
                }

                static void TearDownTestCase() {
                    delete instance;
                    instance = NULL;
                    delete client;
                    client = NULL;
                    delete map;
                    map = NULL;
                    delete expected;
                    expected = NULL;
                }

            protected:
                void testPipelining(const std::shared_ptr<Pipelining<int> > &pipelining) {
                    for (int k = 0; k < MAP_SIZE; k++) {
                        pipelining->add(map->getAsync(k));
                    }

                    vector<std::shared_ptr<int> > results = pipelining->results();
                    ASSERT_EQ(expected->size(), results.size());
                    for (int k = 0; k < MAP_SIZE; ++k) {
                        ASSERT_EQ_PTR((*expected)[k], results[k].get(), int);
                    }
                }

                static HazelcastServer *instance;
                static HazelcastClient *client;
                static const char *MAP_NAME;
                static IMap<int, int> *map;
                static std::vector<int> *expected;
                static const int MAP_SIZE = 10000;
            };

            HazelcastServer *PipeliningTest::instance = NULL;
            HazelcastClient *PipeliningTest::client = NULL;
            const char *PipeliningTest::MAP_NAME = "PipeliningTestMap";
            IMap<int, int> *PipeliningTest::map = NULL;
            std::vector<int> *PipeliningTest::expected = NULL;

            TEST_F(PipeliningTest, testConstructor_whenNegativeDepth) {
                ASSERT_THROW(Pipelining<string>::create(0), exception::IllegalArgumentException);
                ASSERT_THROW(Pipelining<string>::create(-1), exception::IllegalArgumentException);
            }

            TEST_F(PipeliningTest, add_whenNull) {
                std::shared_ptr<Pipelining<string> > pipelining = Pipelining<string>::create(1);
                ASSERT_THROW(pipelining->add(std::shared_ptr<ICompletableFuture<string> >()),
                             exception::NullPointerException);
            }

            TEST_F(PipeliningTest, testPipeliningFunctionalityDepthOne) {
                testPipelining(Pipelining<int>::create(1));
            }

            TEST_F(PipeliningTest, testPipeliningFunctionalityDepth100) {
                testPipelining(Pipelining<int>::create(100));
            }
        }
    }
}


namespace hazelcast {
    namespace client {
        namespace test {
            TestRawDataPortable::TestRawDataPortable() {

            }

            int TestRawDataPortable::getFactoryId() const {
                return TestSerializationConstants::TEST_PORTABLE_FACTORY;
            }

            int TestRawDataPortable::getClassId() const {
                return TestSerializationConstants::TEST_RAW_DATA_PORTABLE;
            }


            void TestRawDataPortable::writePortable(serialization::PortableWriter &writer) const {
                writer.writeLong("l", l);
                writer.writeCharArray("c", &c);
                writer.writePortable("p", &p);
                serialization::ObjectDataOutput &out = writer.getRawDataOutput();
                out.writeInt(k);
                out.writeUTF(&s);
                ds.writeData(out);
            }


            void TestRawDataPortable::readPortable(serialization::PortableReader &reader) {
                l = reader.readLong("l");
                c = *reader.readCharArray("c");
                std::shared_ptr<TestNamedPortable> ptr = reader.readPortable<TestNamedPortable>("p");
                if (ptr != NULL)
                    p = *ptr;
                serialization::ObjectDataInput &in = reader.getRawDataInput();
                k = in.readInt();
                s = *in.readUTF();
                ds.readData(in);
            }

            TestRawDataPortable::TestRawDataPortable(int64_t l, std::vector<char> c, TestNamedPortable p, int32_t k,
                                                     std::string s, TestDataSerializable ds) {
                this->l = l;
                this->c = c;
                this->p = p;
                this->k = k;
                this->s = s;
                this->ds = ds;
            }

            bool TestRawDataPortable::operator==(const TestRawDataPortable &m) const {
                if (this == &m)
                    return true;
                if (l != m.l) return false;
                if (c != m.c) return false;
                if (p != m.p) return false;
                if (k != m.k) return false;
                if (ds != m.ds) return false;
                if (s.compare(m.s) != 0) return false;
                return true;
            }

            bool TestRawDataPortable::operator!=(const TestRawDataPortable &m) const {
                return !(*this == m);
            }

            std::unique_ptr<serialization::Portable> TestDataPortableFactory::create(int32_t classId) const {
                if (classId == TestRawDataPortable::CLASS_ID) {
                    return std::unique_ptr<serialization::Portable>(new TestRawDataPortable());
                }

                return std::unique_ptr<serialization::Portable>();
            }
        }
    }
}


//
// Created by sancar koyunlu on 11/11/13.


namespace hazelcast {
    namespace client {
        namespace test {
            Employee::Employee():age(-1), name("") {
            }

            Employee::Employee(std::string name, int32_t age)
                    :age(age)
                    , name(name) {
                by = 2;
                boolean = true;
                c = 'c';
                s = 4;
                i = 2000;
                l = 321324141;
                f = 3.14f;
                d = 3.14334;
                str = "Hello world";
                utfStr = "   ";

                byte byteArray[] = {50, 100, 150, 200};
                byteVec = std::vector<byte>(byteArray, byteArray + 4);
                char charArray[] = {'c', 'h', 'a', 'r'};
                cc = std::vector<char>(charArray, charArray + 4);
                bool boolArray[] = {true, false, false, true};
                ba = std::vector<bool>(boolArray, boolArray + 4);
                int16_t shortArray[] = {3, 4, 5};
                ss = std::vector<int16_t>(shortArray, shortArray + 3);
                int32_t integerArray[] = {9, 8, 7, 6};
                ii = std::vector<int32_t>(integerArray, integerArray + 4);
                int64_t  longArray[] = {0, 1, 5, 7, 9, 11};
                ll = std::vector<int64_t >(longArray, longArray + 6);
                float floatArray[] = {0.6543f, -3.56f, 45.67f};
                ff = std::vector<float>(floatArray, floatArray + 3);
                double doubleArray[] = {456.456, 789.789, 321.321};
                dd = std::vector<double>(doubleArray, doubleArray + 3);
            }

            bool Employee::operator==(const Employee &rhs) const {
                return age == rhs.getAge() && name == rhs.getName();
            }

            bool Employee::operator !=(const Employee &employee) const {
                return !(*this == employee);
            }

            int32_t Employee::getFactoryId() const {
                return 666;
            }

            int32_t Employee::getClassId() const {
                return 2;
            }

            void Employee::writePortable(serialization::PortableWriter &writer) const {
                writer.writeUTF("n", &name);
                writer.writeInt("a", age);

                writer.writeByte("b", by);
                writer.writeChar("c", c);
                writer.writeBoolean("bo", boolean);
                writer.writeShort("s", s);
                writer.writeInt("i", i);
                writer.writeLong("l", l);
                writer.writeFloat("f", f);
                writer.writeDouble("d", d);
                writer.writeUTF("str", &str);
                writer.writeUTF("utfstr", &utfStr);

                writer.writeByteArray("bb", &byteVec);
                writer.writeCharArray("cc", &cc);
                writer.writeBooleanArray("ba", &ba);
                writer.writeShortArray("ss", &ss);
                writer.writeIntArray("ii", &ii);
                writer.writeFloatArray("ff", &ff);
                writer.writeDoubleArray("dd", &dd);

                serialization::ObjectDataOutput &out = writer.getRawDataOutput();
                out.writeObject<byte>(&by);
                out.writeObject<char>(&c);
                out.writeObject<bool>(&boolean);
                out.writeObject<int16_t>(&s);
                out.writeObject<int32_t>(&i);
                out.writeObject<float>(&f);
                out.writeObject<double>(&d);
                out.writeObject<std::string>(&str);
                out.writeObject<std::string>(&utfStr);
            }

            void Employee::readPortable(serialization::PortableReader &reader) {
                name = *reader.readUTF("n");
                age = reader.readInt("a");

                by = reader.readByte("b");;
                c = reader.readChar("c");;
                boolean = reader.readBoolean("bo");;
                s = reader.readShort("s");;
                i = reader.readInt("i");;
                l = reader.readLong("l");;
                f = reader.readFloat("f");;
                d = reader.readDouble("d");;
                str = *reader.readUTF("str");;
                utfStr = *reader.readUTF("utfstr");;

                byteVec = *reader.readByteArray("bb");;
                cc = *reader.readCharArray("cc");;
                ba = *reader.readBooleanArray("ba");;
                ss = *reader.readShortArray("ss");;
                ii = *reader.readIntArray("ii");;
                ff = *reader.readFloatArray("ff");;
                dd = *reader.readDoubleArray("dd");;

                serialization::ObjectDataInput &in = reader.getRawDataInput();
                by = *in.readObject<byte>();
                c = *in.readObject<char>();
                boolean = *in.readObject<bool>();
                s = *in.readObject<int16_t>();
                i = *in.readObject<int32_t>();
                f = *in.readObject<float>();
                d = *in.readObject<double>();
                str = *in.readObject<std::string>();
                utfStr = *in.readObject<std::string>();
            }

            int32_t Employee::getAge() const {
                return age;
            }

            const std::string &Employee::getName() const {
                return name;
            }

            bool Employee::operator<(const Employee &rhs) const {
                return age < rhs.getAge();
            }

            int32_t EmployeeEntryComparator::getFactoryId() const {
                return 666;
            }

            int32_t EmployeeEntryComparator::getClassId() const {
                return 4;
            }

            void EmployeeEntryComparator::writeData(serialization::ObjectDataOutput &writer) const {
            }

            void EmployeeEntryComparator::readData(serialization::ObjectDataInput &reader) {
            }

            int EmployeeEntryComparator::compare(const std::pair<const int32_t *, const Employee *> *lhs,
                                                 const std::pair<const int32_t *, const Employee *> *rhs) const {
                const Employee *lv = lhs->second;
                const Employee *rv = rhs->second;

                if (NULL == lv && NULL == rv) {
                    // order by key
                    const int32_t leftKey = *lhs->first;
                    const int32_t rightKey = *rhs->first;

                    if (leftKey == rightKey) {
                        return 0;
                    }

                    if (leftKey < rightKey) {
                        return -1;
                    }

                    return 1;
                }

                if (NULL == lv) {
                    return -1;
                }

                if (NULL == rv) {
                    return 1;
                }

                int32_t la = lv->getAge();
                int32_t ra = rv->getAge();

                if (la == ra) {
                    return 0;
                }

                if (la < ra) {
                    return -1;
                }

                return 1;
            }


            int32_t EmployeeEntryKeyComparator::compare(const std::pair<const int32_t *, const Employee *> *lhs,
                                                        const std::pair<const int32_t *, const Employee *> *rhs) const {
                const int32_t *key1 = lhs->first;
                const int32_t *key2 = rhs->first;

                if (NULL == key1) {
                    return -1;
                }

                if (NULL == key2) {
                    return 1;
                }

                if (*key1 == *key2) {
                    return 0;
                }

                if (*key1 < *key2) {
                    return -1;
                }

                return 1;
            }

            int32_t EmployeeEntryKeyComparator::getClassId() const {
                return 5;
            }

            std::ostream &operator<<(std::ostream &out, const Employee &employee) {
                out << "Employee:[" << employee.getName() << ", " << employee.getAge() << "]";
                return out;
            }
        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {
            TestMainPortable::TestMainPortable()
                    : null(true) {
            }

            TestMainPortable::TestMainPortable(byte b, bool boolean, char c, short s, int i, int64_t l, float f, double d, std::string str, TestInnerPortable p) {
                null = false;
                this->b = b;
                this->boolean = boolean;
                this->c = c;
                this->s = s;
                this->i = i;
                this->l = l;
                this->f = f;
                this->d = d;
                this->str = str;
                this->p = p;
            }

            bool TestMainPortable::operator==(const TestMainPortable &m) const {
                if (this == &m) return true;
                if (null == true && m.null == true)
                    return true;
                if (b != m.b) return false;
                if (boolean != m.boolean) return false;
                if (c != m.c) return false;
                if (s != m.s) return false;
                if (i != m.i) return false;
                if (l != m.l) return false;
                if (f != m.f) return false;
                if (d != m.d) return false;
                if (str.compare(m.str)) return false;
                if (p != m.p) return false;
                return true;
            }

            bool TestMainPortable::operator!=(const TestMainPortable &m) const {
                return !(*this == m);
            }

            int TestMainPortable::getFactoryId() const {
                return TestSerializationConstants::TEST_PORTABLE_FACTORY;
            }

            int TestMainPortable::getClassId() const {
                return TestSerializationConstants::TEST_MAIN_PORTABLE;
            }

            void TestMainPortable::writePortable(serialization::PortableWriter &writer) const {
                writer.writeByte("b", b);
                writer.writeBoolean("bool", boolean);
                writer.writeChar("c", c);
                writer.writeShort("s", s);
                writer.writeInt("i", i);
                writer.writeLong("l", l);
                writer.writeFloat("f", f);
                writer.writeDouble("d", d);
                writer.writeUTF("str", &str);
                writer.writePortable("p", &p);
            }


            void TestMainPortable::readPortable(serialization::PortableReader &reader) {
                null = false;
                b = reader.readByte("b");
                boolean = reader.readBoolean("bool");
                c = reader.readChar("c");
                s = reader.readShort("s");
                i = reader.readInt("i");
                l = reader.readLong("l");
                f = reader.readFloat("f");
                d = reader.readDouble("d");
                str = *reader.readUTF("str");
                std::shared_ptr<TestInnerPortable> ptr = reader.readPortable<TestInnerPortable>("p");
                if (ptr != NULL)
                    p = *ptr;
            }

        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {

            TestNamedPortable::TestNamedPortable() {
            }

            TestNamedPortable::TestNamedPortable(std::string name, int k):name(name), k(k) {
            }

            int TestNamedPortable::getFactoryId() const {
                return TestSerializationConstants::TEST_PORTABLE_FACTORY;
            }

            int TestNamedPortable::getClassId() const {
                return TestSerializationConstants::TEST_NAMED_PORTABLE;
            }

            void TestNamedPortable::writePortable(serialization::PortableWriter& writer) const {
                writer.writeUTF("name", &name);
                writer.writeInt("myint", k);
            }


            void TestNamedPortable::readPortable(serialization::PortableReader& reader) {
                name = *reader.readUTF("name");
                k =  reader.readInt("myint");
            }

            bool TestNamedPortable::operator ==(const TestNamedPortable& m) const {
                if (this == &m)
                    return true;
                if (k != m.k)
                    return false;
                if (name.compare(m.name))
                    return false;
                return true;
            }

            bool TestNamedPortable::operator !=(const TestNamedPortable& m) const {
                return !(*this == m);
            }

        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            class PortableVersionTest : public ::testing::Test {
            protected:
                class Child : public serialization::Portable {
                public:
                    Child() {
                    }

                    Child(const std::string &name) : name (name) {
                    }

                    virtual int getFactoryId() const {
                        return 1;
                    }

                    virtual int getClassId() const {
                        return 2;
                    }

                    virtual void writePortable(serialization::PortableWriter &writer) const {
                        writer.writeUTF("name", &name);
                    }

                    virtual void readPortable(serialization::PortableReader &reader) {
                        name = *reader.readUTF("name");
                    }

                    bool operator==(const Child &rhs) const {
                        return name == rhs.name;
                    }

                private:
                    std::string name;

                };

                class Parent : public serialization::Portable {
                public:
                    Parent() {}

                    Parent(const Child &child) : child(child) {}

                    virtual int getFactoryId() const {
                        return 1;
                    }

                    virtual int getClassId() const {
                        return 1;
                    }

                    virtual void writePortable(serialization::PortableWriter &writer) const {
                        writer.writePortable<Child>("child", &child);
                    }

                    virtual void readPortable(serialization::PortableReader &reader) {
                        child = *reader.readPortable<Child>("child");
                    }

                    bool operator==(const Parent &rhs) const {
                        return child == rhs.child;
                    }

                    bool operator!=(const Parent &rhs) const {
                        return !(rhs == *this);
                    }

                private:
                    Child child;
                };

                class MyPortableFactory : public serialization::PortableFactory {
                public:
                    virtual std::unique_ptr<serialization::Portable> create(int32_t classId) const {
                        if (classId == 1) {
                            return std::unique_ptr<serialization::Portable>(new Parent());
                        } else if (classId == 2) {
                            return std::unique_ptr<serialization::Portable>(new Child());
                        }

                        return std::unique_ptr<serialization::Portable>();
                    }
                };
            };

            // Test for issue https://github.com/hazelcast/hazelcast/issues/12733
            TEST_F(PortableVersionTest, test_nestedPortable_versionedSerializer) {
                SerializationConfig serializationConfig;
                serializationConfig.addPortableFactory(1, std::shared_ptr<serialization::PortableFactory>(
                        new MyPortableFactory));
                serialization::pimpl::SerializationService ss1(serializationConfig);

                SerializationConfig serializationConfig2;
                serializationConfig2.setPortableVersion(6).addPortableFactory(1,
                                                                              std::shared_ptr<serialization::PortableFactory>(
                                                                                      new MyPortableFactory));
                serialization::pimpl::SerializationService ss2(serializationConfig2);

                //make sure ss2 cached class definition of Child
                ss2.toData<Child>(new Child("sancar"));

                //serialized parent from ss1
                Parent parent(Child("sancar"));
                serialization::pimpl::Data data = ss1.toData<Parent>(&parent);

                // cached class definition of Child and the class definition from data coming from ss1 should be compatible
                        assertEquals(parent, *ss2.toObject<Parent>(data));

            }
        }
    }
}


namespace hazelcast {
    namespace client {
        namespace test {
            TestInvalidReadPortable::TestInvalidReadPortable() {

            }

            TestInvalidReadPortable::TestInvalidReadPortable(long l, int i, std::string s) {
                this->l = l;
                this->i = i;
                this->s = s;
            }

            int TestInvalidReadPortable::getFactoryId() const {
                return TestSerializationConstants::TEST_PORTABLE_FACTORY;
            }

            int TestInvalidReadPortable::getClassId() const {
                return TestSerializationConstants::TEST_INVALID_READ_PORTABLE;
            }

            void TestInvalidReadPortable::writePortable(serialization::PortableWriter& writer) const {
                writer.writeLong("l", l);
                writer.writeInt("i", i);
                writer.writeUTF("s", &s);
            }


            void TestInvalidReadPortable::readPortable(serialization::PortableReader& reader) {
                l = reader.readLong("l");
                serialization::ObjectDataInput &in = reader.getRawDataInput();
                i = in.readInt();
                s = *reader.readUTF("s");
            }
        }
    }
}


namespace hazelcast {
    namespace client {
        namespace test {
            TestInvalidWritePortable::TestInvalidWritePortable() {

            }

            TestInvalidWritePortable::TestInvalidWritePortable(long l, int i, std::string s) {
                this->l = l;
                this->i = i;
                this->s = s;
            }

            int TestInvalidWritePortable::getFactoryId() const {
                return TestSerializationConstants::TEST_PORTABLE_FACTORY;
            }

            int TestInvalidWritePortable::getClassId() const {
                return TestSerializationConstants::TEST_INVALID_WRITE_PORTABLE;
            }

            void TestInvalidWritePortable::writePortable(serialization::PortableWriter& writer) const {
                writer.writeLong("l", l);
                serialization::ObjectDataOutput& out = writer.getRawDataOutput();
                out.writeInt(i);
                writer.writeUTF("s", &s);
            }

            void TestInvalidWritePortable::readPortable(serialization::PortableReader& reader) {
                l = reader.readLong("l");
                i = reader.readInt("i");
                s = *reader.readUTF("s");
            }
        }
    }
}


namespace hazelcast {
    namespace client {
        namespace test {
            TestInnerPortable::TestInnerPortable() {
            }

            TestInnerPortable::TestInnerPortable(const TestInnerPortable &rhs) {
                *this = rhs;
            }

            TestInnerPortable::TestInnerPortable(std::vector<byte> b,
                                                 std::vector<bool> ba,
                                                 std::vector<char> c,
                                                 std::vector<int16_t> s,
                                                 std::vector<int32_t> i,
                                                 std::vector<int64_t> l,
                                                 std::vector<float> f,
                                                 std::vector<double> d,
                                                 std::vector<TestNamedPortable> n) : ii(i), bb(b), ba(ba), cc(c), ss(s),
                                                                                     ll(l), ff(f), dd(d), nn(n) {
            }

            TestInnerPortable::~TestInnerPortable() {
            }

            TestInnerPortable &TestInnerPortable::operator=(const TestInnerPortable &rhs) {
                bb = rhs.bb;
                ba = rhs.ba;
                cc = rhs.cc;
                ss = rhs.ss;
                ii = rhs.ii;
                ll = rhs.ll;
                ff = rhs.ff;
                dd = rhs.dd;
                nn = rhs.nn;
                return (*this);
            }

            int32_t TestInnerPortable::getClassId() const {
                return TestSerializationConstants::TEST_INNER_PORTABLE;
            }

            int32_t TestInnerPortable::getFactoryId() const {
                return TestSerializationConstants::TEST_DATA_FACTORY;
            }

            bool TestInnerPortable::operator==(const TestInnerPortable &m) const {
                if (bb != m.bb) return false;
                if (ba != m.ba) return false;
                if (cc != m.cc) return false;
                if (ss != m.ss) return false;
                if (ii != m.ii) return false;
                if (ll != m.ll) return false;
                if (ff != m.ff) return false;
                if (dd != m.dd) return false;
                size_t size = nn.size();
                for (size_t i = 0; i < size; i++)
                    if (nn[i] != m.nn[i])
                        return false;
                return true;
            }

            bool TestInnerPortable::operator!=(const TestInnerPortable &m) const {
                return !(*this == m);
            }

            void TestInnerPortable::writePortable(serialization::PortableWriter &writer) const {
                writer.writeByteArray("b", &bb);
                writer.writeBooleanArray("ba", &ba);
                writer.writeCharArray("c", &cc);
                writer.writeShortArray("s", &ss);
                writer.writeIntArray("i", &ii);
                writer.writeLongArray("l", &ll);
                writer.writeFloatArray("f", &ff);
                writer.writeDoubleArray("d", &dd);
                writer.writePortableArray("nn", &nn);
            }

            void TestInnerPortable::readPortable(serialization::PortableReader &reader) {
                bb = *reader.readByteArray("b");
                ba = *reader.readBooleanArray("ba");
                cc = *reader.readCharArray("c");
                ss = *reader.readShortArray("s");
                ii = *reader.readIntArray("i");
                ll = *reader.readLongArray("l");
                ff = *reader.readFloatArray("f");
                dd = *reader.readDoubleArray("d");
                nn = reader.readPortableArray<TestNamedPortable>("nn");
            }

        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {
            TestNamedPortableV2::TestNamedPortableV2() {

            }

            TestNamedPortableV2::TestNamedPortableV2(std::string name, int v) : name(name), k(v * 10), v(v) {
            }

            int TestNamedPortableV2::getFactoryId() const {
                return TestSerializationConstants::TEST_PORTABLE_FACTORY;
            }

            int TestNamedPortableV2::getClassId() const {
                return TestSerializationConstants::TEST_NAMED_PORTABLE_2;
            }


            void TestNamedPortableV2::writePortable(serialization::PortableWriter& writer) const {
                writer.writeInt("v", v);
                writer.writeUTF("name", &name);
                writer.writeInt("myint", k);
            }


            void TestNamedPortableV2::readPortable(serialization::PortableReader& reader) {
                v = reader.readInt("v");
                name = *reader.readUTF("name");
                k = reader.readInt("myint");
            }

        }
    }
}

//
// Created by sancar koyunlu on 05/04/15.
//


namespace hazelcast {
    namespace client {
        namespace test {

            TestNamedPortableV3::TestNamedPortableV3() {
            }

            TestNamedPortableV3::TestNamedPortableV3(std::string name, short k):name(name), k(k) {
            }

            int TestNamedPortableV3::getFactoryId() const {
                return TestSerializationConstants::TEST_PORTABLE_FACTORY;
            }

            int TestNamedPortableV3::getClassId() const {
                return TestSerializationConstants::TEST_NAMED_PORTABLE_3;
            }

            void TestNamedPortableV3::writePortable(serialization::PortableWriter& writer) const {
                writer.writeUTF("name", &name);
                writer.writeShort("myint", k);
            }


            void TestNamedPortableV3::readPortable(serialization::PortableReader& reader) {
                name = *reader.readUTF("name");
                k = reader.readShort("myint");
            }

            bool TestNamedPortableV3::operator ==(const TestNamedPortableV3& m) const {
                if (this == &m)
                    return true;
                if (k != m.k)
                    return false;
                if (name.compare(m.name))
                    return false;
                return true;
            }

            bool TestNamedPortableV3::operator !=(const TestNamedPortableV3& m) const {
                return !(*this == m);
            }

        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {
            class PartitionAwareTest : public ClientTestSupport {
            protected:
                class SimplePartitionAwareObject
                        : public PartitionAware<int>, public serialization::IdentifiedDataSerializable {
                public:
                    SimplePartitionAwareObject() : testKey(5) {}

                    virtual const int *getPartitionKey() const {
                        return &testKey;
                    }

                    int getFactoryId() const {
                        return 1;
                    }

                    int getClassId() const {
                        return 2;
                    }

                    void writeData(serialization::ObjectDataOutput &writer) const {
                    }

                    void readData(serialization::ObjectDataInput &reader) {
                    }

                    int getTestKey() const {
                        return testKey;
                    }
                private:
                    int testKey;
                };
            };

            TEST_F(PartitionAwareTest, testSimplePartitionAwareObjectSerialisation) {
                SerializationConfig serializationConfig;
                serialization::pimpl::SerializationService serializationService(serializationConfig);

                SimplePartitionAwareObject obj;
                serialization::pimpl::Data data = serializationService.toData<SimplePartitionAwareObject>(&obj);
                ASSERT_TRUE(data.hasPartitionHash());

                int testKey = obj.getTestKey();
                serialization::pimpl::Data expectedData = serializationService.toData<int>(&testKey);

                ASSERT_EQ(expectedData.getPartitionHash(), data.getPartitionHash());
            }

            TEST_F(PartitionAwareTest, testNonPartitionAwareObjectSerialisation) {
                SerializationConfig serializationConfig;
                serialization::pimpl::SerializationService serializationService(serializationConfig);

                int obj = 7;
                serialization::pimpl::Data data = serializationService.toData<int>(&obj);
                ASSERT_FALSE(data.hasPartitionHash());
            }
        }
    }
}







namespace hazelcast {
    namespace client {
        namespace test {
            class JsonValueSerializationTest : public ClientTestSupport {
            public:
                JsonValueSerializationTest() : serializationService(SerializationConfig()) {}

            protected:
                serialization::pimpl::SerializationService serializationService;
            };

            TEST_F(JsonValueSerializationTest, testSerializeDeserializeJsonValue) {
                HazelcastJsonValue jsonValue("{ \"key\": \"value\" }");
                serialization::pimpl::Data jsonData = serializationService.toData(&jsonValue);
                std::unique_ptr<HazelcastJsonValue> jsonDeserialized(
                        serializationService.toObject<HazelcastJsonValue>(jsonData));
                ASSERT_EQ_PTR(jsonValue, jsonDeserialized.get(), HazelcastJsonValue);
            }
        }
    }
}

//
// Created by sancar koyunlu on 8/27/13.




namespace hazelcast {
    namespace client {
        namespace test {
            class ClientSerializationTest : public ::testing::Test {
            protected:
                class NonSerializableObject {};

                class DummyGlobalSerializer : public serialization::StreamSerializer {
                public:
                    virtual int32_t getHazelcastTypeId() const {
                        return 123;
                    }

                    virtual void write(serialization::ObjectDataOutput &out, const void *object) {
                        std::string value("Dummy string");
                        out.writeUTF(&value);
                    }

                    virtual void *read(serialization::ObjectDataInput &in) {
                        return in.readUTF().release();
                    }
                };

                template<typename T>
                T toDataAndBackToObject(serialization::pimpl::SerializationService &ss, T &value) {
                    serialization::pimpl::Data data = ss.toData<T>(&value);
                    return *(ss.toObject<T>(data));
                }

                static const unsigned int LARGE_ARRAY_SIZE;
            };

            const unsigned int ClientSerializationTest::LARGE_ARRAY_SIZE =
                    1 * 1024 * 1024;   // 1 MB. Previously it was 10 MB but then the
            // test fails when using Windows 32-bit DLL
            // library with std::bad_alloc with 10 MB

            TEST_F(ClientSerializationTest, testCustomSerialization) {
                SerializationConfig serializationConfig;
                serializationConfig.setPortableVersion(1);
                serialization::pimpl::SerializationService serializationService(serializationConfig);

                std::shared_ptr<serialization::StreamSerializer> serializer1(
                        new TestCustomSerializerX<TestCustomXSerializable>());
                std::shared_ptr<serialization::StreamSerializer> serializer2(new TestCustomPersonSerializer());

                serializationService.registerSerializer(serializer1);
                serializationService.registerSerializer(serializer2);

                TestCustomXSerializable a(131321);
                serialization::pimpl::Data data = serializationService.toData<TestCustomXSerializable>(&a);
                std::unique_ptr<TestCustomXSerializable> a2 = serializationService.toObject<TestCustomXSerializable>(
                        data);
                ASSERT_EQ(a, *a2);

                TestCustomPerson b("TestCustomPerson");
                serialization::pimpl::Data data1 = serializationService.toData<TestCustomPerson>(&b);
                std::unique_ptr<TestCustomPerson> b2 = serializationService.toObject<TestCustomPerson>(data1);
                ASSERT_EQ(b, *b2);
            }


            TEST_F(ClientSerializationTest, testRawData) {
                SerializationConfig serializationConfig;
                serializationConfig.setPortableVersion(1);
                serialization::pimpl::SerializationService serializationService(serializationConfig);
                char charA[] = "test chars";
                std::vector<char> chars(charA, charA + 10);
                std::vector<byte> bytes;
                bytes.resize(5, 0);
                TestDataSerializable ds(123, 's');
                TestNamedPortable np("named portable", 34567);
                TestRawDataPortable p(123213, chars, np, 22, "Testing raw portable", ds);

                serialization::pimpl::Data data = serializationService.toData<TestRawDataPortable>(&p);
                std::unique_ptr<TestRawDataPortable> x = serializationService.toObject<TestRawDataPortable>(data);
                ASSERT_EQ(p, *x);
            }

            TEST_F(ClientSerializationTest, testIdentifiedDataSerializable) {
                SerializationConfig serializationConfig;
                serializationConfig.setPortableVersion(1);
                serialization::pimpl::SerializationService serializationService(serializationConfig);
                serialization::pimpl::Data data;
                TestDataSerializable np(4, 'k');
                data = serializationService.toData<TestDataSerializable>(&np);

                std::unique_ptr<TestDataSerializable> tnp1;
                tnp1 = serializationService.toObject<TestDataSerializable>(data);

                ASSERT_EQ(np, *tnp1);
                int x = 4;
                data = serializationService.toData<int>(&x);
                std::unique_ptr<int> ptr = serializationService.toObject<int>(data);
                int y = *ptr;
                ASSERT_EQ(x, y);
            }

            TEST_F(ClientSerializationTest, testIdentifiedDataSerializableWithFactory) {
                SerializationConfig serializationConfig;
                serializationConfig.setPortableVersion(1);
                serializationConfig.addDataSerializableFactory(TestSerializationConstants::TEST_DATA_FACTORY,
                                                               std::shared_ptr<serialization::DataSerializableFactory>(
                                                                       new TestDataSerializableFactory()));
                serialization::pimpl::SerializationService serializationService(serializationConfig);
                serialization::pimpl::Data data;
                TestDataSerializable np(4, 'k');
                data = serializationService.toData<TestDataSerializable>(&np);

                std::unique_ptr<TestDataSerializable> tnp1;
                tnp1 = serializationService.toObject<TestDataSerializable>(data);
                ASSERT_EQ(np, *tnp1);
            }

            TEST_F(ClientSerializationTest, testPortableWithFactory) {
                SerializationConfig serializationConfig;
                serializationConfig.setPortableVersion(1);
                serializationConfig.addPortableFactory(TestSerializationConstants::TEST_PORTABLE_FACTORY,
                                                       std::shared_ptr<serialization::PortableFactory>(
                                                               new TestDataPortableFactory()));
                serialization::pimpl::SerializationService serializationService(serializationConfig);
                char charA[] = "test chars";
                std::vector<char> chars(charA, charA + 10);
                std::vector<byte> bytes;
                bytes.resize(5, 0);
                TestNamedPortable np("named portable", 34567);
                TestDataSerializable ds(123, 's');
                TestRawDataPortable p(123213, chars, np, 22, "Testing raw portable", ds);
                serialization::pimpl::Data data = serializationService.toData<TestRawDataPortable>(&p);

                std::unique_ptr<TestRawDataPortable> object = serializationService.toObject<TestRawDataPortable>(data);
                ASSERT_EQ(p, *object);
            }

            TEST_F(ClientSerializationTest, testRawDataWithoutRegistering) {
                SerializationConfig serializationConfig;
                serializationConfig.setPortableVersion(1);
                serialization::pimpl::SerializationService serializationService(serializationConfig);
                char charA[] = "test chars";
                std::vector<char> chars(charA, charA + 10);
                std::vector<byte> bytes;
                bytes.resize(5, 0);
                TestNamedPortable np("named portable", 34567);
                TestDataSerializable ds(123, 's');
                TestRawDataPortable p(123213, chars, np, 22, "Testing raw portable", ds);

                serialization::pimpl::Data data = serializationService.toData<TestRawDataPortable>(&p);
                std::unique_ptr<TestRawDataPortable> x = serializationService.toObject<TestRawDataPortable>(data);
                ASSERT_EQ(p, *x);
            }

            TEST_F(ClientSerializationTest, testInvalidWrite) {
                SerializationConfig serializationConfig;
                serializationConfig.setPortableVersion(1);
                serialization::pimpl::SerializationService serializationService(serializationConfig);
                TestInvalidWritePortable p(2131, 123, "q4edfd");
                ASSERT_THROW(serializationService.toData<TestInvalidWritePortable>(&p),
                             exception::HazelcastSerializationException);
            }

            TEST_F(ClientSerializationTest, testInvalidRead) {
                SerializationConfig serializationConfig;
                serializationConfig.setPortableVersion(1);
                serialization::pimpl::SerializationService serializationService(serializationConfig);
                TestInvalidReadPortable p(2131, 123, "q4edfd");
                serialization::pimpl::Data data = serializationService.toData<TestInvalidReadPortable>(&p);
                ASSERT_THROW(serializationService.toObject<TestInvalidReadPortable>(data),
                             exception::HazelcastSerializationException);
            }

            TEST_F(ClientSerializationTest, testDifferentVersions) {
                SerializationConfig serializationConfig;
                serializationConfig.setPortableVersion(1);
                serialization::pimpl::SerializationService serializationService(serializationConfig);

                SerializationConfig serializationConfig2;
                serializationConfig.setPortableVersion(2);
                serialization::pimpl::SerializationService serializationService2(serializationConfig2);

                TestNamedPortable p1("portable-v1", 111);
                serialization::pimpl::Data data = serializationService.toData<TestNamedPortable>(&p1);

                TestNamedPortableV2 p2("portable-v2", 123);
                serialization::pimpl::Data data2 = serializationService2.toData<TestNamedPortableV2>(&p2);

                std::unique_ptr<TestNamedPortableV2> t2 = serializationService2.toObject<TestNamedPortableV2>(data);
                ASSERT_EQ(std::string("portable-v1"), t2->name);
                ASSERT_EQ(111, t2->k);
                ASSERT_EQ(0, t2->v);

                std::unique_ptr<TestNamedPortable> t1 = serializationService.toObject<TestNamedPortable>(data2);
                ASSERT_EQ(std::string("portable-v2"), t1->name);
                ASSERT_EQ(123 * 10, t1->k);

            }

            TEST_F(ClientSerializationTest, testBasicFunctionality) {
                SerializationConfig serializationConfig;
                serializationConfig.setPortableVersion(1);
                serialization::pimpl::SerializationService serializationService(serializationConfig);
                serialization::pimpl::Data data;

                int x = 3;
                data = serializationService.toData<int>(&x);

                std::unique_ptr<int> returnedInt = serializationService.toObject<int>(data);
                ASSERT_EQ(x, *returnedInt);

                int16_t f = 2;
                data = serializationService.toData<int16_t>(&f);

                std::unique_ptr<int16_t> temp = serializationService.toObject<int16_t>(data);
                ASSERT_EQ(f, *temp);

                TestNamedPortable np("name", 5);
                data = serializationService.toData<TestNamedPortable>(&np);

                std::unique_ptr<TestNamedPortable> tnp1, tnp2;
                tnp1 = serializationService.toObject<TestNamedPortable>(data);

                tnp2 = serializationService.toObject<TestNamedPortable>(data);

                ASSERT_EQ(np, *tnp1);
                ASSERT_EQ(np, *tnp2);

                byte byteArray[] = {0, 1, 2};
                std::vector<byte> bb(byteArray, byteArray + 3);
                char charArray[] = {'c', 'h', 'a', 'r'};
                std::vector<char> cc(charArray, charArray + 4);
                bool boolArray[] = {false, true, true, false};
                std::vector<bool> ba(boolArray, boolArray + 4);
                int16_t shortArray[] = {3, 4, 5};
                std::vector<int16_t> ss(shortArray, shortArray + 3);
                int32_t integerArray[] = {9, 8, 7, 6};
                std::vector<int32_t> ii(integerArray, integerArray + 4);
                int64_t longArray[] = {0, 1, 5, 7, 9, 11};
                std::vector<int64_t> ll(longArray, longArray + 6);
                float floatArray[] = {0.6543f, -3.56f, 45.67f};
                std::vector<float> ff(floatArray, floatArray + 3);
                double doubleArray[] = {456.456, 789.789, 321.321};
                std::vector<double> dd(doubleArray, doubleArray + 3);
                TestNamedPortable portableArray[5];
                for (int i = 0; i < 5; i++) {
                    portableArray[i].name = "named-portable-" + hazelcast::util::IOUtil::to_string(i);
                    portableArray[i].k = i;
                }
                std::vector<TestNamedPortable> nn(portableArray, portableArray + 5);

                TestInnerPortable inner(bb, ba, cc, ss, ii, ll, ff, dd, nn);

                data = serializationService.toData<TestInnerPortable>(&inner);

                std::unique_ptr<TestInnerPortable> tip1, tip2;
                tip1 = serializationService.toObject<TestInnerPortable>(data);

                tip2 = serializationService.toObject<TestInnerPortable>(data);

                ASSERT_EQ(inner, *tip1);
                ASSERT_EQ(inner, *tip2);

                TestMainPortable main((byte) 113, true, 'x', -500, 56789, -50992225, 900.5678f, -897543.3678909,
                                      "this is main portable object created for testing!", inner);
                data = serializationService.toData<TestMainPortable>(&main);

                std::unique_ptr<TestMainPortable> tmp1, tmp2;
                tmp1 = serializationService.toObject<TestMainPortable>(data);

                tmp2 = serializationService.toObject<TestMainPortable>(data);
                ASSERT_EQ(main, *tmp1);
                ASSERT_EQ(main, *tmp2);
            }

            TEST_F(ClientSerializationTest, testBasicFunctionalityWithLargeData) {
                SerializationConfig serializationConfig;
                serializationConfig.setPortableVersion(1);
                serialization::pimpl::SerializationService serializationService(serializationConfig);
                serialization::pimpl::Data data;

                byte *byteArray = new byte[LARGE_ARRAY_SIZE];
                std::vector<byte> bb(byteArray, byteArray + LARGE_ARRAY_SIZE);
                bool *boolArray = new bool[LARGE_ARRAY_SIZE];
                std::vector<bool> ba(boolArray, boolArray + LARGE_ARRAY_SIZE);
                char *charArray;
                charArray = new char[LARGE_ARRAY_SIZE];
                std::vector<char> cc(charArray, charArray + LARGE_ARRAY_SIZE);
                int16_t *shortArray;
                shortArray = new int16_t[LARGE_ARRAY_SIZE];
                std::vector<int16_t> ss(shortArray, shortArray + LARGE_ARRAY_SIZE);
                int32_t *integerArray;
                integerArray = new int32_t[LARGE_ARRAY_SIZE];
                std::vector<int32_t> ii(integerArray, integerArray + LARGE_ARRAY_SIZE);
                int64_t *longArray;
                longArray = new int64_t[LARGE_ARRAY_SIZE];
                std::vector<int64_t> ll(longArray, longArray + LARGE_ARRAY_SIZE);
                float *floatArray;
                floatArray = new float[LARGE_ARRAY_SIZE];
                std::vector<float> ff(floatArray, floatArray + LARGE_ARRAY_SIZE);
                double *doubleArray;
                doubleArray = new double[LARGE_ARRAY_SIZE];
                std::vector<double> dd(doubleArray, doubleArray + LARGE_ARRAY_SIZE);

                TestNamedPortable portableArray[5];

                for (int i = 0; i < 5; i++) {
                    portableArray[i].name = "named-portable-" + hazelcast::util::IOUtil::to_string(i);
                    portableArray[i].k = i;
                }
                std::vector<TestNamedPortable> nn(portableArray, portableArray + 5);

                TestInnerPortable inner(bb, ba, cc, ss, ii, ll, ff, dd, nn);

                data = serializationService.toData<TestInnerPortable>(&inner);

                std::unique_ptr<TestInnerPortable> tip1, tip2;
                tip1 = serializationService.toObject<TestInnerPortable>(data);

                tip2 = serializationService.toObject<TestInnerPortable>(data);

                ASSERT_EQ(inner, *tip1);
                ASSERT_EQ(inner, *tip2);

            }

            TEST_F(ClientSerializationTest, testBasicFunctionalityWithDifferentVersions) {
                SerializationConfig serializationConfig;
                serializationConfig.setPortableVersion(1);
                serialization::pimpl::SerializationService serializationService(serializationConfig);

                SerializationConfig serializationConfig2;
                serializationConfig2.setPortableVersion(2);
                serialization::pimpl::SerializationService serializationService2(serializationConfig2);
                serialization::pimpl::Data data;

                int32_t x = 3;
                data = serializationService.toData<int32_t>(&x);

                std::unique_ptr<int32_t> returnedInt = serializationService.toObject<int32_t>(data);
                ASSERT_EQ(x, *returnedInt);

                int16_t f = 2;
                data = serializationService.toData<int16_t>(&f);

                std::unique_ptr<int16_t> temp = serializationService.toObject<int16_t>(data);
                ASSERT_EQ(f, *temp);

                TestNamedPortable np("name", 5);
                data = serializationService.toData<TestNamedPortable>(&np);

                std::unique_ptr<TestNamedPortable> tnp1, tnp2;
                tnp1 = serializationService.toObject<TestNamedPortable>(data);

                tnp2 = serializationService2.toObject<TestNamedPortable>(data);

                ASSERT_EQ(np, *tnp1);
                ASSERT_EQ(np, *tnp2);

                byte byteArray[] = {0, 1, 2};
                std::vector<byte> bb(byteArray, byteArray + 3);
                bool boolArray[] = {true, true, false};
                std::vector<bool> ba(boolArray, boolArray + 3);
                char charArray[] = {'c', 'h', 'a', 'r'};
                std::vector<char> cc(charArray, charArray + 4);
                int16_t shortArray[] = {3, 4, 5};
                std::vector<int16_t> ss(shortArray, shortArray + 3);
                int32_t integerArray[] = {9, 8, 7, 6};
                std::vector<int32_t> ii(integerArray, integerArray + 4);
                int64_t longArray[] = {0, 1, 5, 7, 9, 11};
                std::vector<int64_t> ll(longArray, longArray + 6);
                float floatArray[] = {0.6543f, -3.56f, 45.67f};
                std::vector<float> ff(floatArray, floatArray + 3);
                double doubleArray[] = {456.456, 789.789, 321.321};
                std::vector<double> dd(doubleArray, doubleArray + 3);
                TestNamedPortable portableArray[5];
                for (int i = 0; i < 5; i++) {
                    portableArray[i].name = "named-portable-" + hazelcast::util::IOUtil::to_string(i);
                    portableArray[i].k = i;
                }
                std::vector<TestNamedPortable> nn(portableArray, portableArray + 5);

                TestInnerPortable inner(bb, ba, cc, ss, ii, ll, ff, dd, nn);

                data = serializationService.toData<TestInnerPortable>(&inner);

                std::unique_ptr<TestInnerPortable> tip1, tip2;
                tip1 = serializationService.toObject<TestInnerPortable>(data);

                tip2 = serializationService2.toObject<TestInnerPortable>(data);

                ASSERT_EQ(inner, *tip1);
                ASSERT_EQ(inner, *tip2);

                TestMainPortable main((byte) 113, true, 'x', -500, 56789, -50992225, 900.5678f, -897543.3678909,
                                      "this is main portable object created for testing!", inner);
                data = serializationService.toData<TestMainPortable>(&main);

                std::unique_ptr<TestMainPortable> tmp1, tmp2;
                tmp1 = serializationService.toObject<TestMainPortable>(data);

                tmp2 = serializationService2.toObject<TestMainPortable>(data);
                ASSERT_EQ(main, *tmp1);
                ASSERT_EQ(main, *tmp2);
            }

            TEST_F(ClientSerializationTest, testTemplatedPortable_whenMultipleTypesAreUsed) {
                SerializationConfig serializationConfig;
                serialization::pimpl::SerializationService ss(serializationConfig);

                ParentTemplatedPortable <ChildTemplatedPortable1> portable(new ChildTemplatedPortable1("aaa", "bbb"));
                ss.toData < ParentTemplatedPortable < ChildTemplatedPortable1 > > (&portable);
                ParentTemplatedPortable <ChildTemplatedPortable2> portable2(new ChildTemplatedPortable2("ccc"));

                ASSERT_THROW(ss.toData < ParentTemplatedPortable < ChildTemplatedPortable2 > > (&portable2),
                             exception::HazelcastSerializationException);
            }

            TEST_F(ClientSerializationTest, testDataHash) {
                SerializationConfig serializationConfig;
                serialization::pimpl::SerializationService serializationService(serializationConfig);
                std::string serializable = "key1";
                serialization::pimpl::Data data = serializationService.toData<std::string>(&serializable);
                serialization::pimpl::Data data2 = serializationService.toData<std::string>(&serializable);
                ASSERT_EQ(data.getPartitionHash(), data2.getPartitionHash());

            }

            TEST_F(ClientSerializationTest, testPrimitives) {
                SerializationConfig serializationConfig;
                serialization::pimpl::SerializationService serializationService(serializationConfig);
                byte by = 2;
                bool boolean = true;
                char c = 'c';
                int16_t s = 4;
                int32_t i = 2000;
                int64_t l = 321324141;
                float f = 3.14f;
                double d = 3.14334;
                std::string str = "Hello world";
                std::string utfStr = "   ";

                ASSERT_EQ(by, toDataAndBackToObject(serializationService, by));
                ASSERT_EQ(boolean, toDataAndBackToObject(serializationService, boolean));
                ASSERT_EQ(c, toDataAndBackToObject(serializationService, c));
                ASSERT_EQ(s, toDataAndBackToObject(serializationService, s));
                ASSERT_EQ(i, toDataAndBackToObject(serializationService, i));
                ASSERT_EQ(l, toDataAndBackToObject(serializationService, l));
                ASSERT_EQ(f, toDataAndBackToObject(serializationService, f));
                ASSERT_EQ(d, toDataAndBackToObject(serializationService, d));
                ASSERT_EQ(str, toDataAndBackToObject(serializationService, str));
                ASSERT_EQ(utfStr, toDataAndBackToObject(serializationService, utfStr));
            }

            TEST_F(ClientSerializationTest, testPrimitiveArrays) {
                SerializationConfig serializationConfig;
                serialization::pimpl::SerializationService serializationService(serializationConfig);

                char charArray[] = {'c', 'h', 'a', 'r'};
                std::vector<char> cc(charArray, charArray + 4);
                bool boolArray[] = {true, false, false, true};
                byte byteArray[] = {0, 1, 2};
                std::vector<byte> bb(byteArray, byteArray + 3);
                std::vector<bool> ba(boolArray, boolArray + 4);
                int16_t shortArray[] = {3, 4, 5};
                std::vector<int16_t> ss(shortArray, shortArray + 3);
                int32_t integerArray[] = {9, 8, 7, 6};
                std::vector<int32_t> ii(integerArray, integerArray + 4);
                int64_t longArray[] = {0, 1, 5, 7, 9, 11};
                std::vector<int64_t> ll(longArray, longArray + 6);
                float floatArray[] = {0.6543f, -3.56f, 45.67f};
                std::vector<float> ff(floatArray, floatArray + 3);
                double doubleArray[] = {456.456, 789.789, 321.321};
                std::vector<double> dd(doubleArray, doubleArray + 3);
                const std::string stringArray[] = {"ali", "veli", "   "};
                std::vector<std::string> stringVector;
                for (int i = 0; i < 3; ++i) {
                    stringVector.push_back(stringArray[i]);
                }

                ASSERT_EQ(cc, toDataAndBackToObject<std::vector<char> >(serializationService, cc));
                ASSERT_EQ(ba, toDataAndBackToObject<std::vector<bool> >(serializationService, ba));
                ASSERT_EQ(bb, toDataAndBackToObject<std::vector<byte> >(serializationService, bb));
                ASSERT_EQ(ss, toDataAndBackToObject<std::vector<int16_t> >(serializationService, ss));
                ASSERT_EQ(ii, toDataAndBackToObject<std::vector<int32_t> >(serializationService, ii));
                ASSERT_EQ(ll, toDataAndBackToObject<std::vector<int64_t> >(serializationService, ll));
                ASSERT_EQ(ff, toDataAndBackToObject<std::vector<float> >(serializationService, ff));
                ASSERT_EQ(dd, toDataAndBackToObject<std::vector<double> >(serializationService, dd));
                ASSERT_EQ(stringVector, toDataAndBackToObject<std::vector<std::string> >(serializationService,
                                                                                         stringVector));
            }

            TEST_F(ClientSerializationTest, testWriteObjectWithPortable) {
                SerializationConfig serializationConfig;
                serialization::pimpl::SerializationService ss(serializationConfig);

                TestNamedPortable *namedPortable = new TestNamedPortable("name", 2);
                ObjectCarryingPortable <TestNamedPortable> objectCarryingPortable(namedPortable);
                serialization::pimpl::Data data = ss.toData < ObjectCarryingPortable < TestNamedPortable > > (
                        &objectCarryingPortable);
                std::unique_ptr<ObjectCarryingPortable < TestNamedPortable> > ptr =
                        ss.toObject < ObjectCarryingPortable < TestNamedPortable > > (
                                data);
                ASSERT_EQ(objectCarryingPortable, *ptr);
            }

            TEST_F(ClientSerializationTest, testWriteObjectWithIdentifiedDataSerializable) {
                SerializationConfig serializationConfig;
                serialization::pimpl::SerializationService ss(serializationConfig);

                TestDataSerializable *testDataSerializable = new TestDataSerializable(2, 'c');
                ObjectCarryingPortable <TestDataSerializable> objectCarryingPortable(testDataSerializable);
                serialization::pimpl::Data data = ss.toData < ObjectCarryingPortable < TestDataSerializable > > (
                        &objectCarryingPortable);
                std::unique_ptr<ObjectCarryingPortable < TestDataSerializable> > ptr =
                        ss.toObject < ObjectCarryingPortable < TestDataSerializable > > (
                                data);
                ASSERT_EQ(objectCarryingPortable, *ptr);
            }

            TEST_F(ClientSerializationTest, testWriteObjectWithCustomXSerializable) {
                SerializationConfig serializationConfig;
                serialization::pimpl::SerializationService ss(serializationConfig);
                std::shared_ptr<serialization::StreamSerializer> serializer(
                        new TestCustomSerializerX<TestCustomXSerializable>());

                ss.registerSerializer(serializer);

                TestCustomXSerializable *customXSerializable = new TestCustomXSerializable(131321);
                ObjectCarryingPortable <TestCustomXSerializable> objectCarryingPortable(customXSerializable);
                serialization::pimpl::Data data = ss.toData < ObjectCarryingPortable < TestCustomXSerializable > > (
                        &objectCarryingPortable);
                std::unique_ptr<ObjectCarryingPortable < TestCustomXSerializable> > ptr =
                        ss.toObject < ObjectCarryingPortable < TestCustomXSerializable > > (
                                data);
                ASSERT_EQ(objectCarryingPortable, *ptr);
            }

            TEST_F(ClientSerializationTest, testWriteObjectWithCustomPersonSerializable) {
                SerializationConfig serializationConfig;
                serialization::pimpl::SerializationService ss(serializationConfig);
                std::shared_ptr<serialization::StreamSerializer> serializer(new TestCustomPersonSerializer());

                ss.registerSerializer(serializer);

                TestCustomPerson *testCustomPerson = new TestCustomPerson("TestCustomPerson");

                ObjectCarryingPortable <TestCustomPerson> objectCarryingPortable(testCustomPerson);
                serialization::pimpl::Data data = ss.toData < ObjectCarryingPortable < TestCustomPerson > > (
                        &objectCarryingPortable);
                std::unique_ptr<ObjectCarryingPortable < TestCustomPerson> > ptr =
                        ss.toObject < ObjectCarryingPortable < TestCustomPerson > > (
                                data);
                ASSERT_EQ(objectCarryingPortable, *ptr);
            }


            TEST_F(ClientSerializationTest, testNullData) {
                serialization::pimpl::Data data;
                SerializationConfig serializationConfig;
                serialization::pimpl::SerializationService ss(serializationConfig);
                std::unique_ptr<int32_t> ptr = ss.toObject<int32_t>(data);
                ASSERT_EQ(ptr.get(), (int32_t *) NULL);
            }

            TEST_F(ClientSerializationTest, testMorphingWithDifferentTypes_differentVersions) {
                SerializationConfig serializationConfig;
                serializationConfig.setPortableVersion(1);
                serialization::pimpl::SerializationService serializationService(serializationConfig);

                SerializationConfig serializationConfig2;
                serializationConfig.setPortableVersion(2);
                serialization::pimpl::SerializationService serializationService2(serializationConfig2);

                TestNamedPortableV3 p2("portable-v2", 123);
                serialization::pimpl::Data data2 = serializationService2.toData<TestNamedPortableV3>(&p2);

                std::unique_ptr<TestNamedPortable> t1 = serializationService.toObject<TestNamedPortable>(data2);
                ASSERT_EQ(std::string("portable-v2"), t1->name);
                ASSERT_EQ(123, t1->k);
            }

            TEST_F(ClientSerializationTest, ObjectDataInputOutput) {
                SerializationConfig serializationConfig;
                serializationConfig.setPortableVersion(1);
                serialization::pimpl::SerializationService serializationService(serializationConfig);

                serialization::pimpl::DataOutput dataOutput;
                serialization::ObjectDataOutput out(dataOutput, &serializationService.getSerializerHolder());

                byte by = 2;
                bool boolean = true;
                char c = 'c';
                int16_t s = 4;
                int32_t i = 2000;
                int64_t l = 321324141;
                float f = 3.14f;
                double d = 3.14334;
                std::string str = "Hello world";
                std::string utfStr = "   ";

                byte byteArray[] = {50, 100, 150, 200};
                std::vector<byte> byteVec(byteArray, byteArray + 4);
                char charArray[] = {'c', 'h', 'a', 'r'};
                std::vector<char> cc(charArray, charArray + 4);
                bool boolArray[] = {true, false, false, true};
                std::vector<bool> ba(boolArray, boolArray + 4);
                int16_t shortArray[] = {3, 4, 5};
                std::vector<int16_t> ss(shortArray, shortArray + 3);
                int32_t integerArray[] = {9, 8, 7, 6};
                std::vector<int32_t> ii(integerArray, integerArray + 4);
                int64_t longArray[] = {0, 1, 5, 7, 9, 11};
                std::vector<int64_t> ll(longArray, longArray + 6);
                float floatArray[] = {0.6543f, -3.56f, 45.67f};
                std::vector<float> ff(floatArray, floatArray + 3);
                double doubleArray[] = {456.456, 789.789, 321.321};
                std::vector<double> dd(doubleArray, doubleArray + 3);
                const std::string stringArray[] = {"ali", "veli", "   "};
                std::vector<std::string *> stringVector;
                for (int i = 0; i < 3; ++i) {
                    stringVector.push_back(new std::string(stringArray[i]));
                }

                out.writeByte(by);
                out.writeChar(c);
                out.writeBoolean(boolean);
                out.writeShort(s);
                out.writeInt(i);
                out.writeLong(l);
                out.writeFloat(f);
                out.writeDouble(d);
                out.writeUTF(&str);
                out.writeUTF(&utfStr);

                out.writeByteArray(&byteVec);
                out.writeCharArray(&cc);
                out.writeBooleanArray(&ba);
                out.writeShortArray(&ss);
                out.writeIntArray(&ii);
                out.writeFloatArray(&ff);
                out.writeDoubleArray(&dd);
                out.writeUTFArray(&stringVector);

                out.writeObject<byte>(&by);
                out.writeObject<char>(&c);
                out.writeObject<bool>(&boolean);
                out.writeObject<int16_t>(&s);
                out.writeObject<int32_t>(&i);
                out.writeObject<float>(&f);
                out.writeObject<double>(&d);
                out.writeObject<std::string>(&str);
                out.writeObject<std::string>(&utfStr);
                out.writeInt(5);
                out.writeUTF(NULL);
                out.writeUTFArray(NULL);

                std::unique_ptr<std::vector<byte> > buffer = dataOutput.toByteArray();
                serialization::pimpl::DataInput dataInput(*buffer);
                serialization::ObjectDataInput in(dataInput, serializationService.getSerializerHolder());

                ASSERT_EQ(by, in.readByte());
                ASSERT_EQ(c, in.readChar());
                ASSERT_EQ(boolean, in.readBoolean());
                ASSERT_EQ(s, in.readShort());
                ASSERT_EQ(i, in.readInt());
                ASSERT_EQ(l, in.readLong());
                ASSERT_FLOAT_EQ(f, in.readFloat());
                ASSERT_DOUBLE_EQ(d, in.readDouble());
                ASSERT_EQ(str, *in.readUTF());
                ASSERT_EQ(utfStr, *in.readUTF());

                ASSERT_EQ(byteVec, *in.readByteArray());
                ASSERT_EQ(cc, *in.readCharArray());
                ASSERT_EQ(ba, *in.readBooleanArray());
                ASSERT_EQ(ss, *in.readShortArray());
                ASSERT_EQ(ii, *in.readIntArray());
                ASSERT_EQ(ff, *in.readFloatArray());
                ASSERT_EQ(dd, *in.readDoubleArray());
                std::unique_ptr<std::vector<std::string> > strArrRead = in.readUTFArray();
                ASSERT_NE((std::vector<std::string> *) NULL, strArrRead.get());
                ASSERT_EQ(stringVector.size(), strArrRead->size());
                for (size_t j = 0; j < stringVector.size(); ++j) {
                    ASSERT_EQ((*strArrRead)[j], *(stringVector[j]));
                }

                ASSERT_EQ(by, *in.readObject<byte>());
                ASSERT_EQ(c, *in.readObject<char>());
                ASSERT_EQ(boolean, *in.readObject<bool>());
                ASSERT_EQ(s, *in.readObject<int16_t>());
                ASSERT_EQ(i, *in.readObject<int32_t>());
                ASSERT_EQ(f, *in.readObject<float>());
                ASSERT_EQ(d, *in.readObject<double>());
                ASSERT_EQ(str, *in.readObject<std::string>());
                ASSERT_EQ(utfStr, *in.readObject<std::string>());
                ASSERT_EQ(4, in.skipBytes(4));
                ASSERT_NULL("Expected null string", in.readUTF().get(), std::string);
                ASSERT_NULL("Expected null string array", in.readUTFArray().get(), std::vector<std::string>);
            }

            TEST_F(ClientSerializationTest, testGetUTF8CharCount) {
                std::string utfStr = "xyz123";

                SerializationConfig serializationConfig;
                serializationConfig.setPortableVersion(1);
                serialization::pimpl::SerializationService serializationService(serializationConfig);

                serialization::pimpl::DataOutput dataOutput;
                serialization::ObjectDataOutput out(dataOutput, &serializationService.getSerializerHolder());

                out.writeUTF(&utfStr);
                std::unique_ptr<std::vector<byte> > byteArray = out.toByteArray();
                int strLen = hazelcast::util::Bits::readIntB(*byteArray, 0);
                ASSERT_EQ(7, strLen);
            }

            TEST_F(ClientSerializationTest, testExtendedAscii) {
                std::string utfStr = "Num\xc3\xa9ro";

                SerializationConfig serializationConfig;
                serialization::pimpl::SerializationService serializationService(serializationConfig);

                serialization::pimpl::Data data = serializationService.toData<std::string>(&utfStr);
                std::unique_ptr<std::string> deserializedString = serializationService.toObject<std::string>(data);
                ASSERT_EQ_PTR(utfStr, deserializedString.get(), std::string);
            }

            TEST_F(ClientSerializationTest, testExtendedAsciiIncorrectUtf8Write) {
                std::string utfStr = "Num\351ro";

                SerializationConfig serializationConfig;
                serialization::pimpl::SerializationService serializationService(serializationConfig);

                ASSERT_THROW(serializationService.toData<std::string>(&utfStr), exception::UTFDataFormatException);
            }

            TEST_F(ClientSerializationTest, testGlobalSerializer) {
                SerializationConfig serializationConfig;

                serializationConfig.setGlobalSerializer(
                        std::shared_ptr<serialization::StreamSerializer>(new DummyGlobalSerializer()));
                serialization::pimpl::SerializationService serializationService(serializationConfig);

                NonSerializableObject obj;

                serialization::pimpl::Data data = serializationService.toData<NonSerializableObject>(&obj);

                std::unique_ptr<std::string> deserializedValue = serializationService.toObject<std::string>(data);
                ASSERT_NE((std::string *) NULL, deserializedValue.get());
                ASSERT_EQ("Dummy string", *deserializedValue);
            }
        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {
            TestDataSerializable::TestDataSerializable() {

            }

            TestDataSerializable::TestDataSerializable(int i, char c):i(i), c(c) {

            }

            bool TestDataSerializable::operator ==(const TestDataSerializable & rhs) const {
                if (this == &rhs)
                    return true;
                if (i != rhs.i) return false;
                if (c != rhs.c) return false;
                return true;
            }

            bool TestDataSerializable::operator !=(const TestDataSerializable& m) const {
                return !(*this == m);
            }

            int TestDataSerializable::getFactoryId() const {
                return TestSerializationConstants::TEST_DATA_FACTORY;
            }

            int TestDataSerializable::getClassId() const {
                return TestSerializationConstants::TEST_DATA_SERIALIZABLE;
            }

            void TestDataSerializable::writeData(serialization::ObjectDataOutput& writer) const {
                writer.writeChar(c);
                writer.writeInt(i);
            }

            void TestDataSerializable::readData(serialization::ObjectDataInput &reader) {
                c = reader.readChar();
                i = reader.readInt();
            }

            std::unique_ptr<serialization::IdentifiedDataSerializable>
            TestDataSerializableFactory::create(int32_t classId) {
                switch (classId) {
                    case TestSerializationConstants::TEST_DATA_SERIALIZABLE:
                        return std::unique_ptr<serialization::IdentifiedDataSerializable>(new TestDataSerializable());
                    default:
                        return std::unique_ptr<serialization::IdentifiedDataSerializable>();
                }
            }
        }
    }
}




//
// Created by hsan Demir on Jan 10 2017.
//



namespace hazelcast {
    namespace client {
        namespace test {
            namespace internal {
                namespace nearcache {
                    class NearCacheRecordStoreTest
                            : public ClientTestSupport, public ::testing::WithParamInterface<config::InMemoryFormat> {
                    public:
                        NearCacheRecordStoreTest() {
                            ss = std::unique_ptr<serialization::pimpl::SerializationService>(
                                    new serialization::pimpl::SerializationService(serializationConfig));
                        }

                    protected:
                        static const int DEFAULT_RECORD_COUNT;
                        static const char *DEFAULT_NEAR_CACHE_NAME;

                        void putAndGetRecord(config::InMemoryFormat inMemoryFormat) {
                            config::NearCacheConfig<int, std::string> nearCacheConfig = createNearCacheConfig<int, std::string>(
                                    DEFAULT_NEAR_CACHE_NAME, inMemoryFormat);
                            std::unique_ptr<hazelcast::client::internal::nearcache::impl::NearCacheRecordStore<serialization::pimpl::Data, std::string> >
                                    nearCacheRecordStore = createNearCacheRecordStore<int, std::string, serialization::pimpl::Data>(
                                    nearCacheConfig,
                                    inMemoryFormat);

                            for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                                nearCacheRecordStore->put(getSharedKey(i), getSharedValue(i));
                            }

                            ASSERT_EQ(DEFAULT_RECORD_COUNT, nearCacheRecordStore->size());

                            for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                                std::shared_ptr<std::string> value = nearCacheRecordStore->get(getSharedKey(i));
                                ASSERT_NOTNULL(value.get(), std::string);
                                ASSERT_EQ(*getSharedValue(i), *value);
                            }
                        }

                        void putAndRemoveRecord(config::InMemoryFormat inMemoryFormat) {
                            config::NearCacheConfig<int, std::string> nearCacheConfig = createNearCacheConfig<int, std::string>(
                                    DEFAULT_NEAR_CACHE_NAME, inMemoryFormat);
                            std::unique_ptr<hazelcast::client::internal::nearcache::impl::NearCacheRecordStore<serialization::pimpl::Data, std::string> >
                                    nearCacheRecordStore = createNearCacheRecordStore<int, std::string, serialization::pimpl::Data>(
                                    nearCacheConfig,
                                    inMemoryFormat);

                            for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                                std::shared_ptr<serialization::pimpl::Data> key = getSharedKey(i);
                                nearCacheRecordStore->put(key, getSharedValue(i));

                                // ensure that they are stored
                                ASSERT_NOTNULL(nearCacheRecordStore->get(key).get(), std::string);
                            }

                            ASSERT_EQ(DEFAULT_RECORD_COUNT, nearCacheRecordStore->size());

                            for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                                std::shared_ptr<serialization::pimpl::Data> key = getSharedKey(i);
                                ASSERT_TRUE(nearCacheRecordStore->invalidate(key));
                                ASSERT_NULL("Should not exist", nearCacheRecordStore->get(key).get(), std::string);
                            }

                            ASSERT_EQ(0, nearCacheRecordStore->size());
                        }

                        void clearRecordsOrDestroyStore(config::InMemoryFormat inMemoryFormat, bool destroy) {
                            config::NearCacheConfig<int, std::string> nearCacheConfig = createNearCacheConfig<int, std::string>(
                                    DEFAULT_NEAR_CACHE_NAME, inMemoryFormat);
                            std::unique_ptr<hazelcast::client::internal::nearcache::impl::NearCacheRecordStore<serialization::pimpl::Data, std::string> >
                                    nearCacheRecordStore = createNearCacheRecordStore<int, std::string, serialization::pimpl::Data>(
                                    nearCacheConfig,
                                    inMemoryFormat);

                            for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                                std::shared_ptr<serialization::pimpl::Data> key = getSharedKey(i);
                                nearCacheRecordStore->put(key, getSharedValue(i));

                                // ensure that they are stored
                                ASSERT_NOTNULL(nearCacheRecordStore->get(key).get(), std::string);
                            }

                            if (destroy) {
                                nearCacheRecordStore->destroy();
                            } else {
                                nearCacheRecordStore->clear();
                            }

                            ASSERT_EQ(0, nearCacheRecordStore->size());
                        }

                        void statsCalculated(config::InMemoryFormat inMemoryFormat) {
                            int64_t creationStartTime = hazelcast::util::currentTimeMillis();
                            config::NearCacheConfig<int, std::string> nearCacheConfig = createNearCacheConfig<int, std::string>(
                                    DEFAULT_NEAR_CACHE_NAME, inMemoryFormat);
                            std::unique_ptr<hazelcast::client::internal::nearcache::impl::NearCacheRecordStore<serialization::pimpl::Data, std::string> >
                                    nearCacheRecordStore = createNearCacheRecordStore<int, std::string, serialization::pimpl::Data>(
                                    nearCacheConfig,
                                    inMemoryFormat);
                            int64_t creationEndTime = hazelcast::util::currentTimeMillis();

                            int64_t expectedEntryCount = 0;
                            int64_t expectedHits = 0;
                            int64_t expectedMisses = 0;

                            for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                                nearCacheRecordStore->put(getSharedKey(i), getSharedValue(i));

                                expectedEntryCount++;
                            }

                            for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                                int selectedKey = i * 3;
                                if (nearCacheRecordStore->get(getSharedKey(selectedKey)) != NULL) {
                                    expectedHits++;
                                } else {
                                    expectedMisses++;
                                }
                            }

                            monitor::NearCacheStats &nearCacheStats = nearCacheRecordStore->getNearCacheStats();

                            int64_t memoryCostWhenFull = nearCacheStats.getOwnedEntryMemoryCost();
                            ASSERT_TRUE(nearCacheStats.getCreationTime() >= creationStartTime);
                            ASSERT_TRUE(nearCacheStats.getCreationTime() <= creationEndTime);
                            ASSERT_EQ(expectedHits, nearCacheStats.getHits());
                            ASSERT_EQ(expectedMisses, nearCacheStats.getMisses());
                            ASSERT_EQ(expectedEntryCount, nearCacheStats.getOwnedEntryCount());
                            switch (inMemoryFormat) {
                                case config::BINARY:
                                    ASSERT_TRUE(memoryCostWhenFull > 0);
                                    break;
                                case config::OBJECT:
                                    ASSERT_EQ(0, memoryCostWhenFull);
                            }

                            for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                                int selectedKey = i * 3;
                                if (nearCacheRecordStore->invalidate(getSharedKey(selectedKey))) {
                                    expectedEntryCount--;
                                }
                            }

                            ASSERT_EQ(expectedEntryCount, nearCacheStats.getOwnedEntryCount());
                            switch (inMemoryFormat) {
                                case config::BINARY:
                                    ASSERT_TRUE(nearCacheStats.getOwnedEntryMemoryCost() > 0);
                                    ASSERT_TRUE(nearCacheStats.getOwnedEntryMemoryCost() < memoryCostWhenFull);
                                    break;
                                case config::OBJECT:
                                    ASSERT_EQ(0, nearCacheStats.getOwnedEntryMemoryCost());
                                    break;
                            }

                            nearCacheRecordStore->clear();

                            switch (inMemoryFormat) {
                                case config::BINARY:
                                case config::OBJECT:
                                    ASSERT_EQ(0, nearCacheStats.getOwnedEntryMemoryCost());
                                    break;
                            }
                        }

                        void ttlEvaluated(config::InMemoryFormat inMemoryFormat) {
                            int ttlSeconds = 3;

                            config::NearCacheConfig<int, std::string> nearCacheConfig = createNearCacheConfig<int, std::string>(
                                    DEFAULT_NEAR_CACHE_NAME, inMemoryFormat);
                            nearCacheConfig.setTimeToLiveSeconds(ttlSeconds);

                            std::unique_ptr<hazelcast::client::internal::nearcache::impl::NearCacheRecordStore<serialization::pimpl::Data, std::string> >
                                    nearCacheRecordStore = createNearCacheRecordStore<int, std::string, serialization::pimpl::Data>(
                                    nearCacheConfig,
                                    inMemoryFormat);

                            for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                                nearCacheRecordStore->put(getSharedKey(i), getSharedValue(i));
                            }

                            for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                                ASSERT_NOTNULL(nearCacheRecordStore->get(getSharedKey(i)).get(), std::string);
                            }

                            hazelcast::util::sleep(ttlSeconds + 1);

                            for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                                ASSERT_NULL("", nearCacheRecordStore->get(getSharedKey(i)).get(), std::string);
                            }
                        }

                        void maxIdleTimeEvaluatedSuccessfully(config::InMemoryFormat inMemoryFormat) {
                            int maxIdleSeconds = 3;

                            config::NearCacheConfig<int, std::string> nearCacheConfig = createNearCacheConfig<int, std::string>(
                                    DEFAULT_NEAR_CACHE_NAME, inMemoryFormat);
                            nearCacheConfig.setMaxIdleSeconds(maxIdleSeconds);

                            std::unique_ptr<hazelcast::client::internal::nearcache::impl::NearCacheRecordStore<serialization::pimpl::Data, std::string> >
                                    nearCacheRecordStore = createNearCacheRecordStore<int, std::string, serialization::pimpl::Data>(
                                    nearCacheConfig,
                                    inMemoryFormat);

                            for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                                nearCacheRecordStore->put(getSharedKey(i), getSharedValue(i));
                            }

                            for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                                ASSERT_NOTNULL(nearCacheRecordStore->get(getSharedKey(i)).get(), std::string);
                            }

                            hazelcast::util::sleep(maxIdleSeconds + 1);

                            for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                                ASSERT_NULL("", nearCacheRecordStore->get(getSharedKey(i)).get(), std::string);
                            }
                        }

                        void expiredRecordsCleanedUpSuccessfully(config::InMemoryFormat inMemoryFormat,
                                                                 bool useIdleTime) {
                            int cleanUpThresholdSeconds = 3;

                            config::NearCacheConfig<int, std::string> nearCacheConfig = createNearCacheConfig<int, std::string>(
                                    DEFAULT_NEAR_CACHE_NAME, inMemoryFormat);
                            if (useIdleTime) {
                                nearCacheConfig.setMaxIdleSeconds(cleanUpThresholdSeconds);
                            } else {
                                nearCacheConfig.setTimeToLiveSeconds(cleanUpThresholdSeconds);
                            }

                            std::unique_ptr<hazelcast::client::internal::nearcache::impl::NearCacheRecordStore<serialization::pimpl::Data, std::string> >
                                    nearCacheRecordStore = createNearCacheRecordStore<int, std::string, serialization::pimpl::Data>(
                                    nearCacheConfig,
                                    inMemoryFormat);

                            for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                                nearCacheRecordStore->put(getSharedKey(i), getSharedValue(i));
                            }

                            hazelcast::util::sleep(cleanUpThresholdSeconds + 1);

                            nearCacheRecordStore->doExpiration();

                            ASSERT_EQ(0, nearCacheRecordStore->size());

                            monitor::NearCacheStats &nearCacheStats = nearCacheRecordStore->getNearCacheStats();
                            ASSERT_EQ(0, nearCacheStats.getOwnedEntryCount());
                            ASSERT_EQ(0, nearCacheStats.getOwnedEntryMemoryCost());
                        }

                        void createNearCacheWithMaxSizePolicy(config::InMemoryFormat inMemoryFormat,
                                                              config::EvictionConfig<int, std::string>::MaxSizePolicy maxSizePolicy,
                                                              int32_t size) {
                            config::NearCacheConfig<int, std::string> nearCacheConfig = createNearCacheConfig<int, std::string>(
                                    DEFAULT_NEAR_CACHE_NAME, inMemoryFormat);
                            std::shared_ptr<config::EvictionConfig<int, std::string> > evictionConfig(
                                    new config::EvictionConfig<int, std::string>());
                            evictionConfig->setMaximumSizePolicy(maxSizePolicy);
                            evictionConfig->setSize(size);
                            nearCacheConfig.setEvictionConfig(evictionConfig);

                            std::unique_ptr<hazelcast::client::internal::nearcache::impl::NearCacheRecordStore<serialization::pimpl::Data, std::string> >
                                    nearCacheRecordStore = createNearCacheRecordStore<int, std::string, serialization::pimpl::Data>(
                                    nearCacheConfig,
                                    inMemoryFormat);
                        }

                        void doEvictionWithEntryCountMaxSizePolicy(config::InMemoryFormat inMemoryFormat,
                                                                   config::EvictionPolicy evictionPolicy) {
                            int32_t maxSize = DEFAULT_RECORD_COUNT / 2;

                            config::NearCacheConfig<int, std::string> nearCacheConfig = createNearCacheConfig<int, std::string>(
                                    DEFAULT_NEAR_CACHE_NAME, inMemoryFormat);


                            std::shared_ptr<config::EvictionConfig<int, std::string> > evictionConfig(
                                    new config::EvictionConfig<int, std::string>());

                            evictionConfig->setMaximumSizePolicy(config::EvictionConfig<int, std::string>::ENTRY_COUNT);
                            evictionConfig->setSize(maxSize);
                            evictionConfig->setEvictionPolicy(evictionPolicy);
                            nearCacheConfig.setEvictionConfig(evictionConfig);

                            std::unique_ptr<hazelcast::client::internal::nearcache::impl::NearCacheRecordStore<serialization::pimpl::Data, std::string> >
                                    nearCacheRecordStore = createNearCacheRecordStore<int, std::string, serialization::pimpl::Data>(
                                    nearCacheConfig,
                                    inMemoryFormat);

                            for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                                nearCacheRecordStore->put(getSharedKey(i), getSharedValue(i));
                                nearCacheRecordStore->doEvictionIfRequired();
                                ASSERT_TRUE(maxSize >= nearCacheRecordStore->size());
                            }
                        }

                        template<typename K, typename V, typename KS>
                        std::unique_ptr<hazelcast::client::internal::nearcache::impl::NearCacheRecordStore<KS, V> > createNearCacheRecordStore(
                                config::NearCacheConfig<K, V> &nearCacheConfig,
                                config::InMemoryFormat inMemoryFormat) {
                            std::unique_ptr<hazelcast::client::internal::nearcache::impl::NearCacheRecordStore<KS, V> > recordStore;
                            switch (inMemoryFormat) {
                                case config::BINARY:
                                    recordStore = std::unique_ptr<hazelcast::client::internal::nearcache::impl::NearCacheRecordStore<KS, V> >(
                                            new hazelcast::client::internal::nearcache::impl::store::NearCacheDataRecordStore<K, V, KS>(
                                                    DEFAULT_NEAR_CACHE_NAME, nearCacheConfig, *ss));
                                    break;
                                case config::OBJECT:
                                    recordStore = std::unique_ptr<hazelcast::client::internal::nearcache::impl::NearCacheRecordStore<KS, V> >(
                                            new hazelcast::client::internal::nearcache::impl::store::NearCacheObjectRecordStore<K, V, KS>(
                                                    DEFAULT_NEAR_CACHE_NAME,
                                                    nearCacheConfig, *ss));
                                    break;
                                default:
                                    std::ostringstream out;
                                    out << "Unsupported in-memory format: " << inMemoryFormat;
                                    throw exception::IllegalArgumentException("NearCacheRecordStoreTest", out.str());
                            }
                            recordStore->initialize();

                            return recordStore;
                        }

                        template<typename K, typename V>
                        config::NearCacheConfig<K, V> createNearCacheConfig(const char *name,
                                                                            config::InMemoryFormat inMemoryFormat) {
                            config::NearCacheConfig<K, V> config;
                            config.setName(name).setInMemoryFormat(inMemoryFormat);
                            return config;
                        }

                        std::shared_ptr<std::string> getSharedValue(int value) const {
                            char buf[30];
                            hazelcast::util::hz_snprintf(buf, 30, "Record-%ld", value);
                            return std::shared_ptr<std::string>(new std::string(buf));
                        }

                        std::shared_ptr<serialization::pimpl::Data> getSharedKey(int value) {
                            return ss->toSharedData<int>(&value);
                        }

                        std::unique_ptr<serialization::pimpl::SerializationService> ss;
                        SerializationConfig serializationConfig;
                    };

                    const int NearCacheRecordStoreTest::DEFAULT_RECORD_COUNT = 100;
                    const char *NearCacheRecordStoreTest::DEFAULT_NEAR_CACHE_NAME = "TestNearCache";

                    TEST_P(NearCacheRecordStoreTest, putAndGetRecord) {
                        putAndGetRecord(GetParam());
                    }

                    TEST_P(NearCacheRecordStoreTest, putAndRemoveRecord) {
                        putAndRemoveRecord(GetParam());
                    }

                    TEST_P(NearCacheRecordStoreTest, clearRecords) {
                        clearRecordsOrDestroyStore(GetParam(), false);
                    }

                    TEST_P(NearCacheRecordStoreTest, destroyStore) {
                        clearRecordsOrDestroyStore(GetParam(), true);
                    }

                    TEST_P(NearCacheRecordStoreTest, statsCalculated) {
                        statsCalculated(GetParam());
                    }

                    TEST_P(NearCacheRecordStoreTest, ttlEvaluated) {
                        ttlEvaluated(GetParam());
                    }

                    TEST_P(NearCacheRecordStoreTest, maxIdleTimeEvaluatedSuccessfully) {
                        maxIdleTimeEvaluatedSuccessfully(GetParam());
                    }

                    TEST_P(NearCacheRecordStoreTest, expiredRecordsCleanedUpSuccessfullyBecauseOfTTL) {
                        expiredRecordsCleanedUpSuccessfully(GetParam(), false);
                    }

                    TEST_P(NearCacheRecordStoreTest, expiredRecordsCleanedUpSuccessfullyBecauseOfIdleTime) {
                        expiredRecordsCleanedUpSuccessfully(GetParam(), true);
                    }

                    TEST_P(NearCacheRecordStoreTest, canCreateWithEntryCountMaxSizePolicy) {
                        createNearCacheWithMaxSizePolicy(GetParam(),
                                                         config::EvictionConfig<int, std::string>::ENTRY_COUNT,
                                                         1000);
                    }

                    TEST_P(NearCacheRecordStoreTest,
                           evictionTriggeredAndHandledSuccessfullyWithEntryCountMaxSizePolicyAndLRUEvictionPolicy) {
                        doEvictionWithEntryCountMaxSizePolicy(GetParam(), config::LRU);
                    }

                    TEST_P(NearCacheRecordStoreTest,
                           evictionTriggeredAndHandledSuccessfullyWithEntryCountMaxSizePolicyAndLFUEvictionPolicy) {
                        doEvictionWithEntryCountMaxSizePolicy(GetParam(), config::LFU);
                    }

                    TEST_P(NearCacheRecordStoreTest,
                           evictionTriggeredAndHandledSuccessfullyWithEntryCountMaxSizePolicyAndRandomEvictionPolicy) {
                        doEvictionWithEntryCountMaxSizePolicy(GetParam(), config::RANDOM);
                    }

                    INSTANTIATE_TEST_SUITE_P(BasicStoreTest, NearCacheRecordStoreTest,
                                             ::testing::Values(config::BINARY, config::OBJECT));

                }
            }
        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {
            class ClientLockTest : public ClientTestSupport {
            protected:
                virtual void TearDown() {
                    // clear
                    l->forceUnlock();
                }

                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    client = new HazelcastClient(getConfig());
                    l = new ILock(client->getILock("MyLock"));
                }

                static void TearDownTestCase() {
                    delete l;
                    delete client;
                    delete instance;

                    l = NULL;
                    client = NULL;
                    instance = NULL;
                }

                static HazelcastServer *instance;
                static HazelcastClient *client;
                static ILock *l;
            };

            HazelcastServer *ClientLockTest::instance = NULL;
            HazelcastClient *ClientLockTest::client = NULL;
            ILock *ClientLockTest::l = NULL;

            void testLockLockThread(hazelcast::util::ThreadArgs &args) {
                ILock *l = (ILock *) args.arg0;
                hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg1;
                if (!l->tryLock())
                    latch->countDown();
            }

            TEST_F(ClientLockTest, testLock) {
                l->lock();
                hazelcast::util::CountDownLatch latch(1);
                hazelcast::util::StartedThread t(testLockLockThread, l, &latch);

                ASSERT_TRUE(latch.await(5));
                l->forceUnlock();
            }

            void testLockTtlThread(hazelcast::util::ThreadArgs &args) {
                ILock *l = (ILock *) args.arg0;
                hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg1;
                if (!l->tryLock()) {
                    latch->countDown();
                }
                if (l->tryLock(5 * 1000)) {
                    latch->countDown();
                }
            }

            TEST_F(ClientLockTest, testLockTtl) {
                l->lock(3 * 1000);
                hazelcast::util::CountDownLatch latch(2);
                hazelcast::util::StartedThread t(testLockTtlThread, l, &latch);
                ASSERT_TRUE(latch.await(10));
                l->forceUnlock();
            }

            void testLockTryLockThread1(hazelcast::util::ThreadArgs &args) {
                ILock *l = (ILock *) args.arg0;
                hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg1;
                if (!l->tryLock(2 * 1000)) {
                    latch->countDown();
                }
            }

            void testLockTryLockThread2(hazelcast::util::ThreadArgs &args) {
                ILock *l = (ILock *) args.arg0;
                hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg1;
                if (l->tryLock(20 * 1000)) {
                    latch->countDown();
                }
            }

            TEST_F(ClientLockTest, testTryLock) {

                ASSERT_TRUE(l->tryLock(2 * 1000));
                hazelcast::util::CountDownLatch latch(1);
                hazelcast::util::StartedThread t1(testLockTryLockThread1, l, &latch);
                ASSERT_TRUE(latch.await(100));

                ASSERT_TRUE(l->isLocked());

                hazelcast::util::CountDownLatch latch2(1);
                hazelcast::util::StartedThread t2(testLockTryLockThread2, l, &latch2);
                hazelcast::util::sleep(1);
                l->unlock();
                ASSERT_TRUE(latch2.await(100));
                ASSERT_TRUE(l->isLocked());
                l->forceUnlock();
            }

            void testLockForceUnlockThread(hazelcast::util::ThreadArgs &args) {
                ILock *l = (ILock *) args.arg0;
                hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg1;
                l->forceUnlock();
                latch->countDown();
            }

            TEST_F(ClientLockTest, testForceUnlock) {
                l->lock();
                hazelcast::util::CountDownLatch latch(1);
                hazelcast::util::StartedThread t(testLockForceUnlockThread, l, &latch);
                ASSERT_TRUE(latch.await(100));
                ASSERT_FALSE(l->isLocked());
            }

            void testStatsThread(hazelcast::util::ThreadArgs &args) {
                ILock *l = (ILock *) args.arg0;
                hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg1;
                ASSERT_TRUE(l->isLocked());
                ASSERT_FALSE(l->isLockedByCurrentThread());
                ASSERT_EQ(1, l->getLockCount());
                ASSERT_TRUE(l->getRemainingLeaseTime() > 1000 * 30);
                latch->countDown();
            }

            TEST_F(ClientLockTest, testStats) {
                l->lock();
                ASSERT_TRUE(l->isLocked());
                ASSERT_TRUE(l->isLockedByCurrentThread());
                ASSERT_EQ(1, l->getLockCount());

                l->unlock();
                ASSERT_FALSE(l->isLocked());
                ASSERT_EQ(0, l->getLockCount());
                ASSERT_EQ(-1L, l->getRemainingLeaseTime());

                l->lock(1 * 1000 * 60);
                ASSERT_TRUE(l->isLocked());
                ASSERT_TRUE(l->isLockedByCurrentThread());
                ASSERT_EQ(1, l->getLockCount());
                ASSERT_TRUE(l->getRemainingLeaseTime() > 1000 * 30);

                hazelcast::util::CountDownLatch latch(1);
                hazelcast::util::StartedThread t(testStatsThread, l, &latch);
                ASSERT_TRUE(latch.await(60));
            }
        }
    }
}







namespace hazelcast {
    namespace client {
        namespace test {
            class ClientReplicatedMapTest : public ClientTestSupport {
            public:
            protected:
                static const int OPERATION_COUNT;

                typedef std::vector<std::pair<int, int> > TEST_VALUES_TYPE;

                class SamplePortable : public serialization::Portable {
                public:
                    SamplePortable(int a) : a(a) {}

                    SamplePortable() {}

                    virtual int getFactoryId() const {
                        return 5;
                    }

                    virtual int getClassId() const {
                        return 6;
                    }

                    virtual void writePortable(serialization::PortableWriter &writer) const {
                        writer.writeInt("a", a);
                    }

                    virtual void readPortable(serialization::PortableReader &reader) {
                        a = reader.readInt("a");
                    }

                    int32_t a;
                };

                class SamplePortableFactory : public serialization::PortableFactory {
                public:
                    virtual unique_ptr<serialization::Portable> create(int32_t classId) const {
                        return unique_ptr<serialization::Portable>(new SamplePortable());
                    }
                };

                bool findValueForKey(int key, TEST_VALUES_TYPE &testValues, int &value) {
                    for (const TEST_VALUES_TYPE::value_type &entry : testValues) {
                        if (key == entry.first) {
                            value = entry.second;
                            return true;
                        }
                    }
                    return false;
                }

                template<typename T>
                bool contains(std::shared_ptr<DataArray<T> > &values, const T &value) {
                    for (size_t i = 0; i < values->size(); ++i) {
                        if (*values->get(i) == value) {
                            return true;
                        }
                    }
                    return false;
                }

                TEST_VALUES_TYPE buildTestValues() {
                    TEST_VALUES_TYPE testValues;
                    for (int i = 0; i < 100; ++i) {
                        testValues.push_back(std::make_pair(i, i * i));
                    }
                    return testValues;
                }

                virtual void TearDown() {
                }

                static void SetUpTestCase() {
                    factory = new HazelcastServerFactory(g_srvFactory->getServerAddress(), "hazelcast/test/resources/replicated-map-binary-in-memory-config-hazelcast.xml");
                    instance1 = new HazelcastServer(*factory);
                    client = new HazelcastClient(getConfig());
                    client2 = new HazelcastClient(getConfig());
                }

                static void TearDownTestCase() {
                    delete client;
                    delete client2;
                    delete instance1;
                    delete factory;

                    client = NULL;
                    client2 = NULL;
                    instance1 = NULL;
                    factory = NULL;
                }

                static ClientConfig getClientConfigWithNearCacheInvalidationEnabled() {
                    std::shared_ptr<config::NearCacheConfig<int, int> > nearCacheConfig(
                            new config::NearCacheConfig<int, int>());
                    nearCacheConfig->setInvalidateOnChange(true).setInMemoryFormat(config::BINARY);
                    return ClientConfig().addNearCacheConfig(nearCacheConfig);
                }

                static HazelcastServer *instance1;
                static HazelcastClient *client;
                static HazelcastClient *client2;
                static HazelcastServerFactory *factory;
            };

            HazelcastServer *ClientReplicatedMapTest::instance1 = NULL;
            HazelcastClient *ClientReplicatedMapTest::client = NULL;
            HazelcastClient *ClientReplicatedMapTest::client2 = NULL;
            HazelcastServerFactory *ClientReplicatedMapTest::factory = NULL;
            const int ClientReplicatedMapTest::OPERATION_COUNT = 100;

            TEST_F(ClientReplicatedMapTest, testEmptyMapIsEmpty) {
                std::shared_ptr<ReplicatedMap<int, int> > map = client->getReplicatedMap<int, int>(getTestName());
                ASSERT_TRUE(map->isEmpty()) << "map should be empty";
            }

            TEST_F(ClientReplicatedMapTest, testNonEmptyMapIsNotEmpty) {
                std::shared_ptr<ReplicatedMap<int, int> > map = client->getReplicatedMap<int, int>(getTestName());
                map->put(1, 1);
                ASSERT_FALSE(map->isEmpty()) << "map should not be empty";
            }

            TEST_F(ClientReplicatedMapTest, testPutAll) {
                std::shared_ptr<ReplicatedMap<std::string, std::string> > map1 =
                        client->getReplicatedMap<std::string, std::string>(getTestName());

                std::shared_ptr<ReplicatedMap<std::string, std::string> > map2 =
                        client2->getReplicatedMap<std::string, std::string>(getTestName());

                std::map<std::string, std::string> mapTest;
                for (int i = 0; i < OPERATION_COUNT; i++) {
                    std::ostringstream out;
                    out << "foo-" << i;
                    mapTest[out.str()] = "bar";
                }
                map1->putAll(mapTest);
                ASSERT_EQ((int32_t) mapTest.size(), map1->size());
                std::shared_ptr<LazyEntryArray<std::string, std::string> > entries = map1->entrySet();
                for (size_t j = 0; j < entries->size(); ++j) {
                    const string *key = entries->getKey(j);
                    ASSERT_NOTNULL(key, std::string);
                    ASSERT_EQ(0U, entries->getKey(j)->find("foo-"));
                    const string *value = entries->getValue(j);
                    ASSERT_NOTNULL(value, std::string);
                    ASSERT_EQ("bar", *value);
                }

                entries = map2->entrySet();
                for (size_t j = 0; j < entries->size(); ++j) {
                    const string *key = entries->getKey(j);
                    ASSERT_NOTNULL(key, std::string);
                    ASSERT_EQ(0U, entries->getKey(j)->find("foo-"));
                    const string *value = entries->getValue(j);
                    ASSERT_NOTNULL(value, std::string);
                    ASSERT_EQ("bar", *value);
                }

// TODO add server side data check using remote controller scripting
            }

            TEST_F(ClientReplicatedMapTest, testGet) {
                std::shared_ptr<ReplicatedMap<std::string, std::string> > map1 = client->getReplicatedMap<std::string, std::string>(
                        getTestName());
                std::shared_ptr<ReplicatedMap<std::string, std::string> > map2 = client2->getReplicatedMap<std::string, std::string>(
                        getTestName());

                for (int i = 0; i < OPERATION_COUNT; i++) {
                    std::ostringstream out;
                    out << "foo-" << i;
                    map1->put(out.str(), "bar");
                }

                for (int i = 0; i < OPERATION_COUNT; i++) {
                    std::ostringstream out;
                    out << "foo-" << i;
                    ASSERT_NOTNULL(map1->get(out.str()).get(), std::string);
                    ASSERT_NOTNULL(map2->get(out.str()).get(), std::string);
                    ASSERT_EQ("bar", *map1->get(out.str()));
                    ASSERT_EQ("bar", *map2->get(out.str()));
                }
            }

            TEST_F(ClientReplicatedMapTest, testPutNullReturnValueDeserialization) {
                std::shared_ptr<ReplicatedMap<int, int> > map = client->getReplicatedMap<int, int>(getTestName());
                ASSERT_NULL("Put should return null", map->put(1, 2).get(), int);
            }

            TEST_F(ClientReplicatedMapTest, testPutReturnValueDeserialization) {
                std::shared_ptr<ReplicatedMap<int, int> > map = client->getReplicatedMap<int, int>(getTestName());
                map->put(1, 2);

                std::shared_ptr<int> value = map->put(1, 3);
                ASSERT_NOTNULL(value.get(), int);
                ASSERT_EQ(2, *value);
            }

            TEST_F(ClientReplicatedMapTest, testAdd) {
                std::shared_ptr<ReplicatedMap<std::string, std::string> > map1 =
                        client->getReplicatedMap<std::string, std::string>(getTestName());

                std::shared_ptr<ReplicatedMap<std::string, std::string> > map2 =
                        client2->getReplicatedMap<std::string, std::string>(getTestName());

                for (int i = 0; i < OPERATION_COUNT; i++) {
                    std::ostringstream out;
                    out << "foo-" << i;
                    map1->put(out.str(), "bar");
                }

                ASSERT_EQ(OPERATION_COUNT, map2->size());

                std::shared_ptr<LazyEntryArray<std::string, std::string> > entries = map2->entrySet();
                for (size_t j = 0; j < entries->size(); ++j) {
                    const string *key = entries->getKey(j);
                    ASSERT_NOTNULL(key, std::string);
                    ASSERT_EQ(0U, entries->getKey(j)->find("foo-"));
                    const string *value = entries->getValue(j);
                    ASSERT_NOTNULL(value, std::string);
                    ASSERT_EQ("bar", *value);
                }

                entries = map1->entrySet();
                for (size_t j = 0; j < entries->size(); ++j) {
                    const string *key = entries->getKey(j);
                    ASSERT_NOTNULL(key, std::string);
                    ASSERT_EQ(0U, entries->getKey(j)->find("foo-"));
                    const string *value = entries->getValue(j);
                    ASSERT_NOTNULL(value, std::string);
                    ASSERT_EQ("bar", *value);
                }
            }

            TEST_F(ClientReplicatedMapTest, testClear) {
                std::shared_ptr<ReplicatedMap<std::string, std::string> > map1 =
                        client->getReplicatedMap<std::string, std::string>(getTestName());

                std::shared_ptr<ReplicatedMap<std::string, std::string> > map2 =
                        client2->getReplicatedMap<std::string, std::string>(getTestName());

                for (int i = 0; i < OPERATION_COUNT; i++) {
                    std::ostringstream out;
                    out << "foo-" << i;
                    map1->put(out.str(), "bar");
                }

                ASSERT_EQ(OPERATION_COUNT, map2->size());

                std::shared_ptr<LazyEntryArray<std::string, std::string> > entries = map2->entrySet();
                for (size_t j = 0; j < entries->size(); ++j) {
                    const string *key = entries->getKey(j);
                    ASSERT_NOTNULL(key, std::string);
                    ASSERT_EQ(0U, entries->getKey(j)->find("foo-"));
                    const string *value = entries->getValue(j);
                    ASSERT_NOTNULL(value, std::string);
                    ASSERT_EQ("bar", *value);
                }

                entries = map1->entrySet();
                for (size_t j = 0; j < entries->size(); ++j) {
                    const string *key = entries->getKey(j);
                    ASSERT_NOTNULL(key, std::string);
                    ASSERT_EQ(0U, entries->getKey(j)->find("foo-"));
                    const string *value = entries->getValue(j);
                    ASSERT_NOTNULL(value, std::string);
                    ASSERT_EQ("bar", *value);
                }

                map1->clear();
                ASSERT_EQ(0, map1->size());
                ASSERT_EQ(0, map2->size());
            }

            TEST_F(ClientReplicatedMapTest, testUpdate) {
                std::shared_ptr<ReplicatedMap<std::string, std::string> > map1 =
                        client->getReplicatedMap<std::string, std::string>(getTestName());

                std::shared_ptr<ReplicatedMap<std::string, std::string> > map2 =
                        client2->getReplicatedMap<std::string, std::string>(getTestName());

                for (int i = 0; i < OPERATION_COUNT; i++) {
                    std::ostringstream out;
                    out << "foo-" << i;
                    map1->put(out.str(), "bar");
                }

                ASSERT_EQ(OPERATION_COUNT, map2->size());

                std::shared_ptr<LazyEntryArray<std::string, std::string> > entries = map2->entrySet();
                for (size_t j = 0; j < entries->size(); ++j) {
                    const string *key = entries->getKey(j);
                    ASSERT_NOTNULL(key, std::string);
                    ASSERT_EQ(0U, entries->getKey(j)->find("foo-"));
                    const string *value = entries->getValue(j);
                    ASSERT_NOTNULL(value, std::string);
                    ASSERT_EQ("bar", *value);
                }

                entries = map1->entrySet();
                for (size_t j = 0; j < entries->size(); ++j) {
                    const string *key = entries->getKey(j);
                    ASSERT_NOTNULL(key, std::string);
                    ASSERT_EQ(0U, entries->getKey(j)->find("foo-"));
                    const string *value = entries->getValue(j);
                    ASSERT_NOTNULL(value, std::string);
                    ASSERT_EQ("bar", *value);
                }

                for (int i = 0; i < OPERATION_COUNT; i++) {
                    std::ostringstream out;
                    out << "foo-" << i;
                    map2->put(out.str(), "bar2");
                }

                entries = map2->entrySet();
                for (size_t j = 0; j < entries->size(); ++j) {
                    const string *value = entries->getValue(j);
                    ASSERT_NOTNULL(value, std::string);
                    ASSERT_EQ("bar2", *value);
                }

                entries = map1->entrySet();
                for (size_t j = 0; j < entries->size(); ++j) {
                    const string *value = entries->getValue(j);
                    ASSERT_NOTNULL(value, std::string);
                    ASSERT_EQ("bar2", *value);
                }

            }

            TEST_F(ClientReplicatedMapTest, testRemove) {
                std::shared_ptr<ReplicatedMap<std::string, std::string> > map1 =
                        client->getReplicatedMap<std::string, std::string>(getTestName());

                std::shared_ptr<ReplicatedMap<std::string, std::string> > map2 =
                        client2->getReplicatedMap<std::string, std::string>(getTestName());

                for (int i = 0; i < OPERATION_COUNT; i++) {
                    std::ostringstream out;
                    out << "foo-" << i;
                    map1->put(out.str(), "bar");
                }

                ASSERT_EQ(OPERATION_COUNT, map2->size());

                std::shared_ptr<LazyEntryArray<std::string, std::string> > entries = map2->entrySet();
                for (size_t j = 0; j < entries->size(); ++j) {
                    const string *key = entries->getKey(j);
                    ASSERT_NOTNULL(key, std::string);
                    ASSERT_EQ(0U, entries->getKey(j)->find("foo-"));
                    const string *value = entries->getValue(j);
                    ASSERT_NOTNULL(value, std::string);
                    ASSERT_EQ("bar", *value);
                }

                entries = map1->entrySet();
                for (size_t j = 0; j < entries->size(); ++j) {
                    const string *key = entries->getKey(j);
                    ASSERT_NOTNULL(key, std::string);
                    ASSERT_EQ(0U, entries->getKey(j)->find("foo-"));
                    const string *value = entries->getValue(j);
                    ASSERT_NOTNULL(value, std::string);
                    ASSERT_EQ("bar", *value);
                }

                for (int i = 0; i < OPERATION_COUNT; i++) {
                    std::ostringstream out;
                    out << "foo-" << i;
                    std::shared_ptr<std::string> value = map2->remove(out.str());
                    ASSERT_NOTNULL(value.get(), std::string);
                    ASSERT_EQ("bar", *value);
                }

                for (int i = 0; i < OPERATION_COUNT; i++) {
                    std::ostringstream out;
                    out << "foo-" << i;
                    ASSERT_NULL("Removed value should not exist for map1", map1->get(out.str()).get(), std::string);
                    ASSERT_NULL("Removed value should not exist for map2", map2->get(out.str()).get(), std::string);
                }
            }

            TEST_F(ClientReplicatedMapTest, testSize) {
                std::shared_ptr<ReplicatedMap<int, int> > map1 = client->getReplicatedMap<int, int>(getTestName());
                std::shared_ptr<ReplicatedMap<int, int> > map2 = client2->getReplicatedMap<int, int>(getTestName());

                TEST_VALUES_TYPE testValues = buildTestValues();
                size_t half = testValues.size() / 2;
                for (size_t i = 0; i < testValues.size(); i++) {
                    std::shared_ptr<ReplicatedMap<int, int> > map = i < half ? map1 : map2;
                    std::pair<int, int> &entry = testValues[i];
                    map->put(entry.first, entry.second);
                }

                ASSERT_EQ((int32_t) testValues.size(), map1->size());
                ASSERT_EQ((int32_t) testValues.size(), map2->size());
            }

            TEST_F(ClientReplicatedMapTest, testContainsKey) {
                std::shared_ptr<ReplicatedMap<std::string, std::string> > map1 =
                        client->getReplicatedMap<std::string, std::string>(getTestName());

                std::shared_ptr<ReplicatedMap<std::string, std::string> > map2 =
                        client2->getReplicatedMap<std::string, std::string>(getTestName());

                for (int i = 0; i < OPERATION_COUNT; i++) {
                    std::ostringstream out;
                    out << "foo-" << i;
                    map1->put(out.str(), "bar");
                }

                for (int i = 0; i < OPERATION_COUNT; i++) {
                    std::ostringstream out;
                    out << "foo-" << i;
                    ASSERT_TRUE(map2->containsKey(out.str()));
                }

                for (int i = 0; i < OPERATION_COUNT; i++) {
                    std::ostringstream out;
                    out << "foo-" << i;
                    ASSERT_TRUE(map1->containsKey(out.str()));
                }
            }

            TEST_F(ClientReplicatedMapTest, testContainsValue) {
                std::shared_ptr<ReplicatedMap<int, int> > map1 = client->getReplicatedMap<int, int>(getTestName());
                std::shared_ptr<ReplicatedMap<int, int> > map2 = client2->getReplicatedMap<int, int>(getTestName());

                TEST_VALUES_TYPE testValues = buildTestValues();
                size_t half = testValues.size() / 2;
                for (size_t i = 0; i < testValues.size(); i++) {
                    std::shared_ptr<ReplicatedMap<int, int> > map = i < half ? map1 : map2;
                    std::pair<int, int> &entry = testValues[i];
                    map->put(entry.first, entry.second);
                }

                for (TEST_VALUES_TYPE::value_type &entry : testValues) {
                    ASSERT_TRUE(map2->containsValue(entry.second));
                }

                for (TEST_VALUES_TYPE::value_type &entry : testValues) {
                    ASSERT_TRUE(map1->containsValue(entry.second));
                }
            }

            TEST_F(ClientReplicatedMapTest, testValues) {
                std::shared_ptr<ReplicatedMap<int, int> > map1 = client->getReplicatedMap<int, int>(getTestName());
                std::shared_ptr<ReplicatedMap<int, int> > map2 = client2->getReplicatedMap<int, int>(getTestName());

                TEST_VALUES_TYPE testValues = buildTestValues();
                size_t half = testValues.size() / 2;
                for (size_t i = 0; i < testValues.size(); i++) {
                    std::shared_ptr<ReplicatedMap<int, int> > map = i < half ? map1 : map2;
                    std::pair<int, int> &entry = testValues[i];
                    map->put(entry.first, entry.second);
                }

                std::shared_ptr<DataArray<int> > values1 = map1->values();
                std::shared_ptr<DataArray<int> > values2 = map2->values();

                for (TEST_VALUES_TYPE::value_type &entry : testValues) {
                    ASSERT_TRUE(contains(values1, entry.second));
                    ASSERT_TRUE(contains(values2, entry.second));
                }
            }

            TEST_F(ClientReplicatedMapTest, testKeySet) {
                std::shared_ptr<ReplicatedMap<int, int> > map1 = client->getReplicatedMap<int, int>(getTestName());
                std::shared_ptr<ReplicatedMap<int, int> > map2 = client2->getReplicatedMap<int, int>(getTestName());

                TEST_VALUES_TYPE testValues = buildTestValues();
                size_t half = testValues.size() / 2;
                for (size_t i = 0; i < testValues.size(); i++) {
                    std::shared_ptr<ReplicatedMap<int, int> > map = i < half ? map1 : map2;
                    std::pair<int, int> &entry = testValues[i];
                    map->put(entry.first, entry.second);
                }

                std::shared_ptr<DataArray<int> > keys1 = map1->keySet();
                std::shared_ptr<DataArray<int> > keys2 = map2->keySet();

                for (TEST_VALUES_TYPE::value_type &entry : testValues) {
                    ASSERT_TRUE(contains(keys1, entry.first));
                    ASSERT_TRUE(contains(keys2, entry.first));
                }
            }

            TEST_F(ClientReplicatedMapTest, testEntrySet) {
                std::shared_ptr<ReplicatedMap<int, int> > map1 = client->getReplicatedMap<int, int>(getTestName());
                std::shared_ptr<ReplicatedMap<int, int> > map2 = client2->getReplicatedMap<int, int>(getTestName());

                TEST_VALUES_TYPE testValues = buildTestValues();
                size_t half = testValues.size() / 2;
                for (size_t i = 0; i < testValues.size(); i++) {
                    std::shared_ptr<ReplicatedMap<int, int> > map = i < half ? map1 : map2;
                    std::pair<int, int> &entry = testValues[i];
                    map->put(entry.first, entry.second);
                }

                std::shared_ptr<LazyEntryArray<int, int> > entrySet1 = map1->entrySet();
                std::shared_ptr<LazyEntryArray<int, int> > entrySet2 = map2->entrySet();

                for (size_t j = 0; j < entrySet2->size(); ++j) {
                    int value;
                    ASSERT_TRUE(findValueForKey(*entrySet2->getKey(j), testValues, value));
                    ASSERT_EQ(value, *entrySet2->getValue(j));
                }

                for (size_t j = 0; j < entrySet1->size(); ++j) {
                    int value;
                    ASSERT_TRUE(findValueForKey(*entrySet1->getKey(j), testValues, value));
                    ASSERT_EQ(value, *entrySet1->getValue(j));
                }
            }

            TEST_F(ClientReplicatedMapTest, testRetrieveUnknownValue) {
                std::shared_ptr<ReplicatedMap<std::string, std::string> > map =
                        client->getReplicatedMap<std::string, std::string>(getTestName());

                std::shared_ptr<std::string> value = map->get("foo");
                ASSERT_NULL("No entry with key foo should exist", value.get(), std::string);
            }

            TEST_F(ClientReplicatedMapTest, testNearCacheInvalidation) {
                std::string mapName = randomString();

                ClientConfig clientConfig = getClientConfigWithNearCacheInvalidationEnabled();
                HazelcastClient client1(clientConfig);
                HazelcastClient client2(clientConfig);

                std::shared_ptr<ReplicatedMap<int, int> > replicatedMap1 = client1.getReplicatedMap<int, int>(
                        mapName);

                replicatedMap1->put(1, 1);
// puts key 1 to Near Cache
                replicatedMap1->get(1);

                std::shared_ptr<ReplicatedMap<int, int> > replicatedMap2 = client2.getReplicatedMap<int, int>(
                        mapName);
// this should invalidate Near Cache of replicatedMap1
                replicatedMap2->clear();

                ASSERT_NULL_EVENTUALLY(replicatedMap1->get(1).get(), int);
            }

            TEST_F(ClientReplicatedMapTest, testClientPortableWithoutRegisteringToNode) {
                ClientConfig clientConfig;
                SerializationConfig serializationConfig;
                serializationConfig.addPortableFactory(5, std::shared_ptr<serialization::PortableFactory>(
                        new SamplePortableFactory()));
                clientConfig.setSerializationConfig(serializationConfig);

                HazelcastClient client(clientConfig);
                std::shared_ptr<ReplicatedMap<int, SamplePortable> > sampleMap = client.getReplicatedMap<int, SamplePortable>(
                        getTestName());
                sampleMap->put(1, SamplePortable(666));
                std::shared_ptr<SamplePortable> samplePortable = sampleMap->get(1);
                ASSERT_NOTNULL(samplePortable.get(), SamplePortable);
                ASSERT_EQ(666, samplePortable->a);
            }
        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            class ClientReplicatedMapListenerTest : public ClientTestSupport {
            protected:
                class EventCountingListener : public EntryListener<int, int> {
                public:
                    EventCountingListener() : keys(UINT_MAX) {}

                    virtual void entryAdded(const EntryEvent<int, int> &event) {
                        keys.push(event.getKey());
                        ++addCount;
                    }

                    virtual void entryRemoved(const EntryEvent<int, int> &event) {
                        keys.push(event.getKey());
                        ++removeCount;
                    }

                    virtual void entryUpdated(const EntryEvent<int, int> &event) {
                        keys.push(event.getKey());
                        ++updateCount;
                    }

                    virtual void entryEvicted(const EntryEvent<int, int> &event) {
                        keys.push(event.getKey());
                        ++evictCount;
                    }

                    virtual void entryExpired(const EntryEvent<int, int> &event) {
                    }

                    virtual void entryMerged(const EntryEvent<int, int> &event) {
                    }

                    virtual void mapEvicted(const MapEvent &event) {
                        ++mapEvictCount;
                    }

                    virtual void mapCleared(const MapEvent &event) {
                        ++mapClearCount;
                    }

                    hazelcast::util::BlockingConcurrentQueue<int> keys;
                    hazelcast::util::AtomicInt addCount;
                    hazelcast::util::AtomicInt removeCount;
                    hazelcast::util::AtomicInt updateCount;
                    hazelcast::util::AtomicInt evictCount;
                    hazelcast::util::AtomicInt mapClearCount;
                    hazelcast::util::AtomicInt mapEvictCount;
                };

                virtual void TearDown() {
                }

                static void SetUpTestCase() {
                    instance1 = new HazelcastServer(*g_srvFactory);
                    instance2 = new HazelcastServer(*g_srvFactory);
                    client = new HazelcastClient(getConfig());
                    client2 = new HazelcastClient(getConfig());
                }

                static void TearDownTestCase() {
                    delete client;
                    delete client2;
                    delete instance1;
                    delete instance2;

                    client = NULL;
                    client2 = NULL;
                    instance1 = NULL;
                    instance2 = NULL;
                }

                static HazelcastServer *instance1;
                static HazelcastServer *instance2;
                static HazelcastClient *client;
                static HazelcastClient *client2;
            };

            HazelcastServer *ClientReplicatedMapListenerTest::instance1 = NULL;
            HazelcastServer *ClientReplicatedMapListenerTest::instance2 = NULL;
            HazelcastClient *ClientReplicatedMapListenerTest::client = NULL;
            HazelcastClient *ClientReplicatedMapListenerTest::client2 = NULL;

            TEST_F(ClientReplicatedMapListenerTest, testEntryAdded) {
                std::shared_ptr<ReplicatedMap<int, int> > replicatedMap = client->getReplicatedMap<int, int>(
                        getTestName());
                std::shared_ptr<EventCountingListener> listener(new EventCountingListener());
                replicatedMap->addEntryListener(listener);
                replicatedMap->put(1, 1);
                ASSERT_EQ_EVENTUALLY(1, listener->addCount.load());
            }

            TEST_F(ClientReplicatedMapListenerTest, testEntryUpdated) {
                std::shared_ptr<ReplicatedMap<int, int> > replicatedMap = client->getReplicatedMap<int, int>(
                        getTestName());
                std::shared_ptr<EventCountingListener> listener(new EventCountingListener());
                replicatedMap->addEntryListener(listener);
                replicatedMap->put(1, 1);
                replicatedMap->put(1, 2);
                ASSERT_EQ_EVENTUALLY(1, listener->updateCount.load());
            }

            TEST_F(ClientReplicatedMapListenerTest, testEntryRemoved) {
                std::shared_ptr<ReplicatedMap<int, int> > replicatedMap = client->getReplicatedMap<int, int>(
                        getTestName());
                std::shared_ptr<EventCountingListener> listener(new EventCountingListener());
                replicatedMap->addEntryListener(listener);
                replicatedMap->put(1, 1);
                replicatedMap->remove(1);
                ASSERT_EQ_EVENTUALLY(1, listener->removeCount.load());
            }

            TEST_F(ClientReplicatedMapListenerTest, testMapClear) {
                std::shared_ptr<ReplicatedMap<int, int> > replicatedMap = client->getReplicatedMap<int, int>(
                        getTestName());
                std::shared_ptr<EventCountingListener> listener(new EventCountingListener());
                replicatedMap->addEntryListener(listener);
                replicatedMap->put(1, 1);
                replicatedMap->clear();
                ASSERT_EQ_EVENTUALLY(1, listener->mapClearCount.load());
            }

            TEST_F(ClientReplicatedMapListenerTest, testListenToKeyForEntryAdded) {
                std::shared_ptr<ReplicatedMap<int, int> > replicatedMap = client->getReplicatedMap<int, int>(
                        getTestName());
                std::shared_ptr<EventCountingListener> listener(new EventCountingListener());
                replicatedMap->addEntryListener(listener, 1);
                replicatedMap->put(1, 1);
                replicatedMap->put(2, 2);
                ASSERT_TRUE_EVENTUALLY(
                        listener->keys.size() == 1U && listener->keys.pop() == 1 && listener->addCount.load() == 1);
            }

            TEST_F(ClientReplicatedMapListenerTest, testListenWithPredicate) {
                std::shared_ptr<ReplicatedMap<int, int> > replicatedMap = client->getReplicatedMap<int, int>(
                        getTestName());
                std::shared_ptr<EventCountingListener> listener(new EventCountingListener());
                replicatedMap->addEntryListener(listener, query::FalsePredicate());
                replicatedMap->put(2, 2);
// Check for 3 seconds
                ASSERT_TRUE_ALL_THE_TIME((listener->addCount.load() == 0), 3);
            }

        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            class BasicClientReplicatedMapNearCacheTest
                    : public ClientTestSupport, public ::testing::WithParamInterface<config::InMemoryFormat> {
            public:
                static void SetUpTestSuite() {
                    instance = new HazelcastServer(*g_srvFactory);
                    instance2 = new HazelcastServer(*g_srvFactory);
                }

                static void TearDownTestSuite() {
                    delete instance2;
                    delete instance;
                    instance2 = NULL;
                    instance = NULL;
                }

                virtual void SetUp() {
                    nearCacheConfig = NearCacheTestUtils::createNearCacheConfig<int, std::string>(GetParam(),
                                                                                                  getTestName());
                }

                virtual void TearDown() {
                    if (nearCachedMap.get()) {
                        nearCachedMap->destroy();
                    }
                    if (noNearCacheMap.get()) {
                        noNearCacheMap->destroy();
                    }
                    if (NULL != client.get()) {
                        client->shutdown();
                    }
                    if (NULL != nearCachedClient.get()) {
                        nearCachedClient->shutdown();
                    }
                }

            protected:
                /**
                 * Provides utility methods for unified Near Cache tests.
                 */
                class NearCacheTestUtils : public ClientTestSupport {
                public:
                    /**
                     * Creates a {@link NearCacheConfig} with a given {@link InMemoryFormat}.
                     *
                     * @param inMemoryFormat the {@link InMemoryFormat} to set
                     * @return the {@link NearCacheConfig}
                     */
                    template<typename K, typename V>
                    static std::shared_ptr<config::NearCacheConfig<K, V> > createNearCacheConfig(
                            config::InMemoryFormat inMemoryFormat, const std::string &mapName) {
                        std::shared_ptr<config::NearCacheConfig<K, V> > nearCacheConfig(
                                new config::NearCacheConfig<K, V>());

                        nearCacheConfig->setName(mapName).setInMemoryFormat(inMemoryFormat).setInvalidateOnChange(true);

                        return nearCacheConfig;
                    }

                    /**
                     * Configures the {@link EvictionConfig} of the given {@link NearCacheConfig}.
                     *
                     * @param nearCacheConfig the {@link NearCacheConfig} to configure
                     * @param evictionPolicy  the {@link EvictionPolicy} to set
                     * @param maxSizePolicy   the {@link MaxSizePolicy} to set
                     * @param maxSize         the max size to set
                     */
                    template<typename K, typename V>
                    static void setEvictionConfig(config::NearCacheConfig<K, V> &nearCacheConfig,
                                                  config::EvictionPolicy evictionPolicy,
                                                  typename config::EvictionConfig<K, V>::MaxSizePolicy maxSizePolicy,
                                                  int maxSize) {
                        nearCacheConfig.getEvictionConfig()
                                ->setEvictionPolicy(evictionPolicy)
                                .setMaximumSizePolicy(maxSizePolicy)
                                .setSize(maxSize);
                    }

                    /**
                     * Asserts the {@link NearCacheStats} for expected values.
                     *
                     * @param stats                   stats of the near cache
                     * @param expectedOwnedEntryCount the expected owned entry count
                     * @param expectedHits            the expected Near Cache hits
                     * @param expectedMisses          the expected Near Cache misses
                     */
                    static void assertNearCacheStats(monitor::NearCacheStats &stats,
                                                     int64_t expectedOwnedEntryCount, int64_t expectedHits,
                                                     int64_t expectedMisses) {
                        assertNearCacheStats(stats, expectedOwnedEntryCount, expectedHits, expectedMisses, 0, 0);
                    }

                    /**
                     * Asserts the {@link NearCacheStats} for expected values.
                     *
                     * @param stats                   stats of the near cache
                     * @param expectedOwnedEntryCount the expected owned entry count
                     * @param expectedHits            the expected Near Cache hits
                     * @param expectedMisses          the expected Near Cache misses
                     * @param expectedEvictions       the expected Near Cache evictions
                     * @param expectedExpirations     the expected Near Cache expirations
                     */
                    static void assertNearCacheStats(monitor::NearCacheStats &stats,
                                                     int64_t expectedOwnedEntryCount, int64_t expectedHits,
                                                     int64_t expectedMisses,
                                                     int64_t expectedEvictions, int64_t expectedExpirations) {
                        assertEqualsFormat("Near Cache entry count should be %ld, but was %ld ",
                                           expectedOwnedEntryCount, stats.getOwnedEntryCount(), stats);
                        assertEqualsFormat("Near Cache hits should be %ld, but were %ld ",
                                           expectedHits, stats.getHits(), stats);
                        assertEqualsFormat("Near Cache misses should be %ld, but were %ld ",
                                           expectedMisses, stats.getMisses(), stats);
                        assertEqualsFormat("Near Cache evictions should be %ld, but were %ld ",
                                           expectedEvictions, stats.getEvictions(), stats);
                        assertEqualsFormat("Near Cache expirations should be %ld, but were %ld ",
                                           expectedExpirations, stats.getExpirations(), stats);
                    }

                    static void assertEqualsFormat(const char *messageFormat, int64_t expected, int64_t actual,
                                                   monitor::NearCacheStats &stats) {
                        char buf[300];
                        hazelcast::util::hz_snprintf(buf, 300, messageFormat, expected, actual);
                        ASSERT_EQ(expected, actual) << buf << "(" << stats.toString() << ")";
                    }

                private:
                    NearCacheTestUtils();

                    NearCacheTestUtils(const NearCacheTestUtils &);
                };

                /**
                 * The default count to be inserted into the Near Caches.
                 */
                static const int DEFAULT_RECORD_COUNT;

                void createContext() {
                    createNoNearCacheContext();
                    createNearCacheContext();
                }

                void createNoNearCacheContext() {
                    client = std::unique_ptr<HazelcastClient>(new HazelcastClient(getConfig()));
                    noNearCacheMap = client->getReplicatedMap<int, std::string>(getTestName());
                }

                void createNearCacheContext() {
                    ClientConfig nearCachedClientConfig = getConfig();
                    nearCachedClientConfig.addNearCacheConfig(nearCacheConfig);
                    nearCachedClient = std::unique_ptr<HazelcastClient>(new HazelcastClient(nearCachedClientConfig));
                    nearCachedMap = nearCachedClient->getReplicatedMap<int, std::string>(getTestName());
                    spi::ClientContext clientContext(*nearCachedClient);
                    nearCacheManager = &clientContext.getNearCacheManager();
                    nearCache = nearCacheManager->
                            getNearCache<int, std::string, serialization::pimpl::Data>(getTestName());
                    this->stats = (nearCache.get() == NULL) ? NULL : &nearCache->getNearCacheStats();
                }

                void testContainsKey(bool useNearCachedMapForRemoval) {
                    createNoNearCacheContext();

                    // populate map
                    noNearCacheMap->put(1, "value1");
                    noNearCacheMap->put(2, "value2");
                    noNearCacheMap->put(3, "value3");

                    createNearCacheContext();

                    // populate Near Cache
                    nearCachedMap->get(1);
                    nearCachedMap->get(2);
                    nearCachedMap->get(3);

                    ASSERT_TRUE(nearCachedMap->containsKey(1));
                    ASSERT_TRUE(nearCachedMap->containsKey(2));
                    ASSERT_TRUE(nearCachedMap->containsKey(3));
                    ASSERT_FALSE(nearCachedMap->containsKey(5));

                    // remove a key which is in the Near Cache
                    std::shared_ptr<ReplicatedMap<int, std::string> > &adapter = useNearCachedMapForRemoval
                                                                                 ? nearCachedMap
                                                                                 : noNearCacheMap;
                    adapter->remove(1);

                    WAIT_TRUE_EVENTUALLY(checkContainKeys());
                    ASSERT_FALSE(nearCachedMap->containsKey(1));
                    ASSERT_TRUE(nearCachedMap->containsKey(2));
                    ASSERT_TRUE(nearCachedMap->containsKey(3));
                    ASSERT_FALSE(nearCachedMap->containsKey(5));
                }

                bool checkContainKeys() {
                    return !nearCachedMap->containsKey(1) && nearCachedMap->containsKey(2) &&
                           nearCachedMap->containsKey(3) && !nearCachedMap->containsKey(5);
                }

                void
                assertNearCacheInvalidationRequests(monitor::NearCacheStats &stats, int64_t invalidationRequests) {
                    if (nearCacheConfig->isInvalidateOnChange() && invalidationRequests > 0) {
                        monitor::impl::NearCacheStatsImpl &nearCacheStatsImpl = (monitor::impl::NearCacheStatsImpl &) stats;
                        ASSERT_EQ_EVENTUALLY(invalidationRequests, nearCacheStatsImpl.getInvalidationRequests());
                        nearCacheStatsImpl.resetInvalidationEvents();
                    }
                }

                void populateMap() {
                    char buf[30];
                    for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                        hazelcast::util::hz_snprintf(buf, 30, "value-%d", i);
                        noNearCacheMap->put(i, buf);
                    }

                    assertNearCacheInvalidationRequests(*stats, DEFAULT_RECORD_COUNT);
                }

                void populateNearCache() {
                    char buf[30];
                    for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                        std::shared_ptr<string> value = nearCachedMap->get(i);
                        ASSERT_NOTNULL(value.get(), std::string);
                        hazelcast::util::hz_snprintf(buf, 30, "value-%d", i);
                        ASSERT_EQ(buf, *value);
                    }
                }

                std::shared_ptr<serialization::pimpl::Data> getNearCacheKey(int key) {
                    spi::ClientContext clientContext(*client);
                    return clientContext.getSerializationService().toSharedData<int>(&key);
                }

                int64_t getExpectedMissesWithLocalUpdatePolicy() {
                    if (nearCacheConfig->getLocalUpdatePolicy() == config::NearCacheConfig<int, std::string>::CACHE) {
                        // we expect the first and second get() to be hits, since the value should be already be cached
                        return stats->getMisses();
                    }
                    // we expect the first get() to be a miss, due to the replaced / invalidated value
                    return stats->getMisses() + 1;
                }

                int64_t getExpectedHitsWithLocalUpdatePolicy() {
                    if (nearCacheConfig->getLocalUpdatePolicy() == config::NearCacheConfig<int, std::string>::CACHE) {
                        // we expect the first and second get() to be hits, since the value should be already be cached
                        return stats->getHits() + 2;
                    }
                    // we expect the second get() to be a hit, since it should be served from the Near Cache
                    return stats->getHits() + 1;
                }

                bool checkMissesAndHits(int64_t &expectedMisses, int64_t &expectedHits,
                                        std::shared_ptr<std::string> &value) {
                    expectedMisses = getExpectedMissesWithLocalUpdatePolicy();
                    expectedHits = getExpectedHitsWithLocalUpdatePolicy();

                    value = nearCachedMap->get(1);
                    if (NULL == value.get() || *value != "newValue") {
                        return false;
                    }
                    value = nearCachedMap->get(1);
                    if (NULL == value.get() || *value != "newValue") {
                        return false;
                    }

                    return expectedHits == stats->getHits() && expectedMisses == stats->getMisses();
                }

                void whenPutAllIsUsed_thenNearCacheShouldBeInvalidated(bool useNearCacheAdapter) {
                    createNoNearCacheContext();

                    createNearCacheContext();

                    populateMap();

                    populateNearCache();

                    std::map<int, std::string> invalidationMap;
                    char buf[30];
                    for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                        hazelcast::util::hz_snprintf(buf, 30, "value-%d", i);
                        invalidationMap[i] = buf;
                    }

                    // this should invalidate the Near Cache
                    std::shared_ptr<ReplicatedMap<int, std::string> > &adapter = useNearCacheAdapter ? nearCachedMap
                                                                                                     : noNearCacheMap;
                    adapter->putAll(invalidationMap);

                    WAIT_EQ_EVENTUALLY(0, nearCache->size());
                    ASSERT_EQ(0, nearCache->size()) << "Invalidation is not working on putAll()";
                }

                std::shared_ptr<config::NearCacheConfig<int, std::string> > nearCacheConfig;
                std::unique_ptr<HazelcastClient> client;
                std::unique_ptr<HazelcastClient> nearCachedClient;
                std::shared_ptr<ReplicatedMap<int, std::string> > noNearCacheMap;
                std::shared_ptr<ReplicatedMap<int, std::string> > nearCachedMap;
                hazelcast::client::internal::nearcache::NearCacheManager *nearCacheManager;
                std::shared_ptr<hazelcast::client::internal::nearcache::NearCache<serialization::pimpl::Data, std::string> > nearCache;
                monitor::NearCacheStats *stats;
                static HazelcastServer *instance;
                static HazelcastServer *instance2;
            };

            const int BasicClientReplicatedMapNearCacheTest::DEFAULT_RECORD_COUNT = 1000;
            HazelcastServer *BasicClientReplicatedMapNearCacheTest::instance = NULL;
            HazelcastServer *BasicClientReplicatedMapNearCacheTest::instance2 = NULL;

            /**
             * Checks that the Near Cache keys are correctly checked when {@link DataStructureAdapter#containsKey(Object)} is used.
             *
             * This variant uses the {@link NearCacheTestContext#nearCacheAdapter}, so there is no Near Cache invalidation necessary.
             */
            TEST_P(BasicClientReplicatedMapNearCacheTest, testContainsKey_withUpdateOnNearCacheAdapter) {
                testContainsKey(true);
            }

            /**
             * Checks that the memory costs are calculated correctly.
             *
             * This variant uses the noNearCacheMap(client with no near cache), so we need to configure Near Cache
             * invalidation.
             */
            TEST_P(BasicClientReplicatedMapNearCacheTest, testContainsKey_withUpdateOnDataAdapter) {
                nearCacheConfig->setInvalidateOnChange(true);
                testContainsKey(false);
            }

            /**
             * Checks that the Near Cache never returns its internal {@link NearCache#NULL_OBJECT} to the public API.
             */
            TEST_P(BasicClientReplicatedMapNearCacheTest,
                   whenEmptyMap_thenPopulatedNearCacheShouldReturnNull_neverNULLOBJECT) {
                createContext();

                for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                    // populate Near Cache
                    ASSERT_NULL("Expected null from original data structure for key " << i,
                                nearCachedMap->get(i).get(), std::string);
                    // fetch value from Near Cache
                    ASSERT_NULL("Expected null from Near cached data structure for key " << i,
                                nearCachedMap->get(i).get(), std::string);

                    // fetch internal value directly from Near Cache
                    std::shared_ptr<serialization::pimpl::Data> key = getNearCacheKey(i);
                    std::shared_ptr<std::string> value = nearCache->get(key);
                    if (value.get() != NULL) {
                        // the internal value should either be `null` or `NULL_OBJECT`
                        std::shared_ptr<std::string> nullObj = std::static_pointer_cast<std::string>(
                                hazelcast::client::internal::nearcache::NearCache<int, std::string>::NULL_OBJECT);
                        ASSERT_EQ(nullObj, nearCache->get(key)) << "Expected NULL_OBJECT in Near Cache for key " << i;
                    }
                }
            }

/**
             * Checks that the Near Cache updates value for keys which are already in the Near Cache,
             * even if the Near Cache is full and the eviction is disabled (via {@link com.hazelcast.config.EvictionPolicy#NONE}.
             *
             * This variant uses the {@link NearCacheTestContext#nearCacheAdapter}, so there is no Near Cache invalidation necessary.
             */
            TEST_P(BasicClientReplicatedMapNearCacheTest,
                   whenCacheIsFull_thenPutOnSameKeyShouldUpdateValue_withUpdateOnNearCacheAdapter) {
                int size = DEFAULT_RECORD_COUNT / 2;
                NearCacheTestUtils::setEvictionConfig<int, std::string>(*nearCacheConfig, config::NONE,
                                                                        config::EvictionConfig<int, std::string>::ENTRY_COUNT,
                                                                        size);

                nearCacheConfig->setInvalidateOnChange(false);

                createNoNearCacheContext();

                createNearCacheContext();

                populateMap();

                populateNearCache();

                ASSERT_EQ(size, nearCache->size());
                std::shared_ptr<std::string> value = nearCachedMap->get(1);
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ("value-1", *value);

                nearCachedMap->put(1, "newValue");

                int64_t expectedMisses = getExpectedMissesWithLocalUpdatePolicy();
                int64_t expectedHits = getExpectedHitsWithLocalUpdatePolicy();

                value = nearCachedMap->get(1);
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ("newValue", *value);
                value = nearCachedMap->get(1);
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ("newValue", *value);

                NearCacheTestUtils::assertNearCacheStats(*stats, size, expectedHits, expectedMisses);
            }

/**
             * Checks that the Near Cache updates value for keys which are already in the Near Cache,
             * even if the Near Cache is full an the eviction is disabled (via {@link com.hazelcast.config.EvictionPolicy#NONE}.
             *
             * This variant uses the {@link NearCacheTestContext#dataAdapter}, so we need to configure Near Cache invalidation.
             */
            TEST_P(BasicClientReplicatedMapNearCacheTest,
                   whenCacheIsFull_thenPutOnSameKeyShouldUpdateValue_withUpdateOnDataAdapter) {
                int size = DEFAULT_RECORD_COUNT / 2;
                NearCacheTestUtils::setEvictionConfig<int, std::string>(*nearCacheConfig, config::NONE,
                                                                        config::EvictionConfig<int, std::string>::ENTRY_COUNT,
                                                                        size);
                nearCacheConfig->setInvalidateOnChange(true);

                createNoNearCacheContext();

                createNearCacheContext();

                populateMap();

                populateNearCache();

                ASSERT_EQ(size, nearCache->size());
                std::shared_ptr<std::string> value = nearCachedMap->get(1);
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ("value-1", *value);

                noNearCacheMap->put(1, "newValue");

// we have to use assertTrueEventually since the invalidation is done asynchronously
                int64_t expectedMisses = 0;
                int64_t expectedHits = 0;
                WAIT_TRUE_EVENTUALLY(checkMissesAndHits(expectedMisses, expectedHits, value));
                SCOPED_TRACE("whenCacheIsFull_thenPutOnSameKeyShouldUpdateValue_withUpdateOnDataAdapter");
                NearCacheTestUtils::assertNearCacheStats(*stats, size, expectedHits, expectedMisses);
            }

/**
             * Checks that the Near Cache values are eventually invalidated when {@link DataStructureAdapter#putAll(Map)} is used.
             *
             * This variant uses the nearCacheMap, so there is no Near Cache invalidation necessary.
             */
            TEST_P(BasicClientReplicatedMapNearCacheTest,
                   whenPutAllIsUsed_thenNearCacheShouldBeInvalidated_withUpdateOnNearCacheAdapter) {
                whenPutAllIsUsed_thenNearCacheShouldBeInvalidated(true);
            }

/**
             * Checks that the Near Cache values are eventually invalidated when {@link DataStructureAdapter#putAll(Map)} is used.
             *
             * This variant uses the noNearCacheMap, so we need to configure Near Cache invalidation.
             */
            TEST_P(BasicClientReplicatedMapNearCacheTest,
                   whenPutAllIsUsed_thenNearCacheShouldBeInvalidated_withUpdateOnDataAdapter) {
                nearCacheConfig->setInvalidateOnChange(true);
                whenPutAllIsUsed_thenNearCacheShouldBeInvalidated(false);
            }

/**
             * Checks that the {@link com.hazelcast.monitor.NearCacheStats} are calculated correctly.
             */
            TEST_P(BasicClientReplicatedMapNearCacheTest, testNearCacheStats) {
                createNoNearCacheContext();

                createNearCacheContext();

// populate map
                populateMap();

                {
                    SCOPED_TRACE("testNearCacheStats when near cache is empty");
                    NearCacheTestUtils::assertNearCacheStats(*stats, 0, 0, 0);
                }

// populate Near Cache. Will cause misses and will increment the owned entry count
                populateNearCache();
                {
                    SCOPED_TRACE("testNearCacheStats when near cache is initially populated");
                    NearCacheTestUtils::assertNearCacheStats(*stats, DEFAULT_RECORD_COUNT, 0, DEFAULT_RECORD_COUNT);
                }

// make some hits
                populateNearCache();
                {
                    SCOPED_TRACE("testNearCacheStats when near cache is hit after being populated.");
                    NearCacheTestUtils::assertNearCacheStats(*stats, DEFAULT_RECORD_COUNT, DEFAULT_RECORD_COUNT,
                                                             DEFAULT_RECORD_COUNT);
                }
            }

            TEST_P(BasicClientReplicatedMapNearCacheTest, testNearCacheEviction) {
                NearCacheTestUtils::setEvictionConfig<int, std::string>(*nearCacheConfig, config::LRU,
                                                                        config::EvictionConfig<int, std::string>::ENTRY_COUNT,
                                                                        DEFAULT_RECORD_COUNT);
                createNoNearCacheContext();

// all Near Cache implementations use the same eviction algorithm, which evicts a single entry
                int64_t expectedEvictions = 1;

                createNearCacheContext();

// populate map with an extra entry
                populateMap();
                char buf[20];
                hazelcast::util::hz_snprintf(buf, 20, "value-%d", DEFAULT_RECORD_COUNT);
                noNearCacheMap->put(DEFAULT_RECORD_COUNT, buf);

// populate Near Caches
                populateNearCache();

// we expect (size + the extra entry - the expectedEvictions) entries in the Near Cache
                int64_t expectedOwnedEntryCount = DEFAULT_RECORD_COUNT + 1 - expectedEvictions;
                int64_t expectedHits = stats->getHits();
                int64_t expectedMisses = stats->getMisses() + 1;

// trigger eviction via fetching the extra entry
                nearCachedMap->get(DEFAULT_RECORD_COUNT);

                int64_t evictions = stats->getEvictions();
                ASSERT_GE(evictions, expectedEvictions)
                                            << "Near Cache eviction count didn't reach the desired value ("
                                            << expectedEvictions << " vs. " << evictions << ") ("
                                            << stats->toString();

                SCOPED_TRACE("testNearCacheEviction");

                NearCacheTestUtils::assertNearCacheStats(*stats, expectedOwnedEntryCount, expectedHits, expectedMisses,
                                                         expectedEvictions, 0);
            }

            INSTANTIATE_TEST_SUITE_P(ReplicatedMapNearCacheTest, BasicClientReplicatedMapNearCacheTest,
                                     ::testing::Values(config::BINARY, config::OBJECT));
        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            class ClientReplicatedMapNearCacheTest : public ClientTestSupport {
            protected:
                /**
                 * The default name used for the data structures which have a Near Cache.
                 */
                static const std::string DEFAULT_NEAR_CACHE_NAME;

                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    instance2 = new HazelcastServer(*g_srvFactory);
                }

                static void TearDownTestCase() {
                    delete instance2;
                    delete instance;
                    instance2 = NULL;
                    instance = NULL;
                }


                virtual void TearDown() {
                    if (map.get()) {
                        map->destroy();
                    }
                }

                std::shared_ptr<config::NearCacheConfig<int, int> > newNoInvalidationNearCacheConfig() {
                    std::shared_ptr<config::NearCacheConfig<int, int> > nearCacheConfig(newNearCacheConfig());
                    nearCacheConfig->setInMemoryFormat(config::OBJECT);
                    nearCacheConfig->setInvalidateOnChange(false);
                    return nearCacheConfig;
                }

                std::shared_ptr<config::NearCacheConfig<int, int> > newNearCacheConfig() {
                    return std::shared_ptr<config::NearCacheConfig<int, int> >(
                            new config::NearCacheConfig<int, int>());
                }

                std::unique_ptr<ClientConfig> newClientConfig() {
                    return std::unique_ptr<ClientConfig>(new ClientConfig());
                }

                std::shared_ptr<ReplicatedMap<int, int> > getNearCachedMapFromClient(
                        std::shared_ptr<config::NearCacheConfig<int, int> > nearCacheConfig) {
                    std::string mapName = DEFAULT_NEAR_CACHE_NAME;

                    nearCacheConfig->setName(mapName);

                    clientConfig = newClientConfig();
                    clientConfig->addNearCacheConfig(nearCacheConfig);

                    client = std::unique_ptr<HazelcastClient>(new HazelcastClient(*clientConfig));
                    map = client->getReplicatedMap<int, int>(mapName);
                    return map;
                }

                monitor::NearCacheStats *getNearCacheStats(ReplicatedMap<int, int> &map) {
                    return  (static_cast<proxy::ClientReplicatedMapProxy<int, int> &>(map)).getNearCacheStats();
                }

                void assertThatOwnedEntryCountEquals(ReplicatedMap<int, int> &clientMap, int64_t expected) {
                    ASSERT_EQ(expected, getNearCacheStats(clientMap)->getOwnedEntryCount());
                }

                std::unique_ptr<ClientConfig> clientConfig;
                std::shared_ptr<config::NearCacheConfig<int, int> > nearCacheConfig;
                std::unique_ptr<HazelcastClient> client;
                std::shared_ptr<ReplicatedMap<int, int> > map;
                static HazelcastServer *instance;
                static HazelcastServer *instance2;
            };

            const std::string ClientReplicatedMapNearCacheTest::DEFAULT_NEAR_CACHE_NAME = "defaultNearCache";
            HazelcastServer *ClientReplicatedMapNearCacheTest::instance = NULL;
            HazelcastServer *ClientReplicatedMapNearCacheTest::instance2 = NULL;

            TEST_F(ClientReplicatedMapNearCacheTest, testGetAllChecksNearCacheFirst) {
                std::shared_ptr<ReplicatedMap<int, int> > map = getNearCachedMapFromClient(
                        newNoInvalidationNearCacheConfig());

                int size = 1003;
                for (int i = 0; i < size; i++) {
                    map->put(i, i);
                }
                // populate Near Cache
                for (int i = 0; i < size; i++) {
                    map->get(i);
                }
                // getAll() generates the Near Cache hits
                for (int i = 0; i < size; i++) {
                    map->get(i);
                }

                monitor::NearCacheStats *stats = getNearCacheStats(*map);
                ASSERT_EQ(size, stats->getOwnedEntryCount());
                ASSERT_EQ(size, stats->getHits());
            }

            TEST_F(ClientReplicatedMapNearCacheTest, testGetAllPopulatesNearCache) {
                std::shared_ptr<ReplicatedMap<int, int> > map = getNearCachedMapFromClient(
                        newNoInvalidationNearCacheConfig());

                int size = 1214;
                for (int i = 0; i < size; i++) {
                    map->put(i, i);
                }
// populate Near Cache
                for (int i = 0; i < size; i++) {
                    map->get(i);
                }
// getAll() generates the Near Cache hits
                for (int i = 0; i < size; i++) {
                    map->get(i);
                }

                assertThatOwnedEntryCountEquals(*map, size);
            }

            TEST_F(ClientReplicatedMapNearCacheTest, testRemoveAllNearCache) {
                std::shared_ptr<ReplicatedMap<int, int> > map = getNearCachedMapFromClient(newNearCacheConfig());


                int size = 1214;
                for (int i = 0; i < size; i++) {
                    map->put(i, i);
                }
// populate Near Cache
                for (int i = 0; i < size; i++) {
                    map->get(i);
                }

                for (int i = 0; i < size; i++) {
                    map->remove(i);
                }

                assertThatOwnedEntryCountEquals(*map, 0);
            }
        }
    }
}




namespace hazelcast {
    namespace client {

        namespace test {
            class ClientTopicTest : public ClientTestSupport {
            public:
                ClientTopicTest();

            protected:
                HazelcastServer instance;
                ClientConfig clientConfig;
                HazelcastClient client;
                ITopic<std::string> topic;
            };

            ClientTopicTest::ClientTopicTest() : instance(*g_srvFactory), client(getNewClient()),
                                                 topic(client.getTopic<std::string>("ClientTopicTest")) {
            }

            class MyMessageListener : public topic::MessageListener<std::string> {
            public:
                MyMessageListener(hazelcast::util::CountDownLatch &latch)
                        : latch(latch) {
                }

                void onMessage(std::unique_ptr<topic::Message<std::string> > &&message) {
                    latch.countDown();
                }

            private:
                hazelcast::util::CountDownLatch &latch;
            };

            TEST_F(ClientTopicTest, testTopicListeners) {
                hazelcast::util::CountDownLatch latch(10);
                MyMessageListener listener(latch);
                std::string id = topic.addMessageListener(listener);

                for (int i = 0; i < 10; i++) {
                    topic.publish(std::string("naber") + hazelcast::util::IOUtil::to_string(i));
                }
                ASSERT_TRUE(latch.await(20));
                topic.removeMessageListener(id);
            }
        }
    }
}





namespace hazelcast {
    namespace client {

        class HazelcastClient;

        namespace test {
            class MixedTopicTest : public ClientTestSupport {
            public:
                MixedTopicTest();

            protected:
                HazelcastServer instance;
                ClientConfig clientConfig;
                HazelcastClient client;
                mixedtype::ITopic topic;
            };

            class MixedMessageListener : public hazelcast::client::mixedtype::topic::MessageListener {
            public:
                MixedMessageListener(hazelcast::util::CountDownLatch &latch)
                        : latch(latch) {
                }

                void onMessage(std::unique_ptr<client::topic::Message<TypedData> > &&message) {
                    latch.countDown();
                }

            private:
                hazelcast::util::CountDownLatch &latch;
            };


            MixedTopicTest::MixedTopicTest()
                    : instance(*g_srvFactory), client(getNewClient()),
                      topic(client.toMixedType().getTopic("MixedTopicTest")) {
            }

            TEST_F(MixedTopicTest, testTopicListeners) {
                hazelcast::util::CountDownLatch latch(10);
                MixedMessageListener listener(latch);
                std::string id = topic.addMessageListener(listener);

                for (int i = 0; i < 10; i++) {
                    topic.publish<std::string>(std::string("naber") + hazelcast::util::IOUtil::to_string(i));
                }
                ASSERT_TRUE(latch.await(20));
                topic.removeMessageListener(id);
            }
        }
    }
}


//
// Created by hsan Demir on 19/05/15.
//

#ifndef HAZELCAST_CLIENT_TEST_PROTOCOL_PROTOCOLEXCEPTIONTEST_H
#define HAZELCAST_CLIENT_TEST_PROTOCOL_PROTOCOLEXCEPTIONTEST_H



namespace hazelcast {
    namespace client {
        namespace test {
            namespace protocol {
                TEST(ProtocolExceptionTest, testUndefinedErrorCodeException) {
                    int32_t undefinedError = client::protocol::SERVICE_NOT_FOUND + 1;
                    int64_t callId = 0x1122334455667788LL;
                    const std::string details = "This is the detail about the exception";
                    client::exception::UndefinedErrorCodeException exception("testUndefinedErrorCodeException",
                                                                             "this is a test", undefinedError, callId,
                                                                             details);
                    ASSERT_EQ(undefinedError, exception.getUndefinedErrorCode());
                    ASSERT_EQ(callId, exception.getMessageCallId());
                    ASSERT_EQ(details, exception.getDetailedErrorMessage());
                }
            }
        }
    }
}

#endif //HAZELCAST_CLIENT_TEST_PROTOCOL_PROTOCOLEXCEPTIONTEST_H



namespace hazelcast {
    namespace client {
        namespace test {
            namespace adaptor {
                class RawPointerSetTest : public ClientTestSupport {
                protected:
                    class MySetItemListener : public ItemListener<std::string> {
                    public:
                        MySetItemListener(hazelcast::util::CountDownLatch &latch)
                                :latch(latch) {

                        }

                        void itemAdded(const ItemEvent<std::string>& itemEvent) {
                            latch.countDown();
                        }

                        void itemRemoved(const ItemEvent<std::string>& item) {
                        }

                    private:
                        hazelcast::util::CountDownLatch &latch;
                    };

                    bool itemExists(const std::vector<std::string> &items, const std::string &item) const {
                        bool found = false;
                        for (std::vector<std::string>::const_iterator it = items.begin();it != items.end();++it) {
                            if (item == *it) {
                                found = true;
                                break;
                            }
                        }
                        return found;
                    }

                    virtual void TearDown() {
                        set->clear();
                    }

                    static void SetUpTestCase() {
                        instance = new HazelcastServer(*g_srvFactory);
                        client = new HazelcastClient(getConfig());
                        legacy = new ISet<std::string>(client->getSet<std::string>("MySet"));
                        set = new client::adaptor::RawPointerSet<std::string>(*legacy);
                    }

                    static void TearDownTestCase() {
                        delete set;
                        delete legacy;
                        delete client;
                        delete instance;

                        set = NULL;
                        legacy = NULL;
                        client = NULL;
                        instance = NULL;
                    }

                    static HazelcastServer *instance;
                    static HazelcastClient *client;
                    static ISet<std::string> *legacy;
                    static client::adaptor::RawPointerSet<std::string> *set;
                };

                HazelcastServer *RawPointerSetTest::instance = NULL;
                HazelcastClient *RawPointerSetTest::client = NULL;
                ISet<std::string> *RawPointerSetTest::legacy = NULL;
                client::adaptor::RawPointerSet<std::string> *RawPointerSetTest::set = NULL;

                TEST_F(RawPointerSetTest, testAddAll) {
                    std::vector<std::string> l;
                    l.push_back("item1");
                    l.push_back("item2");

                    ASSERT_TRUE(set->addAll(l));
                    ASSERT_EQ(2, set->size());

                    ASSERT_FALSE(set->addAll(l));
                    ASSERT_EQ(2, set->size());
                }

                TEST_F(RawPointerSetTest, testAddRemove) {
                    ASSERT_TRUE(set->add("item1"));
                    ASSERT_TRUE(set->add("item2"));
                    ASSERT_TRUE(set->add("item3"));
                    ASSERT_EQ(3, set->size());

                    ASSERT_FALSE(set->add("item3"));
                    ASSERT_EQ(3, set->size());


                    ASSERT_FALSE(set->remove("item4"));
                    ASSERT_TRUE(set->remove("item3"));

                }

                TEST_F(RawPointerSetTest, testContains) {
                    ASSERT_TRUE(set->add("item1"));
                    ASSERT_TRUE(set->add("item2"));
                    ASSERT_TRUE(set->add("item3"));
                    ASSERT_TRUE(set->add("item4"));

                    ASSERT_FALSE(set->contains("item5"));
                    ASSERT_TRUE(set->contains("item2"));

                    std::vector<std::string> l;
                    l.push_back("item6");
                    l.push_back("item3");

                    ASSERT_FALSE(set->containsAll(l));
                    ASSERT_TRUE(set->add("item6"));
                    ASSERT_TRUE(set->containsAll(l));
                }

                TEST_F(RawPointerSetTest, testToArray) {
                    ASSERT_TRUE(set->add("item1"));
                    ASSERT_TRUE(set->add("item2"));
                    ASSERT_TRUE(set->add("item3"));
                    ASSERT_TRUE(set->add("item4"));
                    ASSERT_FALSE(set->add("item4"));

                    std::unique_ptr<client::DataArray<std::string> > array = set->toArray();

                    ASSERT_EQ((size_t) 4, array->size());
                    std::vector<std::string> items;

                    for (size_t i = 0; i < array->size(); ++i) {
                        std::unique_ptr<std::string> item = array->release(i);
                        ASSERT_NE((std::string *) NULL, item.get());
                        items.push_back(*item);
                    }

                    ASSERT_TRUE(itemExists(items, "item1"));
                    ASSERT_TRUE(itemExists(items, "item2"));
                    ASSERT_TRUE(itemExists(items, "item3"));
                    ASSERT_TRUE(itemExists(items, "item4"));
                }

                TEST_F(RawPointerSetTest, testRemoveRetainAll) {
                    ASSERT_TRUE(set->add("item1"));
                    ASSERT_TRUE(set->add("item2"));
                    ASSERT_TRUE(set->add("item3"));
                    ASSERT_TRUE(set->add("item4"));

                    std::vector<std::string> l;
                    l.push_back("item4");
                    l.push_back("item3");

                    ASSERT_TRUE(set->removeAll(l));
                    ASSERT_EQ(2, set->size());
                    ASSERT_FALSE(set->removeAll(l));
                    ASSERT_EQ(2, set->size());

                    l.clear();
                    l.push_back("item1");
                    l.push_back("item2");
                    ASSERT_FALSE(set->retainAll(l));
                    ASSERT_EQ(2, set->size());

                    l.clear();
                    ASSERT_TRUE(set->retainAll(l));
                    ASSERT_EQ(0, set->size());
                }

                TEST_F(RawPointerSetTest, testListener) {
                    hazelcast::util::CountDownLatch latch(6);

                    MySetItemListener listener(latch);
                    std::string registrationId = set->addItemListener(listener, true);

                    for (int i = 0; i < 5; i++) {
                        set->add(std::string("item") + hazelcast::util::IOUtil::to_string(i));
                    }
                    set->add("done");

                    ASSERT_TRUE(latch.await(20));

                    ASSERT_TRUE(set->removeItemListener(registrationId));
                }
            }
        }
    }
}






namespace hazelcast {
    namespace client {
        namespace test {
            namespace adaptor {
                class RawPointerMapTest : public ClientTestSupport {
                protected:
                    class MapGetInterceptor : public serialization::IdentifiedDataSerializable {
                    public:
                        MapGetInterceptor(const std::string &prefix) : prefix(
                                std::unique_ptr<std::string>(new std::string(prefix))) {}

                        virtual int getFactoryId() const {
                            return 666;
                        }

                        virtual int getClassId() const {
                            return 6;
                        }

                        virtual void writeData(serialization::ObjectDataOutput &writer) const {
                            writer.writeUTF(prefix.get());
                        }

                        virtual void readData(serialization::ObjectDataInput &reader) {
                            prefix = reader.readUTF();
                        }

                    private:
                        std::unique_ptr<std::string> prefix;
                    };

                    /**
                     * This processor validates that the string value for the entry is the same as the test string
                     * "xyz123    "
                     */
                    class UTFValueValidatorProcessor : public serialization::IdentifiedDataSerializable {
                    public:
                        virtual int getFactoryId() const {
                            return 666;
                        }

                        virtual int getClassId() const {
                            return 9;
                        }

                        virtual void writeData(serialization::ObjectDataOutput &writer) const {
                        }

                        virtual void readData(serialization::ObjectDataInput &reader) {
                        }
                    };


                protected:
                    virtual void SetUp() {
                        legacyMap = new IMap<std::string, std::string>(
                                client->getMap<std::string, std::string>("RawPointerMapTest"));
                        imap = new client::adaptor::RawPointerMap<std::string, std::string>(*legacyMap);
                        legacyEmployees = new IMap<int, Employee>(client->getMap<int, Employee>("EmployeesMap"));
                        employees = new client::adaptor::RawPointerMap<int, Employee>(*legacyEmployees);
                        legacyIntMap = new IMap<int, int>(client->getMap<int, int>("legacyIntMap"));
                        intMap = new client::adaptor::RawPointerMap<int, int>(*legacyIntMap);
                    }

                    virtual void TearDown() {
                        // clear maps
                        legacyIntMap->destroy();
                        legacyEmployees->destroy();
                        legacyMap->destroy();
                    }

                    static void SetUpTestCase() {
#ifdef HZ_BUILD_WITH_SSL
                        sslFactory = new HazelcastServerFactory(g_srvFactory->getServerAddress(), getSslFilePath());
                        instance = new HazelcastServer(*sslFactory);
                        instance2 = new HazelcastServer(*sslFactory);
#else
                        instance = new HazelcastServer(*g_srvFactory);
                        instance2 = new HazelcastServer(*g_srvFactory);
#endif

                        ClientConfig clientConfig = getConfig();
#ifdef HZ_BUILD_WITH_SSL
                        config::SSLConfig sslConfig;
                        sslConfig.setEnabled(true).setProtocol(config::tlsv12).addVerifyFile(getCAFilePath());
                        clientConfig.getNetworkConfig().setSSLConfig(sslConfig);
#endif // HZ_BUILD_WITH_SSL
                        client = new HazelcastClient(clientConfig);
                    }

                    static void TearDownTestCase() {
                        delete intMap;
                        delete legacyIntMap;
                        delete employees;
                        delete legacyEmployees;
                        delete imap;
                        delete legacyMap;
                        delete client;
                        delete instance2;
                        delete instance;
                        delete sslFactory;

                        intMap = NULL;
                        legacyIntMap = NULL;
                        employees = NULL;
                        legacyEmployees = NULL;
                        imap = NULL;
                        legacyMap = NULL;
                        client = NULL;
                        instance2 = NULL;
                        instance = NULL;
                    }

                    void fillMap() {
                        for (int i = 0; i < 10; i++) {
                            std::string key = "key";
                            key += hazelcast::util::IOUtil::to_string(i);
                            std::string value = "value";
                            value += hazelcast::util::IOUtil::to_string(i);
                            imap->put(key, value);
                        }
                    }

                    static HazelcastServer *instance;
                    static HazelcastServer *instance2;
                    static HazelcastClient *client;
                    static client::adaptor::RawPointerMap<std::string, std::string> *imap;
                    static IMap<std::string, std::string> *legacyMap;
                    static IMap<int, Employee> *legacyEmployees;
                    static client::adaptor::RawPointerMap<int, Employee> *employees;
                    static IMap<int, int> *legacyIntMap;
                    static client::adaptor::RawPointerMap<int, int> *intMap;
                    static HazelcastServerFactory *sslFactory;
                };

                HazelcastServer *RawPointerMapTest::instance = NULL;
                HazelcastServer *RawPointerMapTest::instance2 = NULL;
                HazelcastClient *RawPointerMapTest::client = NULL;
                IMap<std::string, std::string> *RawPointerMapTest::legacyMap = NULL;
                client::adaptor::RawPointerMap<std::string, std::string> *RawPointerMapTest::imap = NULL;
                IMap<int, Employee> *RawPointerMapTest::legacyEmployees = NULL;
                client::adaptor::RawPointerMap<int, Employee> *RawPointerMapTest::employees = NULL;
                IMap<int, int> *RawPointerMapTest::legacyIntMap = NULL;
                client::adaptor::RawPointerMap<int, int> *RawPointerMapTest::intMap = NULL;
                HazelcastServerFactory *RawPointerMapTest::sslFactory = NULL;

                void tryPutThread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    client::adaptor::RawPointerMap<std::string, std::string> *imap = (client::adaptor::RawPointerMap<std::string, std::string> *) args.arg1;
                    bool result = imap->tryPut("key1", "value3", 1 * 1000);
                    if (!result) {
                        latch->countDown();
                    }
                }

                void tryRemoveThread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    client::adaptor::RawPointerMap<std::string, std::string> *imap = (client::adaptor::RawPointerMap<std::string, std::string> *) args.arg1;
                    bool result = imap->tryRemove("key2", 1 * 1000);
                    if (!result) {
                        latch->countDown();
                    }
                }

                void testLockThread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    client::adaptor::RawPointerMap<std::string, std::string> *imap = (client::adaptor::RawPointerMap<std::string, std::string> *) args.arg1;
                    imap->tryPut("key1", "value2", 1);
                    latch->countDown();
                }

                void testLockTTLThread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    client::adaptor::RawPointerMap<std::string, std::string> *imap = (client::adaptor::RawPointerMap<std::string, std::string> *) args.arg1;
                    imap->tryPut("key1", "value2", 5 * 1000);
                    latch->countDown();
                }

                void testLockTTL2Thread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    client::adaptor::RawPointerMap<std::string, std::string> *imap = (client::adaptor::RawPointerMap<std::string, std::string> *) args.arg1;
                    if (!imap->tryLock("key1")) {
                        latch->countDown();
                    }
                    if (imap->tryLock("key1", 5 * 1000)) {
                        latch->countDown();
                    }
                }

                void testMapTryLockThread1(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    client::adaptor::RawPointerMap<std::string, std::string> *imap = (client::adaptor::RawPointerMap<std::string, std::string> *) args.arg1;
                    if (!imap->tryLock("key1", 2)) {
                        latch->countDown();
                    }
                }

                void testMapTryLockThread2(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    client::adaptor::RawPointerMap<std::string, std::string> *imap = (client::adaptor::RawPointerMap<std::string, std::string> *) args.arg1;
                    if (imap->tryLock("key1", 20 * 1000)) {
                        latch->countDown();
                    }
                }

                void testMapForceUnlockThread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    client::adaptor::RawPointerMap<std::string, std::string> *imap = (client::adaptor::RawPointerMap<std::string, std::string> *) args.arg1;
                    imap->forceUnlock("key1");
                    latch->countDown();
                }

                template <typename K, typename V>
                class CountdownListener : public EntryAdapter<K, V> {
                public:
                    CountdownListener(hazelcast::util::CountDownLatch &addLatch, hazelcast::util::CountDownLatch &removeLatch,
                                      hazelcast::util::CountDownLatch &updateLatch, hazelcast::util::CountDownLatch &evictLatch)
                            : addLatch(addLatch), removeLatch(removeLatch), updateLatch(updateLatch),
                              evictLatch(evictLatch) {
                    }

                    void entryAdded(const EntryEvent<K, V> &event) {
                        addLatch.countDown();
                    }

                    void entryRemoved(const EntryEvent<K, V> &event) {
                        removeLatch.countDown();
                    }

                    void entryUpdated(const EntryEvent<K, V> &event) {
                        updateLatch.countDown();
                    }

                    void entryEvicted(const EntryEvent<K, V> &event) {
                        evictLatch.countDown();
                    }

                private:
                    hazelcast::util::CountDownLatch &addLatch;
                    hazelcast::util::CountDownLatch &removeLatch;
                    hazelcast::util::CountDownLatch &updateLatch;
                    hazelcast::util::CountDownLatch &evictLatch;
                };

                class MyListener : public EntryAdapter<std::string, std::string> {
                public:
                    MyListener(hazelcast::util::CountDownLatch &latch, hazelcast::util::CountDownLatch &nullLatch)
                            : latch(latch), nullLatch(nullLatch) {
                    }

                    void entryAdded(const EntryEvent<std::string, std::string> &event) {
                        latch.countDown();
                    }

                    void entryEvicted(const EntryEvent<std::string, std::string> &event) {
                        const std::string &oldValue = event.getOldValue();
                        if (oldValue.compare("")) {
                            nullLatch.countDown();
                        }
                        latch.countDown();
                    }

                private:
                    hazelcast::util::CountDownLatch &latch;
                    hazelcast::util::CountDownLatch &nullLatch;
                };

                class ClearListener : public EntryAdapter<std::string, std::string> {
                public:
                    ClearListener(hazelcast::util::CountDownLatch &latch) : latch(latch) {
                    }

                    void mapCleared(const MapEvent &event) {
                        latch.countDown();
                    }

                private:
                    hazelcast::util::CountDownLatch &latch;
                };

                class EvictListener : public EntryAdapter<std::string, std::string> {
                public:
                    EvictListener(hazelcast::util::CountDownLatch &latch) : latch(latch) {
                    }

                    void mapEvicted(const MapEvent &event) {
                        latch.countDown();
                    }

                private:
                    hazelcast::util::CountDownLatch &latch;
                };

                class SampleEntryListenerForPortableKey : public EntryAdapter<Employee, int> {
                public:
                    SampleEntryListenerForPortableKey(hazelcast::util::CountDownLatch &latch, hazelcast::util::AtomicInt &atomicInteger)
                            : latch(latch), atomicInteger(atomicInteger) {

                    }

                    void entryAdded(const EntryEvent<Employee, int> &event) {
                        ++atomicInteger;
                        latch.countDown();
                    }

                private:
                    hazelcast::util::CountDownLatch &latch;
                    hazelcast::util::AtomicInt &atomicInteger;
                };

                class EntryMultiplier : public serialization::IdentifiedDataSerializable {
                public:
                    EntryMultiplier(int multiplier) : multiplier(multiplier) { }

                    /**
                     * @return factory id
                     */
                    virtual int getFactoryId() const {
                        return 666;
                    }

                    /**
                     * @return class id
                     */
                    virtual int getClassId() const {
                        return 3;
                    }

                    /**
                     * Defines how this class will be written.
                     * @param writer ObjectDataOutput
                     */
                    void writeData(serialization::ObjectDataOutput &writer) const {
                        writer.writeInt(multiplier);
                    }

                    /**
                     *Defines how this class will be read.
                     * @param reader ObjectDataInput
                     */
                    void readData(serialization::ObjectDataInput &reader) {
                        multiplier = reader.readInt();
                    }

                    int getMultiplier() const {
                        return multiplier;
                    }

                private:
                    int multiplier;
                };


                class WaitMultiplierProcessor : public serialization::IdentifiedDataSerializable {
                public:
                    WaitMultiplierProcessor(int waitTime, int multiplier)
                            : waiTimeInMillis(waitTime), multiplier(multiplier) { }

                    /**
                     * @return factory id
                     */
                    int getFactoryId() const {
                        return 666;
                    }

                    /**
                     * @return class id
                     */
                    int getClassId() const {
                        return 8;
                    }

                    /**
                     * Defines how this class will be written.
                     * @param writer ObjectDataOutput
                     */
                    void writeData(serialization::ObjectDataOutput &writer) const {
                        writer.writeInt(waiTimeInMillis);
                        writer.writeInt(multiplier);
                    }

                    /**
                     *Defines how this class will be read.
                     * @param reader ObjectDataInput
                     */
                    void readData(serialization::ObjectDataInput &reader) {
                        waiTimeInMillis = reader.readInt();
                        multiplier = reader.readInt();
                    }

                    int getMultiplier() const {
                        return multiplier;
                    }

                private:
                    int waiTimeInMillis;
                    int multiplier;
                };

                class EntryMultiplierWithNullableResult : public EntryMultiplier {
                public:
                    EntryMultiplierWithNullableResult(int multiplier) : EntryMultiplier(multiplier) { }

                    virtual int getFactoryId() const {
                        return 666;
                    }

                    virtual int getClassId() const {
                        return 7;
                    }
                };

                TEST_F(RawPointerMapTest, testIssue537) {
                    hazelcast::util::CountDownLatch latch(2);
                    hazelcast::util::CountDownLatch nullLatch(1);
                    MyListener myListener(latch, nullLatch);
                    std::string id = imap->addEntryListener(myListener, true);

                    imap->put("key1", "value1", 2 * 1000);

                    ASSERT_TRUE(latch.await(10));
                    ASSERT_TRUE(nullLatch.await(1));

                    ASSERT_TRUE(imap->removeEntryListener(id));

                    imap->put("key2", "value2");
                    ASSERT_EQ(1, imap->size());
                }

                TEST_F(RawPointerMapTest, testContains) {
                    fillMap();

                    ASSERT_FALSE(imap->containsKey("key10"));
                    ASSERT_TRUE(imap->containsKey("key1"));

                    ASSERT_FALSE(imap->containsValue("value10"));
                    ASSERT_TRUE(imap->containsValue("value1"));

                }

                TEST_F(RawPointerMapTest, testGet) {
                    fillMap();
                    for (int i = 0; i < 10; i++) {
                        std::string key = "key";
                        key += hazelcast::util::IOUtil::to_string(i);
                        std::unique_ptr<std::string> temp = imap->get(key);

                        std::string value = "value";
                        value += hazelcast::util::IOUtil::to_string(i);
                        ASSERT_EQ(*temp, value);
                    }
                }

                TEST_F(RawPointerMapTest, testRemoveAndDelete) {
                    fillMap();
                    std::unique_ptr<std::string> temp = imap->remove("key10");
                    ASSERT_EQ(temp.get(), (std::string *) NULL);
                    imap->deleteEntry("key9");
                    ASSERT_EQ(imap->size(), 9);
                    for (int i = 0; i < 9; i++) {
                        std::string key = "key";
                        key += hazelcast::util::IOUtil::to_string(i);
                        std::unique_ptr<std::string> temp2 = imap->remove(key);
                        std::string value = "value";
                        value += hazelcast::util::IOUtil::to_string(i);
                        ASSERT_EQ(*temp2, value);
                    }
                    ASSERT_EQ(imap->size(), 0);
                }

                TEST_F(RawPointerMapTest, testRemoveIfSame) {
                    fillMap();

                    ASSERT_FALSE(imap->remove("key2", "value"));
                    ASSERT_EQ(10, imap->size());

                    ASSERT_TRUE((imap->remove("key2", "value2")));
                    ASSERT_EQ(9, imap->size());

                }

                TEST_F(RawPointerMapTest, testRemoveAll) {
                    fillMap();

                    imap->removeAll(
                            query::EqualPredicate<std::string>(query::QueryConstants::getKeyAttributeName(), "key5"));

                    std::unique_ptr<std::string> value = imap->get("key5");

                    ASSERT_NULL("key5 should not exist", value.get(), std::string);

                    query::LikePredicate likeAllValues(query::QueryConstants::getValueAttributeName(), "value%");

                    imap->removeAll(likeAllValues);

                    ASSERT_TRUE(imap->isEmpty());
                }


/**
                 * This failure with this test is reported at https://github.com/hazelcast/hazelcast-cpp-client/issues/379
                 * Do not forget to enable this test once the issue is resolved!!!
                 */
                TEST_F(RawPointerMapTest, DISABLED_testGetAllPutAll) {
                    std::map<std::string, std::string> mapTemp;

                    for (int i = 0; i < 100; i++) {
                        mapTemp[hazelcast::util::IOUtil::to_string(i)] = hazelcast::util::IOUtil::to_string(i);
                    }
                    imap->putAll(mapTemp);
                    ASSERT_EQ(imap->size(), 100);

                    for (int i = 0; i < 100; i++) {
                        std::string expected = hazelcast::util::IOUtil::to_string(i);
                        std::unique_ptr<std::string> actual = imap->get(hazelcast::util::IOUtil::to_string(i));
                        ASSERT_EQ(expected, *actual);
                    }

                    std::set<std::string> tempSet;
                    tempSet.insert(hazelcast::util::IOUtil::to_string(1));
                    tempSet.insert(hazelcast::util::IOUtil::to_string(3));

                    std::unique_ptr<hazelcast::client::EntryArray<std::string, std::string> > m2 = imap->getAll(
                            tempSet);

                    ASSERT_EQ(2U, m2->size());
                    std::unique_ptr<std::string> key1 = m2->releaseKey(0);
                    ASSERT_NE((std::string *) NULL, key1.get());
                    std::unique_ptr<std::string> value1 = m2->releaseValue(0);
                    ASSERT_NE((std::string *) NULL, value1.get());
                    ASSERT_EQ(*key1, *value1);
                    ASSERT_TRUE(*key1 == "1" || *key1 == "3");

                    std::pair<const std::string *, const std::string *> entry = (*m2)[1];
                    ASSERT_NE((std::string *) NULL, entry.first);
                    ASSERT_NE((std::string *) NULL, entry.second);
                    ASSERT_EQ(*entry.first, *entry.second);
                    ASSERT_TRUE(*entry.first == "1" || *entry.first == "3");
                    ASSERT_NE(*key1, *entry.first);
                }

                TEST_F(RawPointerMapTest, testTryPutRemove) {
                    ASSERT_TRUE(imap->tryPut("key1", "value1", 1 * 1000));
                    ASSERT_TRUE(imap->tryPut("key2", "value2", 1 * 1000));
                    imap->lock("key1");
                    imap->lock("key2");

                    hazelcast::util::CountDownLatch latch(2);

                    hazelcast::util::StartedThread t1(tryPutThread, &latch, imap);
                    hazelcast::util::StartedThread t2(tryRemoveThread, &latch, imap);

                    ASSERT_TRUE(latch.await(20));
                    ASSERT_EQ("value1", *(imap->get("key1")));
                    ASSERT_EQ("value2", *(imap->get("key2")));
                    imap->forceUnlock("key1");
                    imap->forceUnlock("key2");
                }

                TEST_F(RawPointerMapTest, testGetEntryViewForNonExistentData) {
                    std::unique_ptr<MapEntryView<std::string, std::string> > view = imap->getEntryView("non-existent");

                    ASSERT_EQ((MapEntryView<std::string, std::string> *) NULL, view.get());

// put an entry that will expire in 1 milliseconds
                    imap->put("short_entry", "short living value", 1);

                    ASSERT_EQ_EVENTUALLY((MapEntryView<std::string, std::string> *) NULL,
                                         (imap->getEntryView("short_entry").get()));
                }

                TEST_F(RawPointerMapTest, testPutTtl) {
                    hazelcast::util::CountDownLatch dummy(10);
                    hazelcast::util::CountDownLatch evict(1);
                    CountdownListener<std::string, std::string> sampleEntryListener(dummy, dummy, dummy, evict);
                    std::string id = imap->addEntryListener(sampleEntryListener, false);

                    imap->put("key1", "value1", 1000);
                    std::unique_ptr<std::string> temp = imap->get("key1");
// If the server response comes later than 1 second, the entry may have expired already.
                    if (temp.get()) {
                        ASSERT_EQ(*temp, "value1");
                    }
// trigger eviction
                    ASSERT_NULL_EVENTUALLY(imap->get("key1").get(), std::string);
                    ASSERT_TRUE(evict.await(5));

                    ASSERT_TRUE(imap->removeEntryListener(id));
                }

                TEST_F(RawPointerMapTest, testPutConfigTtl) {
                    IMap<std::string, std::string> oneSecMap = client->getMap<std::string, std::string>(
                            "OneSecondTtlMap");
                    hazelcast::client::adaptor::RawPointerMap<std::string, std::string> map(oneSecMap);
                    hazelcast::util::CountDownLatch dummy(10);
                    hazelcast::util::CountDownLatch evict(1);
                    CountdownListener<std::string, std::string> sampleEntryListener(dummy, dummy, dummy, evict);
                    std::string id = map.addEntryListener(sampleEntryListener, false);

                    map.put("key1", "value1");
                    std::unique_ptr<std::string> temp = map.get("key1");
// If the server response comes later than 1 second after put, the entry may have expired already.
                    if (temp.get()) {
                        ASSERT_EQ(*temp, "value1");
                    }
// trigger eviction
                    ASSERT_NULL_EVENTUALLY(map.get("key1").get(), std::string);
                    ASSERT_TRUE(evict.await(5));

                    ASSERT_TRUE(map.removeEntryListener(id));
                }

                TEST_F(RawPointerMapTest, testPutIfAbsent) {
                    std::unique_ptr<std::string> o = imap->putIfAbsent("key1", "value1");
                    ASSERT_EQ(o.get(), (std::string *) NULL);
                    ASSERT_EQ("value1", *(imap->putIfAbsent("key1", "value3")));
                }

                TEST_F(RawPointerMapTest, testPutIfAbsentTtl) {
                    ASSERT_EQ(imap->putIfAbsent("key1", "value1", 5000).get(), (std::string *) NULL);
                    ASSERT_EQ("value1", *(imap->putIfAbsent("key1", "value3", 5000)));

                    ASSERT_NULL_EVENTUALLY(imap->putIfAbsent("key1", "value3", 5000).get(), std::string);
                    ASSERT_EQ("value3", *(imap->putIfAbsent("key1", "value4", 5000)));
                }

                TEST_F(RawPointerMapTest, testSet) {
                    imap->set("key1", "value1");
                    ASSERT_EQ("value1", *(imap->get("key1")));

                    imap->set("key1", "value2");
                    ASSERT_EQ("value2", *(imap->get("key1")));

                    imap->set("key1", "value3", 1000);
                    ASSERT_EQ("value3", *(imap->get("key1")));

                    ASSERT_NULL_EVENTUALLY(imap->get("key1").get(), std::string);
                }

                TEST_F(RawPointerMapTest, testSetTtl) {
                    IMap<std::string, std::string> oneSecMap = client->getMap<std::string, std::string>(
                            getTestName());
                    hazelcast::client::adaptor::RawPointerMap<std::string, std::string> map(oneSecMap);
                    hazelcast::util::CountDownLatch dummy(10);
                    hazelcast::util::CountDownLatch evict(1);
                    CountdownListener<std::string, std::string> sampleEntryListener(dummy, dummy, dummy, evict);
                    std::string id = map.addEntryListener(sampleEntryListener, false);

                    map.set("key1", "value1", 1000);
                    std::unique_ptr<std::string> temp = map.get("key1");
// If the server response comes later than 1 second, the entry may have expired already.
                    if (temp.get()) {
                        ASSERT_EQ(*temp, "value1");
                    }
// trigger eviction
                    ASSERT_NULL_EVENTUALLY(map.get("key1").get(), std::string);
                    ASSERT_TRUE(evict.await(5));

                    ASSERT_TRUE(map.removeEntryListener(id));
                }

                TEST_F(RawPointerMapTest, testSetConfigTtl) {
                    IMap<std::string, std::string> oneSecMap = client->getMap<std::string, std::string>(
                            "OneSecondTtlMap");
                    hazelcast::client::adaptor::RawPointerMap<std::string, std::string> map(oneSecMap);
                    hazelcast::util::CountDownLatch dummy(10);
                    hazelcast::util::CountDownLatch evict(1);
                    CountdownListener<std::string, std::string> sampleEntryListener(dummy, dummy, dummy, evict);
                    std::string id = map.addEntryListener(sampleEntryListener, false);

                    map.set("key1", "value1");
                    std::unique_ptr<std::string> temp = map.get("key1");
// If the server response comes later than 1 second, the entry may have expired already.
                    if (temp.get()) {
                        ASSERT_EQ(*temp, "value1");
                    }
// trigger eviction
                    ASSERT_NULL_EVENTUALLY(map.get("key1").get(), std::string);
                    ASSERT_TRUE(evict.await(5));

                    ASSERT_TRUE(map.removeEntryListener(id));
                }

                TEST_F(RawPointerMapTest, testLock) {
                    imap->put("key1", "value1");
                    ASSERT_EQ("value1", *(imap->get("key1")));
                    imap->lock("key1");
                    hazelcast::util::CountDownLatch latch(1);
                    hazelcast::util::StartedThread t1(testLockThread, &latch, imap);
                    ASSERT_TRUE(latch.await(5));
                    ASSERT_EQ("value1", *(imap->get("key1")));
                    imap->forceUnlock("key1");

                }

                TEST_F(RawPointerMapTest, testLockTtl) {
                    imap->put("key1", "value1");
                    ASSERT_EQ("value1", *(imap->get("key1")));
                    imap->lock("key1", 2 * 1000);
                    hazelcast::util::CountDownLatch latch(1);
                    hazelcast::util::StartedThread t1(testLockTTLThread, &latch, imap);
                    ASSERT_TRUE(latch.await(10));
                    ASSERT_FALSE(imap->isLocked("key1"));
                    ASSERT_EQ("value2", *(imap->get("key1")));
                    imap->forceUnlock("key1");

                }

                TEST_F(RawPointerMapTest, testLockTtl2) {
                    imap->lock("key1", 3 * 1000);
                    hazelcast::util::CountDownLatch latch(2);
                    hazelcast::util::StartedThread t1(testLockTTL2Thread, &latch, imap);
                    ASSERT_TRUE(latch.await(10));
                    imap->forceUnlock("key1");

                }

                TEST_F(RawPointerMapTest, testTryLock) {

                    ASSERT_TRUE(imap->tryLock("key1", 2 * 1000));
                    hazelcast::util::CountDownLatch latch(1);
                    hazelcast::util::StartedThread t1(testMapTryLockThread1, &latch, imap);

                    ASSERT_TRUE(latch.await(100));

                    ASSERT_TRUE(imap->isLocked("key1"));

                    hazelcast::util::CountDownLatch latch2(1);
                    hazelcast::util::StartedThread t2(testMapTryLockThread2, &latch2, imap);

                    hazelcast::util::sleep(1);
                    imap->unlock("key1");
                    ASSERT_TRUE(latch2.await(100));
                    ASSERT_TRUE(imap->isLocked("key1"));
                    imap->forceUnlock("key1");

                }

                TEST_F(RawPointerMapTest, testForceUnlock) {
                    imap->lock("key1");
                    hazelcast::util::CountDownLatch latch(1);
                    hazelcast::util::StartedThread t2(testMapForceUnlockThread, &latch, imap);
                    ASSERT_TRUE(latch.await(100));
                    t2.join();
                    ASSERT_FALSE(imap->isLocked("key1"));

                }

                TEST_F(RawPointerMapTest, testValues) {

                    fillMap();
                    query::SqlPredicate predicate("this == value1");
                    std::unique_ptr<hazelcast::client::DataArray<std::string> > tempVector = imap->values(predicate);
                    ASSERT_EQ(1U, tempVector->size());

                    ASSERT_EQ("value1", *tempVector->get(0));
                }

                TEST_F(RawPointerMapTest, testValuesWithPredicate) {
                    const int numItems = 20;
                    for (int i = 0; i < numItems; ++i) {
                        intMap->put(i, 2 * i);
                    }

                    std::unique_ptr<DataArray<int> > values = intMap->values();
                    ASSERT_EQ(numItems, (int) values->size());
                    std::vector<int> actualValues;
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems; ++i) {
                        ASSERT_EQ(2 * i, actualValues[i]);
                    }

// EqualPredicate
// key == 5
                    values = intMap->values(
                            query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5));
                    ASSERT_EQ(1, (int) values->size());
                    ASSERT_NE((const int *) NULL, (*values)[0]);
                    ASSERT_EQ(2 * 5, *((*values)[0]));

// value == 8
                    values = intMap->values(
                            query::EqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 8));
                    ASSERT_EQ(1, (int) values->size());
                    ASSERT_NE((const int *) NULL, (*values)[0]);
                    ASSERT_EQ(8, *((*values)[0]));

// key == numItems
                    values = intMap->values(
                            query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), numItems));
                    ASSERT_EQ(0, (int) values->size());

// NotEqual Predicate
// key != 5
                    values = intMap->values(
                            query::NotEqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5));
                    ASSERT_EQ(numItems - 1, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems - 1; ++i) {
                        if (i >= 5) {
                            ASSERT_EQ(2 * (i + 1), actualValues[i]);
                        } else {
                            ASSERT_EQ(2 * i, actualValues[i]);
                        }
                    }

// this(value) != 8
                    values = intMap->values(
                            query::NotEqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 8));
                    ASSERT_EQ(numItems - 1, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems - 1; ++i) {
                        if (i >= 4) {
                            ASSERT_EQ(2 * (i + 1), actualValues[i]);
                        } else {
                            ASSERT_EQ(2 * i, actualValues[i]);
                        }
                    }

// TruePredicate
                    values = intMap->values(query::TruePredicate());
                    ASSERT_EQ(numItems, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems; ++i) {
                        ASSERT_EQ(2 * i, actualValues[i]);
                    }

// FalsePredicate
                    values = intMap->values(query::FalsePredicate());
                    ASSERT_EQ(0, (int) values->size());

// BetweenPredicate
// 5 <= key <= 10
                    values = intMap->values(
                            query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                    ASSERT_EQ(6, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 6; ++i) {
                        ASSERT_EQ(2 * (i + 5), actualValues[i]);
                    }

// 20 <= key <=30
                    values = intMap->values(
                            query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 20, 30));
                    ASSERT_EQ(0, (int) values->size());

// GreaterLessPredicate
// value <= 10
                    values = intMap->values(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 10, true,
                                                             true));
                    ASSERT_EQ(6, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 6; ++i) {
                        ASSERT_EQ(2 * i, actualValues[i]);
                    }

// key < 7
                    values = intMap->values(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 7, false,
                                                             true));
                    ASSERT_EQ(7, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 7; ++i) {
                        ASSERT_EQ(2 * i, actualValues[i]);
                    }

// value >= 15
                    values = intMap->values(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 15, true,
                                                             false));
                    ASSERT_EQ(12, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 12; ++i) {
                        ASSERT_EQ(2 * (i + 8), actualValues[i]);
                    }

// key > 5
                    values = intMap->values(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, false,
                                                             false));
                    ASSERT_EQ(14, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 14; ++i) {
                        ASSERT_EQ(2 * (i + 6), actualValues[i]);
                    }

// InPredicate
// key in {4, 10, 19}
                    std::vector<int> inVals(3);
                    inVals[0] = 4;
                    inVals[1] = 10;
                    inVals[2] = 19;
                    values = intMap->values(
                            query::InPredicate<int>(query::QueryConstants::getKeyAttributeName(), inVals));
                    ASSERT_EQ(3, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    ASSERT_EQ(2 * 4, actualValues[0]);
                    ASSERT_EQ(2 * 10, actualValues[1]);
                    ASSERT_EQ(2 * 19, actualValues[2]);

// value in {4, 10, 19}
                    values = intMap->values(
                            query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                    ASSERT_EQ(2, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    ASSERT_EQ(4, actualValues[0]);
                    ASSERT_EQ(10, actualValues[1]);

// InstanceOfPredicate
// value instanceof Integer
                    values = intMap->values(query::InstanceOfPredicate("java.lang.Integer"));
                    ASSERT_EQ(20, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems; ++i) {
                        ASSERT_EQ(2 * i, actualValues[i]);
                    }

                    values = intMap->values(query::InstanceOfPredicate("java.lang.String"));
                    ASSERT_EQ(0, (int) values->size());

// NotPredicate
// !(5 <= key <= 10)
                    std::unique_ptr<query::Predicate> bp = std::unique_ptr<query::Predicate>(
                            new query::BetweenPredicate<int>(
                                    query::QueryConstants::getKeyAttributeName(), 5, 10));
                    query::NotPredicate notPredicate(bp);
                    values = intMap->values(notPredicate);
                    ASSERT_EQ(14, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 14; ++i) {
                        if (i >= 5) {
                            ASSERT_EQ(2 * (i + 6), actualValues[i]);
                        } else {
                            ASSERT_EQ(2 * i, actualValues[i]);
                        }
                    }

// AndPredicate
// 5 <= key <= 10 AND Values in {4, 10, 19} = values {4, 10}
                    bp = std::unique_ptr<query::Predicate>(
                            new query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                    std::unique_ptr<query::Predicate> inPred = std::unique_ptr<query::Predicate>(
                            new query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                    values = intMap->values(query::AndPredicate().add(bp).add(inPred));
                    ASSERT_EQ(1, (int) values->size());
                    ASSERT_EQ(10, *(values->release(0)));

// OrPredicate
// 5 <= key <= 10 OR Values in {4, 10, 19} = values {4, 10, 12, 14, 16, 18, 20}
                    bp = std::unique_ptr<query::Predicate>(
                            new query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                    inPred = std::unique_ptr<query::Predicate>(
                            new query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                    values = intMap->values(query::OrPredicate().add(bp).add(inPred));
                    ASSERT_EQ(7, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    ASSERT_EQ(4, actualValues[0]);
                    ASSERT_EQ(10, actualValues[1]);
                    ASSERT_EQ(12, actualValues[2]);
                    ASSERT_EQ(14, actualValues[3]);
                    ASSERT_EQ(16, actualValues[4]);
                    ASSERT_EQ(18, actualValues[5]);
                    ASSERT_EQ(20, actualValues[6]);

                    for (int i = 0; i < 12; i++) {
                        std::string key = "key";
                        key += hazelcast::util::IOUtil::to_string(i);
                        std::string value = "value";
                        value += hazelcast::util::IOUtil::to_string(i);
                        imap->put(key, value);
                    }
                    imap->put("key_111_test", "myvalue_111_test");
                    imap->put("key_22_test", "myvalue_22_test");

// LikePredicate
// value LIKE "value1" : {"value1"}
                    std::unique_ptr<DataArray<std::string> > strValues = imap->keySet(
                            query::LikePredicate(query::QueryConstants::getValueAttributeName(), "value1"));
                    ASSERT_EQ(1, (int) strValues->size());
                    ASSERT_NE((const std::string *) NULL, strValues->get(0));
                    ASSERT_EQ("key1", *strValues->get(0));

// ILikePredicate
// value ILIKE "%VALue%1%" : {"myvalue_111_test", "value1", "value10", "value11"}
                    strValues = imap->keySet(
                            query::ILikePredicate(query::QueryConstants::getValueAttributeName(), "%VALue%1%"));
                    ASSERT_EQ(4, (int) strValues->size());
                    std::vector<std::string> actualStrs;
                    for (int i = 0; i < (int) strValues->size(); ++i) {
                        ASSERT_NE((const std::string *) NULL, strValues->get(i));
                        actualStrs.push_back(*strValues->get(i));
                    }
                    std::sort(actualStrs.begin(), actualStrs.end());
                    ASSERT_EQ("key1", actualStrs[0]);
                    ASSERT_EQ("key10", actualStrs[1]);
                    ASSERT_EQ("key11", actualStrs[2]);
                    ASSERT_EQ("key_111_test", actualStrs[3]);

// value ILIKE "%VAL%2%" : {"myvalue_22_test", "value2"}
                    strValues = imap->keySet(
                            query::ILikePredicate(query::QueryConstants::getValueAttributeName(), "%VAL%2%"));
                    ASSERT_EQ(2, (int) strValues->size());
                    actualStrs.clear();
                    for (int i = 0; i < (int) strValues->size(); ++i) {
                        ASSERT_NE((const std::string *) NULL, strValues->get(i));
                        actualStrs.push_back(*strValues->get(i));
                    }
                    std::sort(actualStrs.begin(), actualStrs.end());
                    ASSERT_EQ("key2", actualStrs[0]);
                    ASSERT_EQ("key_22_test", actualStrs[1]);

// SqlPredicate
// __key BETWEEN 4 and 7 : {4, 5, 6, 7} -> {8, 10, 12, 14}
                    char sql[100];
                    hazelcast::util::hz_snprintf(sql, 50, "%s BETWEEN 4 and 7",
                                                 query::QueryConstants::getKeyAttributeName());
                    values = intMap->values(query::SqlPredicate(sql));
                    ASSERT_EQ(4, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 4; ++i) {
                        ASSERT_EQ(2 * (i + 4), actualValues[i]);
                    }

// RegexPredicate
// value matches the regex ".*value.*2.*" : {myvalue_22_test, value2}
                    strValues = imap->keySet(
                            query::RegexPredicate(query::QueryConstants::getValueAttributeName(), ".*value.*2.*"));
                    ASSERT_EQ(2, (int) strValues->size());
                    actualStrs.clear();
                    for (int i = 0; i < (int) strValues->size(); ++i) {
                        ASSERT_NE((const std::string *) NULL, strValues->get(i));
                        actualStrs.push_back(*strValues->get(i));
                    }
                    std::sort(actualStrs.begin(), actualStrs.end());
                    ASSERT_EQ("key2", actualStrs[0]);
                    ASSERT_EQ("key_22_test", actualStrs[1]);
                }

                TEST_F(RawPointerMapTest, testValuesWithPagingPredicate) {
                    int predSize = 5;
                    const int totalEntries = 25;

                    for (int i = 0; i < totalEntries; ++i) {
                        intMap->put(i, i);
                    }

                    query::PagingPredicate<int, int> predicate((size_t) predSize);

                    std::unique_ptr<DataArray<int> > values = intMap->values(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(i, *values->get(i));
                    }

                    values = intMap->values(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(i, *values->get(i));
                    }

                    predicate.nextPage();
                    values = intMap->values(predicate);
                    ASSERT_EQ(predSize, (int) values->size());

                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(predSize + i, *values->get(i));
                    }

                    const std::pair<int *, int *> *anchor = predicate.getAnchor();
                    ASSERT_NE((const std::pair<int *, int *> *) NULL, anchor);
                    ASSERT_NE((int *) NULL, anchor->first);
                    ASSERT_NE((int *) NULL, anchor->second);
                    ASSERT_EQ(9, *anchor->first);
                    ASSERT_EQ(9, *anchor->second);

                    ASSERT_EQ(1, (int) predicate.getPage());

                    predicate.setPage(4);

                    values = intMap->values(predicate);
                    ASSERT_EQ(predSize, (int) values->size());

                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(predSize * 4 + i, *values->get(i));
                    }

                    anchor = predicate.getAnchor();
                    ASSERT_NE((const std::pair<int *, int *> *) NULL, anchor);
                    ASSERT_NE((int *) NULL, anchor->first);
                    ASSERT_NE((int *) NULL, anchor->second);
                    ASSERT_EQ(24, *anchor->first);
                    ASSERT_EQ(24, *anchor->second);

                    const std::pair<size_t, std::pair<int *, int *> > *anchorEntry = predicate.getNearestAnchorEntry();
                    ASSERT_NE((const std::pair<size_t, std::pair<int *, int *> > *) NULL, anchorEntry);
                    ASSERT_NE((int *) NULL, anchorEntry->second.first);
                    ASSERT_NE((int *) NULL, anchorEntry->second.second);
                    ASSERT_EQ(3, (int) anchorEntry->first);
                    ASSERT_EQ(19, *anchorEntry->second.first);
                    ASSERT_EQ(19, *anchorEntry->second.second);

                    predicate.nextPage();
                    values = intMap->values(predicate);
                    ASSERT_EQ(0, (int) values->size());

                    predicate.setPage(0);
                    values = intMap->values(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(i, *values->get(i));
                    }

                    predicate.previousPage();
                    ASSERT_EQ(0, (int) predicate.getPage());

                    predicate.setPage(5);
                    values = intMap->values(predicate);
                    ASSERT_EQ(0, (int) values->size());

                    predicate.setPage(3);
                    values = intMap->values(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(3 * predSize + i, *values->get(i));
                    }

                    predicate.previousPage();
                    values = intMap->values(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(2 * predSize + i, *values->get(i));
                    }

// test PagingPredicate with inner predicate (value < 10)
                    std::unique_ptr<query::Predicate> lessThanTenPredicate(std::unique_ptr<query::Predicate>(
                            new query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 9,
                                                                 false,
                                                                 true)));
                    query::PagingPredicate<int, int> predicate2(lessThanTenPredicate, 5);
                    values = intMap->values(predicate2);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(i, *values->get(i));
                    }

                    predicate2.nextPage();
// match values 5,6, 7, 8
                    values = intMap->values(predicate2);
                    ASSERT_EQ(predSize - 1, (int) values->size());
                    for (int i = 0; i < predSize - 1; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(predSize + i, *values->get(i));
                    }

                    predicate2.nextPage();
                    values = intMap->values(predicate2);
                    ASSERT_EQ(0, (int) values->size());

// test paging predicate with comparator
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);
                    Employee empl4("ali", 33);
                    Employee empl5("veli", 44);
                    Employee empl6("aylin", 5);

                    employees->put(3, empl1);
                    employees->put(4, empl2);
                    employees->put(5, empl3);
                    employees->put(6, empl4);
                    employees->put(7, empl5);
                    employees->put(8, empl6);

                    predSize = 2;
                    query::PagingPredicate<int, Employee> predicate3(
                            std::unique_ptr<query::EntryComparator<int, Employee> >(new EmployeeEntryComparator()),
                            (size_t) predSize);
                    std::unique_ptr<DataArray<Employee> > result = employees->values(predicate3);
                    ASSERT_EQ(2, (int) result->size());
                    ASSERT_NE((const Employee *) NULL, (*result)[0]);
                    ASSERT_NE((const Employee *) NULL, (*result)[1]);
                    ASSERT_EQ(empl6, *((*result)[0]));
                    ASSERT_EQ(empl2, *result->get(1));

                    predicate3.nextPage();
                    result = employees->values(predicate3);
                    ASSERT_EQ(2, (int) result->size());
                    ASSERT_NE((const Employee *) NULL, (*result)[0]);
                    ASSERT_NE((const Employee *) NULL, (*result)[1]);
                    ASSERT_EQ(empl3, *((*result)[0]));
                    ASSERT_EQ(empl4, *result->get(1));
                }

                TEST_F(RawPointerMapTest, testKeySetWithPredicate) {
                    const int numItems = 20;
                    for (int i = 0; i < numItems; ++i) {
                        intMap->put(i, 2 * i);
                    }

                    std::unique_ptr<DataArray<int> > values = intMap->keySet();
                    ASSERT_EQ(numItems, (int) values->size());
                    std::vector<int> actualValues;
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems; ++i) {
                        ASSERT_EQ(i, actualValues[i]);
                    }

// EqualPredicate
// key == 5
                    values = intMap->keySet(
                            query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5));
                    ASSERT_EQ(1, (int) values->size());
                    ASSERT_NE((const int *) NULL, (*values)[0]);
                    ASSERT_EQ(5, *((*values)[0]));

// value == 8
                    values = intMap->keySet(
                            query::EqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 8));
                    ASSERT_EQ(1, (int) values->size());
                    ASSERT_NE((const int *) NULL, (*values)[0]);
                    ASSERT_EQ(4, *((*values)[0]));

// key == numItems
                    values = intMap->keySet(
                            query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), numItems));
                    ASSERT_EQ(0, (int) values->size());

// NotEqual Predicate
// key != 5
                    values = intMap->keySet(
                            query::NotEqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5));
                    ASSERT_EQ(numItems - 1, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems - 1; ++i) {
                        if (i >= 5) {
                            ASSERT_EQ((i + 1), actualValues[i]);
                        } else {
                            ASSERT_EQ(i, actualValues[i]);
                        }
                    }

// this(value) != 8
                    values = intMap->keySet(
                            query::NotEqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 8));
                    ASSERT_EQ(numItems - 1, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems - 1; ++i) {
                        if (i >= 4) {
                            ASSERT_EQ((i + 1), actualValues[i]);
                        } else {
                            ASSERT_EQ(i, actualValues[i]);
                        }
                    }

// TruePredicate
                    values = intMap->keySet(query::TruePredicate());
                    ASSERT_EQ(numItems, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems; ++i) {
                        ASSERT_EQ(i, actualValues[i]);
                    }

// FalsePredicate
                    values = intMap->keySet(query::FalsePredicate());
                    ASSERT_EQ(0, (int) values->size());

// BetweenPredicate
// 5 <= key <= 10
                    values = intMap->keySet(
                            query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                    ASSERT_EQ(6, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 6; ++i) {
                        ASSERT_EQ((i + 5), actualValues[i]);
                    }

// 20 <= key <=30
                    values = intMap->keySet(
                            query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 20, 30));
                    ASSERT_EQ(0, (int) values->size());

// GreaterLessPredicate
// value <= 10
                    values = intMap->keySet(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 10, true,
                                                             true));
                    ASSERT_EQ(6, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 6; ++i) {
                        ASSERT_EQ(i, actualValues[i]);
                    }

// key < 7
                    values = intMap->keySet(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 7, false,
                                                             true));
                    ASSERT_EQ(7, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 7; ++i) {
                        ASSERT_EQ(i, actualValues[i]);
                    }

// value >= 15
                    values = intMap->keySet(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 15, true,
                                                             false));
                    ASSERT_EQ(12, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 12; ++i) {
                        ASSERT_EQ((i + 8), actualValues[i]);
                    }

// key > 5
                    values = intMap->keySet(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, false,
                                                             false));
                    ASSERT_EQ(14, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 14; ++i) {
                        ASSERT_EQ((i + 6), actualValues[i]);
                    }

// InPredicate
// key in {4, 10, 19}
                    std::vector<int> inVals(3);
                    inVals[0] = 4;
                    inVals[1] = 10;
                    inVals[2] = 19;
                    values = intMap->keySet(
                            query::InPredicate<int>(query::QueryConstants::getKeyAttributeName(), inVals));
                    ASSERT_EQ(3, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    ASSERT_EQ(4, actualValues[0]);
                    ASSERT_EQ(10, actualValues[1]);
                    ASSERT_EQ(19, actualValues[2]);

// value in {4, 10, 19}
                    values = intMap->keySet(
                            query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                    ASSERT_EQ(2, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    ASSERT_EQ(2, actualValues[0]);
                    ASSERT_EQ(5, actualValues[1]);

// InstanceOfPredicate
// value instanceof Integer
                    values = intMap->keySet(query::InstanceOfPredicate("java.lang.Integer"));
                    ASSERT_EQ(20, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems; ++i) {
                        ASSERT_EQ(i, actualValues[i]);
                    }

                    values = intMap->keySet(query::InstanceOfPredicate("java.lang.String"));
                    ASSERT_EQ(0, (int) values->size());

// NotPredicate
// !(5 <= key <= 10)
                    std::unique_ptr<query::Predicate> bp = std::unique_ptr<query::Predicate>(
                            new query::BetweenPredicate<int>(
                                    query::QueryConstants::getKeyAttributeName(), 5, 10));
                    query::NotPredicate notPredicate(bp);
                    values = intMap->keySet(notPredicate);
                    ASSERT_EQ(14, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 14; ++i) {
                        if (i >= 5) {
                            ASSERT_EQ((i + 6), actualValues[i]);
                        } else {
                            ASSERT_EQ(i, actualValues[i]);
                        }
                    }

// AndPredicate
// 5 <= key <= 10 AND Values in {4, 10, 19} = values {4, 10}
                    bp = std::unique_ptr<query::Predicate>(
                            new query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                    std::unique_ptr<query::Predicate> inPred = std::unique_ptr<query::Predicate>(
                            new query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                    values = intMap->keySet(query::AndPredicate().add(bp).add(inPred));
                    ASSERT_EQ(1, (int) values->size());
                    ASSERT_EQ(5, *(values->release(0)));

// OrPredicate
// 5 <= key <= 10 OR Values in {4, 10, 19} = values {4, 10, 12, 14, 16, 18, 20}
                    bp = std::unique_ptr<query::Predicate>(
                            new query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                    inPred = std::unique_ptr<query::Predicate>(
                            new query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                    values = intMap->keySet(query::OrPredicate().add(bp).add(inPred));
                    ASSERT_EQ(7, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    ASSERT_EQ(2, actualValues[0]);
                    ASSERT_EQ(5, actualValues[1]);
                    ASSERT_EQ(6, actualValues[2]);
                    ASSERT_EQ(7, actualValues[3]);
                    ASSERT_EQ(8, actualValues[4]);
                    ASSERT_EQ(9, actualValues[5]);
                    ASSERT_EQ(10, actualValues[6]);

                    for (int i = 0; i < 12; i++) {
                        std::string key = "key";
                        key += hazelcast::util::IOUtil::to_string(i);
                        std::string value = "value";
                        value += hazelcast::util::IOUtil::to_string(i);
                        imap->put(key, value);
                    }
                    imap->put("key_111_test", "myvalue_111_test");
                    imap->put("key_22_test", "myvalue_22_test");

// LikePredicate
// value LIKE "value1" : {"value1"}
                    std::unique_ptr<DataArray<std::string> > strValues = imap->keySet(
                            query::LikePredicate(query::QueryConstants::getValueAttributeName(), "value1"));
                    ASSERT_EQ(1, (int) strValues->size());
                    ASSERT_NE((const std::string *) NULL, strValues->get(0));
                    ASSERT_EQ("key1", *strValues->get(0));

// ILikePredicate
// value ILIKE "%VALue%1%" : {"key_111_test", "key1", "key10", "key11"}
                    strValues = imap->keySet(
                            query::ILikePredicate(query::QueryConstants::getValueAttributeName(), "%VALue%1%"));
                    ASSERT_EQ(4, (int) strValues->size());
                    std::vector<std::string> actualStrs;
                    for (int i = 0; i < (int) strValues->size(); ++i) {
                        ASSERT_NE((const std::string *) NULL, strValues->get(i));
                        actualStrs.push_back(*strValues->get(i));
                    }
                    std::sort(actualStrs.begin(), actualStrs.end());
                    ASSERT_EQ("key1", actualStrs[0]);
                    ASSERT_EQ("key10", actualStrs[1]);
                    ASSERT_EQ("key11", actualStrs[2]);
                    ASSERT_EQ("key_111_test", actualStrs[3]);

// value ILIKE "%VAL%2%" : {"key_22_test", "key2"}
                    strValues = imap->keySet(
                            query::ILikePredicate(query::QueryConstants::getValueAttributeName(), "%VAL%2%"));
                    ASSERT_EQ(2, (int) strValues->size());
                    actualStrs.clear();
                    for (int i = 0; i < (int) strValues->size(); ++i) {
                        ASSERT_NE((const std::string *) NULL, strValues->get(i));
                        actualStrs.push_back(*strValues->get(i));
                    }
                    std::sort(actualStrs.begin(), actualStrs.end());
                    ASSERT_EQ("key2", actualStrs[0]);
                    ASSERT_EQ("key_22_test", actualStrs[1]);

// SqlPredicate
// __key BETWEEN 4 and 7 : {4, 5, 6, 7} -> {8, 10, 12, 14}
                    char sql[100];
                    hazelcast::util::hz_snprintf(sql, 50, "%s BETWEEN 4 and 7",
                                                 query::QueryConstants::getKeyAttributeName());
                    values = intMap->keySet(query::SqlPredicate(sql));
                    ASSERT_EQ(4, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 4; ++i) {
                        ASSERT_EQ(i + 4, actualValues[i]);
                    }

// RegexPredicate
// value matches the regex ".*value.*2.*" : {myvalue_22_test, value2}
                    strValues = imap->keySet(
                            query::RegexPredicate(query::QueryConstants::getValueAttributeName(), ".*value.*2.*"));
                    ASSERT_EQ(2, (int) strValues->size());
                    actualStrs.clear();
                    for (int i = 0; i < (int) strValues->size(); ++i) {
                        ASSERT_NE((const std::string *) NULL, strValues->get(i));
                        actualStrs.push_back(*strValues->get(i));
                    }
                    std::sort(actualStrs.begin(), actualStrs.end());
                    ASSERT_EQ("key2", actualStrs[0]);
                    ASSERT_EQ("key_22_test", actualStrs[1]);
                }

                TEST_F(RawPointerMapTest, testKeySetWithPagingPredicate) {
                    int predSize = 5;
                    const int totalEntries = 25;

                    for (int i = 0; i < totalEntries; ++i) {
                        intMap->put(i, i);
                    }

                    query::PagingPredicate<int, int> predicate((size_t) predSize);

                    std::unique_ptr<DataArray<int> > values = intMap->keySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(i, *values->get(i));
                    }

                    values = intMap->keySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(i, *values->get(i));
                    }

                    predicate.nextPage();
                    values = intMap->keySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());

                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(predSize + i, *values->get(i));
                    }

                    const std::pair<int *, int *> *anchor = predicate.getAnchor();
                    ASSERT_NE((const std::pair<int *, int *> *) NULL, anchor);
                    ASSERT_NE((int *) NULL, anchor->first);
                    ASSERT_EQ(9, *anchor->first);

                    ASSERT_EQ(1, (int) predicate.getPage());

                    predicate.setPage(4);

                    values = intMap->keySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());

                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(predSize * 4 + i, *values->get(i));
                    }

                    anchor = predicate.getAnchor();
                    ASSERT_NE((const std::pair<int *, int *> *) NULL, anchor);
                    ASSERT_NE((int *) NULL, anchor->first);
                    ASSERT_EQ(24, *anchor->first);

                    const std::pair<size_t, std::pair<int *, int *> > *anchorEntry = predicate.getNearestAnchorEntry();
                    ASSERT_NE((const std::pair<size_t, std::pair<int *, int *> > *) NULL, anchorEntry);
                    ASSERT_EQ(3, (int) anchorEntry->first);

                    predicate.nextPage();
                    values = intMap->keySet(predicate);
                    ASSERT_EQ(0, (int) values->size());

                    predicate.setPage(0);
                    values = intMap->keySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(i, *values->get(i));
                    }

                    predicate.previousPage();
                    ASSERT_EQ(0, (int) predicate.getPage());

                    predicate.setPage(5);
                    values = intMap->keySet(predicate);
                    ASSERT_EQ(0, (int) values->size());

                    predicate.setPage(3);
                    values = intMap->keySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(3 * predSize + i, *values->get(i));
                    }

                    predicate.previousPage();
                    values = intMap->keySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        const int *value = values->get(i);
                        ASSERT_NE((const int *) NULL, value);
                        ASSERT_EQ(2 * predSize + i, *value);
                    }

// test PagingPredicate with inner predicate (value < 10)
                    std::unique_ptr<query::Predicate> lessThanTenPredicate(std::unique_ptr<query::Predicate>(
                            new query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 9,
                                                                 false,
                                                                 true)));
                    query::PagingPredicate<int, int> predicate2(lessThanTenPredicate, 5);
                    values = intMap->keySet(predicate2);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(i, *values->get(i));
                    }

                    predicate2.nextPage();
// match values 5,6, 7, 8
                    values = intMap->keySet(predicate2);
                    ASSERT_EQ(predSize - 1, (int) values->size());
                    for (int i = 0; i < predSize - 1; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(predSize + i, *values->get(i));
                    }

                    predicate2.nextPage();
                    values = intMap->keySet(predicate2);
                    ASSERT_EQ(0, (int) values->size());

// test paging predicate with comparator
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);
                    Employee empl4("ali", 33);
                    Employee empl5("veli", 44);
                    Employee empl6("aylin", 5);

                    employees->put(3, empl1);
                    employees->put(4, empl2);
                    employees->put(5, empl3);
                    employees->put(6, empl4);
                    employees->put(7, empl5);
                    employees->put(8, empl6);

                    predSize = 2;
                    query::PagingPredicate<int, Employee> predicate3(
                            std::unique_ptr<query::EntryComparator<int, Employee> >(new EmployeeEntryKeyComparator()),
                            (size_t) predSize);
                    std::unique_ptr<DataArray<int> > result = employees->keySet(predicate3);
// since keyset result only returns keys from the server, no ordering based on the value but ordered based on the keys
                    ASSERT_EQ(2, (int) result->size());
                    ASSERT_NE((const int *) NULL, (*result)[0]);
                    ASSERT_NE((const int *) NULL, (*result)[1]);
                    ASSERT_EQ(3, *((*result)[0]));
                    ASSERT_EQ(4, *result->get(1));

                    predicate3.nextPage();
                    result = employees->keySet(predicate3);
                    ASSERT_EQ(2, (int) result->size());
                    ASSERT_NE((const int *) NULL, (*result)[0]);
                    ASSERT_NE((const int *) NULL, (*result)[1]);
                    ASSERT_EQ(5, *((*result)[0]));
                    ASSERT_EQ(6, *result->get(1));
                }


                TEST_F(RawPointerMapTest, testEntrySetWithPredicate) {
                    const int numItems = 20;
                    std::vector<std::pair<int, int> > expected(numItems);
                    for (int i = 0; i < numItems; ++i) {
                        intMap->put(i, 2 * i);
                        expected[i] = std::pair<int, int>(i, 2 * i);
                    }

                    std::unique_ptr<EntryArray<int, int> > entries = intMap->entrySet();
                    ASSERT_EQ(numItems, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < numItems; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        ASSERT_EQ(expected[i], entry);
                    }

// EqualPredicate
// key == 5
                    entries = intMap->entrySet(
                            query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5));
                    ASSERT_EQ(1, (int) entries->size());
                    std::pair<int, int> entry1(*entries->getKey(0), *entries->getValue(0));
                    ASSERT_EQ(expected[5], entry1);

// value == 8
                    entries = intMap->entrySet(
                            query::EqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 8));
                    ASSERT_EQ(1, (int) entries->size());
                    std::pair<int, int> entry2(*entries->getKey(0), *entries->getValue(0));
                    ASSERT_EQ(expected[4], entry2);

// key == numItems
                    entries = intMap->entrySet(
                            query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), numItems));
                    ASSERT_EQ(0, (int) entries->size());

// NotEqual Predicate
// key != 5
                    entries = intMap->entrySet(
                            query::NotEqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5));
                    ASSERT_EQ(numItems - 1, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < numItems - 1; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        if (i >= 5) {
                            ASSERT_EQ(expected[i + 1], entry);
                        } else {
                            ASSERT_EQ(expected[i], entry);
                        }
                    }

// value != 8
                    entries = intMap->entrySet(
                            query::NotEqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 8));
                    ASSERT_EQ(numItems - 1, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < numItems - 1; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        if (i >= 4) {
                            ASSERT_EQ(expected[i + 1], entry);
                        } else {
                            ASSERT_EQ(expected[i], entry);
                        }
                    }

// TruePredicate
                    entries = intMap->entrySet(query::TruePredicate());
                    ASSERT_EQ(numItems, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < numItems; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        ASSERT_EQ(expected[i], entry);
                    }

// FalsePredicate
                    entries = intMap->entrySet(query::FalsePredicate());
                    ASSERT_EQ(0, (int) entries->size());

// BetweenPredicate
// 5 <= key <= 10
                    entries = intMap->entrySet(
                            query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                    entries->sort(query::ENTRY);
                    ASSERT_EQ(6, (int) entries->size());
                    for (int i = 0; i < 6; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        ASSERT_EQ(expected[i + 5], entry);
                    }

// 20 <= key <=30
                    entries = intMap->entrySet(
                            query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 20, 30));
                    ASSERT_EQ(0, (int) entries->size());

// GreaterLessPredicate
// value <= 10
                    entries = intMap->entrySet(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 10, true,
                                                             true));
                    ASSERT_EQ(6, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < 6; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        ASSERT_EQ(expected[i], entry);
                    }

// key < 7
                    entries = intMap->entrySet(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 7, false,
                                                             true));
                    ASSERT_EQ(7, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < 7; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        ASSERT_EQ(expected[i], entry);
                    }

// value >= 15
                    entries = intMap->entrySet(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 15, true,
                                                             false));
                    ASSERT_EQ(12, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < 12; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        ASSERT_EQ(expected[i + 8], entry);
                    }

// key > 5
                    entries = intMap->entrySet(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, false,
                                                             false));
                    ASSERT_EQ(14, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < 14; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        ASSERT_EQ(expected[i + 6], entry);
                    }

// InPredicate
// key in {4, 10, 19}
                    std::vector<int> inVals(3);
                    inVals[0] = 4;
                    inVals[1] = 10;
                    inVals[2] = 19;
                    entries = intMap->entrySet(
                            query::InPredicate<int>(query::QueryConstants::getKeyAttributeName(), inVals));
                    ASSERT_EQ(3, (int) entries->size());
                    entries->sort(query::ENTRY);
                    {
                        std::pair<int, int> entry(*entries->getKey(0), *entries->getValue(0));
                        ASSERT_EQ(expected[4], entry);
                    }
                    {
                        std::pair<int, int> entry(*entries->getKey(1), *entries->getValue(1));
                        ASSERT_EQ(expected[10], entry);
                    }
                    {
                        std::pair<int, int> entry(*entries->getKey(2), *entries->getValue(2));
                        ASSERT_EQ(expected[19], entry);
                    }

// value in {4, 10, 19}
                    entries = intMap->entrySet(
                            query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                    ASSERT_EQ(2, (int) entries->size());
                    entries->sort(query::ENTRY);
                    std::pair<int, int> entry(*entries->getKey(0), *entries->getValue(0));
                    ASSERT_EQ(expected[2], entry);
                    entry = std::pair<int, int>(*entries->getKey(1), *entries->getValue(1));
                    ASSERT_EQ(expected[5], entry);

// InstanceOfPredicate
// value instanceof Integer
                    entries = intMap->entrySet(query::InstanceOfPredicate("java.lang.Integer"));
                    ASSERT_EQ(20, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < numItems; ++i) {
                        std::pair<int, int> item(*entries->getKey(i), *entries->getValue(i));
                        ASSERT_EQ(expected[i], item);
                    }

                    entries = intMap->entrySet(query::InstanceOfPredicate("java.lang.String"));
                    ASSERT_EQ(0, (int) entries->size());

// NotPredicate
// !(5 <= key <= 10)
                    std::unique_ptr<query::Predicate> bp = std::unique_ptr<query::Predicate>(
                            new query::BetweenPredicate<int>(
                                    query::QueryConstants::getKeyAttributeName(), 5, 10));
                    query::NotPredicate notPredicate(bp);
                    entries = intMap->entrySet(notPredicate);
                    ASSERT_EQ(14, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < 14; ++i) {
                        std::pair<int, int> item(*entries->getKey(i), *entries->getValue(i));
                        if (i >= 5) {
                            ASSERT_EQ(expected[i + 6], item);
                        } else {
                            ASSERT_EQ(expected[i], item);
                        }
                    }

// AndPredicate
// 5 <= key <= 10 AND Values in {4, 10, 19} = entries {4, 10}
                    bp = std::unique_ptr<query::Predicate>(
                            new query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                    std::unique_ptr<query::Predicate> inPred = std::unique_ptr<query::Predicate>(
                            new query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                    entries = intMap->entrySet(query::AndPredicate().add(bp).add(inPred));
                    ASSERT_EQ(1, (int) entries->size());
                    entries->sort(query::ENTRY);
                    entry = std::pair<int, int>(*entries->getKey(0), *entries->getValue(0));
                    ASSERT_EQ(expected[5], entry);

// OrPredicate
// 5 <= key <= 10 OR Values in {4, 10, 19} = entries keys {2, 5, 6, 7, 8, 9, 10}
                    bp = std::unique_ptr<query::Predicate>(
                            new query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                    inPred = std::unique_ptr<query::Predicate>(
                            new query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                    entries = intMap->entrySet(query::OrPredicate().add(bp).add(inPred));
                    ASSERT_EQ(7, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < 7; ++i) {
                        entry = std::pair<int, int>(*entries->getKey(i), *entries->getValue(i));
                        if (i == 0) {
                            ASSERT_EQ(expected[2], entry);
                        } else {
                            ASSERT_EQ(expected[i + 4], entry);
                        }
                    }

                    std::vector<std::pair<std::string, std::string> > expectedStrEntries(14);
                    for (int i = 0; i < 12; i++) {
                        std::string key = "key";
                        key += hazelcast::util::IOUtil::to_string(i);
                        std::string value = "value";
                        value += hazelcast::util::IOUtil::to_string(i);
                        imap->put(key, value);
                        expectedStrEntries[i] = std::pair<std::string, std::string>(key, value);
                    }
                    imap->put("key_111_test", "myvalue_111_test");
                    expectedStrEntries[12] = std::pair<std::string, std::string>("key_111_test", "myvalue_111_test");
                    imap->put("key_22_test", "myvalue_22_test");
                    expectedStrEntries[13] = std::pair<std::string, std::string>("key_22_test", "myvalue_22_test");

// LikePredicate
// value LIKE "value1" : {"value1"}
                    std::unique_ptr<EntryArray<std::string, std::string> > strEntries = imap->entrySet(
                            query::LikePredicate(query::QueryConstants::getValueAttributeName(), "value1"));
                    ASSERT_EQ(1, (int) strEntries->size());
                    std::pair<std::string, std::string> strEntry(*strEntries->getKey(0), *strEntries->getValue(0));
                    ASSERT_EQ(expectedStrEntries[1], strEntry);

// ILikePredicate
// value ILIKE "%VALue%1%" : {"key_111_test", "key1", "key10", "key11"}
                    strEntries = imap->entrySet(
                            query::ILikePredicate(query::QueryConstants::getValueAttributeName(), "%VALue%1%"));
                    ASSERT_EQ(4, (int) strEntries->size());
                    strEntries->sort(query::ENTRY);
                    for (int i = 0; i < 4; ++i) {
                        strEntry = std::pair<std::string, std::string>(*strEntries->getKey(i),
                                                                       *strEntries->getValue(i));
                        if (i == 0) {
                            ASSERT_EQ(expectedStrEntries[1], strEntry);
                        } else {
                            ASSERT_EQ(expectedStrEntries[i + 9], strEntry);
                        }
                    }

// key ILIKE "%VAL%2%" : {"key_22_test", "key2"}
                    strEntries = imap->entrySet(
                            query::ILikePredicate(query::QueryConstants::getValueAttributeName(), "%VAL%2%"));
                    ASSERT_EQ(2, (int) strEntries->size());
                    strEntries->sort(query::ENTRY);
                    strEntry = std::pair<std::string, std::string>(*strEntries->getKey(0), *strEntries->getValue(0));
                    ASSERT_EQ(expectedStrEntries[2], strEntry);
                    strEntry = std::pair<std::string, std::string>(*strEntries->getKey(1), *strEntries->getValue(1));
                    ASSERT_EQ(expectedStrEntries[13], strEntry);

// SqlPredicate
// __key BETWEEN 4 and 7 : {4, 5, 6, 7} -> {8, 10, 12, 14}
                    char sql[100];
                    hazelcast::util::hz_snprintf(sql, 50, "%s BETWEEN 4 and 7",
                                                 query::QueryConstants::getKeyAttributeName());
                    entries = intMap->entrySet(query::SqlPredicate(sql));
                    ASSERT_EQ(4, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < 4; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        ASSERT_EQ(expected[i + 4], entry);
                    }

// RegexPredicate
// value matches the regex ".*value.*2.*" : {key_22_test, value2}
                    strEntries = imap->entrySet(
                            query::RegexPredicate(query::QueryConstants::getValueAttributeName(), ".*value.*2.*"));
                    ASSERT_EQ(2, (int) strEntries->size());
                    strEntries->sort(query::ENTRY);
                    strEntry = std::pair<std::string, std::string>(*strEntries->getKey(0), *strEntries->getValue(0));
                    ASSERT_EQ(expectedStrEntries[2], strEntry);
                    strEntry = std::pair<std::string, std::string>(*strEntries->getKey(1), *strEntries->getValue(1));
                    ASSERT_EQ(expectedStrEntries[13], strEntry);
                }

                TEST_F(RawPointerMapTest, testEntrySetWithPagingPredicate) {
                    int predSize = 5;
                    const int totalEntries = 25;

                    for (int i = 0; i < totalEntries; ++i) {
                        intMap->put(i, i);
                    }

                    query::PagingPredicate<int, int> predicate((size_t) predSize);

                    std::unique_ptr<EntryArray<int, int> > values = intMap->entrySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        std::pair<int, int> expected(i, i);
                        std::pair<int, int> actual(*values->getKey(i), *values->getValue(i));
                        ASSERT_EQ(expected, actual);
                    }

                    values = intMap->entrySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        std::pair<int, int> expected(i, i);
                        std::pair<int, int> actual(*values->getKey(i), *values->getValue(i));
                        ASSERT_EQ(expected, actual);
                    }

                    predicate.nextPage();
                    values = intMap->entrySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());

                    for (int i = 0; i < predSize; ++i) {
                        std::pair<int, int> expected(predSize + i, predSize + i);
                        std::pair<int, int> actual(*values->getKey(i), *values->getValue(i));
                        ASSERT_EQ(expected, actual);
                    }

                    const std::pair<int *, int *> *anchor = predicate.getAnchor();
                    ASSERT_NE((const std::pair<int *, int *> *) NULL, anchor);
                    ASSERT_NE((int *) NULL, anchor->first);
                    ASSERT_NE((int *) NULL, anchor->second);
                    ASSERT_EQ(9, *anchor->first);
                    ASSERT_EQ(9, *anchor->second);

                    ASSERT_EQ(1, (int) predicate.getPage());

                    predicate.setPage(4);

                    values = intMap->entrySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        std::pair<int, int> expected(predSize * 4 + i, predSize * 4 + i);
                        std::pair<int, int> actual(*values->getKey(i), *values->getValue(i));
                        ASSERT_EQ(expected, actual);
                    }

                    anchor = predicate.getAnchor();
                    ASSERT_NE((const std::pair<int *, int *> *) NULL, anchor);
                    ASSERT_NE((int *) NULL, anchor->first);
                    ASSERT_NE((int *) NULL, anchor->second);
                    ASSERT_EQ(24, *anchor->first);
                    ASSERT_EQ(24, *anchor->second);

                    const std::pair<size_t, std::pair<int *, int *> > *anchorEntry = predicate.getNearestAnchorEntry();
                    ASSERT_NE((const std::pair<size_t, std::pair<int *, int *> > *) NULL, anchorEntry);
                    ASSERT_NE((int *) NULL, anchorEntry->second.first);
                    ASSERT_NE((int *) NULL, anchorEntry->second.second);
                    ASSERT_EQ(3, (int) anchorEntry->first);
                    ASSERT_EQ(19, *anchorEntry->second.first);
                    ASSERT_EQ(19, *anchorEntry->second.second);

                    predicate.nextPage();
                    values = intMap->entrySet(predicate);
                    ASSERT_EQ(0, (int) values->size());

                    predicate.setPage(0);
                    values = intMap->entrySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        std::pair<int, int> expected(i, i);
                        std::pair<int, int> actual(*values->getKey(i), *values->getValue(i));
                        ASSERT_EQ(expected, actual);
                    }

                    predicate.previousPage();
                    ASSERT_EQ(0, (int) predicate.getPage());

                    predicate.setPage(5);
                    values = intMap->entrySet(predicate);
                    ASSERT_EQ(0, (int) values->size());

                    predicate.setPage(3);
                    values = intMap->entrySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        std::pair<int, int> expected(3 * predSize + i, 3 * predSize + i);
                        std::pair<int, int> actual(*values->getKey(i), *values->getValue(i));
                        ASSERT_EQ(expected, actual);
                    }

                    predicate.previousPage();
                    values = intMap->entrySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        std::pair<int, int> expected(2 * predSize + i, 2 * predSize + i);
                        std::pair<int, int> actual(*values->getKey(i), *values->getValue(i));
                        ASSERT_EQ(expected, actual);
                    }

// test PagingPredicate with inner predicate (value < 10)
                    std::unique_ptr<query::Predicate> lessThanTenPredicate(std::unique_ptr<query::Predicate>(
                            new query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 9,
                                                                 false,
                                                                 true)));
                    query::PagingPredicate<int, int> predicate2(lessThanTenPredicate, 5);
                    values = intMap->entrySet(predicate2);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        std::pair<int, int> expected(i, i);
                        std::pair<int, int> actual(*values->getKey(i), *values->getValue(i));
                        ASSERT_EQ(expected, actual);
                    }

                    predicate2.nextPage();
// match values 5,6, 7, 8
                    values = intMap->entrySet(predicate2);
                    ASSERT_EQ(predSize - 1, (int) values->size());
                    for (int i = 0; i < predSize - 1; ++i) {
                        std::pair<int, int> expected(predSize + i, predSize + i);
                        std::pair<int, int> actual(*values->getKey(i), *values->getValue(i));
                        ASSERT_EQ(expected, actual);
                    }

                    predicate2.nextPage();
                    values = intMap->entrySet(predicate2);
                    ASSERT_EQ(0, (int) values->size());

// test paging predicate with comparator
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);
                    Employee empl4("ali", 33);
                    Employee empl5("veli", 44);
                    Employee empl6("aylin", 5);

                    employees->put(3, empl1);
                    employees->put(4, empl2);
                    employees->put(5, empl3);
                    employees->put(6, empl4);
                    employees->put(7, empl5);
                    employees->put(8, empl6);

                    predSize = 2;
                    query::PagingPredicate<int, Employee> predicate3(
                            std::unique_ptr<query::EntryComparator<int, Employee> >(new EmployeeEntryComparator()),
                            (size_t) predSize);
                    std::unique_ptr<EntryArray<int, Employee> > result = employees->entrySet(predicate3);
                    ASSERT_EQ(2, (int) result->size());
                    std::pair<int, Employee> expected(8, empl6);
                    std::pair<int, Employee> actual(*result->getKey(0), *result->getValue(0));
                    ASSERT_EQ(expected, actual);
                    expected = std::pair<int, Employee>(4, empl2);
                    actual = std::pair<int, Employee>(*result->getKey(1), *result->getValue(1));
                    ASSERT_EQ(expected, actual);
                }

                TEST_F(RawPointerMapTest, testReplace) {
                    std::unique_ptr<std::string> temp = imap->replace("key1", "value");
                    ASSERT_EQ(temp.get(), (std::string *) NULL);

                    std::string tempKey = "key1";
                    std::string tempValue = "value1";
                    imap->put(tempKey, tempValue);

                    ASSERT_EQ("value1", *(imap->replace("key1", "value2")));
                    ASSERT_EQ("value2", *(imap->get("key1")));

                    ASSERT_FALSE(imap->replace("key1", "value1", "value3"));
                    ASSERT_EQ("value2", *(imap->get("key1")));

                    ASSERT_TRUE(imap->replace("key1", "value2", "value3"));
                    ASSERT_EQ("value3", *(imap->get("key1")));
                }

                TEST_F(RawPointerMapTest, testPredicateListenerWithPortableKey) {
                    IMap<Employee, int> map = client->getMap<Employee, int>("tradeMap");
                    hazelcast::client::adaptor::RawPointerMap<Employee, int> tradeMap(map);
                    hazelcast::util::CountDownLatch countDownLatch(1);
                    hazelcast::util::AtomicInt atomicInteger(0);
                    SampleEntryListenerForPortableKey listener(countDownLatch, atomicInteger);
                    Employee key("a", 1);
                    std::string id = tradeMap.addEntryListener(listener, key, true);
                    Employee key2("a", 2);
                    tradeMap.put(key2, 1);
                    tradeMap.put(key, 3);
                    ASSERT_TRUE(countDownLatch.await(5));
                    ASSERT_EQ(1, (int) atomicInteger);

                    ASSERT_TRUE(tradeMap.removeEntryListener(id));
                }

                TEST_F(RawPointerMapTest, testListener) {
                    hazelcast::util::CountDownLatch latch1Add(5);
                    hazelcast::util::CountDownLatch latch1Remove(2);
                    hazelcast::util::CountDownLatch dummy(10);
                    hazelcast::util::CountDownLatch latch2Add(1);
                    hazelcast::util::CountDownLatch latch2Remove(1);

                    CountdownListener<std::string, std::string> listener1(latch1Add, latch1Remove, dummy, dummy);
                    CountdownListener<std::string, std::string> listener2(latch2Add, latch2Remove, dummy, dummy);

                    std::string listener1ID = imap->addEntryListener(listener1, false);
                    std::string listener2ID = imap->addEntryListener(listener2, "key3", true);

                    hazelcast::util::sleep(2);

                    imap->put("key1", "value1");
                    imap->put("key2", "value2");
                    imap->put("key3", "value3");
                    imap->put("key4", "value4");
                    imap->put("key5", "value5");

                    imap->remove("key1");
                    imap->remove("key3");

                    ASSERT_TRUE(latch1Add.await(10));
                    ASSERT_TRUE(latch1Remove.await(10));
                    ASSERT_TRUE(latch2Add.await(5));
                    ASSERT_TRUE(latch2Remove.await(5));

                    ASSERT_TRUE(imap->removeEntryListener(listener1ID));
                    ASSERT_TRUE(imap->removeEntryListener(listener2ID));

                }

                TEST_F(RawPointerMapTest, testListenerWithTruePredicate) {
                    hazelcast::util::CountDownLatch latchAdd(3);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener<int, int> listener(latchAdd, latchRemove, latchUpdate, latchEvict);

                    std::string listenerId = intMap->addEntryListener(listener, query::TruePredicate(), false);

                    intMap->put(1, 1);
                    intMap->put(2, 2);
                    intMap->put(3, 3, 1000); // evict after 1 second
                    intMap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ(NULL, intMap->get(3).get()); // trigger eviction

// update an entry
                    intMap->set(1, 5);
                    std::unique_ptr<int> value = intMap->get(1);
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchRemove).add(latchUpdate).add(latchEvict);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    ASSERT_TRUE(intMap->removeEntryListener(listenerId));
                }

                TEST_F(RawPointerMapTest, testListenerWithFalsePredicate) {
                    hazelcast::util::CountDownLatch latchAdd(3);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener<int, int> listener(latchAdd, latchRemove, latchUpdate, latchEvict);

                    std::string listenerId = intMap->addEntryListener(listener, query::FalsePredicate(), false);

                    intMap->put(1, 1);
                    intMap->put(2, 2);
                    intMap->put(3, 3, 1000); // evict after 1 second
                    intMap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ(NULL, intMap->get(3).get()); // trigger eviction

// update an entry
                    intMap->set(1, 5);
                    std::unique_ptr<int> value = intMap->get(1);
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchRemove).add(latchUpdate).add(latchEvict);
                    ASSERT_FALSE(latches.awaitMillis(2000));

                    ASSERT_TRUE(intMap->removeEntryListener(listenerId));
                }

                TEST_F(RawPointerMapTest, testListenerWithEqualPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(1);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener<int, int> listener(latchAdd, latchRemove, latchUpdate, latchEvict);

                    std::string listenerId = intMap->addEntryListener(listener, query::EqualPredicate<int>(
                            query::QueryConstants::getKeyAttributeName(), 3), true);

                    intMap->put(1, 1);
                    intMap->put(2, 2);
                    intMap->put(3, 3, 1000); // evict after 1 second
                    intMap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ(NULL, intMap->get(3).get()); // trigger eviction

// update an entry
                    intMap->set(1, 5);
                    std::unique_ptr<int> value = intMap->get(1);
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchEvict);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    latches.reset();
                    latches.add(latchUpdate).add(latchRemove);
                    ASSERT_FALSE(latches.awaitMillis(2000));

                    ASSERT_TRUE(intMap->removeEntryListener(listenerId));
                }

                TEST_F(RawPointerMapTest, testListenerWithNotEqualPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(2);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener<int, int> listener(latchAdd, latchRemove, latchUpdate, latchEvict);

                    std::string listenerId = intMap->addEntryListener(listener, query::NotEqualPredicate<int>(
                            query::QueryConstants::getKeyAttributeName(), 3), true);

                    intMap->put(1, 1);
                    intMap->put(2, 2);
                    intMap->put(3, 3, 1000); // evict after 1 second
                    intMap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ(NULL, intMap->get(3).get()); // trigger eviction

// update an entry
                    intMap->set(1, 5);
                    std::unique_ptr<int> value = intMap->get(1);
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchRemove).add(latchUpdate);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    latches.reset();
                    latches.add(latchEvict);
                    ASSERT_FALSE(latches.awaitMillis(2000));

                    ASSERT_TRUE(intMap->removeEntryListener(listenerId));
                }

                TEST_F(RawPointerMapTest, testListenerWithGreaterLessPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(2);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener<int, int> listener(latchAdd, latchRemove, latchUpdate, latchEvict);

// key <= 2
                    std::string listenerId = intMap->addEntryListener(listener, query::GreaterLessPredicate<int>(
                            query::QueryConstants::getKeyAttributeName(), 2, true, true), false);

                    intMap->put(1, 1);
                    intMap->put(2, 2);
                    intMap->put(3, 3, 1000); // evict after 1 second
                    intMap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ(NULL, intMap->get(3).get()); // trigger eviction

// update an entry
                    intMap->set(1, 5);
                    std::unique_ptr<int> value = intMap->get(1);
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchRemove).add(latchUpdate);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    ASSERT_FALSE(latchEvict.awaitMillis(2000));

                    ASSERT_TRUE(intMap->removeEntryListener(listenerId));
                }

                TEST_F(RawPointerMapTest, testListenerWithBetweenPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(2);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener<int, int> listener(latchAdd, latchRemove, latchUpdate, latchEvict);

// 1 <=key <= 2
                    std::string listenerId = intMap->addEntryListener(listener, query::BetweenPredicate<int>(
                            query::QueryConstants::getKeyAttributeName(), 1, 2), true);

                    intMap->put(1, 1);
                    intMap->put(2, 2);
                    intMap->put(3, 3, 1000); // evict after 1 second
                    intMap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ(NULL, intMap->get(3).get()); // trigger eviction

// update an entry
                    intMap->set(1, 5);
                    std::unique_ptr<int> value = intMap->get(1);
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchRemove).add(latchUpdate);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    ASSERT_FALSE(latchEvict.awaitMillis(2000));

                    ASSERT_TRUE(intMap->removeEntryListener(listenerId));
                }

                TEST_F(RawPointerMapTest, testListenerWithSqlPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(1);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener<int, int> listener(latchAdd, latchRemove, latchUpdate, latchEvict);

// 1 <=key <= 2
                    std::string listenerId = intMap->addEntryListener(listener, query::SqlPredicate("__key < 2"), true);

                    intMap->put(1, 1);
                    intMap->put(2, 2);
                    intMap->put(3, 3, 1000); // evict after 1 second
                    intMap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ(NULL, intMap->get(3).get()); // trigger eviction

// update an entry
                    intMap->set(1, 5);
                    std::unique_ptr<int> value = intMap->get(1);
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchUpdate);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    latches.reset();
                    latches.add(latchRemove).add(latchEvict);
                    ASSERT_FALSE(latches.awaitMillis(2000));

                    ASSERT_TRUE(intMap->removeEntryListener(listenerId));
                }

                TEST_F(RawPointerMapTest, testListenerWithRegExPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(2);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener<std::string, std::string> listener(latchAdd, latchRemove, latchUpdate,
                                                                         latchEvict);

// key matches any word containing ".*met.*"
                    std::string listenerId = imap->addEntryListener(listener, query::RegexPredicate(
                            query::QueryConstants::getKeyAttributeName(), ".*met.*"), true);

                    imap->put("ilkay", "yasar");
                    imap->put("mehmet", "demir");
                    imap->put("metin", "ozen", 1000); // evict after 1 second
                    imap->put("hasan", "can");
                    imap->remove("mehmet");

                    hazelcast::util::sleep(2);

                    ASSERT_EQ((std::string *) NULL, imap->get("metin").get()); // trigger eviction

// update an entry
                    imap->set("hasan", "suphi");
                    std::unique_ptr<std::string> value = imap->get("hasan");
                    ASSERT_NE((std::string *) NULL, value.get());
                    ASSERT_EQ("suphi", *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchRemove).add(latchEvict);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    ASSERT_FALSE(latchUpdate.awaitMillis(2000));

                    ASSERT_TRUE(imap->removeEntryListener(listenerId));
                }

                TEST_F(RawPointerMapTest, testListenerWithInstanceOfPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(3);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener<int, int> listener(latchAdd, latchRemove, latchUpdate, latchEvict);

// 1 <=key <= 2
                    std::string listenerId = intMap->addEntryListener(listener,
                                                                      query::InstanceOfPredicate("java.lang.Integer"),
                                                                      false);

                    intMap->put(1, 1);
                    intMap->put(2, 2);
                    intMap->put(3, 3, 1000); // evict after 1 second
                    intMap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ(NULL, intMap->get(3).get()); // trigger eviction

// update an entry
                    intMap->set(1, 5);
                    std::unique_ptr<int> value = intMap->get(1);
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchRemove).add(latchUpdate).add(latchEvict);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    ASSERT_TRUE(intMap->removeEntryListener(listenerId));
                }

                TEST_F(RawPointerMapTest, testListenerWithNotPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(2);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener<int, int> listener(latchAdd, latchRemove, latchUpdate, latchEvict);

// key >= 3
                    std::unique_ptr<query::Predicate> greaterLessPred = std::unique_ptr<query::Predicate>(
                            new query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 3, true,
                                                                 false));
                    query::NotPredicate notPredicate(greaterLessPred);
                    std::string listenerId = intMap->addEntryListener(listener, notPredicate, false);

                    intMap->put(1, 1);
                    intMap->put(2, 2);
                    intMap->put(3, 3, 1000); // evict after 1 second
                    intMap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ(NULL, intMap->get(3).get()); // trigger eviction

// update an entry
                    intMap->set(1, 5);
                    std::unique_ptr<int> value = intMap->get(1);
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchRemove).add(latchUpdate);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    latches.reset();
                    latches.add(latchEvict);
                    ASSERT_FALSE(latches.awaitMillis(1000));

                    ASSERT_TRUE(intMap->removeEntryListener(listenerId));
                }

                TEST_F(RawPointerMapTest, testListenerWithAndPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(1);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener<int, int> listener(latchAdd, latchRemove, latchUpdate, latchEvict);

// key < 3
                    std::unique_ptr<query::Predicate> greaterLessPred = std::unique_ptr<query::Predicate>(
                            new query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 3, false,
                                                                 true));
// value == 1
                    std::unique_ptr<query::Predicate> equalPred = std::unique_ptr<query::Predicate>(
                            new query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 1));
                    query::AndPredicate predicate;
// key < 3 AND key == 1 --> (1, 1)
                    predicate.add(greaterLessPred).add(equalPred);
                    std::string listenerId = intMap->addEntryListener(listener, predicate, false);

                    intMap->put(1, 1);
                    intMap->put(2, 2);
                    intMap->put(3, 3, 1000); // evict after 1 second
                    intMap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ(NULL, intMap->get(3).get()); // trigger eviction

// update an entry
                    intMap->set(1, 5);
                    std::unique_ptr<int> value = intMap->get(1);
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchUpdate);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    latches.reset();
                    latches.add(latchEvict).add(latchRemove);
                    ASSERT_FALSE(latches.awaitMillis(1000));

                    ASSERT_TRUE(intMap->removeEntryListener(listenerId));
                }

                TEST_F(RawPointerMapTest, testListenerWithOrPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(2);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener<int, int> listener(latchAdd, latchRemove, latchUpdate, latchEvict);

// key >= 3
                    std::unique_ptr<query::Predicate> greaterLessPred = std::unique_ptr<query::Predicate>(
                            new query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 3, true,
                                                                 false));
// value == 1
                    std::unique_ptr<query::Predicate> equalPred = std::unique_ptr<query::Predicate>(
                            new query::EqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 2));
                    query::OrPredicate predicate;
// key >= 3 OR value == 2 --> (1, 1), (2, 2)
                    predicate.add(greaterLessPred).add(equalPred);
                    std::string listenerId = intMap->addEntryListener(listener, predicate, true);

                    intMap->put(1, 1);
                    intMap->put(2, 2);
                    intMap->put(3, 3, 1000); // evict after 1 second
                    intMap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ(NULL, intMap->get(3).get()); // trigger eviction

// update an entry
                    intMap->set(1, 5);
                    std::unique_ptr<int> value = intMap->get(1);
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchEvict).add(latchRemove);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    ASSERT_FALSE(latchUpdate.awaitMillis(2000));

                    ASSERT_TRUE(intMap->removeEntryListener(listenerId));
                }

                TEST_F(RawPointerMapTest, testClearEvent) {
                    hazelcast::util::CountDownLatch latch(1);
                    ClearListener clearListener(latch);
                    std::string listenerId = imap->addEntryListener(clearListener, false);
                    imap->put("key1", "value1");
                    imap->clear();
                    ASSERT_TRUE(latch.await(120));
                    imap->removeEntryListener(listenerId);
                }

                TEST_F(RawPointerMapTest, testEvictAllEvent) {
                    hazelcast::util::CountDownLatch latch(1);
                    EvictListener evictListener(latch);
                    std::string listenerId = imap->addEntryListener(evictListener, false);
                    imap->put("key1", "value1");
                    imap->evictAll();
                    ASSERT_TRUE(latch.await(120));
                    imap->removeEntryListener(listenerId);
                }

                TEST_F(RawPointerMapTest, testBasicPredicate) {
                    fillMap();

                    query::SqlPredicate predicate("this = 'value1'");
                    std::unique_ptr<hazelcast::client::DataArray<std::string> > tempArray = imap->values(predicate);

                    std::unique_ptr<std::string> actualVal = tempArray->release(0);
                    ASSERT_NE((std::string *) NULL, actualVal.get());
                    ASSERT_EQ("value1", *actualVal);

                    std::unique_ptr<hazelcast::client::DataArray<std::string> > tempArray2 = imap->keySet(predicate);

                    const std::string *actual = (*tempArray2)[0];
                    ASSERT_NE((std::string *) NULL, actual);
                    ASSERT_EQ("key1", *actual);


                    std::unique_ptr<hazelcast::client::EntryArray<std::string, std::string> > tempArray3 = imap->entrySet(
                            predicate);
                    actual = tempArray3->getKey(0);
                    ASSERT_NE((std::string *) NULL, actual);
                    ASSERT_EQ("key1", *actual);

                    actual = tempArray3->getValue(0);
                    ASSERT_NE((std::string *) NULL, actual);
                    ASSERT_EQ("value1", *actual);
                }

                TEST_F(RawPointerMapTest, testKeySetAndValuesWithPredicates) {
                    std::string name = "testKeysetAndValuesWithPredicates";
                    IMap<Employee, Employee> mapOriginal = client->getMap<Employee, Employee>(name);
                    hazelcast::client::adaptor::RawPointerMap<Employee, Employee> map(mapOriginal);

                    Employee emp1("abc-123-xvz", 34);
                    Employee emp2("abc-123-xvz", 20);

                    map.put(emp1, emp1);
                    ASSERT_EQ(map.put(emp2, emp2).get(), (Employee *) NULL);
                    ASSERT_EQ(2, (int) map.size());
                    ASSERT_EQ(2, (int) map.keySet()->size());
                    query::SqlPredicate predicate("a = 10");
                    ASSERT_EQ(0, (int) map.keySet(predicate)->size());
                    query::SqlPredicate predicate2("a = 10");
                    ASSERT_EQ(0, (int) map.values(predicate2)->size());
                    query::SqlPredicate predicate3("a >= 10");
                    ASSERT_EQ(2, (int) map.keySet(predicate3)->size());
                    ASSERT_EQ(2, (int) map.values(predicate3)->size());
                    ASSERT_EQ(2, (int) map.size());
                    ASSERT_EQ(2, (int) map.values()->size());
                }

                TEST_F(RawPointerMapTest, testMapWithPortable) {
                    std::unique_ptr<Employee> n1 = employees->get(1);
                    ASSERT_EQ(n1.get(), (Employee *) NULL);
                    Employee employee("sancar", 24);
                    std::unique_ptr<Employee> ptr = employees->put(1, employee);
                    ASSERT_EQ(ptr.get(), (Employee *) NULL);
                    ASSERT_FALSE(employees->isEmpty());
                    std::unique_ptr<hazelcast::client::MapEntryView<int, Employee> > view = employees->getEntryView(1);
                    ASSERT_EQ(*(view->getValue()), employee);
                    ASSERT_EQ(*(view->getKey()), 1);

                    employees->addIndex("a", true);
                    employees->addIndex("n", false);
                }


                TEST_F(RawPointerMapTest, testMapStoreRelatedRequests) {
                    imap->putTransient("ali", "veli", 1100);
                    imap->flush();
                    ASSERT_EQ(1, imap->size());
                    ASSERT_FALSE(imap->evict("deli"));
                    ASSERT_TRUE(imap->evict("ali"));
                    ASSERT_EQ(imap->get("ali").get(), (std::string *) NULL);
                }

                TEST_F(RawPointerMapTest, testExecuteOnKey) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);

                    employees->put(3, empl1);
                    employees->put(4, empl2);

                    EntryMultiplier processor(4);

                    std::unique_ptr<int> result = employees->executeOnKey<int, EntryMultiplier>(4, processor);

                    ASSERT_NE((int *) NULL, result.get());
                    ASSERT_EQ(4 * processor.getMultiplier(), *result);
                }

                TEST_F(RawPointerMapTest, testExecuteOnNonExistentKey) {
                    EntryMultiplier processor(4);

                    std::unique_ptr<int> result = employees->executeOnKey<int, EntryMultiplier>(17, processor);

                    ASSERT_NE((int *) NULL, result.get());
                    ASSERT_EQ(-1, *result);
                }

                TEST_F(RawPointerMapTest, testSubmitToKey) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);

                    employees->put(3, empl1);
                    employees->put(4, empl2);

// Waits at the server side before running the operation
                    WaitMultiplierProcessor processor(3000, 4);

                    hazelcast::client::Future<int> initialFuture =
                            employees->submitToKey<int, WaitMultiplierProcessor>(
                                    4, processor);

// Should invalidate the initialFuture
                    hazelcast::client::Future<int> future = initialFuture;

                    ASSERT_FALSE(initialFuture.valid());
                    ASSERT_THROW(initialFuture.wait_for(1000), exception::FutureUninitialized);
                    ASSERT_TRUE(future.valid());

                    future_status status = future.wait_for(1 * 1000);
                    ASSERT_EQ(future_status::timeout, status);
                    ASSERT_TRUE(future.valid());

                    status = future.wait_for(3 * 1000);
                    ASSERT_EQ(future_status::ready, status);
                    std::unique_ptr<int> result = future.get();
                    ASSERT_NE((int *) NULL, result.get());
                    ASSERT_EQ(4 * processor.getMultiplier(), *result);
                    ASSERT_FALSE(future.valid());
                }

                TEST_F(RawPointerMapTest, testSubmitToKeyMultipleAsyncCalls) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);

                    employees->put(3, empl1);
                    employees->put(4, empl2);

                    int waitTimeInMillis = 500;

// Waits at the server side before running the operation
                    WaitMultiplierProcessor processor(waitTimeInMillis, 4);

                    std::vector<hazelcast::client::Future<int> > allFutures;

// test putting into a vector of futures
                    hazelcast::client::Future<int> future = employees->submitToKey<int, WaitMultiplierProcessor>(
                            3, processor);
                    allFutures.push_back(future);

// test re-assigning a future and putting into the vector
                    future = employees->submitToKey<int, WaitMultiplierProcessor>(
                            3, processor);
                    allFutures.push_back(future);

// test submitting a non-existent key
                    allFutures.push_back(employees->submitToKey<int, WaitMultiplierProcessor>(
                            99, processor));

                    for (std::vector<hazelcast::client::Future<int> >::const_iterator it = allFutures.begin();
                         it != allFutures.end(); ++it) {
                        future_status status = (*it).wait_for(2 * waitTimeInMillis);
                        ASSERT_EQ(future_status::ready, status);
                    }

                    for (std::vector<hazelcast::client::Future<int> >::iterator it = allFutures.begin();
                         it != allFutures.end(); ++it) {
                        std::unique_ptr<int> result = (*it).get();
                        ASSERT_NE((int *) NULL, result.get());
                        ASSERT_FALSE((*it).valid());
                    }
                }

                TEST_F(RawPointerMapTest, testExecuteOnKeys) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    employees->put(3, empl1);
                    employees->put(4, empl2);
                    employees->put(5, empl3);

                    EntryMultiplierWithNullableResult processor(4);

                    std::set<int> keys;
                    keys.insert(3);
                    keys.insert(5);
// put non existent key
                    keys.insert(999);

                    std::unique_ptr<hazelcast::client::EntryArray<int, int> > result =
                            employees->executeOnKeys<int, EntryMultiplier>(keys, processor);

                    ASSERT_EQ(2, (int) result->size());
                    ASSERT_NE((const int *) NULL, result->getKey(0));
                    ASSERT_NE((const int *) NULL, result->getKey(1));
                    int key0 = *result->getKey(0);
                    ASSERT_TRUE(3 == key0 || 5 == key0);
                    int key1 = *result->getKey(1);
                    ASSERT_TRUE(3 == key1 || 5 == key1);
                    ASSERT_NE(key0, key1);
                    ASSERT_EQ(key0 * processor.getMultiplier(), *result->getValue(0));
                    ASSERT_EQ(key1 * processor.getMultiplier(), *result->getValue(1));
                }

                TEST_F(RawPointerMapTest, testExecuteOnEntries) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    employees->put(3, empl1);
                    employees->put(4, empl2);
                    employees->put(5, empl3);

                    EntryMultiplier processor(4);

                    std::unique_ptr<hazelcast::client::EntryArray<int, int> > result = employees->executeOnEntries<int, EntryMultiplier>(
                            processor);

                    ASSERT_EQ(3, (int) result->size());
                    for (size_t i = 0; i < result->size(); ++i) {
                        const int *key = result->getKey(i);
                        const int *value = result->getValue(i);
                        ASSERT_TRUE(*key == 3 || *key == 4 || *key == 5);
                        ASSERT_EQ((*key) * processor.getMultiplier(), (*value));
                    }
                }

                TEST_F(RawPointerMapTest, testExecuteOnEntriesWithTruePredicate) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    employees->put(3, empl1);
                    employees->put(4, empl2);
                    employees->put(5, empl3);

                    EntryMultiplier processor(4);

                    std::unique_ptr<hazelcast::client::EntryArray<int, int> > result =
                            employees->executeOnEntries<int, EntryMultiplier>(processor, query::TruePredicate());

                    ASSERT_EQ(3, (int) result->size());
                    for (size_t i = 0; i < result->size(); ++i) {
                        const int *key = result->getKey(i);
                        const int *value = result->getValue(i);
                        ASSERT_TRUE(*key == 3 || *key == 4 || *key == 5);
                        ASSERT_EQ((*key) * processor.getMultiplier(), (*value));
                    }
                }

                TEST_F(RawPointerMapTest, testExecuteOnEntriesWithFalsePredicate) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    employees->put(3, empl1);
                    employees->put(4, empl2);
                    employees->put(5, empl3);

                    EntryMultiplier processor(4);

                    std::unique_ptr<hazelcast::client::EntryArray<int, int> > result =
                            employees->executeOnEntries<int, EntryMultiplier>(processor, query::FalsePredicate());

                    ASSERT_EQ(0, (int) result->size());
                }

                TEST_F(RawPointerMapTest, testExecuteOnEntriesWithAndPredicate) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    employees->put(3, empl1);
                    employees->put(4, empl2);
                    employees->put(5, empl3);

                    query::AndPredicate andPredicate;
/* 25 <= age <= 35 AND age = 35 */
                    andPredicate.add(
                            std::unique_ptr<query::Predicate>(new query::BetweenPredicate<int>("a", 25, 35))).add(
                            std::unique_ptr<query::Predicate>(
                                    new query::NotPredicate(
                                            std::unique_ptr<query::Predicate>(
                                                    new query::EqualPredicate<int>("a", 35)))));

                    EntryMultiplier processor(4);

                    std::unique_ptr<hazelcast::client::EntryArray<int, int> > result = employees->executeOnEntries<int, EntryMultiplier>(
                            processor, andPredicate);

                    ASSERT_EQ(1, (int) result->size());
                    ASSERT_EQ(5, *result->getKey(0));
                    ASSERT_EQ(5 * processor.getMultiplier(), *result->getValue(0));
                }

                TEST_F(RawPointerMapTest, testExecuteOnEntriesWithOrPredicate) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    employees->put(3, empl1);
                    employees->put(4, empl2);
                    employees->put(5, empl3);

                    query::OrPredicate orPredicate;
/* age == 21 OR age > 25 */
                    orPredicate.add(
                            std::unique_ptr<query::Predicate>(new query::EqualPredicate<int>("a", 21))).add(
                            std::unique_ptr<query::Predicate>(
                                    new query::GreaterLessPredicate<int>("a", 25, false, false)));

                    EntryMultiplier processor(4);

                    std::unique_ptr<hazelcast::client::EntryArray<int, int> > result = employees->executeOnEntries<int, EntryMultiplier>(
                            processor, orPredicate);

                    ASSERT_EQ(2, (int) result->size());
                    if (3 == *result->getKey(0)) {
                        ASSERT_EQ(3 * processor.getMultiplier(), *result->getValue(0));
                        ASSERT_EQ(4, *result->getKey(1));
                        ASSERT_EQ(4 * processor.getMultiplier(), *result->getValue(1));
                    } else {
                        ASSERT_EQ(4, *result->getKey(0));
                        ASSERT_EQ(4 * processor.getMultiplier(), *result->getValue(0));
                        ASSERT_EQ(3, *result->getKey(1));
                        ASSERT_EQ(3 * processor.getMultiplier(), *result->getValue(1));
                    }
                }

                TEST_F(RawPointerMapTest, testExecuteOnEntriesWithBetweenPredicate) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    employees->put(3, empl1);
                    employees->put(4, empl2);
                    employees->put(5, empl3);

                    EntryMultiplier processor(4);

                    std::unique_ptr<hazelcast::client::EntryArray<int, int> > result = employees->executeOnEntries<int, EntryMultiplier>(
                            processor, query::BetweenPredicate<int>("a", 25, 35));

                    ASSERT_EQ(2, (int) result->size());
                    if (3 == *result->getKey(0)) {
                        ASSERT_EQ(3 * processor.getMultiplier(), *result->getValue(0));
                        ASSERT_EQ(5, *result->getKey(1));
                        ASSERT_EQ(5 * processor.getMultiplier(), *result->getValue(1));
                    } else {
                        ASSERT_EQ(5, *result->getKey(0));
                        ASSERT_EQ(5 * processor.getMultiplier(), *result->getValue(0));
                        ASSERT_EQ(3, *result->getKey(1));
                        ASSERT_EQ(3 * processor.getMultiplier(), *result->getValue(1));
                    }
                }

                TEST_F(RawPointerMapTest, testExecuteOnEntriesWithEqualPredicate) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    employees->put(3, empl1);
                    employees->put(4, empl2);
                    employees->put(5, empl3);

                    EntryMultiplier processor(4);

                    std::unique_ptr<hazelcast::client::EntryArray<int, int> > result = employees->executeOnEntries<int, EntryMultiplier>(
                            processor, query::EqualPredicate<int>("a", 25));

                    ASSERT_EQ(1, (int) result->size());
                    ASSERT_EQ(5, *result->getKey(0));
                    ASSERT_EQ(5 * processor.getMultiplier(), *result->getValue(0));
                }

                TEST_F(RawPointerMapTest, testExecuteOnEntriesWithNotEqualPredicate) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    employees->put(3, empl1);
                    employees->put(4, empl2);
                    employees->put(5, empl3);

                    EntryMultiplier processor(4);

                    std::unique_ptr<hazelcast::client::EntryArray<int, int> > result = employees->executeOnEntries<int, EntryMultiplier>(
                            processor, query::NotEqualPredicate<int>("a", 25));

                    ASSERT_EQ(2, (int) result->size());
                    if (3 == *result->getKey(0)) {
                        ASSERT_EQ(3 * processor.getMultiplier(), *result->getValue(0));
                        ASSERT_EQ(4, *result->getKey(1));
                        ASSERT_EQ(4 * processor.getMultiplier(), *result->getValue(1));
                    } else {
                        ASSERT_EQ(4, *result->getKey(0));
                        ASSERT_EQ(4 * processor.getMultiplier(), *result->getValue(0));
                        ASSERT_EQ(3, *result->getKey(1));
                        ASSERT_EQ(3 * processor.getMultiplier(), *result->getValue(1));
                    }
                }

                TEST_F(RawPointerMapTest, testExecuteOnEntriesWithGreaterLessPredicate) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    employees->put(3, empl1);
                    employees->put(4, empl2);
                    employees->put(5, empl3);

                    EntryMultiplier processor(4);

                    std::unique_ptr<hazelcast::client::EntryArray<int, int> > result = employees->executeOnEntries<int, EntryMultiplier>(
                            processor, query::GreaterLessPredicate<int>("a", 25, false, true)); // <25 matching

                    ASSERT_EQ(1, (int) result->size());
                    ASSERT_EQ(4, *result->getKey(0));
                    ASSERT_EQ(4 * processor.getMultiplier(), *result->getValue(0));

                    result = employees->executeOnEntries<int, EntryMultiplier>(
                            processor, query::GreaterLessPredicate<int>("a", 25, true, true)); // <=25 matching

                    ASSERT_EQ(2, (int) result->size());
                    if (4 == *result->getKey(0)) {
                        ASSERT_EQ(4 * processor.getMultiplier(), *result->getValue(0));
                        ASSERT_EQ(5, *result->getKey(1));
                        ASSERT_EQ(5 * processor.getMultiplier(), *result->getValue(1));
                    } else {
                        ASSERT_EQ(5, *result->getKey(0));
                        ASSERT_EQ(5 * processor.getMultiplier(), *result->getValue(0));
                        ASSERT_EQ(4, *result->getKey(1));
                        ASSERT_EQ(4 * processor.getMultiplier(), *result->getValue(1));
                    }

                    result = employees->executeOnEntries<int, EntryMultiplier>(
                            processor, query::GreaterLessPredicate<int>("a", 25, false, false)); // >25 matching

                    ASSERT_EQ(1, (int) result->size());
                    ASSERT_EQ(3, *result->getKey(0));
                    ASSERT_EQ(3 * processor.getMultiplier(), *result->getValue(0));

                    result = employees->executeOnEntries<int, EntryMultiplier>(
                            processor, query::GreaterLessPredicate<int>("a", 25, true, false)); // >=25 matching

                    ASSERT_EQ(2, (int) result->size());
                    if (3 == *result->getKey(0)) {
                        ASSERT_EQ(3 * processor.getMultiplier(), *result->getValue(0));
                        ASSERT_EQ(5, *result->getKey(1));
                        ASSERT_EQ(5 * processor.getMultiplier(), *result->getValue(1));
                    } else {
                        ASSERT_EQ(5, *result->getKey(0));
                        ASSERT_EQ(5 * processor.getMultiplier(), *result->getValue(0));
                        ASSERT_EQ(3, *result->getKey(1));
                        ASSERT_EQ(3 * processor.getMultiplier(), *result->getValue(1));
                    }
                }

                TEST_F(RawPointerMapTest, testExecuteOnEntriesWithLikePredicate) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    employees->put(3, empl1);
                    employees->put(4, empl2);
                    employees->put(5, empl3);

                    EntryMultiplier processor(4);

                    std::unique_ptr<hazelcast::client::EntryArray<int, int> > result = employees->executeOnEntries<int, EntryMultiplier>(
                            processor, query::LikePredicate("n", "deniz"));

                    ASSERT_EQ(1, (int) result->size());
                    ASSERT_EQ(5, *result->getKey(0));
                    ASSERT_EQ(5 * processor.getMultiplier(), *result->getValue(0));
                }

                TEST_F(RawPointerMapTest, testExecuteOnEntriesWithILikePredicate) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    employees->put(3, empl1);
                    employees->put(4, empl2);
                    employees->put(5, empl3);

                    EntryMultiplier processor(4);

                    std::unique_ptr<hazelcast::client::EntryArray<int, int> > result = employees->executeOnEntries<int, EntryMultiplier>(
                            processor, query::ILikePredicate("n", "deniz"));

                    ASSERT_EQ(1, (int) result->size());
                    ASSERT_EQ(5, *result->getKey(0));
                    ASSERT_EQ(5 * processor.getMultiplier(), *result->getValue(0));
                }

                TEST_F(RawPointerMapTest, testExecuteOnEntriesWithInPredicate) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    employees->put(3, empl1);
                    employees->put(4, empl2);
                    employees->put(5, empl3);

                    EntryMultiplier processor(4);

                    std::vector<std::string> values;
                    values.push_back("ahmet");
                    query::InPredicate<std::string> predicate("n", values);
                    predicate.add("mehmet");
                    std::unique_ptr<hazelcast::client::EntryArray<int, int> > result = employees->executeOnEntries<int, EntryMultiplier>(
                            processor, predicate);

                    ASSERT_EQ(2, (int) result->size());
                    if (3 == *result->getKey(0)) {
                        ASSERT_EQ(3 * processor.getMultiplier(), *result->getValue(0));
                        ASSERT_EQ(4, *result->getKey(1));
                        ASSERT_EQ(4 * processor.getMultiplier(), *result->getValue(1));
                    } else {
                        ASSERT_EQ(4, *result->getKey(0));
                        ASSERT_EQ(4 * processor.getMultiplier(), *result->getValue(0));
                        ASSERT_EQ(3, *result->getKey(1));
                        ASSERT_EQ(3 * processor.getMultiplier(), *result->getValue(1));
                    }
                }

                TEST_F(RawPointerMapTest, testExecuteOnEntriesWithInstanceOfPredicate) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    employees->put(3, empl1);
                    employees->put(4, empl2);
                    employees->put(5, empl3);

                    EntryMultiplier processor(4);
                    std::unique_ptr<hazelcast::client::EntryArray<int, int> > result = employees->executeOnEntries<int, EntryMultiplier>(
                            processor, query::InstanceOfPredicate("com.hazelcast.client.test.Employee"));

                    ASSERT_EQ(3, (int) result->size());
                }

                TEST_F(RawPointerMapTest, testExecuteOnEntriesWithNotPredicate) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    employees->put(3, empl1);
                    employees->put(4, empl2);
                    employees->put(5, empl3);

                    EntryMultiplier processor(4);
                    query::NotPredicate notEqualPredicate(
                            std::unique_ptr<query::Predicate>(new query::EqualPredicate<int>("a", 25)));
                    std::unique_ptr<hazelcast::client::EntryArray<int, int> > result =
                            employees->executeOnEntries<int, EntryMultiplier>(processor, notEqualPredicate);

                    ASSERT_EQ(2, (int) result->size());
                    if (3 == *result->getKey(0)) {
                        ASSERT_EQ(3 * processor.getMultiplier(), *result->getValue(0));
                        ASSERT_EQ(4, *result->getKey(1));
                        ASSERT_EQ(4 * processor.getMultiplier(), *result->getValue(1));
                    } else {
                        ASSERT_EQ(4, *result->getKey(0));
                        ASSERT_EQ(4 * processor.getMultiplier(), *result->getValue(0));
                        ASSERT_EQ(3, *result->getKey(1));
                        ASSERT_EQ(3 * processor.getMultiplier(), *result->getValue(1));
                    }

                    query::NotPredicate notFalsePredicate(
                            std::unique_ptr<query::Predicate>(new query::FalsePredicate()));
                    result = employees->executeOnEntries<int, EntryMultiplier>(processor, notFalsePredicate);

                    ASSERT_EQ(3, (int) result->size());

                    query::NotPredicate notBetweenPredicate(
                            std::unique_ptr<query::Predicate>(new query::BetweenPredicate<int>("a", 25, 35)));
                    result = employees->executeOnEntries<int, EntryMultiplier>(processor, notBetweenPredicate);

                    ASSERT_EQ(1, (int) result->size());
                    ASSERT_EQ(4, *result->getKey(0));
                    ASSERT_EQ(4 * processor.getMultiplier(), *result->getValue(0));
                }

                TEST_F(RawPointerMapTest, testExecuteOnEntriesWithRegexPredicate) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    employees->put(3, empl1);
                    employees->put(4, empl2);
                    employees->put(5, empl3);

                    EntryMultiplier processor(4);

                    std::unique_ptr<hazelcast::client::EntryArray<int, int> > result = employees->executeOnEntries<int, EntryMultiplier>(
                            processor, query::RegexPredicate("n", ".*met"));

                    ASSERT_EQ(2, (int) result->size());
                    if (3 == *result->getKey(0)) {
                        ASSERT_EQ(3 * processor.getMultiplier(), *result->getValue(0));
                        ASSERT_EQ(4, *result->getKey(1));
                        ASSERT_EQ(4 * processor.getMultiplier(), *result->getValue(1));
                    } else {
                        ASSERT_EQ(4, *result->getKey(0));
                        ASSERT_EQ(4 * processor.getMultiplier(), *result->getValue(0));
                        ASSERT_EQ(3, *result->getKey(1));
                        ASSERT_EQ(3 * processor.getMultiplier(), *result->getValue(1));
                    }
                }

                TEST_F(RawPointerMapTest, testAddInterceptor) {
                    std::string prefix("My Prefix");
                    MapGetInterceptor interceptor(prefix);
                    imap->addInterceptor<MapGetInterceptor>(interceptor);

                    std::unique_ptr<std::string> val = imap->get("nonexistent");
                    ASSERT_NE((std::string *) NULL, val.get());
                    ASSERT_EQ(prefix, *val);

                    val = imap->put("key1", "value1");
                    ASSERT_EQ((std::string *) NULL, val.get());

                    val = imap->get("key1");
                    ASSERT_NE((std::string *) NULL, val.get());
                    ASSERT_EQ(prefix + "value1", *val);
                }

                TEST_F(RawPointerMapTest, testReadUTFWrittenByJava) {
                    std::string value = "xyz123    ";
                    std::string key = "myutfkey";
                    IMap<std::string, std::string> map = client->getMap<std::string, std::string>(
                            "testReadUTFWrittenByJavaMap");
                    map.put(key, value);
                    UTFValueValidatorProcessor processor;
                    std::shared_ptr<bool> result = map.executeOnKey<bool, UTFValueValidatorProcessor>(key, processor);
                    ASSERT_NOTNULL(result.get(), bool);
                    ASSERT_TRUE(*result);
                }
            }
        }
    }
}





namespace hazelcast {
    namespace client {
        namespace test {
            namespace adaptor {
                class RawPointerListTest : public ClientTestSupport {
                protected:
                    class MyListItemListener : public ItemListener<std::string> {
                    public:
                        MyListItemListener(hazelcast::util::CountDownLatch& latch)
                                : latch(latch) {

                        }

                        void itemAdded(const ItemEvent<std::string>& itemEvent) {
                            latch.countDown();
                        }

                        void itemRemoved(const ItemEvent<std::string>& item) {
                        }

                    private:
                        hazelcast::util::CountDownLatch& latch;
                    };

                    virtual void TearDown() {
                        // clear list
                        list->clear();
                    }

                    static void SetUpTestCase() {
                        instance = new HazelcastServer(*g_srvFactory);
                        instance2 = new HazelcastServer(*g_srvFactory);
                        client = new HazelcastClient();
                        legacyList = new IList<std::string>(client->getList<std::string>("MyList"));
                        list = new client::adaptor::RawPointerList<std::string>(*legacyList);
                    }

                    static void TearDownTestCase() {
                        delete list;
                        delete legacyList;
                        delete client;
                        delete instance2;
                        delete instance;

                        list = NULL;
                        legacyList = NULL;
                        client = NULL;
                        instance2 = NULL;
                        instance = NULL;
                    }

                    static HazelcastServer *instance;
                    static HazelcastServer *instance2;
                    static HazelcastClient *client;
                    static IList<std::string> *legacyList;
                    static client::adaptor::RawPointerList<std::string> *list;
                };

                HazelcastServer *RawPointerListTest::instance = NULL;
                HazelcastServer *RawPointerListTest::instance2 = NULL;
                HazelcastClient *RawPointerListTest::client = NULL;
                IList<std::string> *RawPointerListTest::legacyList = NULL;
                client::adaptor::RawPointerList<std::string> *RawPointerListTest::list = NULL;

                TEST_F(RawPointerListTest, testAddAll) {
                    std::vector<std::string> l;
                    l.push_back("item1");
                    l.push_back("item2");
                    ASSERT_TRUE(list->addAll(l));

                    ASSERT_TRUE(list->addAll(1, l));
                    ASSERT_EQ(4, list->size());

                    ASSERT_EQ("item1", *(list->get(0)));
                    ASSERT_EQ("item1", *(list->get(1)));
                    ASSERT_EQ("item2", *(list->get(2)));
                    ASSERT_EQ("item2", *(list->get(3)));
                }

                TEST_F(RawPointerListTest, testAddSetRemove) {
                    ASSERT_TRUE(list->add("item1"));
                    ASSERT_TRUE(list->add("item2"));
                    list->add(0, "item3");
                    ASSERT_EQ(3, list->size());
                    std::unique_ptr<std::string> temp = list->set(2, "item4");
                    ASSERT_EQ("item2", *temp);

                    ASSERT_EQ(3, list->size());
                    ASSERT_EQ("item3", *(list->get(0)));
                    ASSERT_EQ("item1", *(list->get(1)));
                    ASSERT_EQ("item4", *(list->get(2)));

                    ASSERT_FALSE(list->remove("item2"));
                    ASSERT_TRUE(list->remove("item3"));

                    temp = list->remove(1);
                    ASSERT_EQ("item4", *temp);

                    ASSERT_EQ(1, list->size());
                    ASSERT_EQ("item1", *(list->get(0)));
                }

                TEST_F(RawPointerListTest, testIndexOf) {
                    ASSERT_TRUE(list->add("item1"));
                    ASSERT_TRUE(list->add("item2"));
                    ASSERT_TRUE(list->add("item1"));
                    ASSERT_TRUE(list->add("item4"));

                    ASSERT_EQ(-1, list->indexOf("item5"));
                    ASSERT_EQ(0, list->indexOf("item1"));

                    ASSERT_EQ(-1, list->lastIndexOf("item6"));
                    ASSERT_EQ(2, list->lastIndexOf("item1"));
                }

                TEST_F(RawPointerListTest, testToArray) {
                    ASSERT_TRUE(list->add("item1"));
                    ASSERT_TRUE(list->add("item2"));
                    ASSERT_TRUE(list->add("item1"));
                    ASSERT_TRUE(list->add("item4"));

                    std::unique_ptr<client::DataArray<std::string> > ar = list->toArray();

                    ASSERT_EQ((size_t) 4, ar->size());
                    ASSERT_NE((std::string *) NULL, ar->get(0));
                    ASSERT_NE((std::string *) NULL, ar->get(1));
                    ASSERT_NE((std::string *) NULL, ar->get(2));
                    ASSERT_NE((std::string *) NULL, ar->get(3));
                    ASSERT_EQ("item1", *((*ar)[0]));
                    ASSERT_EQ("item2", *ar->get(1));
                    ASSERT_EQ("item1", *((*ar)[2]));
                    ASSERT_EQ("item4", *ar->get(3));

                    ar = list->subList(1, 3);

                    ASSERT_EQ((size_t) 2, ar->size());
                    ASSERT_NE((std::string *) NULL, ar->get(0));
                    ASSERT_NE((std::string *) NULL, ar->get(1));
                    ASSERT_EQ("item2", *ar->get(0));
                    ASSERT_EQ("item1", *ar->get(1));
                }

                TEST_F(RawPointerListTest, testContains) {
                    ASSERT_TRUE(list->add("item1"));
                    ASSERT_TRUE(list->add("item2"));
                    ASSERT_TRUE(list->add("item1"));
                    ASSERT_TRUE(list->add("item4"));

                    ASSERT_FALSE(list->contains("item3"));
                    ASSERT_TRUE(list->contains("item2"));

                    std::vector<std::string> l;
                    l.push_back("item4");
                    l.push_back("item3");

                    ASSERT_FALSE(list->containsAll(l));
                    ASSERT_TRUE(list->add("item3"));
                    ASSERT_TRUE(list->containsAll(l));
                }

                TEST_F(RawPointerListTest, testRemoveRetainAll) {
                    ASSERT_TRUE(list->add("item1"));
                    ASSERT_TRUE(list->add("item2"));
                    ASSERT_TRUE(list->add("item1"));
                    ASSERT_TRUE(list->add("item4"));

                    std::vector<std::string> l;
                    l.push_back("item4");
                    l.push_back("item3");

                    ASSERT_TRUE(list->removeAll(l));
                    ASSERT_EQ(3, (int) list->size());
                    ASSERT_FALSE(list->removeAll(l));
                    ASSERT_EQ(3, (int) list->size());

                    l.clear();
                    l.push_back("item1");
                    l.push_back("item2");
                    ASSERT_FALSE(list->retainAll(l));
                    ASSERT_EQ(3, (int) list->size());

                    l.clear();
                    ASSERT_TRUE(list->retainAll(l));
                    ASSERT_EQ(0, (int) list->size());

                }

                TEST_F(RawPointerListTest, testListener) {
                    hazelcast::util::CountDownLatch latch(5);

                    MyListItemListener listener(latch);
                    std::string registrationId = list->addItemListener(listener, true);

                    for (int i = 0; i < 5; i++) {
                        list->add(std::string("item") + hazelcast::util::IOUtil::to_string(i));
                    }

                    ASSERT_TRUE(latch.await(20));

                    ASSERT_TRUE(list->removeItemListener(registrationId));
                }
            }
        }
    }
}





namespace hazelcast {
    namespace client {
        namespace test {
            namespace adaptor {
                class RawPointerTxnQueueTest : public ClientTestSupport {
                protected:
                    static void SetUpTestCase() {
                        instance = new HazelcastServer(*g_srvFactory);
                        client = new HazelcastClient(getConfig());
                    }

                    static void TearDownTestCase() {
                        delete client;
                        delete instance;

                        client = NULL;
                        instance = NULL;
                    }

                    static HazelcastServer *instance;
                    static HazelcastClient *client;
                };

                HazelcastServer *RawPointerTxnQueueTest::instance = NULL;
                HazelcastClient *RawPointerTxnQueueTest::client = NULL;

                TEST_F(RawPointerTxnQueueTest, testTransactionalOfferPoll1) {
                    std::string name = "defQueue";

                    TransactionContext context = client->newTransactionContext();
                    context.beginTransaction();
                    TransactionalQueue<std::string> queue = context.getQueue<std::string>(name);
                    client::adaptor::RawPointerTransactionalQueue<std::string> q(queue);
                    ASSERT_TRUE(q.offer("ali"));
                    std::unique_ptr<std::string> item = q.poll();
                    ASSERT_NE((std::string *) NULL, item.get());
                    ASSERT_EQ("ali", *item);
                    context.commitTransaction();
                    ASSERT_EQ(0, client->getQueue<std::string>(name).size());
                }

                void testTransactionalOfferPoll2Thread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    HazelcastClient *client = (HazelcastClient *) args.arg1;
                    latch->await();
                    client->getQueue<std::string>("defQueue0").offer("item0");
                }

                TEST_F(RawPointerTxnQueueTest, testTransactionalOfferPoll2) {
                    hazelcast::util::CountDownLatch latch(1);
                    hazelcast::util::StartedThread t(testTransactionalOfferPoll2Thread, &latch, client);
                    TransactionContext context = client->newTransactionContext();
                    context.beginTransaction();
                    TransactionalQueue<std::string> queue0 = context.getQueue<std::string>("defQueue0");
                    client::adaptor::RawPointerTransactionalQueue<std::string> q0(queue0);
                    TransactionalQueue<std::string> queue1 = context.getQueue<std::string>("defQueue1");
                    client::adaptor::RawPointerTransactionalQueue<std::string> q1(queue1);
                    latch.countDown();
                    std::unique_ptr<std::string> item = q0.poll(10 * 1000);
                    ASSERT_NE((std::string *) NULL, item.get());
                    ASSERT_EQ("item0", *item);
                    ASSERT_TRUE(q1.offer(*item));

                    ASSERT_NO_THROW(context.commitTransaction());

                    ASSERT_EQ(0, client->getQueue<std::string>("defQueue0").size());
                    ASSERT_EQ("item0", *(client->getQueue<std::string>("defQueue1").poll()));
                }
            }
        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            namespace adaptor {
                class RawPointerQueueTest : public ClientTestSupport {
                protected:
                    class QueueTestItemListener : public ItemListener<std::string> {
                    public:
                        QueueTestItemListener(hazelcast::util::CountDownLatch &latch)
                                : latch(latch) {

                        }

                        void itemAdded(const ItemEvent<std::string> &itemEvent) {
                            latch.countDown();
                        }

                        void itemRemoved(const ItemEvent<std::string> &item) {
                        }

                    private:
                        hazelcast::util::CountDownLatch &latch;
                    };

                    virtual void TearDown() {
                        q->clear();
                    }

                    static void SetUpTestCase() {
                        instance = new HazelcastServer(*g_srvFactory);
                        client = new HazelcastClient(getConfig());
                        legacy = new IQueue<std::string>(client->getQueue<std::string>("MyQueue"));
                        q = new client::adaptor::RawPointerQueue<std::string>(*legacy);
                    }

                    static void TearDownTestCase() {
                        delete q;
                        delete legacy;
                        delete client;
                        delete instance;

                        q = NULL;
                        legacy = NULL;
                        client = NULL;
                        instance = NULL;
                    }

                    static HazelcastServer *instance;
                    static HazelcastClient *client;
                    static IQueue<std::string> *legacy;
                    static client::adaptor::RawPointerQueue<std::string> *q;
                };

                HazelcastServer *RawPointerQueueTest::instance = NULL;
                HazelcastClient *RawPointerQueueTest::client = NULL;
                IQueue<std::string> *RawPointerQueueTest::legacy = NULL;
                client::adaptor::RawPointerQueue<std::string> *RawPointerQueueTest::q = NULL;

                TEST_F(RawPointerQueueTest, testListener) {
                    ASSERT_EQ(0, q->size());

                    hazelcast::util::CountDownLatch latch(5);

                    QueueTestItemListener qener(latch);
                    std::string id = q->addItemListener(qener, true);

                    hazelcast::util::sleep(1);

                    for (int i = 0; i < 5; i++) {
                        ASSERT_TRUE(q->offer(std::string("event_item") + hazelcast::util::IOUtil::to_string(i)));
                    }

                    ASSERT_TRUE(latch.await(5));
                    ASSERT_TRUE(q->removeItemListener(id));
                }

                void testOfferPollThread2(hazelcast::util::ThreadArgs &args) {
                    client::adaptor::RawPointerQueue<std::string> *q = (client::adaptor::RawPointerQueue<std::string> *) args.arg0;
                    hazelcast::util::sleep(2);
                    q->offer("item1");
                }

                TEST_F(RawPointerQueueTest, testOfferPoll) {
                    for (int i = 0; i < 10; i++) {
                        bool result = q->offer("item");
                        ASSERT_TRUE(result);
                    }
                    ASSERT_EQ(10, q->size());
                    q->poll();
                    bool result = q->offer("item", 5);
                    ASSERT_TRUE(result);

                    for (int i = 0; i < 10; i++) {
                        ASSERT_NE(q->poll().get(), (std::string *) NULL);
                    }
                    ASSERT_EQ(0, q->size());

                    hazelcast::util::StartedThread t2(testOfferPollThread2, q);

                    std::unique_ptr<std::string> item = q->poll(30 * 1000);
                    ASSERT_NE(item.get(), (std::string *) NULL);
                    ASSERT_EQ("item1", *item);
                    t2.join();
                }

                TEST_F(RawPointerQueueTest, testRemainingCapacity) {
                    int capacity = q->remainingCapacity();
                    ASSERT_TRUE(capacity > 10000);
                    q->offer("item");
                    ASSERT_EQ(capacity - 1, q->remainingCapacity());
                }

                TEST_F(RawPointerQueueTest, testPeek) {
                    ASSERT_TRUE(q->offer("peek 1"));
                    ASSERT_TRUE(q->offer("peek 2"));
                    ASSERT_TRUE(q->offer("peek 3"));

                    std::unique_ptr<std::string> item = q->peek();
                    ASSERT_NE((std::string *) NULL, item.get());
                    ASSERT_EQ("peek 1", *item);
                }

                TEST_F(RawPointerQueueTest, testTake) {
                    ASSERT_TRUE(q->offer("peek 1"));
                    ASSERT_TRUE(q->offer("peek 2"));
                    ASSERT_TRUE(q->offer("peek 3"));

                    std::unique_ptr<std::string> item = q->take();
                    ASSERT_NE((std::string *) NULL, item.get());
                    ASSERT_EQ("peek 1", *item);

                    item = q->take();
                    ASSERT_NE((std::string *) NULL, item.get());
                    ASSERT_EQ("peek 2", *item);

                    item = q->take();
                    ASSERT_NE((std::string *) NULL, item.get());
                    ASSERT_EQ("peek 3", *item);

                    ASSERT_TRUE(q->isEmpty());

// start a thread to insert an item
                    hazelcast::util::StartedThread t2(testOfferPollThread2, q);

                    item = q->take();  //  should block till it gets an item
                    ASSERT_NE((std::string *) NULL, item.get());
                    ASSERT_EQ("item1", *item);

                    t2.join();
                }

                TEST_F(RawPointerQueueTest, testRemove) {
                    ASSERT_TRUE(q->offer("item1"));
                    ASSERT_TRUE(q->offer("item2"));
                    ASSERT_TRUE(q->offer("item3"));

                    ASSERT_FALSE(q->remove("item4"));
                    ASSERT_EQ(3, q->size());

                    ASSERT_TRUE(q->remove("item2"));

                    ASSERT_EQ(2, q->size());

                    ASSERT_EQ("item1", *(q->poll()));
                    ASSERT_EQ("item3", *(q->poll()));
                }


                TEST_F(RawPointerQueueTest, testContains) {
                    ASSERT_TRUE(q->offer("item1"));
                    ASSERT_TRUE(q->offer("item2"));
                    ASSERT_TRUE(q->offer("item3"));
                    ASSERT_TRUE(q->offer("item4"));
                    ASSERT_TRUE(q->offer("item5"));


                    ASSERT_TRUE(q->contains("item3"));
                    ASSERT_FALSE(q->contains("item"));

                    std::vector<std::string> list;
                    list.push_back("item4");
                    list.push_back("item2");

                    ASSERT_TRUE(q->containsAll(list));

                    list.push_back("item");
                    ASSERT_FALSE(q->containsAll(list));
                }

                TEST_F(RawPointerQueueTest, testDrain) {
                    ASSERT_TRUE(q->offer("item1"));
                    ASSERT_TRUE(q->offer("item2"));
                    ASSERT_TRUE(q->offer("item3"));
                    ASSERT_TRUE(q->offer("item4"));
                    ASSERT_TRUE(q->offer("item5"));

                    std::unique_ptr<client::DataArray<std::string> > list = q->drainTo(2);
                    ASSERT_EQ((size_t) 2U, list->size());
                    ASSERT_NE((std::string *) NULL, list->get(0));
                    ASSERT_NE((std::string *) NULL, list->get(1));
                    ASSERT_EQ("item1", *list->get(0));
                    ASSERT_EQ("item2", *list->get(1));

                    list = q->drainTo();
                    ASSERT_EQ((size_t) 3U, list->size());
                    ASSERT_NE((std::string *) NULL, list->get(0));
                    ASSERT_NE((std::string *) NULL, list->get(1));
                    ASSERT_NE((std::string *) NULL, list->get(2));
                    ASSERT_EQ("item3", *list->get(0));
                    ASSERT_EQ("item4", *list->get(1));
                    ASSERT_EQ("item5", *list->get(2));

                    ASSERT_TRUE(q->offer("item1"));
                    ASSERT_TRUE(q->offer("item2"));
                    ASSERT_TRUE(q->offer("item3"));
                    list = q->drainTo(5);
                    ASSERT_EQ((size_t) 3U, list->size());
                    ASSERT_NE((std::string *) NULL, list->get(0));
                    ASSERT_NE((std::string *) NULL, list->get(1));
                    ASSERT_NE((std::string *) NULL, list->get(2));
                    ASSERT_EQ("item1", *list->get(0));
                    ASSERT_EQ("item2", *list->get(1));
                    ASSERT_EQ("item3", *list->get(2));
                }

                TEST_F(RawPointerQueueTest, testToArray) {
                    ASSERT_TRUE(q->offer("item1"));
                    ASSERT_TRUE(q->offer("item2"));
                    ASSERT_TRUE(q->offer("item3"));
                    ASSERT_TRUE(q->offer("item4"));
                    ASSERT_TRUE(q->offer("item5"));

                    std::unique_ptr<client::DataArray<std::string> > array = q->toArray();
                    size_t size = array->size();
                    ASSERT_EQ(5U, size);
                    for (size_t i = 0; i < size; i++) {
                        const std::string *item = (*array)[i];
                        ASSERT_NE((std::string *) NULL, item);
                        ASSERT_EQ(std::string("item") + hazelcast::util::IOUtil::to_string(i + 1), *item);
                    }
                }

                TEST_F(RawPointerQueueTest, testAddAll) {
                    std::vector<std::string> coll;
                    coll.push_back("item1");
                    coll.push_back("item2");
                    coll.push_back("item3");
                    coll.push_back("item4");

                    ASSERT_TRUE(q->addAll(coll));
                    int size = q->size();
                    ASSERT_EQ(size, (int) coll.size());
                }

                TEST_F(RawPointerQueueTest, testRemoveRetain) {
                    ASSERT_TRUE(q->offer("item1"));
                    ASSERT_TRUE(q->offer("item2"));
                    ASSERT_TRUE(q->offer("item3"));
                    ASSERT_TRUE(q->offer("item4"));
                    ASSERT_TRUE(q->offer("item5"));

                    std::vector<std::string> list;
                    list.push_back("item8");
                    list.push_back("item9");
                    ASSERT_FALSE(q->removeAll(list));
                    ASSERT_EQ(5, q->size());

                    list.push_back("item3");
                    list.push_back("item4");
                    list.push_back("item1");
                    ASSERT_TRUE(q->removeAll(list));
                    ASSERT_EQ(2, q->size());

                    list.clear();
                    list.push_back("item2");
                    list.push_back("item5");
                    ASSERT_FALSE(q->retainAll(list));
                    ASSERT_EQ(2, q->size());

                    list.clear();
                    ASSERT_TRUE(q->retainAll(list));
                    ASSERT_EQ(0, q->size());
                }

                TEST_F(RawPointerQueueTest, testClear) {
                    ASSERT_TRUE(q->offer("item1"));
                    ASSERT_TRUE(q->offer("item2"));
                    ASSERT_TRUE(q->offer("item3"));
                    ASSERT_TRUE(q->offer("item4"));
                    ASSERT_TRUE(q->offer("item5"));

                    q->clear();

                    ASSERT_EQ(0, q->size());
                    ASSERT_EQ(q->poll().get(), (std::string *) NULL);
                }
            }
        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            class RawPointerClientTxnMapTest : public ClientTestSupport {
            protected:
                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    client = new HazelcastClient(getConfig());
                }

                static void TearDownTestCase() {
                    delete client;
                    delete instance;

                    client = NULL;
                    instance = NULL;
                }

                static HazelcastServer *instance;
                static HazelcastClient *client;
            };

            HazelcastServer *RawPointerClientTxnMapTest::instance = NULL;
            HazelcastClient *RawPointerClientTxnMapTest::client = NULL;

            TEST_F(RawPointerClientTxnMapTest, testPutGet) {
                std::string name = "defMap";

                TransactionContext context = client->newTransactionContext();
                context.beginTransaction();

                TransactionalMap<std::string, std::string> originalMap = context.getMap<std::string, std::string>(name);
                client::adaptor::RawPointerTransactionalMap<std::string, std::string> map(originalMap);

                ASSERT_EQ(map.put("key1", "value1").get(), (std::string *) NULL);
                ASSERT_EQ("value1", *(map.get("key1")));
                std::shared_ptr<std::string> val = client->getMap<std::string, std::string>(name).get("key1");
                ASSERT_EQ(val.get(), (std::string *) NULL);

                context.commitTransaction();

                ASSERT_EQ("value1", *(client->getMap<std::string, std::string>(name).get("key1")));
            }


//            @Test MTODO
//            public void testGetForUpdate() throws TransactionException {
//            final IMap<String, Integer> map = hz.getMap("testTxnGetForUpdate");
//            final CountDownLatch latch1 = new CountDownLatch(1);
//            final CountDownLatch latch2 = new CountDownLatch(1);
//            map.put("var", 0);
//            final AtomicBoolean pass = new AtomicBoolean(true);
//
//
//            Runnable incrementor = new Runnable() {
//                public void run() {
//                    try {
//                        latch1.await(100, TimeUnit.SECONDS);
//                        pass.set(map.tryPut("var", 1, 0, TimeUnit.SECONDS) == false);
//                        latch2.countDown();
//                    } catch (Exception e) {
//                    }
//                }
//            }
//            new Thread(incrementor).start();
//            boolean b = hz.executeTransaction(new TransactionalTask<Boolean>() {
//                public Boolean execute(TransactionalTaskContext context) throws TransactionException {
//                    try {
//                        final TransactionalMap<String, Integer> txMap = context.getMap("testTxnGetForUpdate");
//                        txMap.getForUpdate("var");
//                        latch1.countDown();
//                        latch2.await(100, TimeUnit.SECONDS);
//                    } catch (Exception e) {
//                    }
//                    return true;
//                }
//            });
//            assertTrue(b);
//            assertTrue(pass.get());
//            assertTrue(map.tryPut("var", 1, 0, TimeUnit.SECONDS));
//        }

            TEST_F(RawPointerClientTxnMapTest, testKeySetValues) {
                std::string name = "testKeySetValues";
                IMap<std::string, std::string> map = client->getMap<std::string, std::string>(name);
                map.put("key1", "value1");
                map.put("key2", "value2");

                TransactionContext context = client->newTransactionContext();
                context.beginTransaction();
                TransactionalMap<std::string, std::string> originalMap = context.getMap<std::string, std::string>(name);
                client::adaptor::RawPointerTransactionalMap<std::string, std::string> txMap(originalMap);
                ASSERT_EQ(txMap.put("key3", "value3").get(), (std::string *) NULL);


                ASSERT_EQ(3, (int) txMap.size());
                ASSERT_EQ(3, (int) txMap.keySet()->size());
                ASSERT_EQ(3, (int) txMap.values()->size());
                context.commitTransaction();

                ASSERT_EQ(3, (int) map.size());
                ASSERT_EQ(3, (int) map.keySet().size());
                ASSERT_EQ(3, (int) map.values().size());

            }

            TEST_F(RawPointerClientTxnMapTest, testKeySetAndValuesWithPredicates) {
                std::string name = "testKeysetAndValuesWithPredicates";
                IMap<Employee, Employee> map = client->getMap<Employee, Employee>(name);

                Employee emp1("abc-123-xvz", 34);
                Employee emp2("abc-123-xvz", 20);

                map.put(emp1, emp1);

                TransactionContext context = client->newTransactionContext();
                context.beginTransaction();

                TransactionalMap<Employee, Employee> originalMap = context.getMap<Employee, Employee>(name);
                client::adaptor::RawPointerTransactionalMap<Employee, Employee> txMap(originalMap);

                ASSERT_EQ(txMap.put(emp2, emp2).get(), (Employee *) NULL);

                ASSERT_EQ(2, (int) txMap.size());
                ASSERT_EQ(2, (int) txMap.keySet()->size());
                query::SqlPredicate predicate("a = 10");
                ASSERT_EQ(0, (int) txMap.keySet(&predicate)->size());
                ASSERT_EQ(0, (int) txMap.values(&predicate)->size());
                query::SqlPredicate predicate2("a >= 10");
                ASSERT_EQ(2, (int) txMap.keySet(&predicate2)->size());
                ASSERT_EQ(2, (int) txMap.values(&predicate2)->size());

                context.commitTransaction();

                ASSERT_EQ(2, (int) map.size());
                ASSERT_EQ(2, (int) map.values().size());
            }
        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            namespace adaptor {
                class RawPointerMultiMapTest : public ClientTestSupport {
                protected:
                    class MyMultiMapListener : public EntryAdapter<std::string, std::string>{
                    public:
                        MyMultiMapListener(hazelcast::util::CountDownLatch& addedLatch, hazelcast::util::CountDownLatch& removedLatch)
                                : addedLatch(addedLatch), removedLatch(removedLatch) {
                        }

                        void entryAdded(const EntryEvent<std::string, std::string>& event) {
                            addedLatch.countDown();
                        }

                        void entryRemoved(const EntryEvent<std::string, std::string>& event) {
                            removedLatch.countDown();
                        }

                    private:
                        hazelcast::util::CountDownLatch& addedLatch;
                        hazelcast::util::CountDownLatch& removedLatch;
                    };

                    static void lockTtlThread(hazelcast::util::ThreadArgs& args) {
                        client::adaptor::RawPointerMultiMap<std::string, std::string> *map = (client::adaptor::RawPointerMultiMap<std::string, std::string> *)args.arg0;
                        hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *)args.arg1;

                        if (!map->tryLock("key1")) {
                            latch->countDown();
                        }

                        if (map->tryLock("key1", 5 * 1000)) {
                            latch->countDown();
                        }
                    }

                    virtual void TearDown() {
                        // clear mm
                        mm->clear();
                    }

                    static void SetUpTestCase() {
                        instance = new HazelcastServer(*g_srvFactory);
                        client = new HazelcastClient;
                        legacy = new MultiMap<std::string, std::string>(client->getMultiMap<std::string, std::string>("MyMultiMap"));
                        mm = new client::adaptor::RawPointerMultiMap<std::string, std::string>(*legacy);
                    }

                    static void TearDownTestCase() {
                        delete mm;
                        delete legacy;
                        delete client;
                        delete clientConfig;
                        delete instance;

                        mm = NULL;
                        legacy = NULL;
                        client = NULL;
                        clientConfig = NULL;
                        instance = NULL;
                    }

                    static HazelcastServer *instance;
                    static ClientConfig *clientConfig;
                    static HazelcastClient *client;
                    static MultiMap<std::string, std::string> *legacy;
                    static client::adaptor::RawPointerMultiMap<std::string, std::string> *mm;
                };

                HazelcastServer *RawPointerMultiMapTest::instance = NULL;
                ClientConfig *RawPointerMultiMapTest::clientConfig = NULL;
                HazelcastClient *RawPointerMultiMapTest::client = NULL;
                MultiMap<std::string, std::string> *RawPointerMultiMapTest::legacy = NULL;
                client::adaptor::RawPointerMultiMap<std::string, std::string> *RawPointerMultiMapTest::mm = NULL;

                TEST_F(RawPointerMultiMapTest, testPutGetRemove) {
                    ASSERT_TRUE(mm->put("key1", "value1"));
                    ASSERT_TRUE(mm->put("key1", "value2"));
                    ASSERT_TRUE(mm->put("key1", "value3"));

                    ASSERT_TRUE(mm->put("key2", "value4"));
                    ASSERT_TRUE(mm->put("key2", "value5"));

                    ASSERT_EQ(3, mm->valueCount("key1"));
                    ASSERT_EQ(2, mm->valueCount("key2"));
                    ASSERT_EQ(5, mm->size());

                    std::unique_ptr<hazelcast::client::DataArray<std::string> > coll = mm->get("key1");
                    ASSERT_EQ(3, (int) coll->size());

                    coll = mm->remove("key2");
                    ASSERT_EQ(2, (int) coll->size());
                    ASSERT_EQ(0, mm->valueCount("key2"));
                    ASSERT_EQ(0, (int) mm->get("key2")->size());

                    ASSERT_FALSE(mm->remove("key1", "value4"));
                    ASSERT_EQ(3, mm->size());

                    ASSERT_TRUE(mm->remove("key1", "value2"));
                    ASSERT_EQ(2, mm->size());

                    ASSERT_TRUE(mm->remove("key1", "value1"));
                    ASSERT_EQ(1, mm->size());
                    coll = mm->get("key1");
                    std::unique_ptr<std::string> val = coll->release(0);
                    ASSERT_NE((std::string *) NULL, val.get());
                    ASSERT_EQ("value3", *val);
                }

                TEST_F(RawPointerMultiMapTest, testKeySetEntrySetAndValues) {
                    ASSERT_TRUE(mm->put("key1", "value1"));
                    ASSERT_TRUE(mm->put("key1", "value2"));
                    ASSERT_TRUE(mm->put("key1", "value3"));

                    ASSERT_TRUE(mm->put("key2", "value4"));
                    ASSERT_TRUE(mm->put("key2", "value5"));


                    ASSERT_EQ(2, (int) mm->keySet()->size());
                    ASSERT_EQ(5, (int) mm->values()->size());
                    ASSERT_EQ(5, (int) mm->entrySet()->size());
                }

                TEST_F(RawPointerMultiMapTest, testContains) {
                    ASSERT_TRUE(mm->put("key1", "value1"));
                    ASSERT_TRUE(mm->put("key1", "value2"));
                    ASSERT_TRUE(mm->put("key1", "value3"));

                    ASSERT_TRUE(mm->put("key2", "value4"));
                    ASSERT_TRUE(mm->put("key2", "value5"));

                    ASSERT_FALSE(mm->containsKey("key3"));
                    ASSERT_TRUE(mm->containsKey("key1"));

                    ASSERT_FALSE(mm->containsValue("value6"));
                    ASSERT_TRUE(mm->containsValue("value4"));

                    ASSERT_FALSE(mm->containsEntry("key1", "value4"));
                    ASSERT_FALSE(mm->containsEntry("key2", "value3"));
                    ASSERT_TRUE(mm->containsEntry("key1", "value1"));
                    ASSERT_TRUE(mm->containsEntry("key2", "value5"));
                }

                TEST_F(RawPointerMultiMapTest, testListener) {
                    hazelcast::util::CountDownLatch latch1Add(8);
                    hazelcast::util::CountDownLatch latch1Remove(4);

                    hazelcast::util::CountDownLatch latch2Add(3);
                    hazelcast::util::CountDownLatch latch2Remove(3);

                    MyMultiMapListener mmener1(latch1Add, latch1Remove);
                    MyMultiMapListener mmener2(latch2Add, latch2Remove);

                    std::string id1 = mm->addEntryListener(mmener1, true);
                    std::string id2 = mm->addEntryListener(mmener2, "key3", true);

                    mm->put("key1", "value1");
                    mm->put("key1", "value2");
                    mm->put("key1", "value3");
                    mm->put("key2", "value4");
                    mm->put("key2", "value5");

                    mm->remove("key1", "value2");

                    mm->put("key3", "value6");
                    mm->put("key3", "value7");
                    mm->put("key3", "value8");

                    mm->remove("key3");

                    ASSERT_TRUE(latch1Add.await(20));
                    ASSERT_TRUE(latch1Remove.await(20));

                    ASSERT_TRUE(latch2Add.await(20));
                    ASSERT_TRUE(latch2Remove.await(20));

                    ASSERT_TRUE(mm->removeEntryListener(id1));
                    ASSERT_TRUE(mm->removeEntryListener(id2));

                }

                void lockThread(hazelcast::util::ThreadArgs &args) {
                    client::adaptor::RawPointerMultiMap<std::string, std::string> *mm = (client::adaptor::RawPointerMultiMap<std::string, std::string> *) args.arg0;
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg1;
                    if (!mm->tryLock("key1")) {
                        latch->countDown();
                    }
                }

                TEST_F(RawPointerMultiMapTest, testLock) {
                    mm->lock("key1");
                    hazelcast::util::CountDownLatch latch(1);
                    hazelcast::util::StartedThread t(lockThread, mm, &latch);
                    ASSERT_TRUE(latch.await(5));
                    mm->forceUnlock("key1");
                    t.join();
                }

                TEST_F(RawPointerMultiMapTest, testLockTtl) {
                    mm->lock("key1", 3 * 1000);
                    hazelcast::util::CountDownLatch latch(2);
                    hazelcast::util::StartedThread t(lockTtlThread, mm, &latch);
                    ASSERT_TRUE(latch.await(10));
                    mm->forceUnlock("key1");
                    t.join();
                }


                void tryLockThread(hazelcast::util::ThreadArgs &args) {
                    client::adaptor::RawPointerMultiMap<std::string, std::string> *mm = (client::adaptor::RawPointerMultiMap<std::string, std::string> *) args.arg0;
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg1;
                    try {
                        if (!mm->tryLock("key1", 2)) {
                            latch->countDown();
                        }
                    } catch (...) {
                        std::cerr << "Unexpected exception at RawPointerMultiMapTest tryLockThread" << std::endl;
                    }
                }

                void tryLockThread2(hazelcast::util::ThreadArgs &args) {
                    client::adaptor::RawPointerMultiMap<std::string, std::string> *mm = (client::adaptor::RawPointerMultiMap<std::string, std::string> *) args.arg0;
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg1;
                    try {
                        if (mm->tryLock("key1", 20 * 1000)) {
                            latch->countDown();
                        }
                    } catch (...) {
                        std::cerr << "Unexpected exception at RawPointerMultiMapTest lockThread2" << std::endl;
                    }
                }

                TEST_F(RawPointerMultiMapTest, testTryLock) {
                    ASSERT_TRUE(mm->tryLock("key1", 2 * 1000));
                    hazelcast::util::CountDownLatch latch(1);
                    hazelcast::util::StartedThread t(tryLockThread, mm, &latch);
                    ASSERT_TRUE(latch.await(100));
                    ASSERT_TRUE(mm->isLocked("key1"));

                    hazelcast::util::CountDownLatch latch2(1);
                    hazelcast::util::StartedThread t2(tryLockThread2, mm, &latch2);

                    hazelcast::util::sleep(1);
                    mm->unlock("key1");
                    ASSERT_TRUE(latch2.await(100));
                    ASSERT_TRUE(mm->isLocked("key1"));
                    mm->forceUnlock("key1");
                }

                void forceUnlockThread(hazelcast::util::ThreadArgs &args) {
                    client::adaptor::RawPointerMultiMap<std::string, std::string> *mm = (client::adaptor::RawPointerMultiMap<std::string, std::string> *) args.arg0;
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg1;
                    mm->forceUnlock("key1");
                    latch->countDown();
                }

                TEST_F(RawPointerMultiMapTest, testForceUnlock) {
                    mm->lock("key1");
                    hazelcast::util::CountDownLatch latch(1);
                    hazelcast::util::StartedThread t(forceUnlockThread, mm, &latch);
                    ASSERT_TRUE(latch.await(100));
                    ASSERT_FALSE(mm->isLocked("key1"));
                }
            }
        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            namespace adaptor {
                class RawPointerTxnMultiMapTest : public ClientTestSupport {
                protected:
                    static void SetUpTestCase() {
                        instance = new HazelcastServer(*g_srvFactory);
                        client = new HazelcastClient(getConfig());
                    }

                    static void TearDownTestCase() {
                        delete client;
                        delete clientConfig;
                        delete instance;

                        client = NULL;
                        clientConfig = NULL;
                        instance = NULL;
                    }

                    class GetRemoveTestTask : public hazelcast::util::Runnable {
                    public:
                        GetRemoveTestTask(MultiMap<string, string> &mm, hazelcast::util::CountDownLatch &latch) : mm(
                                mm),
                                                                                                                  latch(latch) {}

                        virtual void run() {
                            std::string key = hazelcast::util::IOUtil::to_string(hazelcast::util::getCurrentThreadId());
                            client->getMultiMap<std::string, std::string>("testPutGetRemove").put(key, "value");
                            TransactionContext context = client->newTransactionContext();
                            context.beginTransaction();
                            TransactionalMultiMap<std::string, std::string> originalMultiMap = context.getMultiMap<std::string, std::string>(
                                    "testPutGetRemove");
                            client::adaptor::RawPointerTransactionalMultiMap<std::string, std::string> multiMap(
                                    originalMultiMap);
                            ASSERT_FALSE(multiMap.put(key, "value"));
                            ASSERT_TRUE(multiMap.put(key, "value1"));
                            ASSERT_TRUE(multiMap.put(key, "value2"));
                            ASSERT_EQ(3, (int) multiMap.get(key)->size());
                            context.commitTransaction();

                            ASSERT_EQ(3, (int) mm.get(key).size());

                            latch.countDown();
                        }

                        virtual const string getName() const {
                            return "GetRemoveTestTask";
                        }

                    private:
                        MultiMap<std::string, std::string> &mm;
                        hazelcast::util::CountDownLatch &latch;
                    };

                    static HazelcastServer *instance;
                    static ClientConfig *clientConfig;
                    static HazelcastClient *client;
                };

                HazelcastServer *RawPointerTxnMultiMapTest::instance = NULL;
                ClientConfig *RawPointerTxnMultiMapTest::clientConfig = NULL;
                HazelcastClient *RawPointerTxnMultiMapTest::client = NULL;

                TEST_F(RawPointerTxnMultiMapTest, testPutGetRemove) {
                    MultiMap<std::string, std::string> mm = client->getMultiMap<std::string, std::string>(
                            "testPutGetRemove");
                    int n = 10;
                    hazelcast::util::CountDownLatch latch(n);

                    std::vector<std::shared_ptr<hazelcast::util::Thread> > allThreads;
                    for (int i = 0; i < n; i++) {
                        std::shared_ptr<hazelcast::util::Thread> t(
                                new hazelcast::util::Thread(
                                        std::shared_ptr<hazelcast::util::Runnable>(new GetRemoveTestTask(mm, latch)),
                                        getLogger()));
                        t->start();
                        allThreads.push_back(t);
                    }
                    ASSERT_OPEN_EVENTUALLY(latch);
                }
            }
        }
    }
}


//
// Created by hsan Demir on 17/05/15.
//



namespace hazelcast {
    namespace client {
        namespace test {
            namespace common {
                namespace containers {
                    class LittleEndianBufferTest : public ::testing::Test,
                                                   public hazelcast::util::LittleEndianBufferWrapper /* Need this in order to test*/
                    {
                    public:
                        LittleEndianBufferTest() : LittleEndianBufferWrapper(0) {}
                    };

                    TEST_F (LittleEndianBufferTest, testBinaryFormat) {
#define TEST_DATA_SIZE 8
#define LARGE_BUFFER_SIZE 20
#define START_BYTE_NUMBER  5

                        uint64_t ONE = 1;
                        uint64_t oneByteFactor = ONE << 8;
                        uint64_t twoBytesFactor = ONE << 16;
                        uint64_t threeBytesFactor = ONE << 24;
                        uint64_t fourBytesFactor = ONE << 32;
                        uint64_t fiveBytesFactor = ONE << 40;
                        uint64_t sixBytesFactor = ONE << 48;
                        uint64_t sevenBytesFactor = ONE << 56;

                        byte buf[TEST_DATA_SIZE] = {0x8A, 0x9A, 0xAA, 0xBA, 0xCA, 0xDA, 0xEA, 0x8B};
                        buffer->resize(LARGE_BUFFER_SIZE);
                        memcpy(&(*buffer)[START_BYTE_NUMBER], buf, TEST_DATA_SIZE);

                        // ----- Test unsigned get starts ---------------------------------
                        // NOTE: When the first bit of the highest byte is equal to 1, than the number is negative,
                        // and the value is (-1 * (1s complement + 1)) (i.e. this is twos complement)
                        {
                            wrapForRead(LARGE_BUFFER_SIZE, START_BYTE_NUMBER);
                            uint8_t result = getUint8();
                            ASSERT_EQ(0x8A, result);
                        }

                        {
                            wrapForRead(LARGE_BUFFER_SIZE, START_BYTE_NUMBER);
                            uint16_t result = getUint16();
                            ASSERT_EQ(0x8A + 0x9A * oneByteFactor, result);
                        }

                        {
                            wrapForRead(LARGE_BUFFER_SIZE, START_BYTE_NUMBER);
                            uint32_t result = getUint32();
                            ASSERT_EQ(0x8A +
                                      0x9A * oneByteFactor +
                                      0xAA * twoBytesFactor +
                                      0xBA * threeBytesFactor, result);
                        }

                        {
                            wrapForRead(LARGE_BUFFER_SIZE, START_BYTE_NUMBER);
                            uint64_t result = getUint64();
                            ASSERT_EQ(0x8A +
                                      0x9A * oneByteFactor +
                                      0xAA * twoBytesFactor +
                                      0xBA * threeBytesFactor +
                                      0xCA * fourBytesFactor +
                                      0xDA * fiveBytesFactor +
                                      0xEA * sixBytesFactor +
                                      0x8B * sevenBytesFactor, result);
                        }
                        // ----- Test unsigned get ends ---------------------------------

                        // ----- Test signed get starts ---------------------------------

                        {
                            wrapForRead(LARGE_BUFFER_SIZE, START_BYTE_NUMBER);
                            int16_t result = getInt16();
                            ASSERT_EQ(-1 * (~((int16_t) (0x8A +
                                                         0x9A * oneByteFactor)) + 1), result);
                        }

                        {
                            wrapForRead(LARGE_BUFFER_SIZE, START_BYTE_NUMBER);
                            int32_t result = getInt32();
                            ASSERT_EQ(-1 * (~((int32_t) (
                                    0x8A +
                                    0x9A * oneByteFactor +
                                    0xAA * twoBytesFactor +
                                    0xBA * threeBytesFactor)) + 1), result);
                        }

                        {
                            wrapForRead(LARGE_BUFFER_SIZE, START_BYTE_NUMBER);
                            int64_t result = getInt64();
                            ASSERT_EQ(-1 * (~((int64_t) (
                                    0x8A +
                                    0x9A * oneByteFactor +
                                    0xAA * twoBytesFactor +
                                    0xBA * threeBytesFactor +
                                    0xCA * fourBytesFactor +
                                    0xDA * fiveBytesFactor +
                                    0xEA * sixBytesFactor +
                                    0x8B * sevenBytesFactor)) + 1), result);
                        }
// ----- Test signed get ends ---------------------------------

                        const byte firstChar = 'B';
                        byte strBytes[8] = {4, 0, 0, 0, /* This part is the len field which is 4 bytes */
                                            firstChar, firstChar + 1, firstChar + 2,
                                            firstChar + 3}; // This is string BCDE

                        buffer->clear();
                        buffer->insert(buffer->begin(), strBytes, strBytes + 8);
                        {
                            wrapForRead(8, 0);
                            ASSERT_EQ("BCDE", getStringUtf8());
                        }

// ---- Test consecutive gets starts ---------------------------
                        {
                            byte continousBuffer[45] = {0x8A, 0x9A, 0xAA, 0xBA, 0xCA, 0xDA, 0xEA, 0x8B,
                                                        0x8A, 0x9A, 0xAA, 0xBA, 0xCA, 0xDA, 0xEA, 0x8B,
                                                        0x8A, 0x9A, 0xAA, 0xBA, 0xCA, 0xDA, 0xEA, 0x8B,
                                                        0x8A, 0x9A, 0xAA, 0xBA, 0xCA,
                                                        4, 0, 0, 0, /* This part is the len field which is 4 bytes */
                                                        firstChar, firstChar + 1, firstChar + 2, firstChar + 3,
                                                        0x8A, 0x01, 0x00, 0xBA, 0xCA, 0xDA, 0xEA, 0x8B};

                            buffer->clear();
                            buffer->insert(buffer->begin(), continousBuffer, continousBuffer + 45);

                            wrapForRead(8 * 10, 0);

                            {
                                uint8_t result = getUint8();
                                ASSERT_EQ(0x8A, result);
                            }

                            {
                                uint16_t result = getUint16();
                                ASSERT_EQ(0x9A +
                                          0xAA * oneByteFactor, result);
                            }

                            {
                                uint32_t result = getUint32();
                                ASSERT_EQ(0xBA +
                                          0xCA * oneByteFactor +
                                          0xDA * twoBytesFactor +
                                          0xEA * threeBytesFactor, result);
                            }

                            {
                                uint64_t result = getUint64();
                                ASSERT_EQ(0x8B +
                                          0x8A * oneByteFactor +
                                          0x9A * twoBytesFactor +
                                          0xAA * threeBytesFactor +
                                          0xBA * fourBytesFactor +
                                          0xCA * fiveBytesFactor +
                                          0xDA * sixBytesFactor +
                                          0xEA * sevenBytesFactor, result);
                            }
// ----- Test unsigned get ends ---------------------------------

// ----- Test signed get starts ---------------------------------

                            {
                                int16_t result = getInt16();
                                ASSERT_EQ(-1 * (~((int16_t) (0x8B +
                                                             0x8A * oneByteFactor)) + 1), result);
                            }

                            {
                                int32_t result = getInt32();
                                ASSERT_EQ(-1 * (~((int32_t) (
                                        0x9A +
                                        0xAA * oneByteFactor +
                                        0xBA * twoBytesFactor +
                                        0xCA * threeBytesFactor)) + 1), result);
                            }

                            {
                                int64_t result = getInt64();
                                ASSERT_EQ(-1 * (~((int64_t) (
                                        0xDA +
                                        0xEA * oneByteFactor +
                                        0x8B * twoBytesFactor +
                                        0x8A * threeBytesFactor +
                                        0x9A * fourBytesFactor +
                                        0xAA * fiveBytesFactor +
                                        0xBA * sixBytesFactor +
                                        0xCA * sevenBytesFactor)) + 1), result);
                            }
// ----- Test signed get ends ---------------------------------

                            {
                                ASSERT_EQ("BCDE", getStringUtf8());
                            }

                            {
                                bool result = getBoolean();
                                ASSERT_TRUE(result);

                                result = getBoolean();
                                ASSERT_TRUE(result);

                                result = getBoolean();
                                ASSERT_FALSE(result);
                            }

                        }
// ---- Test consecutive gets ends ---------------------------

// ---- Write related tests starts --------------------------
                        buffer->clear();
                        buffer->resize(30, 0);
                        wrapForWrite(30, 0);

                        set((uint8_t) 0x8A);
                        ASSERT_EQ(0x8A, (*buffer)[0]);

                        set(true);
                        ASSERT_EQ(0x01, (*buffer)[1]);

                        set(false);
                        ASSERT_EQ(0x00, (*buffer)[2]);

                        set('C');
                        ASSERT_EQ('C', (*buffer)[3]);

                        int16_t int16Val = 0x7BCD;
                        set(int16Val);
                        ASSERT_EQ(0xCD, (*buffer)[4]);
                        ASSERT_EQ(0x7B, (*buffer)[5]);

                        uint16_t uInt16Val = 0xABCD;
                        set(uInt16Val);
                        ASSERT_EQ(0xCD, (*buffer)[6]);
                        ASSERT_EQ(0xAB, (*buffer)[7]);

                        int32_t int32Val = 0xAEBCEEFF;
                        set(int32Val);
                        ASSERT_EQ(0xFF, (*buffer)[8]);
                        ASSERT_EQ(0xEE, (*buffer)[9]);
                        ASSERT_EQ(0xBC, (*buffer)[10]);
                        ASSERT_EQ(0xAE, (*buffer)[11]);


                        set(std::string("Test Data"));
                        ASSERT_EQ(0x09, (int) (*buffer)[12]);
                        ASSERT_EQ(0x0, (*buffer)[13]);
                        ASSERT_EQ(0x0, (*buffer)[14]);
                        ASSERT_EQ(0x0, (*buffer)[15]);
                        ASSERT_EQ('T', (*buffer)[16]);
                        ASSERT_EQ('e', (*buffer)[17]);
                        ASSERT_EQ('a', (*buffer)[24]);
                    }
                }
            }
        }
    }
}




namespace hazelcast {
    namespace client {

        namespace test {
            class CallIdSequenceWithoutBackpressureTest : public ClientTestSupport {
            protected:
                spi::impl::sequence::CallIdSequenceWithoutBackpressure sequence;

                void next(bool isUrgent) {
                    int64_t oldSequence = sequence.getLastCallId();
                    int64_t result = nextCallId(sequence, isUrgent);
                    assertEquals(oldSequence + 1, result);
                    assertEquals(oldSequence + 1, sequence.getLastCallId());
                }

                int64_t nextCallId(spi::impl::sequence::CallIdSequence &seq, bool isUrgent) {
                    return isUrgent ? seq.forceNext() : seq.next();
                }
            };

            TEST_F(CallIdSequenceWithoutBackpressureTest, testInit) {
                        assertEquals(0, sequence.getLastCallId());
                        assertEquals(INT32_MAX, sequence.getMaxConcurrentInvocations());
            }

            TEST_F(CallIdSequenceWithoutBackpressureTest, testNext) {
                // regular operation
                next(false);
                next(true);
            }

            TEST_F(CallIdSequenceWithoutBackpressureTest, whenNextRepeated_thenKeepSucceeding) {
                for (int64_t k = 1; k < 10000; k++) {
                            assertEquals(k, nextCallId(sequence, false));
                }
            }

            TEST_F(CallIdSequenceWithoutBackpressureTest, complete) {
                nextCallId(sequence, false);
                int64_t oldSequence = sequence.getLastCallId();
                sequence.complete();
                        assertEquals(oldSequence, sequence.getLastCallId());
            }
        }
    }
}



namespace hazelcast {
    namespace client {

        namespace test {
            class CallIdSequenceWithBackpressureTest : public ClientTestSupport {
            public:
                CallIdSequenceWithBackpressureTest() {}

            protected:
                class ThreeSecondDelayCompleteOperation : public hazelcast::util::Runnable {
                public:
                    ThreeSecondDelayCompleteOperation(spi::impl::sequence::CallIdSequenceWithBackpressure &sequence,
                                                      hazelcast::util::CountDownLatch &nextCalledLatch) : sequence(
                            sequence),
                                                                                                          nextCalledLatch(
                                                                                                                  nextCalledLatch) {}

                private:
                    virtual const std::string getName() const {
                        return "ThreeSecondDelayCompleteOperation";
                    }

                    virtual void run() {
                        sequence.next();
                        nextCalledLatch.countDown();
                        sleepSeconds(3);
                        sequence.complete();
                    }

                private:
                    spi::impl::sequence::CallIdSequenceWithBackpressure &sequence;
                    hazelcast::util::CountDownLatch &nextCalledLatch;
                };

                int64_t nextCallId(spi::impl::sequence::CallIdSequence &seq, bool isUrgent) {
                    return isUrgent ? seq.forceNext() : seq.next();
                }
            };

            TEST_F(CallIdSequenceWithBackpressureTest, testInit) {
                spi::impl::sequence::CallIdSequenceWithBackpressure sequence(100, 60000);
                        assertEquals(0, sequence.getLastCallId());
                        assertEquals(100, sequence.getMaxConcurrentInvocations());
            }

            TEST_F(CallIdSequenceWithBackpressureTest, whenNext_thenSequenceIncrements) {
                spi::impl::sequence::CallIdSequenceWithBackpressure sequence(100, 60000);
                int64_t oldSequence = sequence.getLastCallId();
                int64_t result = sequence.next();
                        assertEquals(oldSequence + 1, result);
                        assertEquals(oldSequence + 1, sequence.getLastCallId());

                oldSequence = sequence.getLastCallId();
                result = sequence.forceNext();
                        assertEquals(oldSequence + 1, result);
                        assertEquals(oldSequence + 1, sequence.getLastCallId());
            }

            TEST_F(CallIdSequenceWithBackpressureTest, next_whenNoCapacity_thenBlockTillCapacity) {
                spi::impl::sequence::CallIdSequenceWithBackpressure sequence(1, 60000);
                int64_t oldLastCallId = sequence.getLastCallId();

                hazelcast::util::CountDownLatch nextCalledLatch(1);

                hazelcast::util::Thread t(std::shared_ptr<hazelcast::util::Runnable>(
                        new ThreeSecondDelayCompleteOperation(sequence, nextCalledLatch)), getLogger());
                t.start();

                ASSERT_OPEN_EVENTUALLY(nextCalledLatch);

                int64_t result = sequence.next();
                        assertEquals(oldLastCallId + 2, result);
                        assertEquals(oldLastCallId + 2, sequence.getLastCallId());
            }

            TEST_F(CallIdSequenceWithBackpressureTest, next_whenNoCapacity_thenBlockTillTimeout) {
                spi::impl::sequence::CallIdSequenceWithBackpressure sequence(1, 2000);
// first invocation consumes the available call ID
                nextCallId(sequence, false);

                int64_t oldLastCallId = sequence.getLastCallId();
                ASSERT_THROW(sequence.next(), exception::HazelcastOverloadException);

                        assertEquals(oldLastCallId, sequence.getLastCallId());
            }

            TEST_F(CallIdSequenceWithBackpressureTest, when_overCapacityButPriorityItem_then_noBackpressure) {
                spi::impl::sequence::CallIdSequenceWithBackpressure sequence(1, 60000);

// occupy the single call ID slot
                nextCallId(sequence, true);

                int64_t oldLastCallId = sequence.getLastCallId();

                int64_t result = nextCallId(sequence, true);
                        assertEquals(oldLastCallId + 1, result);
                        assertEquals(oldLastCallId + 1, sequence.getLastCallId());
            }

            TEST_F(CallIdSequenceWithBackpressureTest, whenComplete_thenTailIncrements) {
                spi::impl::sequence::CallIdSequenceWithBackpressure sequence(1, 60000);

                nextCallId(sequence, false);

                int64_t oldSequence = sequence.getLastCallId();
                int64_t oldTail = sequence.getTail();
                sequence.complete();

                        assertEquals(oldSequence, sequence.getLastCallId());
                        assertEquals(oldTail + 1, sequence.getTail());
            }

        }
    }
}



namespace hazelcast {
    namespace client {

        namespace test {
            class FailFastCallIdSequenceTest : public ClientTestSupport {
            public:
            };

            TEST_F(FailFastCallIdSequenceTest, testGettersAndDefaults) {
                spi::impl::sequence::FailFastCallIdSequence sequence(100);
                ASSERT_EQ(0, sequence.getLastCallId());
                ASSERT_EQ(100, sequence.getMaxConcurrentInvocations());
            }

            TEST_F(FailFastCallIdSequenceTest, whenNext_thenSequenceIncrements) {
                spi::impl::sequence::FailFastCallIdSequence sequence(100);
                int64_t oldSequence = sequence.getLastCallId();
                int64_t result = sequence.next();
                ASSERT_EQ(oldSequence + 1, result);
                ASSERT_EQ(oldSequence + 1, sequence.getLastCallId());
            }

            TEST_F(FailFastCallIdSequenceTest, next_whenNoCapacity_thenThrowException) {
                spi::impl::sequence::FailFastCallIdSequence sequence(1);

                // take the only slot available
                sequence.next();

                // this next is going to fail with an exception
                ASSERT_THROW(sequence.next(), exception::HazelcastOverloadException);
            }

            TEST_F(FailFastCallIdSequenceTest, when_overCapacityButPriorityItem_then_noException) {
                spi::impl::sequence::FailFastCallIdSequence sequence(1);

// take the only slot available
                ASSERT_EQ(1, sequence.next());

                ASSERT_EQ(2, sequence.forceNext());
            }

            TEST_F(FailFastCallIdSequenceTest, whenComplete_thenTailIncrements) {
                spi::impl::sequence::FailFastCallIdSequence sequence(100);
                sequence.next();

                int64_t oldSequence = sequence.getLastCallId();
                int64_t oldTail = sequence.getTail();
                sequence.complete();

                ASSERT_EQ(oldSequence, sequence.getLastCallId());
                ASSERT_EQ(oldTail + 1, sequence.getTail());
            }

        }
    }
}

namespace hazelcast {
    namespace client {
        namespace test {
            extern HazelcastServerFactory *g_srvFactory;
            extern std::shared_ptr<RemoteControllerClient> remoteController;

            HazelcastServerFactory::HazelcastServerFactory(const std::string &serverXmlConfigFilePath)
                    : HazelcastServerFactory::HazelcastServerFactory(g_srvFactory->getServerAddress(),
                                                                     serverXmlConfigFilePath) {
            }

            HazelcastServerFactory::HazelcastServerFactory(const std::string &serverAddress,
                                                           const std::string &serverXmlConfigFilePath)
                    : logger("HazelcastServerFactory", "HazelcastServerFactory", "testversion", config::LoggerConfig()),
                      serverAddress(serverAddress) {

                if (!logger.start()) {
                    throw (client::exception::ExceptionBuilder<client::exception::IllegalStateException>(
                            "HazelcastServerFactory::HazelcastServerFactory") << "Could not start logger "
                                                                              << logger.getInstanceName()).build();
                }

                std::string xmlConfig = readFromXmlFile(serverXmlConfigFilePath);

                remote::Cluster cluster;
                remoteController->createCluster(cluster, HAZELCAST_VERSION, xmlConfig);

                this->clusterId = cluster.id;
            }

            HazelcastServerFactory::~HazelcastServerFactory() {
                remoteController->shutdownCluster(clusterId);
            }

            remote::Member HazelcastServerFactory::startServer() {
                remote::Member member;
                remoteController->startMember(member, clusterId);
                return member;
            }

            bool HazelcastServerFactory::setAttributes(int memberStartOrder) {
                std::ostringstream script;
                script << "function attrs() { "
                          "var member = instance_" << memberStartOrder << ".getCluster().getLocalMember(); "
                                                                          "member.setIntAttribute(\"intAttr\", 211); "
                                                                          "member.setBooleanAttribute(\"boolAttr\", true); "
                                                                          "member.setByteAttribute(\"byteAttr\", 7); "
                                                                          "member.setDoubleAttribute(\"doubleAttr\", 2.0); "
                                                                          "member.setFloatAttribute(\"floatAttr\", 1.2); "
                                                                          "member.setShortAttribute(\"shortAttr\", 3); "
                                                                          "return member.setStringAttribute(\"strAttr\", \"strAttr\");} "
                                                                          " result=attrs(); ";


                Response response;
                remoteController->executeOnController(response, clusterId, script.str().c_str(), Lang::JAVASCRIPT);
                return response.success;
            }

            bool HazelcastServerFactory::shutdownServer(const remote::Member &member) {
                return remoteController->shutdownMember(clusterId, member.uuid);
            }

            bool HazelcastServerFactory::terminateServer(const remote::Member &member) {
                return remoteController->terminateMember(clusterId, member.uuid);
            }

            const std::string &HazelcastServerFactory::getServerAddress() {
                return serverAddress;
            }

            std::string HazelcastServerFactory::readFromXmlFile(const std::string &xmlFilePath) {
                std::ifstream xmlFile(xmlFilePath.c_str());
                if (!xmlFile) {
                    std::ostringstream out;
                    out << "Failed to read from xml file to at " << xmlFilePath;
                    throw exception::IllegalStateException("HazelcastServerFactory::readFromXmlFile", out.str());
                }

                std::ostringstream buffer;

                buffer << xmlFile.rdbuf();

                xmlFile.close();

                return buffer.str();
            }

        }
    }
}








using namespace hazelcast::client::mixedtype;

namespace hazelcast {
    namespace client {
        namespace test {
            class BaseCustom {
            public:
                BaseCustom() {
                    value = 3;
                }

                BaseCustom(int value) : value(value) {}

                int getValue() const {
                    return value;
                }

                void setValue(int value) {
                    BaseCustom::value = value;
                }

                bool operator<(const BaseCustom &rhs) const {
                    return getValue() < rhs.getValue();
                }

            private:
                int value;
            };

            class Derived1Custom : public BaseCustom {
            public:
                Derived1Custom() : BaseCustom(4) {}

                Derived1Custom(int value) : BaseCustom(value) {}
            };

            class Derived2Custom : public Derived1Custom {
            public:
                Derived2Custom() : Derived1Custom(5) {}
            };

            int32_t getHazelcastTypeId(const BaseCustom *) {
                return 3;
            }

            int32_t getHazelcastTypeId(const Derived1Custom *) {
                return 4;
            }

            int32_t getHazelcastTypeId(const Derived2Custom *) {
                return 5;
            }

            class MixedMapTest : public ClientTestSupport {
            protected:
                class BaseCustomSerializer : public serialization::StreamSerializer {
                public:
                    virtual int32_t getHazelcastTypeId() const {
                        return 3;
                    }

                    virtual void write(serialization::ObjectDataOutput &out, const void *object) {
                        out.writeInt(static_cast<const BaseCustom *>(object)->getValue());
                    }

                    virtual void *read(serialization::ObjectDataInput &in) {
                        std::unique_ptr<BaseCustom> object(new BaseCustom);
                        object->setValue(in.readInt());
                        return object.release();
                    }
                };

                class Derived1CustomSerializer : public BaseCustomSerializer {
                public:
                    virtual int32_t getHazelcastTypeId() const {
                        return 4;
                    }

                    virtual void *read(serialization::ObjectDataInput &in) {
                        std::unique_ptr<Derived1Custom> object(new Derived1Custom);
                        object->setValue(in.readInt());
                        return object.release();
                    }
                };

                class Derived2CustomSerializer : public BaseCustomSerializer {
                public:
                    virtual int32_t getHazelcastTypeId() const {
                        return 5;
                    }

                    virtual void *read(serialization::ObjectDataInput &in) {
                        std::unique_ptr<Derived2Custom> object(new Derived2Custom);
                        object->setValue(in.readInt());
                        return object.release();
                    }
                };

                class BaseDataSerializable : public serialization::IdentifiedDataSerializable {
                public:
                    virtual ~BaseDataSerializable() {}

                    virtual int getFactoryId() const {
                        return 666;
                    }

                    virtual int getClassId() const {
                        return 10;
                    }

                    virtual void writeData(serialization::ObjectDataOutput &writer) const {
                    }

                    virtual void readData(serialization::ObjectDataInput &reader) {
                    }

                    virtual bool operator<(const BaseDataSerializable &rhs) const {
                        return getClassId() < rhs.getClassId();
                    }
                };

                class Derived1DataSerializable : public BaseDataSerializable {
                public:
                    virtual int getClassId() const {
                        return 11;
                    }
                };

                class Derived2DataSerializable : public Derived1DataSerializable {
                public:
                    virtual int getClassId() const {
                        return 12;
                    }
                };

                class BasePortable : public serialization::Portable {
                public:
                    virtual ~BasePortable() {}

                    virtual int getFactoryId() const {
                        return 666;
                    }

                    virtual int getClassId() const {
                        return 3;
                    }

                    virtual void writePortable(serialization::PortableWriter &writer) const {
                    }

                    virtual void readPortable(serialization::PortableReader &reader) {
                    }

                    bool operator<(const BasePortable &rhs) const {
                        return getClassId() < rhs.getClassId();
                    }
                };

                class Derived1Portable : public BasePortable {
                public:
                    virtual int getClassId() const {
                        return 4;
                    }
                };

                class Derived2Portable : public BasePortable {
                public:
                    virtual int getClassId() const {
                        return 5;
                    }
                };

                class PolymorphicDataSerializableFactory : public serialization::DataSerializableFactory {
                public:
                    virtual std::unique_ptr<serialization::IdentifiedDataSerializable> create(int32_t typeId) {
                        switch (typeId) {
                            case 10:
                                return std::unique_ptr<serialization::IdentifiedDataSerializable>(new BaseDataSerializable);
                            case 11:
                                return std::unique_ptr<serialization::IdentifiedDataSerializable>(new Derived1DataSerializable);
                            case 12:
                                return std::unique_ptr<serialization::IdentifiedDataSerializable>(new Derived2DataSerializable);
                            default:
                                return std::unique_ptr<serialization::IdentifiedDataSerializable>();
                        }
                    }
                };

                class PolymorphicPortableFactory : public serialization::PortableFactory {
                public:
                    virtual std::unique_ptr<serialization::Portable> create(int32_t classId) const {
                        switch (classId) {
                            case 3:
                                return std::unique_ptr<serialization::Portable>(new BasePortable);
                            case 4:
                                return std::unique_ptr<serialization::Portable>(new Derived1Portable);
                            case 5:
                                return std::unique_ptr<serialization::Portable>(new Derived2Portable);
                            default:
                                return std::unique_ptr<serialization::Portable>();
                        }
                    }
                };

                virtual void TearDown() {
                    // clear maps
                    mixedMap->clear();
                }

                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    client = new HazelcastClient(getConfig());
                    mixedMap = new mixedtype::IMap(client->toMixedType().getMap("MyMap"));

                    ClientConfig config;
                    SerializationConfig &serializationConfig = config.getSerializationConfig();
                    serializationConfig.addDataSerializableFactory(666,
                                                                   std::shared_ptr<serialization::DataSerializableFactory>(
                                                                           new PolymorphicDataSerializableFactory()));
                    serializationConfig.addPortableFactory(666, std::shared_ptr<serialization::PortableFactory>(
                            new PolymorphicPortableFactory));

                    serializationConfig.registerSerializer(
                            std::shared_ptr<serialization::SerializerBase>(new BaseCustomSerializer));

                    serializationConfig.registerSerializer(
                            std::shared_ptr<serialization::SerializerBase>(new Derived1CustomSerializer));

                    serializationConfig.registerSerializer(
                            std::shared_ptr<serialization::SerializerBase>(new Derived2CustomSerializer));

                    client2 = new HazelcastClient(config);
                    imap = new IMap<int, BaseDataSerializable>(client2->getMap<int, BaseDataSerializable>("MyMap"));
                    rawPointerMap = new hazelcast::client::adaptor::RawPointerMap<int, BaseDataSerializable> (*imap);
                    imapPortable = new IMap<int, BasePortable>(client2->getMap<int, BasePortable>("MyMap"));
                    rawPointerMapPortable = new hazelcast::client::adaptor::RawPointerMap<int, BasePortable> (*imapPortable);
                    imapCustom = new IMap<int, BaseCustom>(client2->getMap<int, BaseCustom>("MyMap"));
                    rawPointerMapCustom = new hazelcast::client::adaptor::RawPointerMap<int, BaseCustom> (*imapCustom);
                }

                static void TearDownTestCase() {
                    //delete mixedMap;
                    delete rawPointerMap;
                    delete imap;
                    delete rawPointerMapPortable;
                    delete imapPortable;
                    delete rawPointerMapCustom;
                    delete imapCustom;
                    delete client;
                    delete client2;
                    delete instance2;
                    delete instance;

                    mixedMap = NULL;
                    rawPointerMap = NULL;
                    imap = NULL;
                    rawPointerMapPortable = NULL;
                    imapPortable = NULL;
                    rawPointerMapCustom = NULL;
                    imapCustom = NULL;
                    client = NULL;
                    client2 = NULL;
                    instance2 = NULL;
                    instance = NULL;
                }

                static HazelcastServer *instance;
                static HazelcastServer *instance2;
                static HazelcastClient *client;
                static mixedtype::IMap *mixedMap;
                static HazelcastClient *client2;
                static IMap<int, BaseDataSerializable> *imap;
                static hazelcast::client::adaptor::RawPointerMap<int, BaseDataSerializable> *rawPointerMap;
                static IMap<int, BasePortable> *imapPortable;
                static hazelcast::client::adaptor::RawPointerMap<int, BasePortable> *rawPointerMapPortable;
                static IMap<int, BaseCustom> *imapCustom;
                static hazelcast::client::adaptor::RawPointerMap<int, BaseCustom> *rawPointerMapCustom;
            };

            HazelcastServer *MixedMapTest::instance = NULL;
            HazelcastServer *MixedMapTest::instance2 = NULL;
            HazelcastClient *MixedMapTest::client = NULL;
            mixedtype::IMap *MixedMapTest::mixedMap = NULL;
            HazelcastClient *MixedMapTest::client2 = NULL;
            IMap<int, MixedMapTest::BaseDataSerializable> * MixedMapTest::imap = NULL;
            hazelcast::client::adaptor::RawPointerMap<int, MixedMapTest::BaseDataSerializable> *MixedMapTest::rawPointerMap = NULL;
            IMap<int, MixedMapTest::BasePortable> * MixedMapTest::imapPortable = NULL;
            hazelcast::client::adaptor::RawPointerMap<int, MixedMapTest::BasePortable> *MixedMapTest::rawPointerMapPortable = NULL;
            IMap<int, BaseCustom> * MixedMapTest::imapCustom = NULL;
            hazelcast::client::adaptor::RawPointerMap<int, BaseCustom> *MixedMapTest::rawPointerMapCustom = NULL;

            TEST_F(MixedMapTest, testPutDifferentTypes) {
                mixedMap->put<int, int>(3, 5);
                TypedData oldData = mixedMap->put<int, std::string>(10, "MyStringValue");

                ASSERT_EQ(NULL, oldData.getData().get());

                TypedData result = mixedMap->get<int>(3);
                ASSERT_EQ(-7, result.getType().typeId);
                std::unique_ptr<int> value = result.get<int>();
                ASSERT_NE((int *) NULL, value.get());
                ASSERT_EQ(5, *value);

                result = mixedMap->get<int>(10);
                ASSERT_EQ(-11, result.getType().typeId);
                std::unique_ptr<std::string> strValue = result.get<std::string>();
                ASSERT_NE((std::string *) NULL, strValue.get());
                ASSERT_EQ("MyStringValue", *strValue);
            }

            TEST_F(MixedMapTest, testPolymorphismWithIdentifiedDataSerializable) {
                BaseDataSerializable base;
                Derived1DataSerializable derived1;
                Derived2DataSerializable derived2;
                mixedMap->put<int, BaseDataSerializable>(1, base);
                mixedMap->put<int, Derived1DataSerializable>(2, derived1);
                mixedMap->put<int, Derived2DataSerializable>(3, derived2);

                std::set<int> keys;
                keys.insert(1);
                keys.insert(2);
                keys.insert(3);

                std::vector<std::pair<TypedData, TypedData> > values = mixedMap->getAll<int>(keys);
                for (std::vector<std::pair<TypedData, TypedData> >::iterator it = values.begin();
                     it != values.end(); ++it) {
                    TypedData &keyData = (*it).first;
                    TypedData &valueData = (*it).second;
                    std::unique_ptr<int> key = keyData.get<int>();
                    ASSERT_NE((int *) NULL, key.get());
                    serialization::pimpl::ObjectType objectType = valueData.getType();
                    switch (*key) {
                        case 1: {
                            // serialization::pimpl::SerializationConstants::CONSTANT_TYPE_DATA, using -2 since static
                            // variable is not exported into the library
                            ASSERT_EQ(-2, objectType.typeId);
                            ASSERT_EQ(666, objectType.factoryId);
                            ASSERT_EQ(10, objectType.classId);
                            std::unique_ptr<BaseDataSerializable> value = valueData.get<BaseDataSerializable>();
                            ASSERT_NE((BaseDataSerializable *) NULL, value.get());
                            break;
                        }
                        case 2: {
                            ASSERT_EQ(-2, objectType.typeId);
                            ASSERT_EQ(666, objectType.factoryId);
                            ASSERT_EQ(11, objectType.classId);
                            std::unique_ptr<BaseDataSerializable> value(valueData.get<Derived1DataSerializable>());
                            ASSERT_NE((BaseDataSerializable *) NULL, value.get());
                            break;
                        }
                        case 3: {
                            ASSERT_EQ(-2, objectType.typeId);
                            ASSERT_EQ(666, objectType.factoryId);
                            ASSERT_EQ(12, objectType.classId);
                            std::unique_ptr<BaseDataSerializable> value(valueData.get<Derived2DataSerializable>());
                            ASSERT_NE((BaseDataSerializable *) NULL, value.get());
                            break;
                        }
                        default:
                            FAIL();
                    }
                }
            }

            TEST_F(MixedMapTest, testPolymorphismUsingBaseClassWithIdentifiedDataSerializable) {
                BaseDataSerializable base;
                Derived1DataSerializable derived1;
                Derived2DataSerializable derived2;
                rawPointerMap->put(1, base);
                rawPointerMap->put(2, derived1);
                rawPointerMap->put(3, derived2);

                std::set<int> keys;
                keys.insert(1);
                keys.insert(2);
                keys.insert(3);

                std::unique_ptr<EntryArray<int, BaseDataSerializable> > entries = rawPointerMap->getAll(keys);
                ASSERT_NE((EntryArray<int, BaseDataSerializable> *) NULL, entries.get());
                ASSERT_EQ((size_t) 3, entries->size());
                for (size_t i = 0; i < entries->size(); ++i) {
                    std::pair<const int *, const BaseDataSerializable *> entry = (*entries)[i];
                    const int *key = entry.first;
                    ASSERT_NE((const int *) NULL, key);
                    const BaseDataSerializable *value = entry.second;
                    ASSERT_NE((const BaseDataSerializable *) NULL, value);
                    switch (*key) {
                        case 1:
                            ASSERT_EQ(base.getClassId(), value->getClassId());
                            break;
                        case 2:
                            ASSERT_EQ(derived1.getClassId(), value->getClassId());
                            break;
                        case 3:
                            ASSERT_EQ(derived2.getClassId(), value->getClassId());
                            break;
                        default:
                            FAIL();
                    }
                }
            }

            TEST_F(MixedMapTest, testPolymorphismWithPortable) {
                BasePortable base;
                Derived1Portable derived1;
                Derived2Portable derived2;
                mixedMap->put<int, BasePortable>(1, base);
                mixedMap->put<int, Derived1Portable>(2, derived1);
                mixedMap->put<int, Derived2Portable>(3, derived2);

                TypedData secondData = mixedMap->get<int>(2);
                serialization::pimpl::ObjectType secondType = secondData.getType();
                ASSERT_EQ(-1, secondType.typeId);
                secondData.get<Derived1Portable>();

                std::set<int> keys;
                keys.insert(1);
                keys.insert(2);
                keys.insert(3);

                std::vector<std::pair<TypedData, TypedData> > values = mixedMap->getAll<int>(keys);
                for (std::vector<std::pair<TypedData, TypedData> >::iterator it = values.begin();
                     it != values.end(); ++it) {
                    TypedData &keyData = (*it).first;
                    TypedData &valueData = (*it).second;
                    std::unique_ptr<int> key = keyData.get<int>();
                    ASSERT_NE((int *) NULL, key.get());
                    serialization::pimpl::ObjectType objectType = valueData.getType();
                    switch (*key) {
                        case 1: {
// serialization::pimpl::SerializationConstants::CONSTANT_TYPE_PORTABLE, using -1 since static
// variable is not exported into the library
                            ASSERT_EQ(-1, objectType.typeId);
                            ASSERT_EQ(666, objectType.factoryId);
                            ASSERT_EQ(3, objectType.classId);
                            std::unique_ptr<BasePortable> value = valueData.get<BasePortable>();
                            ASSERT_NE((BasePortable *) NULL, value.get());
                            break;
                        }
                        case 2: {
                            ASSERT_EQ(-1, objectType.typeId);
                            ASSERT_EQ(666, objectType.factoryId);
                            ASSERT_EQ(4, objectType.classId);
                            std::unique_ptr<BasePortable> value(valueData.get<Derived1Portable>());
                            ASSERT_NE((BasePortable *) NULL, value.get());
                            break;
                        }
                        case 3: {
                            ASSERT_EQ(-1, objectType.typeId);
                            ASSERT_EQ(666, objectType.factoryId);
                            ASSERT_EQ(5, objectType.classId);
                            std::unique_ptr<BasePortable> value(valueData.get<Derived2Portable>());
                            ASSERT_NE((BasePortable *) NULL, value.get());
                            break;
                        }
                        default:
                            FAIL();
                    }
                }
            }

            TEST_F(MixedMapTest, testPolymorphismUsingBaseClassWithPortable) {
                BasePortable basePortable;
                Derived1Portable derived1Portable;
                Derived2Portable derived2Portable;
                rawPointerMapPortable->put(1, basePortable);
                rawPointerMapPortable->put(2, derived1Portable);
                rawPointerMapPortable->put(3, derived2Portable);

                std::set<int> keys;
                keys.insert(1);
                keys.insert(2);
                keys.insert(3);

                std::unique_ptr<EntryArray<int, BasePortable> > entries = rawPointerMapPortable->getAll(keys);
                ASSERT_NE((EntryArray<int, BasePortable> *) NULL, entries.get());
                ASSERT_EQ((size_t) 3, entries->size());
                for (size_t i = 0; i < entries->size(); ++i) {
                    std::pair<const int *, const BasePortable *> entry = (*entries)[i];
                    const int *key = entry.first;
                    ASSERT_NE((const int *) NULL, key);
                    const BasePortable *value = entry.second;
                    ASSERT_NE((const BasePortable *) NULL, value);
                    switch (*key) {
                        case 1:
                            ASSERT_EQ(basePortable.getClassId(), value->getClassId());
                            break;
                        case 2:
                            ASSERT_EQ(derived1Portable.getClassId(), value->getClassId());
                            break;
                        case 3:
                            ASSERT_EQ(derived2Portable.getClassId(), value->getClassId());
                            break;
                        default:
                            FAIL();
                    }
                }
            }

            TEST_F(MixedMapTest, testPolymorphismUsingBaseClass) {
                BaseCustom baseCustom;
                Derived1Custom derived1Custom;
                Derived2Custom derived2Custom;
                rawPointerMapCustom->put(1, baseCustom);
                rawPointerMapCustom->put(2, derived1Custom);
                rawPointerMapCustom->put(3, derived2Custom);

                std::set<int> keys;
                keys.insert(1);
                keys.insert(2);
                keys.insert(3);

                std::unique_ptr<EntryArray<int, BaseCustom> > entries = rawPointerMapCustom->getAll(keys);
                ASSERT_NE((EntryArray<int, BaseCustom> *) NULL, entries.get());
                ASSERT_EQ((size_t) 3, entries->size());
                for (size_t i = 0; i < entries->size(); ++i) {
                    std::pair<const int *, const BaseCustom *> entry = (*entries)[i];
                    const int *key = entry.first;
                    ASSERT_NE((const int *) NULL, key);
                    const BaseCustom *value = entry.second;
                    ASSERT_NE((const BaseCustom *) NULL, value);
                    switch (*key) {
                        case 1:
                            ASSERT_EQ(baseCustom.getValue(), value->getValue());
                            break;
                        case 2:
                            ASSERT_EQ(derived1Custom.getValue(), value->getValue());
                            break;
                        case 3:
                            ASSERT_EQ(derived2Custom.getValue(), value->getValue());
                            break;
                        default:
                            FAIL();
                    }
                }
            }
        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {
            class MapGlobalSerializerTest : public ClientTestSupport {
            public:
                class UnknownObject {};

                class WriteReadIntGlobalSerializer : public serialization::StreamSerializer {
                public:
                    virtual int32_t getHazelcastTypeId() const {
                        return 123;
                    }

                    virtual void write(serialization::ObjectDataOutput &out, const void *object) {
                    }

                    virtual void *read(serialization::ObjectDataInput &in) {
                        return new int(5);
                    }
                };
            protected:

                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    ClientConfig clientConfig;
                    clientConfig.getSerializationConfig().setGlobalSerializer(
                            std::shared_ptr<serialization::StreamSerializer>(new WriteReadIntGlobalSerializer()));
                    client = new HazelcastClient(clientConfig);
                    imap = new mixedtype::IMap(client->toMixedType().getMap("UnknownObject"));
                }

                static void TearDownTestCase() {
                    delete imap;
                    delete client;
                    delete instance;

                    imap = NULL;
                    client = NULL;
                    instance = NULL;
                }

                static HazelcastServer *instance;
                static HazelcastClient *client;
                static mixedtype::IMap *imap;
            };

            HazelcastServer *MapGlobalSerializerTest::instance = NULL;
            HazelcastClient *MapGlobalSerializerTest::client = NULL;
            mixedtype::IMap *MapGlobalSerializerTest::imap = NULL;

            TEST_F(MapGlobalSerializerTest, testPutUnknownObjectButGetIntegerValue) {
                MapGlobalSerializerTest::UnknownObject myObject;
                imap->put<int, MapGlobalSerializerTest::UnknownObject>(2, myObject);

                TypedData data = imap->get<int>(2);
                ASSERT_EQ(123, data.getType().typeId);
                std::ostringstream out;
                out << data.getType();
                ASSERT_TRUE(out.str().find("123") != std::string::npos);
                std::unique_ptr<int> value = data.get<int>();
                ASSERT_NE((int *) NULL, value.get());
                ASSERT_EQ(5, *value);
            }

        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {
            class ClientExpirationListenerTest : public ClientTestSupport {
            protected:
                virtual void TearDown() {
                    // clear maps
                    imap->clear();
                }

                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    instance2 = new HazelcastServer(*g_srvFactory);
                    ClientConfig clientConfig(getConfig());
                    clientConfig.getProperties()[ClientProperties::PROP_HEARTBEAT_TIMEOUT] = "20";
                    client = new HazelcastClient(clientConfig);
                    imap = new IMap<int, int>(client->getMap<int, int>("IntMap"));
                }

                static void TearDownTestCase() {
                    delete imap;
                    delete client;
                    delete instance2;
                    delete instance;

                    imap = NULL;
                    client = NULL;
                    instance2 = NULL;
                    instance = NULL;
                }

                static HazelcastServer *instance;
                static HazelcastServer *instance2;
                static HazelcastClient *client;
                static IMap<int, int> *imap;
            };

            HazelcastServer *ClientExpirationListenerTest::instance = NULL;
            HazelcastServer *ClientExpirationListenerTest::instance2 = NULL;
            HazelcastClient *ClientExpirationListenerTest::client = NULL;
            IMap<int, int> *ClientExpirationListenerTest::imap = NULL;

            class ExpirationListener : public EntryAdapter<int, int> {
            public:
                ExpirationListener(hazelcast::util::CountDownLatch &latch)
                        : latch(latch) {

                }

                void entryExpired(const EntryEvent<int, int> &event) {
                    latch.countDown();
                }

            private:
                hazelcast::util::CountDownLatch &latch;
            };

            TEST_F(ClientExpirationListenerTest, notified_afterExpirationOfEntries) {
                int numberOfPutOperations = 10000;
                hazelcast::util::CountDownLatch expirationEventArrivalCount(numberOfPutOperations);

                ExpirationListener expirationListener(expirationEventArrivalCount);
                std::string registrationId = imap->addEntryListener(expirationListener, true);

                for (int i = 0; i < numberOfPutOperations; i++) {
                    imap->put(i, i, 100);
                }

                // wait expiration of entries.
                hazelcast::util::sleep(1);

                // trigger immediate fire of expiration events by touching them.
                for (int i = 0; i < numberOfPutOperations; ++i) {
                    imap->get(i);
                }

                ASSERT_OPEN_EVENTUALLY(expirationEventArrivalCount);
                ASSERT_TRUE(imap->removeEntryListener(registrationId));
            }


            class ExpirationAndEvictionListener : public EntryAdapter<int, int> {
            public:
                ExpirationAndEvictionListener(hazelcast::util::CountDownLatch &evictedLatch,
                                              hazelcast::util::CountDownLatch &expiredLatch)
                        : evictedLatch(evictedLatch), expiredLatch(expiredLatch) {

                }

                void entryEvicted(const EntryEvent<int, int> &event) {
                    evictedLatch.countDown();
                }

                void entryExpired(const EntryEvent<int, int> &event) {
                    expiredLatch.countDown();
                }

            private:
                hazelcast::util::CountDownLatch &evictedLatch;
                hazelcast::util::CountDownLatch &expiredLatch;
            };

            TEST_F(ClientExpirationListenerTest, bothNotified_afterExpirationOfEntries) {
                int numberOfPutOperations = 1000;
                hazelcast::util::CountDownLatch expirationEventArrivalCount(numberOfPutOperations);
                hazelcast::util::CountDownLatch evictedEventArrivalCount(numberOfPutOperations);

                ExpirationAndEvictionListener expirationListener(expirationEventArrivalCount, evictedEventArrivalCount);
                std::string registrationId = imap->addEntryListener(expirationListener, true);

                for (int i = 0; i < numberOfPutOperations; i++) {
                    imap->put(i, i, 100);
                }

// wait expiration of entries.
                hazelcast::util::sleep(1);

// trigger immediate fire of expiration events by touching them.
                for (int i = 0; i < numberOfPutOperations; i++) {
                    imap->get(i);
                }

                ASSERT_TRUE(expirationEventArrivalCount.await(120));
                ASSERT_TRUE(evictedEventArrivalCount.await(120));
                ASSERT_TRUE(imap->removeEntryListener(registrationId));
            }
        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {
            class PartitionAwareInt : public serialization::IdentifiedDataSerializable, public PartitionAware<int> {
            public:
                PartitionAwareInt() : partitionKey(0), actualKey(0) {}

                PartitionAwareInt(int partitionKey, int actualKey)
                        : partitionKey(partitionKey), actualKey(actualKey) {}

                virtual const int *getPartitionKey() const {
                    return &partitionKey;
                }

                int getActualKey() const {
                    return actualKey;
                }

                virtual int getFactoryId() const {
                    return 666;
                }

                virtual int getClassId() const {
                    return 9;
                }

                virtual void writeData(serialization::ObjectDataOutput &writer) const {
                    writer.writeInt(actualKey);
                }

                virtual void readData(serialization::ObjectDataInput &reader) {
                    actualKey = reader.readInt();
                }

            private:
                int partitionKey;
                int actualKey;
            };

            bool operator<(const PartitionAwareInt &lhs, const PartitionAwareInt &rhs) {
                return lhs.getActualKey() < rhs.getActualKey();
            }

            class MapClientConfig : public ClientConfig {
            public:
                static const char *intMapName;
                static const char *employeesMapName;
                static const char *imapName;
                static const std::string ONE_SECOND_MAP_NAME;

                MapClientConfig() {
                    addAddress(Address(g_srvFactory->getServerAddress(), 5701));
                }

                virtual ~MapClientConfig() {
                }
            };

            const char *MapClientConfig::intMapName = "IntMap";
            const char *MapClientConfig::employeesMapName = "EmployeesMap";
            const char *MapClientConfig::imapName = "clientMapTest";
            const std::string MapClientConfig::ONE_SECOND_MAP_NAME = "OneSecondTtlMap";

            class NearCachedDataMapClientConfig : public MapClientConfig {
            public:
                NearCachedDataMapClientConfig() {
                    addNearCacheConfig<int, int>(std::shared_ptr<config::NearCacheConfig<int, int> >(
                            new config::NearCacheConfig<int, int>(intMapName)));

                    addNearCacheConfig<int, Employee>(std::shared_ptr<config::NearCacheConfig<int, Employee> >(
                            new config::NearCacheConfig<int, Employee>(employeesMapName)));

                    addNearCacheConfig<std::string, std::string>(
                            std::shared_ptr<config::NearCacheConfig<std::string, std::string> >(
                                    new config::NearCacheConfig<std::string, std::string>(imapName)));

                    addNearCacheConfig<std::string, std::string>(
                            std::shared_ptr<config::NearCacheConfig<std::string, std::string> >(
                                    new config::NearCacheConfig<std::string, std::string>(ONE_SECOND_MAP_NAME)));
                }
            };

            class NearCachedObjectMapClientConfig : public MapClientConfig {
            public:
                NearCachedObjectMapClientConfig() {
                    addNearCacheConfig<int, int>(std::shared_ptr<config::NearCacheConfig<int, int> >(
                            new config::NearCacheConfig<int, int>(intMapName, config::OBJECT)));

                    addNearCacheConfig<int, Employee>(std::shared_ptr<config::NearCacheConfig<int, Employee> >(
                            new config::NearCacheConfig<int, Employee>(employeesMapName, config::OBJECT)));

                    addNearCacheConfig<std::string, std::string>(
                            std::shared_ptr<config::NearCacheConfig<std::string, std::string> >(
                                    new config::NearCacheConfig<std::string, std::string>(imapName, config::OBJECT)));

                    addNearCacheConfig<std::string, std::string>(
                            std::shared_ptr<config::NearCacheConfig<std::string, std::string> >(
                                    new config::NearCacheConfig<std::string, std::string>(ONE_SECOND_MAP_NAME,
                                                                                          config::OBJECT)));
                }
            };

            class ClientMapTest : public ClientTestSupport, public ::testing::WithParamInterface<ClientConfig> {
            public:
                ClientMapTest() : client(HazelcastClient(GetParam())),
                                  imap(client.getMap<std::string, std::string>(MapClientConfig::imapName)),
                                  intMap(client.getMap<int, int>(MapClientConfig::intMapName)),
                                  employees(client.getMap<int, Employee>(MapClientConfig::employeesMapName)) {
                }

                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    instance2 = new HazelcastServer(*g_srvFactory);
                }

                static void TearDownTestCase() {
                    delete instance2;
                    delete instance;

                    instance2 = NULL;
                    instance = NULL;
                }

            protected:
                class MapGetInterceptor : public serialization::IdentifiedDataSerializable {
                public:
                    MapGetInterceptor(const std::string &prefix) : prefix(
                            std::unique_ptr<std::string>(new std::string(prefix))) {}

                    virtual int getFactoryId() const {
                        return 666;
                    }

                    virtual int getClassId() const {
                        return 6;
                    }

                    virtual void writeData(serialization::ObjectDataOutput &writer) const {
                        writer.writeUTF(prefix.get());
                    }

                    virtual void readData(serialization::ObjectDataInput &reader) {
                        prefix = reader.readUTF();
                    }

                private:
                    std::unique_ptr<std::string> prefix;
                };

                virtual void TearDown() {
                    // clear maps
                    employees.destroy();
                    intMap.destroy();
                    imap.destroy();
                    client.getMap<std::string, std::string>(MapClientConfig::ONE_SECOND_MAP_NAME).destroy();
                    client.getMap<Employee, int>("tradeMap").destroy();
                }

                void fillMap() {
                    for (int i = 0; i < 10; i++) {
                        std::string key = "key";
                        key += hazelcast::util::IOUtil::to_string(i);
                        std::string value = "value";
                        value += hazelcast::util::IOUtil::to_string(i);
                        imap.put(key, value);
                    }
                }

                static void tryPutThread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    IMap<std::string, std::string> *pMap = (IMap<std::string, std::string> *) args.arg1;
                    bool result = pMap->tryPut("key1", "value3", 1 * 1000);
                    if (!result) {
                        latch->countDown();
                    }
                }

                static void tryRemoveThread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    IMap<std::string, std::string> *pMap = (IMap<std::string, std::string> *) args.arg1;
                    bool result = pMap->tryRemove("key2", 1 * 1000);
                    if (!result) {
                        latch->countDown();
                    }
                }

                static void testLockThread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    IMap<std::string, std::string> *pMap = (IMap<std::string, std::string> *) args.arg1;
                    pMap->tryPut("key1", "value2", 1);
                    latch->countDown();
                }

                static void testLockTTLThread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    IMap<std::string, std::string> *pMap = (IMap<std::string, std::string> *) args.arg1;
                    pMap->tryPut("key1", "value2", 5 * 1000);
                    latch->countDown();
                }

                static void testLockTTL2Thread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    IMap<std::string, std::string> *pMap = (IMap<std::string, std::string> *) args.arg1;
                    if (!pMap->tryLock("key1")) {
                        latch->countDown();
                    }
                    if (pMap->tryLock("key1", 5 * 1000)) {
                        latch->countDown();
                    }
                }

                static void testMapTryLockThread1(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    IMap<std::string, std::string> *pMap = (IMap<std::string, std::string> *) args.arg1;
                    if (!pMap->tryLock("key1", 2)) {
                        latch->countDown();
                    }
                }

                static void testMapTryLockThread2(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    IMap<std::string, std::string> *pMap = (IMap<std::string, std::string> *) args.arg1;
                    if (pMap->tryLock("key1", 20 * 1000)) {
                        latch->countDown();
                    }
                }

                static void testMapForceUnlockThread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    IMap<std::string, std::string> *pMap = (IMap<std::string, std::string> *) args.arg1;
                    pMap->forceUnlock("key1");
                    latch->countDown();
                }

                template<typename K, typename V>
                class EvictedEntryListener : public EntryAdapter<K, V> {
                public:
                    EvictedEntryListener(const std::shared_ptr<CountDownLatch> &evictLatch) : evictLatch(
                            evictLatch) {}

                    virtual void entryEvicted(const EntryEvent<K, V> &event) {
                        evictLatch->countDown();
                    }

                private:
                    std::shared_ptr<hazelcast::util::CountDownLatch> evictLatch;
                };

                template<typename K, typename V>
                class CountdownListener : public EntryAdapter<K, V> {
                public:
                    CountdownListener(hazelcast::util::CountDownLatch &addLatch, hazelcast::util::CountDownLatch &removeLatch,
                                      hazelcast::util::CountDownLatch &updateLatch, hazelcast::util::CountDownLatch &evictLatch)
                            : addLatch(addLatch), removeLatch(removeLatch), updateLatch(updateLatch),
                              evictLatch(evictLatch) {
                    }

                    void entryAdded(const EntryEvent<K, V> &event) {
                        addLatch.countDown();
                    }

                    void entryRemoved(const EntryEvent<K, V> &event) {
                        removeLatch.countDown();
                    }

                    void entryUpdated(const EntryEvent<K, V> &event) {
                        updateLatch.countDown();
                    }

                    void entryEvicted(const EntryEvent<K, V> &event) {
                        evictLatch.countDown();
                    }

                private:
                    hazelcast::util::CountDownLatch &addLatch;
                    hazelcast::util::CountDownLatch &removeLatch;
                    hazelcast::util::CountDownLatch &updateLatch;
                    hazelcast::util::CountDownLatch &evictLatch;
                };

                class MyListener : public EntryAdapter<std::string, std::string> {
                public:
                    MyListener(hazelcast::util::CountDownLatch &latch, hazelcast::util::CountDownLatch &nullLatch)
                            : latch(latch), nullLatch(nullLatch) {
                    }

                    void entryAdded(const EntryEvent<std::string, std::string> &event) {
                        latch.countDown();
                    }

                    void entryEvicted(const EntryEvent<std::string, std::string> &event) {
                        const std::string &oldValue = event.getOldValue();
                        if (oldValue.compare("")) {
                            nullLatch.countDown();
                        }
                        latch.countDown();
                    }

                private:
                    hazelcast::util::CountDownLatch &latch;
                    hazelcast::util::CountDownLatch &nullLatch;
                };

                class ClearListener : public EntryAdapter<std::string, std::string> {
                public:
                    ClearListener(hazelcast::util::CountDownLatch &latch) : latch(latch) {
                    }

                    void mapCleared(const MapEvent &event) {
                        latch.countDown();
                    }

                private:
                    hazelcast::util::CountDownLatch &latch;
                };

                class EvictListener : public EntryAdapter<std::string, std::string> {
                public:
                    EvictListener(hazelcast::util::CountDownLatch &latch) : latch(latch) {
                    }

                    void mapEvicted(const MapEvent &event) {
                        latch.countDown();
                    }

                private:
                    hazelcast::util::CountDownLatch &latch;
                };

                class SampleEntryListenerForPortableKey : public EntryAdapter<Employee, int> {
                public:
                    SampleEntryListenerForPortableKey(hazelcast::util::CountDownLatch &latch, hazelcast::util::AtomicInt &atomicInteger)
                            : latch(latch), atomicInteger(atomicInteger) {

                    }

                    void entryAdded(const EntryEvent<Employee, int> &event) {
                        ++atomicInteger;
                        latch.countDown();
                    }

                private:
                    hazelcast::util::CountDownLatch &latch;
                    hazelcast::util::AtomicInt &atomicInteger;
                };

                class EntryMultiplier : public serialization::IdentifiedDataSerializable {
                public:
                    EntryMultiplier(int multiplier) : multiplier(multiplier) {}

                    /**
                     * @return factory id
                     */
                    int getFactoryId() const {
                        return 666;
                    }

                    /**
                     * @return class id
                     */
                    int getClassId() const {
                        return 3;
                    }

                    /**
                     * Defines how this class will be written.
                     * @param writer ObjectDataOutput
                     */
                    void writeData(serialization::ObjectDataOutput &writer) const {
                        writer.writeInt(multiplier);
                    }

                    /**
                     *Defines how this class will be read.
                     * @param reader ObjectDataInput
                     */
                    void readData(serialization::ObjectDataInput &reader) {
                        multiplier = reader.readInt();
                    }

                    int getMultiplier() const {
                        return multiplier;
                    }

                private:
                    int multiplier;
                };

                HazelcastClient client;
                IMap<std::string, std::string> imap;
                IMap<int, int> intMap;
                IMap<int, Employee> employees;

                static HazelcastServer *instance;
                static HazelcastServer *instance2;
            };

            HazelcastServer *ClientMapTest::instance = NULL;
            HazelcastServer *ClientMapTest::instance2 = NULL;

            INSTANTIATE_TEST_SUITE_P(ClientMapTestWithDifferentConfigs, ClientMapTest,
                                     ::testing::Values(MapClientConfig(), NearCachedDataMapClientConfig(),
                                                       NearCachedObjectMapClientConfig()));

            TEST_P(ClientMapTest, testIssue537) {
                hazelcast::util::CountDownLatch latch(2);
                hazelcast::util::CountDownLatch nullLatch(1);
                MyListener myListener(latch, nullLatch);
                std::string id = imap.addEntryListener(myListener, true);

                imap.put("key1", "value1", 2 * 1000);

                ASSERT_TRUE(latch.await(10));
                ASSERT_TRUE(nullLatch.await(1));

                ASSERT_TRUE(imap.removeEntryListener(id));

                imap.put("key2", "value2");
                ASSERT_EQ(1, imap.size());
            }

            TEST_P(ClientMapTest, testContains) {
                fillMap();

                ASSERT_FALSE(imap.containsKey("key10"));
                ASSERT_TRUE(imap.containsKey("key1"));

                ASSERT_FALSE(imap.containsValue("value10"));
                ASSERT_TRUE(imap.containsValue("value1"));
            }

            TEST_P(ClientMapTest, testGet) {
                fillMap();
                for (int i = 0; i < 10; i++) {
                    std::string key = "key";
                    key += hazelcast::util::IOUtil::to_string(i);
                    std::shared_ptr<std::string> temp = imap.get(key);

                    std::string value = "value";
                    value += hazelcast::util::IOUtil::to_string(i);
                    ASSERT_EQ(*temp, value);
                }
            }

            TEST_P(ClientMapTest, testAsyncGet) {
                fillMap();
                std::shared_ptr<ICompletableFuture<std::string> > future = imap.getAsync(
                        "key1");
                std::shared_ptr<std::string> value = future->get();
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ("value1", *value);
            }

            TEST_P(ClientMapTest, testAsyncPut) {
                fillMap();
                std::shared_ptr<ICompletableFuture<std::string> > future = imap.putAsync(
                        "key3", "value");
                std::shared_ptr<std::string> value = future->get();
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ("value3", *value);
                value = imap.get("key3");
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ("value", *value);
            }

            TEST_P(ClientMapTest, testAsyncPutWithTtl) {
                fillMap();
                std::shared_ptr<hazelcast::util::CountDownLatch> evictLatch(new hazelcast::util::CountDownLatch(1));
                EvictedEntryListener <std::string, std::string> listener(
                        evictLatch);
                std::string listenerId = imap.addEntryListener(listener, true);

                std::shared_ptr<ICompletableFuture<std::string> > future = imap.putAsync(
                        "key", "value1", 3, hazelcast::util::concurrent::TimeUnit::SECONDS());
                std::shared_ptr<std::string> value = future->get();
                ASSERT_NULL("no value for key should exist", value.get(), std::string);
                value = imap.get("key");
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ("value1", *value);

                ASSERT_OPEN_EVENTUALLY(*evictLatch);

                monitor::impl::NearCacheStatsImpl *nearCacheStatsImpl =
                        (monitor::impl::NearCacheStatsImpl *) imap.getLocalMapStats().getNearCacheStats();

// When ttl expires at server, the server does not send near cache invalidation, hence below is for
// non-near cache test case.
                if (!nearCacheStatsImpl) {
                    value = imap.get("key");
                    ASSERT_NULL("The value for key should have expired and not exist", value.get(), std::string);
                }

                ASSERT_TRUE(imap.removeEntryListener(listenerId));
            }

            TEST_P(ClientMapTest, testAsyncPutWithMaxIdle) {
                fillMap();
                std::shared_ptr<hazelcast::util::CountDownLatch> evictLatch(new hazelcast::util::CountDownLatch(1));
                EvictedEntryListener <std::string, std::string> listener(
                        evictLatch);
                std::string listenerId = imap.addEntryListener(listener, true);

                std::shared_ptr<ICompletableFuture<std::string> > future = imap.putAsync(
                        "key", "value1", 0, hazelcast::util::concurrent::TimeUnit::SECONDS(), 3,
                        hazelcast::util::concurrent::TimeUnit::SECONDS());
                std::shared_ptr<std::string> value = future->get();
                ASSERT_NULL("no value for key should exist", value.get(), std::string);
                value = imap.get("key");
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ("value1", *value);

                ASSERT_OPEN_EVENTUALLY(*evictLatch);

                monitor::impl::NearCacheStatsImpl *nearCacheStatsImpl =
                        (monitor::impl::NearCacheStatsImpl *) imap.getLocalMapStats().getNearCacheStats();

// When ttl expires at server, the server does not send near cache invalidation, hence below is for
// non-near cache test case.
                if (!nearCacheStatsImpl) {
                    value = imap.get("key");
                    ASSERT_NULL("The value for key should have expired and not exist", value.get(), std::string);
                }

                ASSERT_TRUE(imap.removeEntryListener(listenerId));
            }

            TEST_P(ClientMapTest, testAsyncSet) {
                fillMap();
                std::shared_ptr<ICompletableFuture<void> > future = imap.setAsync("key3",
                                                                                  "value");
                future->get();
                std::shared_ptr<std::string> value = imap.get("key3");
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ("value", *value);
            }

            TEST_P(ClientMapTest, testAsyncSetWithTtl) {
                fillMap();
                std::shared_ptr<hazelcast::util::CountDownLatch> evictLatch(new hazelcast::util::CountDownLatch(1));
                EvictedEntryListener <std::string, std::string> listener(
                        evictLatch);
                std::string listenerId = imap.addEntryListener(listener, true);

                std::shared_ptr<ICompletableFuture<void> > future = imap.setAsync("key",
                                                                                  "value1",
                                                                                  3,
                                                                                  hazelcast::util::concurrent::TimeUnit::SECONDS());
                future->get();
                std::shared_ptr<std::string> value = imap.get("key");
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ("value1", *value);

                ASSERT_OPEN_EVENTUALLY(*evictLatch);

                monitor::impl::NearCacheStatsImpl *nearCacheStatsImpl =
                        (monitor::impl::NearCacheStatsImpl *) imap.getLocalMapStats().getNearCacheStats();

// When ttl expires at server, the server does not send near cache invalidation, hence below is for
// non-near cache test case.
                if (!nearCacheStatsImpl) {
                    value = imap.get("key");
                    ASSERT_NULL("The value for key should have expired and not exist", value.get(), std::string);
                }

                ASSERT_TRUE(imap.removeEntryListener(listenerId));
            }

            TEST_P(ClientMapTest, testAsyncSetWithMaxIdle) {
                fillMap();
                std::shared_ptr<hazelcast::util::CountDownLatch> evictLatch(new hazelcast::util::CountDownLatch(1));
                EvictedEntryListener <std::string, std::string> listener(
                        evictLatch);
                std::string listenerId = imap.addEntryListener(listener, true);

                std::shared_ptr<ICompletableFuture<void> > future = imap.setAsync("key",
                                                                                  "value1",
                                                                                  0,
                                                                                  hazelcast::util::concurrent::TimeUnit::SECONDS(),
                                                                                  3,
                                                                                  hazelcast::util::concurrent::TimeUnit::SECONDS());
                future->get();
                std::shared_ptr<std::string> value = imap.get("key");
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ("value1", *value);

                ASSERT_OPEN_EVENTUALLY(*evictLatch);

                monitor::impl::NearCacheStatsImpl *nearCacheStatsImpl =
                        (monitor::impl::NearCacheStatsImpl *) imap.getLocalMapStats().getNearCacheStats();

// When ttl expires at server, the server does not send near cache invalidation, hence below is for
// non-near cache test case.
                if (!nearCacheStatsImpl) {
                    value = imap.get("key");
                    ASSERT_NULL("The value for key should have expired and not exist", value.get(), std::string);
                }

                ASSERT_TRUE(imap.removeEntryListener(listenerId));
            }

            TEST_P(ClientMapTest, testAsyncRemove) {
                fillMap();
                std::shared_ptr<ICompletableFuture<string> > future = imap.removeAsync(
                        "key4");
                future->get();
                std::shared_ptr<std::string> value = future->get();
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ("value4", *value);
            }

            TEST_P(ClientMapTest, testPartitionAwareKey) {
                int partitionKey = 5;
                int value = 25;
                IMap<PartitionAwareInt, int> map =
                        client.getMap<PartitionAwareInt, int>(MapClientConfig::intMapName);
                PartitionAwareInt partitionAwareInt(partitionKey, 7);
                map.put(partitionAwareInt, value);
                std::shared_ptr<int> val = map.get(partitionAwareInt);
                ASSERT_NOTNULL(val.get(), int);
                ASSERT_EQ(*val, value);
            }

            TEST_P(ClientMapTest, testRemoveAndDelete) {
                fillMap();
                std::shared_ptr<std::string> temp = imap.remove("key10");
                ASSERT_EQ(temp.get(), (std::string *) NULL);
                imap.deleteEntry("key9");
                ASSERT_EQ(imap.size(), 9);
                for (int i = 0; i < 9; i++) {
                    std::string key = "key";
                    key += hazelcast::util::IOUtil::to_string(i);
                    std::shared_ptr<std::string> temp2 = imap.remove(key);
                    std::string value = "value";
                    value += hazelcast::util::IOUtil::to_string(i);
                    ASSERT_EQ(*temp2, value);
                }
                ASSERT_EQ(imap.size(), 0);
            }

            TEST_P(ClientMapTest, testRemoveIfSame) {
                fillMap();

                ASSERT_FALSE(imap.remove("key2", "value"));
                ASSERT_EQ(10, imap.size());

                ASSERT_TRUE((imap.remove("key2", "value2")));
                ASSERT_EQ(9, imap.size());

            }

            TEST_P(ClientMapTest, testRemoveAll) {
                fillMap();

                imap.removeAll(
                        query::EqualPredicate<std::string>(query::QueryConstants::getKeyAttributeName(), "key5"));

                std::shared_ptr<std::string> value = imap.get("key5");

                ASSERT_NULL("key5 should not exist", value.get(), std::string);

                imap.removeAll(
                        query::LikePredicate(query::QueryConstants::getValueAttributeName(), "value%"));

                ASSERT_TRUE(imap.isEmpty());
            }

            TEST_P(ClientMapTest, testGetAllPutAll) {

                std::map<std::string, std::string> mapTemp;

                for (int i = 0; i < 100; i++) {
                    mapTemp[hazelcast::util::IOUtil::to_string(i)] = hazelcast::util::IOUtil::to_string(i);
                }
                ASSERT_EQ(imap.size(), 0);
                imap.putAll(mapTemp);
                ASSERT_EQ(imap.size(), 100);

                for (int i = 0; i < 100; i++) {
                    std::string expected = hazelcast::util::IOUtil::to_string(i);
                    std::shared_ptr<std::string> actual = imap.get(
                            hazelcast::util::IOUtil::to_string(i));
                    ASSERT_EQ(expected, *actual);
                }

                std::set<std::string> tempSet;
                tempSet.insert(hazelcast::util::IOUtil::to_string(1));
                tempSet.insert(hazelcast::util::IOUtil::to_string(3));

                std::map<std::string, std::string> m2 = imap.getAll(tempSet);

                ASSERT_EQ(2U, m2.size());
                ASSERT_EQ(m2[hazelcast::util::IOUtil::to_string(1)], "1");
                ASSERT_EQ(m2[hazelcast::util::IOUtil::to_string(3)], "3");

            }

            TEST_P(ClientMapTest, testTryPutRemove) {
                ASSERT_TRUE(imap.tryPut("key1", "value1", 1 * 1000));
                ASSERT_TRUE(imap.tryPut("key2", "value2", 1 * 1000));
                imap.lock("key1");
                imap.lock("key2");

                hazelcast::util::CountDownLatch latch(2);

                hazelcast::util::StartedThread t1(tryPutThread, &latch, &imap);
                hazelcast::util::StartedThread t2(tryRemoveThread, &latch, &imap);

                ASSERT_TRUE(latch.await(20));
                ASSERT_EQ("value1", *(imap.get("key1")));
                ASSERT_EQ("value2", *(imap.get("key2")));
                imap.forceUnlock("key1");
                imap.forceUnlock("key2");
            }

            TEST_P(ClientMapTest, testPutTtl) {
                hazelcast::util::CountDownLatch dummy(10);
                hazelcast::util::CountDownLatch evict(1);
                CountdownListener<std::string, std::string> sampleEntryListener(
                        dummy, dummy, dummy, evict);
                std::string id = imap.addEntryListener(sampleEntryListener, false);


                auto nearCacheStatsImpl = (monitor::impl::NearCacheStatsImpl *) imap.getLocalMapStats().getNearCacheStats();

                int64_t initialInvalidationRequests = 0;
                if (nearCacheStatsImpl) {
                    initialInvalidationRequests = nearCacheStatsImpl->getInvalidationRequests();
                }

// put will cause an invalidation event sent from the server to the client
                imap.put("key1", "value1", 1000);

// if near cache is enabled
                if (nearCacheStatsImpl) {
                    ASSERT_EQ_EVENTUALLY(initialInvalidationRequests + 1,
                                         nearCacheStatsImpl->getInvalidationRequests());

// populate near cache
                    imap.get("key1").get();

// When ttl expires at server, the server does not send near cache invalidation.
                    ASSERT_TRUE_ALL_THE_TIME((imap.get("key1").get() && nearCacheStatsImpl->getInvalidationRequests() ==
                                                                        initialInvalidationRequests + 1), 2);
                } else {
// trigger eviction
                    ASSERT_NULL_EVENTUALLY(imap.get("key1").get(), std::string);
                }

                ASSERT_TRUE(evict.await(5));

                ASSERT_TRUE(imap.removeEntryListener(id));
            }

            TEST_P(ClientMapTest, testPutConfigTtl) {
                IMap<std::string, std::string> map = client.getMap<std::string, std::string>(
                        MapClientConfig::ONE_SECOND_MAP_NAME);
                hazelcast::util::CountDownLatch dummy(10);
                hazelcast::util::CountDownLatch evict(1);
                CountdownListener<std::string, std::string> sampleEntryListener(
                        dummy, dummy, dummy, evict);
                std::string id = map.addEntryListener(sampleEntryListener, false);

                auto nearCacheStatsImpl = (monitor::impl::NearCacheStatsImpl *) map.getLocalMapStats().getNearCacheStats();

                int64_t initialInvalidationRequests = 0;
                if (nearCacheStatsImpl) {
                    initialInvalidationRequests = nearCacheStatsImpl->getInvalidationRequests();
                }

// put will cause an invalidation event sent from the server to the client
                map.put("key1", "value1");

// if near cache is enabled
                if (nearCacheStatsImpl) {
                    ASSERT_EQ_EVENTUALLY(initialInvalidationRequests + 1,
                                         nearCacheStatsImpl->getInvalidationRequests());

// populate near cache
                    imap.get("key1").get();

// When ttl expires at server, the server does not send near cache invalidation.
                    ASSERT_TRUE_ALL_THE_TIME((map.get("key1").get() && nearCacheStatsImpl->getInvalidationRequests() ==
                                                                       initialInvalidationRequests + 1), 2);
                } else {
// trigger eviction
                    ASSERT_NULL_EVENTUALLY(map.get("key1").get(), std::string);
                }

                ASSERT_TRUE(evict.await(5));

                ASSERT_TRUE(map.removeEntryListener(id));
            }

            TEST_P(ClientMapTest, testPutIfAbsent) {
                std::shared_ptr<std::string> o = imap.putIfAbsent("key1", "value1");
                ASSERT_EQ(o.get(), (std::string *) NULL);
                ASSERT_EQ("value1", *(imap.putIfAbsent("key1", "value3")));
            }

            TEST_P(ClientMapTest, testPutIfAbsentTtl) {
                ASSERT_EQ(imap.putIfAbsent("key1", "value1", 1000).get(),
                          (std::string *) NULL);
                ASSERT_EQ("value1", *(imap.putIfAbsent("key1", "value3", 1000)));

                ASSERT_NULL_EVENTUALLY(imap.putIfAbsent("key1", "value3", 1000).get(), std::string);
                ASSERT_EQ("value3", *(imap.putIfAbsent("key1", "value4", 1000)));
            }

            TEST_P(ClientMapTest, testSet) {
                imap.set("key1", "value1");
                ASSERT_EQ("value1", *(imap.get("key1")));

                imap.set("key1", "value2");
                ASSERT_EQ("value2", *(imap.get("key1")));
            }

            TEST_P(ClientMapTest, testSetTtl) {
                hazelcast::util::CountDownLatch dummy(10);
                hazelcast::util::CountDownLatch evict(1);
                CountdownListener<std::string, std::string> sampleEntryListener(
                        dummy, dummy, dummy, evict);
                std::string id = imap.addEntryListener(sampleEntryListener, false);

                monitor::impl::NearCacheStatsImpl *nearCacheStatsImpl = (monitor::impl::NearCacheStatsImpl *) imap.getLocalMapStats().getNearCacheStats();

                int64_t initialInvalidationRequests = 0;
                if (nearCacheStatsImpl) {
                    initialInvalidationRequests = nearCacheStatsImpl->getInvalidationRequests();
                }

// set will cause an invalidation event sent from the server to the client
                imap.set("key1", "value1", 1000);

// if near cache is enabled
                if (nearCacheStatsImpl) {
                    ASSERT_EQ_EVENTUALLY(initialInvalidationRequests + 1,
                                         nearCacheStatsImpl->getInvalidationRequests());

// populate near cache
                    imap.get("key1").get();

// When ttl expires at server, the server does not send near cache invalidation.
                    ASSERT_TRUE_ALL_THE_TIME((imap.get("key1").get() && nearCacheStatsImpl->getInvalidationRequests() ==
                                                                        initialInvalidationRequests + 1), 2);
                } else {
// trigger eviction
                    ASSERT_NULL_EVENTUALLY(imap.get("key1").get(), std::string);
                }

                ASSERT_TRUE(evict.await(5));

                ASSERT_TRUE(imap.removeEntryListener(id));
            }

            TEST_P(ClientMapTest, testSetConfigTtl) {
                IMap<std::string, std::string> map = client.getMap<std::string, std::string>(
                        MapClientConfig::ONE_SECOND_MAP_NAME);
                hazelcast::util::CountDownLatch dummy(10);
                hazelcast::util::CountDownLatch evict(1);
                CountdownListener<std::string, std::string> sampleEntryListener(
                        dummy, dummy, dummy, evict);
                std::string id = map.addEntryListener(sampleEntryListener, false);

                monitor::impl::NearCacheStatsImpl *nearCacheStatsImpl = (monitor::impl::NearCacheStatsImpl *) map.getLocalMapStats().getNearCacheStats();

                int64_t initialInvalidationRequests = 0;
                if (nearCacheStatsImpl) {
                    initialInvalidationRequests = nearCacheStatsImpl->getInvalidationRequests();
                }

// put will cause an invalidation event sent from the server to the client
                map.set("key1", "value1");

// if near cache is enabled
                if (nearCacheStatsImpl) {
                    ASSERT_EQ_EVENTUALLY(initialInvalidationRequests + 1,
                                         nearCacheStatsImpl->getInvalidationRequests());

// populate near cache
                    imap.get("key1").get();

// When ttl expires at server, the server does not send near cache invalidation.
                    ASSERT_TRUE_ALL_THE_TIME((map.get("key1").get() && nearCacheStatsImpl->getInvalidationRequests() ==
                                                                       initialInvalidationRequests + 1), 2);
                } else {
// trigger eviction
                    ASSERT_NULL_EVENTUALLY(map.get("key1").get(), std::string);
                }

                ASSERT_TRUE(evict.await(5));

                ASSERT_TRUE(map.removeEntryListener(id));
            }

            TEST_P(ClientMapTest, testLock) {
                imap.put("key1", "value1");
                ASSERT_EQ("value1", *(imap.get("key1")));
                imap.lock("key1");
                hazelcast::util::CountDownLatch latch(1);
                hazelcast::util::StartedThread t1(testLockThread, &latch, &imap);
                ASSERT_TRUE(latch.await(5));
                ASSERT_EQ("value1", *(imap.get("key1")));
                imap.forceUnlock("key1");
            }

            TEST_P(ClientMapTest, testLockTtl) {
                imap.put("key1", "value1");
                ASSERT_EQ("value1", *(imap.get("key1")));
                imap.lock("key1", 2 * 1000);
                hazelcast::util::CountDownLatch latch(1);
                hazelcast::util::StartedThread t1(testLockTTLThread, &latch, &imap);
                ASSERT_TRUE(latch.await(10));
                ASSERT_FALSE(imap.isLocked("key1"));
                ASSERT_EQ("value2", *(imap.get("key1")));
                imap.forceUnlock("key1");
            }

            TEST_P(ClientMapTest, testLockTtl2) {
                imap.lock("key1", 3 * 1000);
                hazelcast::util::CountDownLatch latch(2);
                hazelcast::util::StartedThread t1(testLockTTL2Thread, &latch, &imap);
                ASSERT_TRUE(latch.await(10));
                imap.forceUnlock("key1");
            }

            TEST_P(ClientMapTest, testTryLock) {
                ASSERT_TRUE(imap.tryLock("key1", 2 * 1000));
                hazelcast::util::CountDownLatch latch(1);
                hazelcast::util::StartedThread t1(testMapTryLockThread1, &latch, &imap);

                ASSERT_TRUE(latch.await(100));

                ASSERT_TRUE(imap.isLocked("key1"));

                hazelcast::util::CountDownLatch latch2(1);
                hazelcast::util::StartedThread t2(testMapTryLockThread2, &latch2, &imap);

                hazelcast::util::sleep(1);
                imap.unlock("key1");
                ASSERT_TRUE(latch2.await(100));
                ASSERT_TRUE(imap.isLocked("key1"));
                imap.forceUnlock("key1");
            }

            TEST_P(ClientMapTest, testForceUnlock) {
                imap.lock("key1");
                hazelcast::util::CountDownLatch latch(1);
                hazelcast::util::StartedThread t2(testMapForceUnlockThread, &latch, &imap);
                ASSERT_TRUE(latch.await(100));
                t2.join();
                ASSERT_FALSE(imap.isLocked("key1"));

            }

            TEST_P(ClientMapTest, testValues) {
                fillMap();
                std::vector<std::string> tempVector;
                query::SqlPredicate predicate("this == value1");
                tempVector = imap.values(predicate);
                ASSERT_EQ(1U, tempVector.size());

                std::vector<std::string>::iterator it = tempVector.begin();
                ASSERT_EQ("value1", *it);
            }

            TEST_P(ClientMapTest, testValuesWithPredicate) {
                const int numItems = 20;
                for (int i = 0; i < numItems; ++i) {
                    intMap.put(i, 2 * i);
                }

                std::vector<int> values = intMap.values();
                ASSERT_EQ(numItems, (int) values.size());
                std::sort(values.begin(), values.end());
                for (int i = 0; i < numItems; ++i) {
                    ASSERT_EQ(2 * i, values[i]);
                }

// EqualPredicate
// key == 5
                values = intMap.values(
                        query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5));
                ASSERT_EQ(1, (int) values.size());
                ASSERT_EQ(2 * 5, values[0]);

// value == 8
                values = intMap.values(
                        query::EqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 8));
                ASSERT_EQ(1, (int) values.size());
                ASSERT_EQ(8, values[0]);

// key == numItems
                values = intMap.values(
                        query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), numItems));
                ASSERT_EQ(0, (int) values.size());

// NotEqual Predicate
// key != 5
                values = intMap.values(
                        query::NotEqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5));
                ASSERT_EQ(numItems - 1, (int) values.size());
                std::sort(values.begin(), values.end());
                for (int i = 0; i < numItems - 1; ++i) {
                    if (i >= 5) {
                        ASSERT_EQ(2 * (i + 1), values[i]);
                    } else {
                        ASSERT_EQ(2 * i, values[i]);
                    }
                }

// this(value) != 8
                values = intMap.values(
                        query::NotEqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 8));
                ASSERT_EQ(numItems - 1, (int) values.size());
                std::sort(values.begin(), values.end());
                for (int i = 0; i < numItems - 1; ++i) {
                    if (i >= 4) {
                        ASSERT_EQ(2 * (i + 1), values[i]);
                    } else {
                        ASSERT_EQ(2 * i, values[i]);
                    }
                }

// TruePredicate
                values = intMap.values(query::TruePredicate());
                ASSERT_EQ(numItems, (int) values.size());
                std::sort(values.begin(), values.end());
                for (int i = 0; i < numItems; ++i) {
                    ASSERT_EQ(2 * i, values[i]);
                }

// FalsePredicate
                values = intMap.values(query::FalsePredicate());
                ASSERT_EQ(0, (int) values.size());

// BetweenPredicate
// 5 <= key <= 10
                values = intMap.values(
                        query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                std::sort(values.begin(), values.end());
                ASSERT_EQ(6, (int) values.size());
                for (int i = 0; i < 6; ++i) {
                    ASSERT_EQ(2 * (i + 5), values[i]);
                }

// 20 <= key <=30
                values = intMap.values(
                        query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 20, 30));
                ASSERT_EQ(0, (int) values.size());

// GreaterLessPredicate
// value <= 10
                values = intMap.values(
                        query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 10, true,
                                                         true));
                ASSERT_EQ(6, (int) values.size());
                std::sort(values.begin(), values.end());
                for (int i = 0; i < 6; ++i) {
                    ASSERT_EQ(2 * i, values[i]);
                }

// key < 7
                values = intMap.values(
                        query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 7, false, true));
                ASSERT_EQ(7, (int) values.size());
                std::sort(values.begin(), values.end());
                for (int i = 0; i < 7; ++i) {
                    ASSERT_EQ(2 * i, values[i]);
                }

// value >= 15
                values = intMap.values(
                        query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 15, true,
                                                         false));
                ASSERT_EQ(12, (int) values.size());
                std::sort(values.begin(), values.end());
                for (int i = 0; i < 12; ++i) {
                    ASSERT_EQ(2 * (i + 8), values[i]);
                }

// key > 5
                values = intMap.values(
                        query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, false,
                                                         false));
                ASSERT_EQ(14, (int) values.size());
                std::sort(values.begin(), values.end());
                for (int i = 0; i < 14; ++i) {
                    ASSERT_EQ(2 * (i + 6), values[i]);
                }

// InPredicate
// key in {4, 10, 19}
                std::vector<int> inVals(3);
                inVals[0] = 4;
                inVals[1] = 10;
                inVals[2] = 19;
                values = intMap.values(
                        query::InPredicate<int>(query::QueryConstants::getKeyAttributeName(), inVals));
                ASSERT_EQ(3, (int) values.size());
                std::sort(values.begin(), values.end());
                ASSERT_EQ(2 * 4, values[0]);
                ASSERT_EQ(2 * 10, values[1]);
                ASSERT_EQ(2 * 19, values[2]);

// value in {4, 10, 19}
                values = intMap.values(
                        query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                ASSERT_EQ(2, (int) values.size());
                std::sort(values.begin(), values.end());
                ASSERT_EQ(4, values[0]);
                ASSERT_EQ(10, values[1]);

// InstanceOfPredicate
// value instanceof Integer
                values = intMap.values(query::InstanceOfPredicate("java.lang.Integer"));
                ASSERT_EQ(20, (int) values.size());
                std::sort(values.begin(), values.end());
                for (int i = 0; i < numItems; ++i) {
                    ASSERT_EQ(2 * i, values[i]);
                }

                values = intMap.values(query::InstanceOfPredicate("java.lang.String"));
                ASSERT_EQ(0, (int) values.size());

// NotPredicate
// !(5 <= key <= 10)
                std::unique_ptr<query::Predicate> bp = std::unique_ptr<query::Predicate>(
                        new query::BetweenPredicate<int>(
                                query::QueryConstants::getKeyAttributeName(), 5, 10));
                query::NotPredicate notPredicate(bp);
                values = intMap.values(notPredicate);
                ASSERT_EQ(14, (int) values.size());
                std::sort(values.begin(), values.end());
                for (int i = 0; i < 14; ++i) {
                    if (i >= 5) {
                        ASSERT_EQ(2 * (i + 6), values[i]);
                    } else {
                        ASSERT_EQ(2 * i, values[i]);
                    }
                }

// AndPredicate
// 5 <= key <= 10 AND Values in {4, 10, 19} = values {4, 10}
                bp = std::unique_ptr<query::Predicate>(
                        new query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                std::unique_ptr<query::Predicate> inPred = std::unique_ptr<query::Predicate>(
                        new query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                values = intMap.values(query::AndPredicate().add(bp).add(inPred));
                ASSERT_EQ(1, (int) values.size());
                std::sort(values.begin(), values.end());
                ASSERT_EQ(10, values[0]);

// OrPredicate
// 5 <= key <= 10 OR Values in {4, 10, 19} = values {4, 10, 12, 14, 16, 18, 20}
                bp = std::unique_ptr<query::Predicate>(
                        new query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                inPred = std::unique_ptr<query::Predicate>(
                        new query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                values = intMap.values(query::OrPredicate().add(bp).add(inPred));
                ASSERT_EQ(7, (int) values.size());
                std::sort(values.begin(), values.end());
                ASSERT_EQ(4, values[0]);
                ASSERT_EQ(10, values[1]);
                ASSERT_EQ(12, values[2]);
                ASSERT_EQ(14, values[3]);
                ASSERT_EQ(16, values[4]);
                ASSERT_EQ(18, values[5]);
                ASSERT_EQ(20, values[6]);

                for (int i = 0; i < 12; i++) {
                    std::string key = "key";
                    key += hazelcast::util::IOUtil::to_string(i);
                    std::string value = "value";
                    value += hazelcast::util::IOUtil::to_string(i);
                    imap.put(key, value);
                }
                imap.put("key_111_test", "myvalue_111_test");
                imap.put("key_22_test", "myvalue_22_test");

// LikePredicate
// value LIKE "value1" : {"value1"}
                std::vector<std::string> strValues = imap.values(
                        query::LikePredicate(query::QueryConstants::getValueAttributeName(), "value1"));
                ASSERT_EQ(1, (int) strValues.size());
                ASSERT_EQ("value1", strValues[0]);

// ILikePredicate
// value ILIKE "%VALue%1%" : {"myvalue_111_test", "value1", "value10", "value11"}
                strValues = imap.values(
                        query::ILikePredicate(query::QueryConstants::getValueAttributeName(), "%VALue%1%"));
                ASSERT_EQ(4, (int) strValues.size());
                std::sort(strValues.begin(), strValues.end());
                ASSERT_EQ("myvalue_111_test", strValues[0]);
                ASSERT_EQ("value1", strValues[1]);
                ASSERT_EQ("value10", strValues[2]);
                ASSERT_EQ("value11", strValues[3]);

// value ILIKE "%VAL%2%" : {"myvalue_22_test", "value2"}
                strValues = imap.values(
                        query::ILikePredicate(query::QueryConstants::getValueAttributeName(), "%VAL%2%"));
                ASSERT_EQ(2, (int) strValues.size());
                std::sort(strValues.begin(), strValues.end());
                ASSERT_EQ("myvalue_22_test", strValues[0]);
                ASSERT_EQ("value2", strValues[1]);

// SqlPredicate
// __key BETWEEN 4 and 7 : {4, 5, 6, 7} -> {8, 10, 12, 14}
                char sql[100];
                hazelcast::util::hz_snprintf(sql, 50, "%s BETWEEN 4 and 7",
                                             query::QueryConstants::getKeyAttributeName());
                values = intMap.values(query::SqlPredicate(sql));
                ASSERT_EQ(4, (int) values.size());
                std::sort(values.begin(), values.end());
                for (int i = 0; i < 4; ++i) {
                    ASSERT_EQ(2 * (i + 4), values[i]);
                }

// RegexPredicate
// value matches the regex ".*value.*2.*" : {myvalue_22_test, value2}
                strValues = imap.values(
                        query::RegexPredicate(query::QueryConstants::getValueAttributeName(), ".*value.*2.*"));
                ASSERT_EQ(2, (int) strValues.size());
                std::sort(strValues.begin(), strValues.end());
                ASSERT_EQ("myvalue_22_test", strValues[0]);
                ASSERT_EQ("value2", strValues[1]);
            }

            TEST_P(ClientMapTest, testValuesWithPagingPredicate) {
                int predSize = 5;
                const int totalEntries = 25;

                for (int i = 0; i < totalEntries; ++i) {
                    intMap.put(i, i);
                }

                query::PagingPredicate<int, int> predicate((size_t) predSize);

                std::vector<int> values = intMap.values(predicate);
                ASSERT_EQ(predSize, (int) values.size());
                for (int i = 0; i < predSize; ++i) {
                    ASSERT_EQ(i, values[i]);
                }

                values = intMap.values(predicate);
                ASSERT_EQ(predSize, (int) values.size());
                for (int i = 0; i < predSize; ++i) {
                    ASSERT_EQ(i, values[i]);
                }

                predicate.nextPage();
                values = intMap.values(predicate);
                ASSERT_EQ(predSize, (int) values.size());

                for (int i = 0; i < predSize; ++i) {
                    ASSERT_EQ(predSize + i, values[i]);
                }

                const std::pair<int *, int *> *anchor = predicate.getAnchor();
                ASSERT_NE((const std::pair<int *, int *> *) NULL, anchor);
                ASSERT_NE((int *) NULL, anchor->first);
                ASSERT_NE((int *) NULL, anchor->second);
                ASSERT_EQ(9, *anchor->first);
                ASSERT_EQ(9, *anchor->second);

                ASSERT_EQ(1, (int) predicate.getPage());

                predicate.setPage(4);

                values = intMap.values(predicate);
                ASSERT_EQ(predSize, (int) values.size());

                for (int i = 0; i < predSize; ++i) {
                    ASSERT_EQ(predSize * 4 + i, values[i]);
                }

                anchor = predicate.getAnchor();
                ASSERT_NE((const std::pair<int *, int *> *) NULL, anchor);
                ASSERT_NE((int *) NULL, anchor->first);
                ASSERT_NE((int *) NULL, anchor->second);
                ASSERT_EQ(24, *anchor->first);
                ASSERT_EQ(24, *anchor->second);

                const std::pair<size_t, std::pair<int *, int *> > *anchorEntry = predicate.getNearestAnchorEntry();
                ASSERT_NE((const std::pair<size_t, std::pair<int *, int *> > *) NULL, anchorEntry);
                ASSERT_NE((int *) NULL, anchorEntry->second.first);
                ASSERT_NE((int *) NULL, anchorEntry->second.second);
                ASSERT_EQ(3, (int) anchorEntry->first);
                ASSERT_EQ(19, *anchorEntry->second.first);
                ASSERT_EQ(19, *anchorEntry->second.second);

                predicate.nextPage();
                values = intMap.values(predicate);
                ASSERT_EQ(0, (int) values.size());

                predicate.setPage(0);
                values = intMap.values(predicate);
                ASSERT_EQ(predSize, (int) values.size());
                for (int i = 0; i < predSize; ++i) {
                    ASSERT_EQ(i, values[i]);
                }

                predicate.previousPage();
                ASSERT_EQ(0, (int) predicate.getPage());

                predicate.setPage(5);
                values = intMap.values(predicate);
                ASSERT_EQ(0, (int) values.size());

                predicate.setPage(3);
                values = intMap.values(predicate);
                ASSERT_EQ(predSize, (int) values.size());
                for (int i = 0; i < predSize; ++i) {
                    ASSERT_EQ(3 * predSize + i, values[i]);
                }

                predicate.previousPage();
                values = intMap.values(predicate);
                ASSERT_EQ(predSize, (int) values.size());
                for (int i = 0; i < predSize; ++i) {
                    ASSERT_EQ(2 * predSize + i, values[i]);
                }

// test PagingPredicate with inner predicate (value < 10)
                std::unique_ptr<query::Predicate> lessThanTenPredicate(std::unique_ptr<query::Predicate>(
                        new query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 9, false,
                                                             true)));
                query::PagingPredicate<int, int> predicate2(lessThanTenPredicate, 5);
                values = intMap.values(predicate2);
                ASSERT_EQ(predSize, (int) values.size());
                for (int i = 0; i < predSize; ++i) {
                    ASSERT_EQ(i, values[i]);
                }

                predicate2.nextPage();
// match values 5,6, 7, 8
                values = intMap.values(predicate2);
                ASSERT_EQ(predSize - 1, (int) values.size());
                for (int i = 0; i < predSize - 1; ++i) {
                    ASSERT_EQ(predSize + i, values[i]);
                }

                predicate2.nextPage();
                values = intMap.values(predicate2);
                ASSERT_EQ(0, (int) values.size());

// test paging predicate with comparator
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);
                Employee empl3("deniz", 25);
                Employee empl4("ali", 33);
                Employee empl5("veli", 44);
                Employee empl6("aylin", 5);

                employees.put(3, empl1);
                employees.put(4, empl2);
                employees.put(5, empl3);
                employees.put(6, empl4);
                employees.put(7, empl5);
                employees.put(8, empl6);

                predSize = 2;
                query::PagingPredicate<int, Employee> predicate3(
                        std::unique_ptr<query::EntryComparator<int, Employee> >(new EmployeeEntryComparator()),
                        (size_t) predSize);
                std::vector<Employee> result = employees.values(predicate3);
                ASSERT_EQ(2, (int) result.size());
                ASSERT_EQ(empl6, result[0]);
                ASSERT_EQ(empl2, result[1]);

                predicate3.nextPage();
                result = employees.values(predicate3);
                ASSERT_EQ(2, (int) result.size());
                ASSERT_EQ(empl3, result[0]);
                ASSERT_EQ(empl4, result[1]);
            }

            TEST_P(ClientMapTest, testKeySetWithPredicate) {
                const int numItems = 20;
                for (int i = 0; i < numItems; ++i) {
                    intMap.put(i, 2 * i);
                }

                std::vector<int> keys = intMap.keySet();
                ASSERT_EQ(numItems, (int) keys.size());
                std::sort(keys.begin(), keys.end());
                for (int i = 0; i < numItems; ++i) {
                    ASSERT_EQ(i, keys[i]);
                }

// EqualPredicate
// key == 5
                keys = intMap.keySet(
                        query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5));
                ASSERT_EQ(1, (int) keys.size());
                ASSERT_EQ(5, keys[0]);

// value == 8
                keys = intMap.keySet(
                        query::EqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 8));
                ASSERT_EQ(1, (int) keys.size());
                ASSERT_EQ(4, keys[0]);

// key == numItems
                keys = intMap.keySet(
                        query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), numItems));
                ASSERT_EQ(0, (int) keys.size());

// NotEqual Predicate
// key != 5
                keys = intMap.keySet(
                        query::NotEqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5));
                ASSERT_EQ(numItems - 1, (int) keys.size());
                std::sort(keys.begin(), keys.end());
                for (int i = 0; i < numItems - 1; ++i) {
                    if (i >= 5) {
                        ASSERT_EQ(i + 1, keys[i]);
                    } else {
                        ASSERT_EQ(i, keys[i]);
                    }
                }

// value != 8
                keys = intMap.keySet(
                        query::NotEqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 8));
                ASSERT_EQ(numItems - 1, (int) keys.size());
                std::sort(keys.begin(), keys.end());
                for (int i = 0; i < numItems - 1; ++i) {
                    if (i >= 4) {
                        ASSERT_EQ(i + 1, keys[i]);
                    } else {
                        ASSERT_EQ(i, keys[i]);
                    }
                }

// TruePredicate
                keys = intMap.keySet(query::TruePredicate());
                ASSERT_EQ(numItems, (int) keys.size());
                std::sort(keys.begin(), keys.end());
                for (int i = 0; i < numItems; ++i) {
                    ASSERT_EQ(i, keys[i]);
                }

// FalsePredicate
                keys = intMap.keySet(query::FalsePredicate());
                ASSERT_EQ(0, (int) keys.size());

// BetweenPredicate
// 5 <= key <= 10
                keys = intMap.keySet(
                        query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                std::sort(keys.begin(), keys.end());
                ASSERT_EQ(6, (int) keys.size());
                for (int i = 0; i < 6; ++i) {
                    ASSERT_EQ((i + 5), keys[i]);
                }

// 20 <= key <=30
                keys = intMap.keySet(
                        query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 20, 30));
                ASSERT_EQ(0, (int) keys.size());

// GreaterLessPredicate
// value <= 10
                keys = intMap.keySet(
                        query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 10, true,
                                                         true));
                ASSERT_EQ(6, (int) keys.size());
                std::sort(keys.begin(), keys.end());
                for (int i = 0; i < 6; ++i) {
                    ASSERT_EQ(i, keys[i]);
                }

// key < 7
                keys = intMap.keySet(
                        query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 7, false, true));
                ASSERT_EQ(7, (int) keys.size());
                std::sort(keys.begin(), keys.end());
                for (int i = 0; i < 7; ++i) {
                    ASSERT_EQ(i, keys[i]);
                }

// value >= 15
                keys = intMap.keySet(
                        query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 15, true,
                                                         false));
                ASSERT_EQ(12, (int) keys.size());
                std::sort(keys.begin(), keys.end());
                for (int i = 0; i < 12; ++i) {
                    ASSERT_EQ(i + 8, keys[i]);
                }

// key > 5
                keys = intMap.keySet(
                        query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, false,
                                                         false));
                ASSERT_EQ(14, (int) keys.size());
                std::sort(keys.begin(), keys.end());
                for (int i = 0; i < 14; ++i) {
                    ASSERT_EQ(i + 6, keys[i]);
                }

// InPredicate
// key in {4, 10, 19}
                std::vector<int> inVals(3);
                inVals[0] = 4;
                inVals[1] = 10;
                inVals[2] = 19;
                keys = intMap.keySet(
                        query::InPredicate<int>(query::QueryConstants::getKeyAttributeName(), inVals));
                ASSERT_EQ(3, (int) keys.size());
                std::sort(keys.begin(), keys.end());
                ASSERT_EQ(4, keys[0]);
                ASSERT_EQ(10, keys[1]);
                ASSERT_EQ(19, keys[2]);

// value in {4, 10, 19}
                keys = intMap.keySet(
                        query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                ASSERT_EQ(2, (int) keys.size());
                std::sort(keys.begin(), keys.end());
                ASSERT_EQ(2, keys[0]);
                ASSERT_EQ(5, keys[1]);

// InstanceOfPredicate
// value instanceof Integer
                keys = intMap.keySet(query::InstanceOfPredicate("java.lang.Integer"));
                ASSERT_EQ(20, (int) keys.size());
                std::sort(keys.begin(), keys.end());
                for (int i = 0; i < numItems; ++i) {
                    ASSERT_EQ(i, keys[i]);
                }

                keys = intMap.keySet(query::InstanceOfPredicate("java.lang.String"));
                ASSERT_EQ(0, (int) keys.size());

// NotPredicate
// !(5 <= key <= 10)
                std::unique_ptr<query::Predicate> bp = std::unique_ptr<query::Predicate>(
                        new query::BetweenPredicate<int>(
                                query::QueryConstants::getKeyAttributeName(), 5, 10));
                query::NotPredicate notPredicate(bp);
                keys = intMap.keySet(notPredicate);
                ASSERT_EQ(14, (int) keys.size());
                std::sort(keys.begin(), keys.end());
                for (int i = 0; i < 14; ++i) {
                    if (i >= 5) {
                        ASSERT_EQ(i + 6, keys[i]);
                    } else {
                        ASSERT_EQ(i, keys[i]);
                    }
                }

// AndPredicate
// 5 <= key <= 10 AND Values in {4, 10, 19} = keys {4, 10}
                bp = std::unique_ptr<query::Predicate>(
                        new query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                std::unique_ptr<query::Predicate> inPred = std::unique_ptr<query::Predicate>(
                        new query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                keys = intMap.keySet(query::AndPredicate().add(bp).add(inPred));
                ASSERT_EQ(1, (int) keys.size());
                std::sort(keys.begin(), keys.end());
                ASSERT_EQ(5, keys[0]);

// OrPredicate
// 5 <= key <= 10 OR Values in {4, 10, 19} = keys {2, 5, 6, 7, 8, 9, 10}
                bp = std::unique_ptr<query::Predicate>(
                        new query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                inPred = std::unique_ptr<query::Predicate>(
                        new query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                keys = intMap.keySet(query::OrPredicate().add(bp).add(inPred));
                ASSERT_EQ(7, (int) keys.size());
                std::sort(keys.begin(), keys.end());
                ASSERT_EQ(2, keys[0]);
                ASSERT_EQ(5, keys[1]);
                ASSERT_EQ(6, keys[2]);
                ASSERT_EQ(7, keys[3]);
                ASSERT_EQ(8, keys[4]);
                ASSERT_EQ(9, keys[5]);
                ASSERT_EQ(10, keys[6]);

                for (int i = 0; i < 12; i++) {
                    std::string key = "key";
                    key += hazelcast::util::IOUtil::to_string(i);
                    std::string value = "value";
                    value += hazelcast::util::IOUtil::to_string(i);
                    imap.put(key, value);
                }
                imap.put("key_111_test", "myvalue_111_test");
                imap.put("key_22_test", "myvalue_22_test");

// LikePredicate
// value LIKE "value1" : {"value1"}
                std::vector<std::string> strKeys = imap.keySet(
                        query::LikePredicate(query::QueryConstants::getValueAttributeName(), "value1"));
                ASSERT_EQ(1, (int) strKeys.size());
                ASSERT_EQ("key1", strKeys[0]);

// ILikePredicate
// value ILIKE "%VALue%1%" : {"key_111_test", "key1", "key10", "key11"}
                strKeys = imap.keySet(
                        query::ILikePredicate(query::QueryConstants::getValueAttributeName(), "%VALue%1%"));
                ASSERT_EQ(4, (int) strKeys.size());
                std::sort(strKeys.begin(), strKeys.end());
                ASSERT_EQ("key1", strKeys[0]);
                ASSERT_EQ("key10", strKeys[1]);
                ASSERT_EQ("key11", strKeys[2]);
                ASSERT_EQ("key_111_test", strKeys[3]);

// key ILIKE "%VAL%2%" : {"key_22_test", "key2"}
                strKeys = imap.keySet(
                        query::ILikePredicate(query::QueryConstants::getValueAttributeName(), "%VAL%2%"));
                ASSERT_EQ(2, (int) strKeys.size());
                std::sort(strKeys.begin(), strKeys.end());
                ASSERT_EQ("key2", strKeys[0]);
                ASSERT_EQ("key_22_test", strKeys[1]);

// SqlPredicate
// __key BETWEEN 4 and 7 : {4, 5, 6, 7} -> {8, 10, 12, 14}
                char sql[100];
                hazelcast::util::hz_snprintf(sql, 50, "%s BETWEEN 4 and 7",
                                             query::QueryConstants::getKeyAttributeName());
                keys = intMap.keySet(query::SqlPredicate(sql));
                ASSERT_EQ(4, (int) keys.size());
                std::sort(keys.begin(), keys.end());
                for (int i = 0; i < 4; ++i) {
                    ASSERT_EQ(i + 4, keys[i]);
                }

// RegexPredicate
// value matches the regex ".*value.*2.*" : {key_22_test, value2}
                strKeys = imap.keySet(
                        query::RegexPredicate(query::QueryConstants::getValueAttributeName(), ".*value.*2.*"));
                ASSERT_EQ(2, (int) strKeys.size());
                std::sort(strKeys.begin(), strKeys.end());
                ASSERT_EQ("key2", strKeys[0]);
                ASSERT_EQ("key_22_test", strKeys[1]);
            }

            TEST_P(ClientMapTest, testKeySetWithPagingPredicate) {
                int predSize = 5;
                const int totalEntries = 25;

                for (int i = 0; i < totalEntries; ++i) {
                    intMap.put(i, i);
                }

                query::PagingPredicate<int, int> predicate((size_t) predSize);

                std::vector<int> values = intMap.keySet(predicate);
                ASSERT_EQ(predSize, (int) values.size());
                for (int i = 0; i < predSize; ++i) {
                    ASSERT_EQ(i, values[i]);
                }

                values = intMap.keySet(predicate);
                ASSERT_EQ(predSize, (int) values.size());
                for (int i = 0; i < predSize; ++i) {
                    ASSERT_EQ(i, values[i]);
                }

                predicate.nextPage();
                values = intMap.keySet(predicate);
                ASSERT_EQ(predSize, (int) values.size());

                for (int i = 0; i < predSize; ++i) {
                    ASSERT_EQ(predSize + i, values[i]);
                }

                const std::pair<int *, int *> *anchor = predicate.getAnchor();
                ASSERT_NE((const std::pair<int *, int *> *) NULL, anchor);
                ASSERT_NE((int *) NULL, anchor->first);
                ASSERT_EQ(9, *anchor->first);

                ASSERT_EQ(1, (int) predicate.getPage());

                predicate.setPage(4);

                values = intMap.keySet(predicate);
                ASSERT_EQ(predSize, (int) values.size());

                for (int i = 0; i < predSize; ++i) {
                    ASSERT_EQ(predSize * 4 + i, values[i]);
                }

                anchor = predicate.getAnchor();
                ASSERT_NE((const std::pair<int *, int *> *) NULL, anchor);
                ASSERT_NE((int *) NULL, anchor->first);
                ASSERT_EQ(24, *anchor->first);

                const std::pair<size_t, std::pair<int *, int *> > *anchorEntry = predicate.getNearestAnchorEntry();
                ASSERT_NE((const std::pair<size_t, std::pair<int *, int *> > *) NULL, anchorEntry);
                ASSERT_NE((int *) NULL, anchorEntry->second.first);
                ASSERT_EQ(3, (int) anchorEntry->first);
                ASSERT_EQ(19, *anchorEntry->second.first);

                predicate.nextPage();
                values = intMap.keySet(predicate);
                ASSERT_EQ(0, (int) values.size());

                predicate.setPage(0);
                values = intMap.keySet(predicate);
                ASSERT_EQ(predSize, (int) values.size());
                for (int i = 0; i < predSize; ++i) {
                    ASSERT_EQ(i, values[i]);
                }

                predicate.previousPage();
                ASSERT_EQ(0, (int) predicate.getPage());

                predicate.setPage(5);
                values = intMap.keySet(predicate);
                ASSERT_EQ(0, (int) values.size());

                predicate.setPage(3);
                values = intMap.keySet(predicate);
                ASSERT_EQ(predSize, (int) values.size());
                for (int i = 0; i < predSize; ++i) {
                    ASSERT_EQ(3 * predSize + i, values[i]);
                }

                predicate.previousPage();
                values = intMap.keySet(predicate);
                ASSERT_EQ(predSize, (int) values.size());
                for (int i = 0; i < predSize; ++i) {
                    ASSERT_EQ(2 * predSize + i, values[i]);
                }

// test PagingPredicate with inner predicate (value < 10)
                std::unique_ptr<query::Predicate> lessThanTenPredicate(std::unique_ptr<query::Predicate>(
                        new query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 9, false,
                                                             true)));
                query::PagingPredicate<int, int> predicate2(lessThanTenPredicate, 5);
                values = intMap.keySet(predicate2);
                ASSERT_EQ(predSize, (int) values.size());
                for (int i = 0; i < predSize; ++i) {
                    ASSERT_EQ(i, values[i]);
                }

                predicate2.nextPage();
// match values 5,6, 7, 8
                values = intMap.keySet(predicate2);
                ASSERT_EQ(predSize - 1, (int) values.size());
                for (int i = 0; i < predSize - 1; ++i) {
                    ASSERT_EQ(predSize + i, values[i]);
                }

                predicate2.nextPage();
                values = intMap.keySet(predicate2);
                ASSERT_EQ(0, (int) values.size());

// test paging predicate with comparator
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);
                Employee empl3("deniz", 25);
                Employee empl4("ali", 33);
                Employee empl5("veli", 44);
                Employee empl6("aylin", 5);

                employees.put(3, empl1);
                employees.put(4, empl2);
                employees.put(5, empl3);
                employees.put(6, empl4);
                employees.put(7, empl5);
                employees.put(8, empl6);

                predSize = 2;
                query::PagingPredicate<int, Employee> predicate3(
                        std::unique_ptr<query::EntryComparator<int, Employee> >(new EmployeeEntryKeyComparator()),
                        (size_t) predSize);
                std::vector<int> result = employees.keySet(predicate3);
// since keyset result only returns keys from the server, no ordering based on the value but ordered based on the keys
                ASSERT_EQ(2, (int) result.size());
                ASSERT_EQ(3, result[0]);
                ASSERT_EQ(4, result[1]);

                predicate3.nextPage();
                result = employees.keySet(predicate3);
                ASSERT_EQ(2, (int) result.size());
                ASSERT_EQ(5, result[0]);
                ASSERT_EQ(6, result[1]);
            }

            TEST_P(ClientMapTest, testEntrySetWithPredicate) {
                const int numItems = 20;
                std::vector<std::pair<int, int> > expected(numItems);
                for (int i = 0; i < numItems; ++i) {
                    intMap.put(i, 2 * i);
                    expected[i] = std::pair<int, int>(i, 2 * i);
                }

                std::vector<std::pair<int, int> > entries = intMap.entrySet();
                ASSERT_EQ(numItems, (int) entries.size());
                std::sort(entries.begin(), entries.end());
                for (int i = 0; i < numItems; ++i) {
                    ASSERT_EQ(expected[i], entries[i]);
                }

// EqualPredicate
// key == 5
                entries = intMap.entrySet(
                        query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5));
                ASSERT_EQ(1, (int) entries.size());
                ASSERT_EQ(expected[5], entries[0]);

// value == 8
                entries = intMap.entrySet(
                        query::EqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 8));
                ASSERT_EQ(1, (int) entries.size());
                ASSERT_EQ(expected[4], entries[0]);

// key == numItems
                entries = intMap.entrySet(
                        query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), numItems));
                ASSERT_EQ(0, (int) entries.size());

// NotEqual Predicate
// key != 5
                entries = intMap.entrySet(
                        query::NotEqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5));
                ASSERT_EQ(numItems - 1, (int) entries.size());
                std::sort(entries.begin(), entries.end());
                for (int i = 0; i < numItems - 1; ++i) {
                    if (i >= 5) {
                        ASSERT_EQ(expected[i + 1], entries[i]);
                    } else {
                        ASSERT_EQ(expected[i], entries[i]);
                    }
                }

// value != 8
                entries = intMap.entrySet(
                        query::NotEqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 8));
                ASSERT_EQ(numItems - 1, (int) entries.size());
                std::sort(entries.begin(), entries.end());
                for (int i = 0; i < numItems - 1; ++i) {
                    if (i >= 4) {
                        ASSERT_EQ(expected[i + 1], entries[i]);
                    } else {
                        ASSERT_EQ(expected[i], entries[i]);
                    }
                }

// TruePredicate
                entries = intMap.entrySet(query::TruePredicate());
                ASSERT_EQ(numItems, (int) entries.size());
                std::sort(entries.begin(), entries.end());
                for (int i = 0; i < numItems; ++i) {
                    ASSERT_EQ(expected[i], entries[i]);
                }

// FalsePredicate
                entries = intMap.entrySet(query::FalsePredicate());
                ASSERT_EQ(0, (int) entries.size());

// BetweenPredicate
// 5 <= key <= 10
                entries = intMap.entrySet(
                        query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                std::sort(entries.begin(), entries.end());
                ASSERT_EQ(6, (int) entries.size());
                for (int i = 0; i < 6; ++i) {
                    ASSERT_EQ(expected[i + 5], entries[i]);
                }

// 20 <= key <=30
                entries = intMap.entrySet(
                        query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 20, 30));
                ASSERT_EQ(0, (int) entries.size());

// GreaterLessPredicate
// value <= 10
                entries = intMap.entrySet(
                        query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 10, true,
                                                         true));
                ASSERT_EQ(6, (int) entries.size());
                std::sort(entries.begin(), entries.end());
                for (int i = 0; i < 6; ++i) {
                    ASSERT_EQ(expected[i], entries[i]);
                }

// key < 7
                entries = intMap.entrySet(
                        query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 7, false, true));
                ASSERT_EQ(7, (int) entries.size());
                std::sort(entries.begin(), entries.end());
                for (int i = 0; i < 7; ++i) {
                    ASSERT_EQ(expected[i], entries[i]);
                }

// value >= 15
                entries = intMap.entrySet(
                        query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 15, true,
                                                         false));
                ASSERT_EQ(12, (int) entries.size());
                std::sort(entries.begin(), entries.end());
                for (int i = 0; i < 12; ++i) {
                    ASSERT_EQ(expected[i + 8], entries[i]);
                }

// key > 5
                entries = intMap.entrySet(
                        query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, false,
                                                         false));
                ASSERT_EQ(14, (int) entries.size());
                std::sort(entries.begin(), entries.end());
                for (int i = 0; i < 14; ++i) {
                    ASSERT_EQ(expected[i + 6], entries[i]);
                }

// InPredicate
// key in {4, 10, 19}
                std::vector<int> inVals(3);
                inVals[0] = 4;
                inVals[1] = 10;
                inVals[2] = 19;
                entries = intMap.entrySet(
                        query::InPredicate<int>(query::QueryConstants::getKeyAttributeName(), inVals));
                ASSERT_EQ(3, (int) entries.size());
                std::sort(entries.begin(), entries.end());
                ASSERT_EQ(expected[4], entries[0]);
                ASSERT_EQ(expected[10], entries[1]);
                ASSERT_EQ(expected[19], entries[2]);

// value in {4, 10, 19}
                entries = intMap.entrySet(
                        query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                ASSERT_EQ(2, (int) entries.size());
                std::sort(entries.begin(), entries.end());
                ASSERT_EQ(expected[2], entries[0]);
                ASSERT_EQ(expected[5], entries[1]);

// InstanceOfPredicate
// value instanceof Integer
                entries = intMap.entrySet(query::InstanceOfPredicate("java.lang.Integer"));
                ASSERT_EQ(20, (int) entries.size());
                std::sort(entries.begin(), entries.end());
                for (int i = 0; i < numItems; ++i) {
                    ASSERT_EQ(expected[i], entries[i]);
                }

                entries = intMap.entrySet(query::InstanceOfPredicate("java.lang.String"));
                ASSERT_EQ(0, (int) entries.size());

// NotPredicate
// !(5 <= key <= 10)
                std::unique_ptr<query::Predicate> bp = std::unique_ptr<query::Predicate>(
                        new query::BetweenPredicate<int>(
                                query::QueryConstants::getKeyAttributeName(), 5, 10));
                query::NotPredicate notPredicate(bp);
                entries = intMap.entrySet(notPredicate);
                ASSERT_EQ(14, (int) entries.size());
                std::sort(entries.begin(), entries.end());
                for (int i = 0; i < 14; ++i) {
                    if (i >= 5) {
                        ASSERT_EQ(expected[i + 6], entries[i]);
                    } else {
                        ASSERT_EQ(expected[i], entries[i]);
                    }
                }

// AndPredicate
// 5 <= key <= 10 AND Values in {4, 10, 19} = entries {4, 10}
                bp = std::unique_ptr<query::Predicate>(
                        new query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                std::unique_ptr<query::Predicate> inPred = std::unique_ptr<query::Predicate>(
                        new query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                entries = intMap.entrySet(query::AndPredicate().add(bp).add(inPred));
                ASSERT_EQ(1, (int) entries.size());
                std::sort(entries.begin(), entries.end());
                ASSERT_EQ(expected[5], entries[0]);

// OrPredicate
// 5 <= key <= 10 OR Values in {4, 10, 19} = entries {2, 5, 6, 7, 8, 9, 10}
                bp = std::unique_ptr<query::Predicate>(
                        new query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                inPred = std::unique_ptr<query::Predicate>(
                        new query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                entries = intMap.entrySet(query::OrPredicate().add(bp).add(inPred));
                ASSERT_EQ(7, (int) entries.size());
                std::sort(entries.begin(), entries.end());
                ASSERT_EQ(expected[2], entries[0]);
                ASSERT_EQ(expected[5], entries[1]);
                ASSERT_EQ(expected[6], entries[2]);
                ASSERT_EQ(expected[7], entries[3]);
                ASSERT_EQ(expected[8], entries[4]);
                ASSERT_EQ(expected[9], entries[5]);
                ASSERT_EQ(expected[10], entries[6]);

                std::vector<std::pair<std::string, std::string> > expectedStrEntries(14);
                for (int i = 0; i < 12; i++) {
                    std::string key = "key";
                    key += hazelcast::util::IOUtil::to_string(i);
                    std::string value = "value";
                    value += hazelcast::util::IOUtil::to_string(i);
                    imap.put(key, value);
                    expectedStrEntries[i] = std::pair<std::string, std::string>(key, value);
                }
                imap.put("key_111_test", "myvalue_111_test");
                expectedStrEntries[12] = std::pair<std::string, std::string>("key_111_test", "myvalue_111_test");
                imap.put("key_22_test", "myvalue_22_test");
                expectedStrEntries[13] = std::pair<std::string, std::string>("key_22_test", "myvalue_22_test");

// LikePredicate
// value LIKE "value1" : {"value1"}
                std::vector<std::pair<std::string, std::string> > strEntries = imap.entrySet(
                        query::LikePredicate(query::QueryConstants::getValueAttributeName(), "value1"));
                ASSERT_EQ(1, (int) strEntries.size());
                ASSERT_EQ(expectedStrEntries[1], strEntries[0]);

// ILikePredicate
// value ILIKE "%VALue%1%" : {"key_111_test", "key1", "key10", "key11"}
                strEntries = imap.entrySet(
                        query::ILikePredicate(query::QueryConstants::getValueAttributeName(), "%VALue%1%"));
                ASSERT_EQ(4, (int) strEntries.size());
                std::sort(strEntries.begin(), strEntries.end());
                ASSERT_EQ(expectedStrEntries[1], strEntries[0]);
                ASSERT_EQ(expectedStrEntries[10], strEntries[1]);
                ASSERT_EQ(expectedStrEntries[11], strEntries[2]);
                ASSERT_EQ(expectedStrEntries[12], strEntries[3]);

// key ILIKE "%VAL%2%" : {"key_22_test", "key2"}
                strEntries = imap.entrySet(
                        query::ILikePredicate(query::QueryConstants::getValueAttributeName(), "%VAL%2%"));
                ASSERT_EQ(2, (int) strEntries.size());
                std::sort(strEntries.begin(), strEntries.end());
                ASSERT_EQ(expectedStrEntries[2], strEntries[0]);
                ASSERT_EQ(expectedStrEntries[13], strEntries[1]);

// SqlPredicate
// __key BETWEEN 4 and 7 : {4, 5, 6, 7} -> {8, 10, 12, 14}
                char sql[100];
                hazelcast::util::hz_snprintf(sql, 50, "%s BETWEEN 4 and 7",
                                             query::QueryConstants::getKeyAttributeName());
                entries = intMap.entrySet(query::SqlPredicate(sql));
                ASSERT_EQ(4, (int) entries.size());
                std::sort(entries.begin(), entries.end());
                for (int i = 0; i < 4; ++i) {
                    ASSERT_EQ(expected[i + 4], entries[i]);
                }

// RegexPredicate
// value matches the regex ".*value.*2.*" : {key_22_test, value2}
                strEntries = imap.entrySet(
                        query::RegexPredicate(query::QueryConstants::getValueAttributeName(), ".*value.*2.*"));
                ASSERT_EQ(2, (int) strEntries.size());
                std::sort(strEntries.begin(), strEntries.end());
                ASSERT_EQ(expectedStrEntries[2], strEntries[0]);
                ASSERT_EQ(expectedStrEntries[13], strEntries[1]);
            }

            TEST_P(ClientMapTest, testEntrySetWithPagingPredicate) {
                int predSize = 5;
                const int totalEntries = 25;

                for (int i = 0; i < totalEntries; ++i) {
                    intMap.put(i, i);
                }

                query::PagingPredicate<int, int> predicate((size_t) predSize);

                std::vector<std::pair<int, int> > values = intMap.entrySet(predicate);
                ASSERT_EQ(predSize, (int) values.size());
                for (int i = 0; i < predSize; ++i) {
                    std::pair<int, int> value(i, i);
                    ASSERT_EQ(value, values[i]);
                }

                values = intMap.entrySet(predicate);
                ASSERT_EQ(predSize, (int) values.size());
                for (int i = 0; i < predSize; ++i) {
                    std::pair<int, int> value(i, i);
                    ASSERT_EQ(value, values[i]);
                }

                predicate.nextPage();
                values = intMap.entrySet(predicate);
                ASSERT_EQ(predSize, (int) values.size());

                for (int i = 0; i < predSize; ++i) {
                    std::pair<int, int> value(predSize + i, predSize + i);
                    ASSERT_EQ(value, values[i]);
                }

                const std::pair<int *, int *> *anchor = predicate.getAnchor();
                ASSERT_NE((const std::pair<int *, int *> *) NULL, anchor);
                ASSERT_NE((int *) NULL, anchor->first);
                ASSERT_NE((int *) NULL, anchor->second);
                ASSERT_EQ(9, *anchor->first);
                ASSERT_EQ(9, *anchor->second);

                ASSERT_EQ(1, (int) predicate.getPage());

                predicate.setPage(4);

                values = intMap.entrySet(predicate);
                ASSERT_EQ(predSize, (int) values.size());
                for (int i = 0; i < predSize; ++i) {
                    std::pair<int, int> value(predSize * 4 + i, predSize * 4 + i);
                    ASSERT_EQ(value, values[i]);
                }

                anchor = predicate.getAnchor();
                ASSERT_NE((const std::pair<int *, int *> *) NULL, anchor);
                ASSERT_NE((int *) NULL, anchor->first);
                ASSERT_NE((int *) NULL, anchor->second);
                ASSERT_EQ(24, *anchor->first);
                ASSERT_EQ(24, *anchor->second);

                const std::pair<size_t, std::pair<int *, int *> > *anchorEntry = predicate.getNearestAnchorEntry();
                ASSERT_NE((const std::pair<size_t, std::pair<int *, int *> > *) NULL, anchorEntry);
                ASSERT_NE((int *) NULL, anchorEntry->second.first);
                ASSERT_NE((int *) NULL, anchorEntry->second.second);
                ASSERT_EQ(3, (int) anchorEntry->first);
                ASSERT_EQ(19, *anchorEntry->second.first);
                ASSERT_EQ(19, *anchorEntry->second.second);

                predicate.nextPage();
                values = intMap.entrySet(predicate);
                ASSERT_EQ(0, (int) values.size());

                predicate.setPage(0);
                values = intMap.entrySet(predicate);
                ASSERT_EQ(predSize, (int) values.size());
                for (int i = 0; i < predSize; ++i) {
                    std::pair<int, int> value(i, i);
                    ASSERT_EQ(value, values[i]);
                }

                predicate.previousPage();
                ASSERT_EQ(0, (int) predicate.getPage());

                predicate.setPage(5);
                values = intMap.entrySet(predicate);
                ASSERT_EQ(0, (int) values.size());

                predicate.setPage(3);
                values = intMap.entrySet(predicate);
                ASSERT_EQ(predSize, (int) values.size());
                for (int i = 0; i < predSize; ++i) {
                    std::pair<int, int> value(3 * predSize + i, 3 * predSize + i);
                    ASSERT_EQ(value, values[i]);
                }

                predicate.previousPage();
                values = intMap.entrySet(predicate);
                ASSERT_EQ(predSize, (int) values.size());
                for (int i = 0; i < predSize; ++i) {
                    std::pair<int, int> value(2 * predSize + i, 2 * predSize + i);
                    ASSERT_EQ(value, values[i]);
                }

// test PagingPredicate with inner predicate (value < 10)
                std::unique_ptr<query::Predicate> lessThanTenPredicate(std::unique_ptr<query::Predicate>(
                        new query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 9, false,
                                                             true)));
                query::PagingPredicate<int, int> predicate2(lessThanTenPredicate, 5);
                values = intMap.entrySet(predicate2);
                ASSERT_EQ(predSize, (int) values.size());
                for (int i = 0; i < predSize; ++i) {
                    std::pair<int, int> value(i, i);
                    ASSERT_EQ(value, values[i]);
                }

                predicate2.nextPage();
// match values 5,6, 7, 8
                values = intMap.entrySet(predicate2);
                ASSERT_EQ(predSize - 1, (int) values.size());
                for (int i = 0; i < predSize - 1; ++i) {
                    std::pair<int, int> value(predSize + i, predSize + i);
                    ASSERT_EQ(value, values[i]);
                }

                predicate2.nextPage();
                values = intMap.entrySet(predicate2);
                ASSERT_EQ(0, (int) values.size());

// test paging predicate with comparator
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);
                Employee empl3("deniz", 25);
                Employee empl4("ali", 33);
                Employee empl5("veli", 44);
                Employee empl6("aylin", 5);

                employees.put(3, empl1);
                employees.put(4, empl2);
                employees.put(5, empl3);
                employees.put(6, empl4);
                employees.put(7, empl5);
                employees.put(8, empl6);

                predSize = 2;
                query::PagingPredicate<int, Employee> predicate3(
                        std::unique_ptr<query::EntryComparator<int, Employee> >(new EmployeeEntryComparator()),
                        (size_t) predSize);
                std::vector<std::pair<int, Employee> > result = employees.entrySet(
                        predicate3);
                ASSERT_EQ(2, (int) result.size());
                std::pair<int, Employee> value(8, empl6);
                ASSERT_EQ(value, result[0]);
                value = std::pair<int, Employee>(4, empl2);
                ASSERT_EQ(value, result[1]);

                predicate3.nextPage();
                result = employees.entrySet(predicate3);
                ASSERT_EQ(2, (int) result.size());
                value = std::pair<int, Employee>(5, empl3);
                ASSERT_EQ(value, result[0]);
                value = std::pair<int, Employee>(6, empl4);
                ASSERT_EQ(value, result[1]);
            }

            TEST_P(ClientMapTest, testReplace) {
                std::shared_ptr<std::string> temp = imap.replace("key1", "value");
                ASSERT_EQ(temp.get(), (std::string *) NULL);

                std::string tempKey = "key1";
                std::string tempValue = "value1";
                imap.put(tempKey, tempValue);

                ASSERT_EQ("value1", *(imap.replace("key1", "value2")));
                ASSERT_EQ("value2", *(imap.get("key1")));

                ASSERT_FALSE(imap.replace("key1", "value1", "value3"));
                ASSERT_EQ("value2", *(imap.get("key1")));

                ASSERT_TRUE(imap.replace("key1", "value2", "value3"));
                ASSERT_EQ("value3", *(imap.get("key1")));
            }

            TEST_P(ClientMapTest, testListenerWithPortableKey) {
                IMap<Employee, int> tradeMap = client.getMap<Employee, int>("tradeMap");
                hazelcast::util::CountDownLatch countDownLatch(1);
                hazelcast::util::AtomicInt atomicInteger(0);
                SampleEntryListenerForPortableKey listener(countDownLatch,
                                                           atomicInteger);
                Employee key("a", 1);
                std::string id = tradeMap.addEntryListener(listener, key, true);
                Employee key2("a", 2);
                tradeMap.put(key2, 1);
                tradeMap.put(key, 3);
                ASSERT_OPEN_EVENTUALLY(countDownLatch);
                ASSERT_EQ(1, (int) atomicInteger);

                ASSERT_TRUE(tradeMap.removeEntryListener(id));
            }

            TEST_P(ClientMapTest, testListener) {
                hazelcast::util::CountDownLatch latch1Add(5);
                hazelcast::util::CountDownLatch latch1Remove(2);
                hazelcast::util::CountDownLatch dummy(10);
                hazelcast::util::CountDownLatch latch2Add(1);
                hazelcast::util::CountDownLatch latch2Remove(1);

                CountdownListener<std::string, std::string> listener1(
                        latch1Add, latch1Remove, dummy, dummy);
                CountdownListener<std::string, std::string> listener2(
                        latch2Add, latch2Remove, dummy, dummy);

                std::string listener1ID = imap.addEntryListener(listener1, false);
                std::string listener2ID = imap.addEntryListener(listener2, "key3", true);

                hazelcast::util::sleep(2);

                imap.put("key1", "value1");
                imap.put("key2", "value2");
                imap.put("key3", "value3");
                imap.put("key4", "value4");
                imap.put("key5", "value5");

                imap.remove("key1");
                imap.remove("key3");

                ASSERT_TRUE(latch1Add.await(10));
                ASSERT_TRUE(latch1Remove.await(10));
                ASSERT_TRUE(latch2Add.await(5));
                ASSERT_TRUE(latch2Remove.await(5));

                ASSERT_TRUE(imap.removeEntryListener(listener1ID));
                ASSERT_TRUE(imap.removeEntryListener(listener2ID));

            }

            TEST_P(ClientMapTest, testListenerWithTruePredicate) {
                hazelcast::util::CountDownLatch latchAdd(3);
                hazelcast::util::CountDownLatch latchRemove(1);
                hazelcast::util::CountDownLatch latchEvict(1);
                hazelcast::util::CountDownLatch latchUpdate(1);

                CountdownListener<int, int> listener(latchAdd, latchRemove,
                                                     latchUpdate,
                                                     latchEvict);

                std::string listenerId = intMap.addEntryListener(listener,
                                                                 query::TruePredicate(),
                                                                 false);

                intMap.put(1, 1);
                intMap.put(2, 2);
                intMap.put(3, 3, 1000); // evict after 1 second
                intMap.remove(2);

                hazelcast::util::sleep(2);

                ASSERT_EQ(NULL, intMap.get(3).get()); // trigger eviction

// update an entry
                intMap.set(1, 5);
                std::shared_ptr<int> value = intMap.get(1);
                ASSERT_NE((int *) NULL, value.get());
                ASSERT_EQ(5, *value);

                hazelcast::util::CountDownLatchWaiter latches;
                latches.add(latchAdd).add(latchRemove).add(latchUpdate).add(latchEvict);
                ASSERT_TRUE(latches.awaitMillis(2000));

                ASSERT_TRUE(intMap.removeEntryListener(listenerId));
            }

            TEST_P(ClientMapTest, testListenerWithFalsePredicate) {
                hazelcast::util::CountDownLatch latchAdd(3);
                hazelcast::util::CountDownLatch latchRemove(1);
                hazelcast::util::CountDownLatch latchEvict(1);
                hazelcast::util::CountDownLatch latchUpdate(1);

                CountdownListener<int, int> listener(latchAdd, latchRemove,
                                                     latchUpdate,
                                                     latchEvict);

                std::string listenerId = intMap.addEntryListener(listener,
                                                                 query::FalsePredicate(),
                                                                 false);

                intMap.put(1, 1);
                intMap.put(2, 2);
                intMap.put(3, 3, 1000); // evict after 1 second
                intMap.remove(2);

                hazelcast::util::sleep(2);

                ASSERT_EQ(NULL, intMap.get(3).get()); // trigger eviction

// update an entry
                intMap.set(1, 5);
                std::shared_ptr<int> value = intMap.get(1);
                ASSERT_NE((int *) NULL, value.get());
                ASSERT_EQ(5, *value);

                hazelcast::util::CountDownLatchWaiter latches;
                latches.add(latchAdd).add(latchRemove).add(latchUpdate).add(latchEvict);
                ASSERT_FALSE(latches.awaitMillis(2000));

                ASSERT_TRUE(intMap.removeEntryListener(listenerId));
            }

            TEST_P(ClientMapTest, testListenerWithEqualPredicate) {
                hazelcast::util::CountDownLatch latchAdd(1);
                hazelcast::util::CountDownLatch latchRemove(1);
                hazelcast::util::CountDownLatch latchEvict(1);
                hazelcast::util::CountDownLatch latchUpdate(1);

                CountdownListener<int, int> listener(latchAdd, latchRemove,
                                                     latchUpdate,
                                                     latchEvict);

                std::string listenerId = intMap.addEntryListener(listener,
                                                                 query::EqualPredicate<int>(
                                                                         query::QueryConstants::getKeyAttributeName(),
                                                                         3), true);

                intMap.put(1, 1);
                intMap.put(2, 2);
                intMap.put(3, 3, 1000); // evict after 1 second
                intMap.remove(2);

                hazelcast::util::sleep(2);

                ASSERT_EQ(NULL, intMap.get(3).get()); // trigger eviction

// update an entry
                intMap.set(1, 5);
                std::shared_ptr<int> value = intMap.get(1);
                ASSERT_NE((int *) NULL, value.get());
                ASSERT_EQ(5, *value);

                hazelcast::util::CountDownLatchWaiter latches;
                latches.add(latchAdd).add(latchEvict);
                ASSERT_TRUE(latches.awaitMillis(2000));

                latches.reset();
                latches.add(latchUpdate).add(latchRemove);
                ASSERT_FALSE(latches.awaitMillis(2000));

                ASSERT_TRUE(intMap.removeEntryListener(listenerId));
            }

            TEST_P(ClientMapTest, testListenerWithNotEqualPredicate) {
                hazelcast::util::CountDownLatch latchAdd(2);
                hazelcast::util::CountDownLatch latchRemove(1);
                hazelcast::util::CountDownLatch latchEvict(1);
                hazelcast::util::CountDownLatch latchUpdate(1);

                CountdownListener<int, int> listener(latchAdd, latchRemove,
                                                     latchUpdate,
                                                     latchEvict);

                std::string listenerId = intMap.addEntryListener(listener,
                                                                 query::NotEqualPredicate<int>(
                                                                         query::QueryConstants::getKeyAttributeName(),
                                                                         3), true);

                intMap.put(1, 1);
                intMap.put(2, 2);
                intMap.put(3, 3, 1000); // evict after 1 second
                intMap.remove(2);

                hazelcast::util::sleep(2);

                ASSERT_EQ(NULL, intMap.get(3).get()); // trigger eviction

// update an entry
                intMap.set(1, 5);
                std::shared_ptr<int> value = intMap.get(1);
                ASSERT_NE((int *) NULL, value.get());
                ASSERT_EQ(5, *value);

                hazelcast::util::CountDownLatchWaiter latches;
                latches.add(latchAdd).add(latchRemove).add(latchUpdate);
                ASSERT_TRUE(latches.awaitMillis(2000));

                latches.reset();
                latches.add(latchEvict);
                ASSERT_FALSE(latches.awaitMillis(2000));

                ASSERT_TRUE(intMap.removeEntryListener(listenerId));
            }

            TEST_P(ClientMapTest, testListenerWithGreaterLessPredicate) {
                hazelcast::util::CountDownLatch latchAdd(2);
                hazelcast::util::CountDownLatch latchRemove(1);
                hazelcast::util::CountDownLatch latchEvict(1);
                hazelcast::util::CountDownLatch latchUpdate(1);

                CountdownListener<int, int> listener(latchAdd, latchRemove,
                                                     latchUpdate,
                                                     latchEvict);

// key <= 2
                std::string listenerId = intMap.addEntryListener(listener,
                                                                 query::GreaterLessPredicate<int>(
                                                                         query::QueryConstants::getKeyAttributeName(),
                                                                         2, true, true),
                                                                 false);

                intMap.put(1, 1);
                intMap.put(2, 2);
                intMap.put(3, 3, 1000); // evict after 1 second
                intMap.remove(2);

                hazelcast::util::sleep(2);

                ASSERT_EQ(NULL, intMap.get(3).get()); // trigger eviction

// update an entry
                intMap.set(1, 5);
                std::shared_ptr<int> value = intMap.get(1);
                ASSERT_NE((int *) NULL, value.get());
                ASSERT_EQ(5, *value);

                hazelcast::util::CountDownLatchWaiter latches;
                latches.add(latchAdd).add(latchRemove).add(latchUpdate);
                ASSERT_TRUE(latches.awaitMillis(2000));

                ASSERT_FALSE(latchEvict.awaitMillis(2000));

                ASSERT_TRUE(intMap.removeEntryListener(listenerId));
            }

            TEST_P(ClientMapTest, testListenerWithBetweenPredicate) {
                hazelcast::util::CountDownLatch latchAdd(2);
                hazelcast::util::CountDownLatch latchRemove(1);
                hazelcast::util::CountDownLatch latchEvict(1);
                hazelcast::util::CountDownLatch latchUpdate(1);

                CountdownListener<int, int> listener(latchAdd, latchRemove,
                                                     latchUpdate,
                                                     latchEvict);

// 1 <=key <= 2
                std::string listenerId = intMap.addEntryListener(listener,
                                                                 query::BetweenPredicate<int>(
                                                                         query::QueryConstants::getKeyAttributeName(),
                                                                         1, 2), true);

                intMap.put(1, 1);
                intMap.put(2, 2);
                intMap.put(3, 3, 1000); // evict after 1 second
                intMap.remove(2);

                hazelcast::util::sleep(2);

                ASSERT_EQ(NULL, intMap.get(3).get()); // trigger eviction

// update an entry
                intMap.set(1, 5);
                std::shared_ptr<int> value = intMap.get(1);
                ASSERT_NE((int *) NULL, value.get());
                ASSERT_EQ(5, *value);

                hazelcast::util::CountDownLatchWaiter latches;
                latches.add(latchAdd).add(latchRemove).add(latchUpdate);
                ASSERT_TRUE(latches.awaitMillis(2000));

                ASSERT_FALSE(latchEvict.awaitMillis(2000));

                ASSERT_TRUE(intMap.removeEntryListener(listenerId));
            }

            TEST_P(ClientMapTest, testListenerWithSqlPredicate) {
                hazelcast::util::CountDownLatch latchAdd(1);
                hazelcast::util::CountDownLatch latchRemove(1);
                hazelcast::util::CountDownLatch latchEvict(1);
                hazelcast::util::CountDownLatch latchUpdate(1);

                CountdownListener<int, int> listener(latchAdd, latchRemove,
                                                     latchUpdate,
                                                     latchEvict);

// 1 <=key <= 2
                std::string listenerId = intMap.addEntryListener(listener,
                                                                 query::SqlPredicate(
                                                                         "__key < 2"), true);

                intMap.put(1, 1);
                intMap.put(2, 2);
                intMap.put(3, 3, 1000); // evict after 1 second
                intMap.remove(2);

                hazelcast::util::sleep(2);

                ASSERT_EQ(NULL, intMap.get(3).get()); // trigger eviction

// update an entry
                intMap.set(1, 5);
                std::shared_ptr<int> value = intMap.get(1);
                ASSERT_NE((int *) NULL, value.get());
                ASSERT_EQ(5, *value);

                hazelcast::util::CountDownLatchWaiter latches;
                latches.add(latchAdd).add(latchUpdate);
                ASSERT_TRUE(latches.awaitMillis(2000));

                latches.reset();
                latches.add(latchRemove).add(latchEvict);
                ASSERT_FALSE(latches.awaitMillis(2000));

                ASSERT_TRUE(intMap.removeEntryListener(listenerId));
            }

            TEST_P(ClientMapTest, testListenerWithRegExPredicate) {
                hazelcast::util::CountDownLatch latchAdd(2);
                hazelcast::util::CountDownLatch latchRemove(1);
                hazelcast::util::CountDownLatch latchEvict(1);
                hazelcast::util::CountDownLatch latchUpdate(1);

                CountdownListener<std::string, std::string> listener(
                        latchAdd, latchRemove, latchUpdate, latchEvict);

// key matches any word containing ".*met.*"
                std::string listenerId = imap.addEntryListener(listener,
                                                               query::RegexPredicate(
                                                                       query::QueryConstants::getKeyAttributeName(),
                                                                       ".*met.*"), true);

                imap.put("ilkay", "yasar");
                imap.put("mehmet", "demir");
                imap.put("metin", "ozen", 1000); // evict after 1 second
                imap.put("hasan", "can");
                imap.remove("mehmet");

                hazelcast::util::sleep(2);

                ASSERT_EQ((std::string *) NULL, imap.get("metin").get()); // trigger eviction

// update an entry
                imap.set("hasan", "suphi");
                std::shared_ptr<std::string> value = imap.get("hasan");
                ASSERT_NE((std::string *) NULL, value.get());
                ASSERT_EQ("suphi", *value);

                hazelcast::util::CountDownLatchWaiter latches;
                latches.add(latchAdd).add(latchRemove).add(latchEvict);
                ASSERT_TRUE(latches.awaitMillis(2000));

                ASSERT_FALSE(latchUpdate.awaitMillis(2000));

                ASSERT_TRUE(imap.removeEntryListener(listenerId));
            }

            TEST_P(ClientMapTest, testListenerWithInstanceOfPredicate) {
                hazelcast::util::CountDownLatch latchAdd(3);
                hazelcast::util::CountDownLatch latchRemove(1);
                hazelcast::util::CountDownLatch latchEvict(1);
                hazelcast::util::CountDownLatch latchUpdate(1);

                CountdownListener<int, int> listener(latchAdd, latchRemove,
                                                     latchUpdate,
                                                     latchEvict);

// 1 <=key <= 2
                std::string listenerId = intMap.addEntryListener(listener,
                                                                 query::InstanceOfPredicate(
                                                                         "java.lang.Integer"),
                                                                 false);

                intMap.put(1, 1);
                intMap.put(2, 2);
                intMap.put(3, 3, 1000); // evict after 1 second
                intMap.remove(2);

                hazelcast::util::sleep(2);

                ASSERT_EQ(NULL, intMap.get(3).get()); // trigger eviction

// update an entry
                intMap.set(1, 5);
                std::shared_ptr<int> value = intMap.get(1);
                ASSERT_NE((int *) NULL, value.get());
                ASSERT_EQ(5, *value);

                hazelcast::util::CountDownLatchWaiter latches;
                latches.add(latchAdd).add(latchRemove).add(latchUpdate).add(latchEvict);
                ASSERT_TRUE(latches.awaitMillis(2000));

                ASSERT_TRUE(intMap.removeEntryListener(listenerId));
            }

            TEST_P(ClientMapTest, testListenerWithNotPredicate) {
                hazelcast::util::CountDownLatch latchAdd(2);
                hazelcast::util::CountDownLatch latchRemove(1);
                hazelcast::util::CountDownLatch latchEvict(1);
                hazelcast::util::CountDownLatch latchUpdate(1);

                CountdownListener<int, int> listener(latchAdd, latchRemove,
                                                     latchUpdate,
                                                     latchEvict);

// key >= 3
                std::unique_ptr<query::Predicate> greaterLessPred = std::unique_ptr<query::Predicate>(
                        new query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 3, true,
                                                             false));
                query::NotPredicate notPredicate(greaterLessPred);
                std::string listenerId = intMap.addEntryListener(listener, notPredicate,
                                                                 false);

                intMap.put(1, 1);
                intMap.put(2, 2);
                intMap.put(3, 3, 1000); // evict after 1 second
                intMap.remove(2);

                hazelcast::util::sleep(2);

                ASSERT_EQ(NULL, intMap.get(3).get()); // trigger eviction

// update an entry
                intMap.set(1, 5);
                std::shared_ptr<int> value = intMap.get(1);
                ASSERT_NE((int *) NULL, value.get());
                ASSERT_EQ(5, *value);

                hazelcast::util::CountDownLatchWaiter latches;
                latches.add(latchAdd).add(latchRemove).add(latchUpdate);
                ASSERT_TRUE(latches.awaitMillis(2000));

                latches.reset();
                latches.add(latchEvict);
                ASSERT_FALSE(latches.awaitMillis(1000));

                ASSERT_TRUE(intMap.removeEntryListener(listenerId));
            }

            TEST_P(ClientMapTest, testListenerWithAndPredicate) {
                hazelcast::util::CountDownLatch latchAdd(1);
                hazelcast::util::CountDownLatch latchRemove(1);
                hazelcast::util::CountDownLatch latchEvict(1);
                hazelcast::util::CountDownLatch latchUpdate(1);

                CountdownListener<int, int> listener(latchAdd, latchRemove,
                                                     latchUpdate,
                                                     latchEvict);

// key < 3
                std::unique_ptr<query::Predicate> greaterLessPred = std::unique_ptr<query::Predicate>(
                        new query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 3, false,
                                                             true));
// value == 1
                std::unique_ptr<query::Predicate> equalPred = std::unique_ptr<query::Predicate>(
                        new query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 1));
                query::AndPredicate predicate;
// key < 3 AND key == 1 --> (1, 1)
                predicate.add(greaterLessPred).add(equalPred);
                std::string listenerId = intMap.addEntryListener(listener, predicate, false);

                intMap.put(1, 1);
                intMap.put(2, 2);
                intMap.put(3, 3, 1000); // evict after 1 second
                intMap.remove(2);

                hazelcast::util::sleep(2);

                ASSERT_EQ(NULL, intMap.get(3).get()); // trigger eviction

// update an entry
                intMap.set(1, 5);
                std::shared_ptr<int> value = intMap.get(1);
                ASSERT_NE((int *) NULL, value.get());
                ASSERT_EQ(5, *value);

                hazelcast::util::CountDownLatchWaiter latches;
                latches.add(latchAdd).add(latchUpdate);
                ASSERT_TRUE(latches.awaitMillis(2000));

                latches.reset();
                latches.add(latchEvict).add(latchRemove);
                ASSERT_FALSE(latches.awaitMillis(1000));

                ASSERT_TRUE(intMap.removeEntryListener(listenerId));
            }

            TEST_P(ClientMapTest, testListenerWithOrPredicate) {
                hazelcast::util::CountDownLatch latchAdd(2);
                hazelcast::util::CountDownLatch latchRemove(1);
                hazelcast::util::CountDownLatch latchEvict(1);
                hazelcast::util::CountDownLatch latchUpdate(1);

                CountdownListener<int, int> listener(latchAdd, latchRemove,
                                                     latchUpdate,
                                                     latchEvict);

// key >= 3
                std::unique_ptr<query::Predicate> greaterLessPred = std::unique_ptr<query::Predicate>(
                        new query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 3, true,
                                                             false));
// value == 1
                std::unique_ptr<query::Predicate> equalPred = std::unique_ptr<query::Predicate>(
                        new query::EqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 2));
                query::OrPredicate predicate;
// key >= 3 OR value == 2 --> (1, 1), (2, 2)
                predicate.add(greaterLessPred).add(equalPred);
                std::string listenerId = intMap.addEntryListener(listener, predicate, true);

                intMap.put(1, 1);
                intMap.put(2, 2);
                intMap.put(3, 3, 1000); // evict after 1 second
                intMap.remove(2);

                hazelcast::util::sleep(2);

                ASSERT_EQ(NULL, intMap.get(3).get()); // trigger eviction

// update an entry
                intMap.set(1, 5);
                std::shared_ptr<int> value = intMap.get(1);
                ASSERT_NE((int *) NULL, value.get());
                ASSERT_EQ(5, *value);

                hazelcast::util::CountDownLatchWaiter latches;
                latches.add(latchAdd).add(latchEvict).add(latchRemove);
                ASSERT_TRUE(latches.awaitMillis(2000));

                ASSERT_FALSE(latchUpdate.awaitMillis(2000));

                ASSERT_TRUE(intMap.removeEntryListener(listenerId));
            }

            TEST_P(ClientMapTest, testClearEvent) {
                hazelcast::util::CountDownLatch latch(1);
                ClearListener clearListener(latch);
                std::string listenerId = imap.addEntryListener(clearListener, false);
                imap.put("key1", "value1");
                imap.clear();
                ASSERT_TRUE(latch.await(120));
                imap.removeEntryListener(listenerId);
            }

            TEST_P(ClientMapTest, testEvictAllEvent) {
                hazelcast::util::CountDownLatch latch(1);
                EvictListener evictListener(latch);
                std::string listenerId = imap.addEntryListener(evictListener, false);
                imap.put("key1", "value1");
                imap.evictAll();
                ASSERT_TRUE(latch.await(120));
                imap.removeEntryListener(listenerId);
            }

            TEST_P(ClientMapTest, testMapWithPortable) {
                std::shared_ptr<Employee> n1 = employees.get(1);
                ASSERT_EQ(n1.get(), (Employee *) NULL);
                Employee employee("sancar", 24);
                std::shared_ptr<Employee> ptr = employees.put(1, employee);
                ASSERT_EQ(ptr.get(), (Employee *) NULL);
                ASSERT_FALSE(employees.isEmpty());
                EntryView<int, Employee> view = employees.getEntryView(1);
                ASSERT_EQ(view.value, employee);
                ASSERT_EQ(view.key, 1);

                employees.addIndex("a", true);
                employees.addIndex("n", false);
            }

            TEST_P(ClientMapTest, testMapStoreRelatedRequests) {
                imap.putTransient("ali", "veli", 1100);
                imap.flush();
                ASSERT_EQ(1, imap.size());
                ASSERT_FALSE(imap.evict("deli"));
                ASSERT_TRUE(imap.evict("ali"));
                ASSERT_EQ(imap.get("ali").get(), (std::string *) NULL);
            }

            TEST_P(ClientMapTest, testExecuteOnKey) {
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);

                employees.put(3, empl1);
                employees.put(4, empl2);

                EntryMultiplier processor(4);

                std::shared_ptr<int> result = employees.executeOnKey<int, EntryMultiplier>(
                        4, processor);

                ASSERT_NE((int *) NULL, result.get());
                ASSERT_EQ(4 * processor.getMultiplier(), *result);
            }

            TEST_P(ClientMapTest, testSubmitToKey) {
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);

                employees.put(3, empl1);
                employees.put(4, empl2);

                EntryMultiplier processor(4);

                hazelcast::client::Future<int> future =
                        employees.submitToKey<int, EntryMultiplier>(
                                4, processor);

                future_status status = future.wait_for(2 * 1000);
                ASSERT_EQ(future_status::ready, status);
                std::unique_ptr<int> result = future.get();
                ASSERT_NE((int *) NULL, result.get());
                ASSERT_EQ(4 * processor.getMultiplier(), *result);
            }

            TEST_P(ClientMapTest, testExecuteOnNonExistentKey) {
                EntryMultiplier processor(4);

                std::shared_ptr<int> result = employees.executeOnKey<int, EntryMultiplier>(
                        17, processor);

                ASSERT_NE((int *) NULL, result.get());
                ASSERT_EQ(-1, *result);
            }

            TEST_P(ClientMapTest, testExecuteOnKeys) {
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);
                Employee empl3("deniz", 25);

                employees.put(3, empl1);
                employees.put(4, empl2);
                employees.put(5, empl3);

                EntryMultiplier processor(4);

                std::set<int> keys;
                keys.insert(3);
                keys.insert(5);
// put non existent key
                keys.insert(999);

                std::map<int, std::shared_ptr<int> > result = employees.executeOnKeys<int, EntryMultiplier>(
                        keys, processor);

                ASSERT_EQ(3, (int) result.size());
                ASSERT_NE(result.end(), result.find(3));
                ASSERT_NE(result.end(), result.find(5));
                ASSERT_NE(result.end(), result.find(999));
                ASSERT_EQ(3 * processor.getMultiplier(), *result[3]);
                ASSERT_EQ(5 * processor.getMultiplier(), *result[5]);
                ASSERT_EQ(-1, *result[999]);
            }

            TEST_P(ClientMapTest, testExecuteOnEntries) {
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);
                Employee empl3("deniz", 25);

                employees.put(3, empl1);
                employees.put(4, empl2);
                employees.put(5, empl3);

                EntryMultiplier processor(4);

                std::map<int, std::shared_ptr<int> > result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor);

                ASSERT_EQ(3, (int) result.size());
                ASSERT_TRUE((result.end() != result.find(3)));
                ASSERT_TRUE((result.end() != result.find(4)));
                ASSERT_TRUE((result.end() != result.find(5)));
                ASSERT_EQ(3 * processor.getMultiplier(), *result[3]);
                ASSERT_EQ(4 * processor.getMultiplier(), *result[4]);
                ASSERT_EQ(5 * processor.getMultiplier(), *result[5]);
            }

            TEST_P(ClientMapTest, testExecuteOnEntriesWithTruePredicate) {
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);
                Employee empl3("deniz", 25);

                employees.put(3, empl1);
                employees.put(4, empl2);
                employees.put(5, empl3);

                EntryMultiplier processor(4);

                std::map<int, std::shared_ptr<int> > result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, query::TruePredicate());

                ASSERT_EQ(3, (int) result.size());
                ASSERT_TRUE((result.end() != result.find(3)));
                ASSERT_TRUE((result.end() != result.find(4)));
                ASSERT_TRUE((result.end() != result.find(5)));
                ASSERT_EQ(3 * processor.getMultiplier(), *result[3]);
                ASSERT_EQ(4 * processor.getMultiplier(), *result[4]);
                ASSERT_EQ(5 * processor.getMultiplier(), *result[5]);
            }

            TEST_P(ClientMapTest, testExecuteOnEntriesWithFalsePredicate) {
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);
                Employee empl3("deniz", 25);

                employees.put(3, empl1);
                employees.put(4, empl2);
                employees.put(5, empl3);

                EntryMultiplier processor(4);

                std::map<int, std::shared_ptr<int> > result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, query::FalsePredicate());

                ASSERT_EQ(0, (int) result.size());
            }

            TEST_P(ClientMapTest, testExecuteOnEntriesWithAndPredicate) {
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);
                Employee empl3("deniz", 25);

                employees.put(3, empl1);
                employees.put(4, empl2);
                employees.put(5, empl3);

                query::AndPredicate andPredicate;
/* 25 <= age <= 35 AND age = 35 */
                andPredicate.add(
                        std::unique_ptr<query::Predicate>(new query::BetweenPredicate<int>("a", 25, 35))).add(
                        std::unique_ptr<query::Predicate>(
                                new query::NotPredicate(
                                        std::unique_ptr<query::Predicate>(new query::EqualPredicate<int>("a", 35)))));

                EntryMultiplier processor(4);

                std::map<int, std::shared_ptr<int> > result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, andPredicate);

                ASSERT_EQ(1, (int) result.size());
                ASSERT_TRUE((result.end() != result.find(5)));
                ASSERT_EQ(5 * processor.getMultiplier(), *result[5]);
            }

            TEST_P(ClientMapTest, testExecuteOnEntriesWithOrPredicate) {
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);
                Employee empl3("deniz", 25);

                employees.put(3, empl1);
                employees.put(4, empl2);
                employees.put(5, empl3);

                query::OrPredicate orPredicate;
/* age == 21 OR age > 25 */
                orPredicate.add(
                        std::unique_ptr<query::Predicate>(new query::EqualPredicate<int>("a", 21))).add(
                        std::unique_ptr<query::Predicate>(new query::GreaterLessPredicate<int>("a", 25, false, false)));

                EntryMultiplier processor(4);

                std::map<int, std::shared_ptr<int> > result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, orPredicate);

                ASSERT_EQ(2, (int) result.size());
                ASSERT_TRUE((result.end() != result.find(3)));
                ASSERT_TRUE((result.end() != result.find(4)));
                ASSERT_EQ(3 * processor.getMultiplier(), *result[3]);
                ASSERT_EQ(4 * processor.getMultiplier(), *result[4]);
            }

            TEST_P(ClientMapTest, testExecuteOnEntriesWithBetweenPredicate) {
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);
                Employee empl3("deniz", 25);

                employees.put(3, empl1);
                employees.put(4, empl2);
                employees.put(5, empl3);

                EntryMultiplier processor(4);

                std::map<int, std::shared_ptr<int> > result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, query::BetweenPredicate<int>("a", 25, 35));

                ASSERT_EQ(2, (int) result.size());
                ASSERT_TRUE((result.end() != result.find(3)));
                ASSERT_TRUE((result.end() != result.find(5)));
                ASSERT_EQ(3 * processor.getMultiplier(), *result[3]);
                ASSERT_EQ(5 * processor.getMultiplier(), *result[5]);
            }

            TEST_P(ClientMapTest, testExecuteOnEntriesWithEqualPredicate) {
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);
                Employee empl3("deniz", 25);

                employees.put(3, empl1);
                employees.put(4, empl2);
                employees.put(5, empl3);

                EntryMultiplier processor(4);

                std::map<int, std::shared_ptr<int> > result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, query::EqualPredicate<int>("a", 25));

                ASSERT_EQ(1, (int) result.size());
                ASSERT_TRUE((result.end() != result.find(5)));

                result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, query::EqualPredicate<int>("a", 10));

                ASSERT_EQ(0, (int) result.size());
            }

            TEST_P(ClientMapTest, testExecuteOnEntriesWithNotEqualPredicate) {
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);
                Employee empl3("deniz", 25);

                employees.put(3, empl1);
                employees.put(4, empl2);
                employees.put(5, empl3);

                EntryMultiplier processor(4);

                std::map<int, std::shared_ptr<int> > result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, query::NotEqualPredicate<int>("a", 25));

                ASSERT_EQ(2, (int) result.size());
                ASSERT_TRUE((result.end() != result.find(3)));
                ASSERT_TRUE((result.end() != result.find(4)));
            }

            TEST_P(ClientMapTest, testExecuteOnEntriesWithGreaterLessPredicate) {
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);
                Employee empl3("deniz", 25);

                employees.put(3, empl1);
                employees.put(4, empl2);
                employees.put(5, empl3);

                EntryMultiplier processor(4);

                std::map<int, std::shared_ptr<int> > result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, query::GreaterLessPredicate<int>("a", 25, false, true)); // <25 matching

                ASSERT_EQ(1, (int) result.size());
                ASSERT_TRUE((result.end() != result.find(4)));

                result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, query::GreaterLessPredicate<int>("a", 25, true, true)); // <=25 matching

                ASSERT_EQ(2, (int) result.size());
                ASSERT_TRUE((result.end() != result.find(4)));
                ASSERT_TRUE((result.end() != result.find(5)));

                result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, query::GreaterLessPredicate<int>("a", 25, false, false)); // >25 matching

                ASSERT_EQ(1, (int) result.size());
                ASSERT_TRUE((result.end() != result.find(3)));

                result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, query::GreaterLessPredicate<int>("a", 25, true, false)); // >=25 matching

                ASSERT_EQ(2, (int) result.size());
                ASSERT_TRUE((result.end() != result.find(3)));
                ASSERT_TRUE((result.end() != result.find(5)));
            }

            TEST_P(ClientMapTest, testExecuteOnEntriesWithLikePredicate) {
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);
                Employee empl3("deniz", 25);

                employees.put(3, empl1);
                employees.put(4, empl2);
                employees.put(5, empl3);

                EntryMultiplier processor(4);

                std::map<int, std::shared_ptr<int> > result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, query::LikePredicate("n", "deniz"));

                ASSERT_EQ(1, (int) result.size());
                ASSERT_TRUE((result.end() != result.find(5)));
            }

            TEST_P(ClientMapTest, testExecuteOnEntriesWithILikePredicate) {
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);
                Employee empl3("deniz", 25);

                employees.put(3, empl1);
                employees.put(4, empl2);
                employees.put(5, empl3);

                EntryMultiplier processor(4);

                std::map<int, std::shared_ptr<int> > result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, query::ILikePredicate("n", "deniz"));

                ASSERT_EQ(1, (int) result.size());
                ASSERT_TRUE((result.end() != result.find(5)));
            }

            TEST_P(ClientMapTest, testExecuteOnEntriesWithInPredicate) {
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);
                Employee empl3("deniz", 25);

                employees.put(3, empl1);
                employees.put(4, empl2);
                employees.put(5, empl3);

                EntryMultiplier processor(4);

                std::vector<std::string> values;
                values.push_back("ahmet");
                query::InPredicate<std::string> predicate("n", values);
                predicate.add("mehmet");
                std::map<int, std::shared_ptr<int> > result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, predicate);

                ASSERT_EQ(2, (int) result.size());
                ASSERT_TRUE((result.end() != result.find(3)));
                ASSERT_TRUE((result.end() != result.find(4)));
            }

            TEST_P(ClientMapTest, testExecuteOnEntriesWithInstanceOfPredicate) {
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);
                Employee empl3("deniz", 25);

                employees.put(3, empl1);
                employees.put(4, empl2);
                employees.put(5, empl3);

                EntryMultiplier processor(4);
                std::map<int, std::shared_ptr<int> > result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, query::InstanceOfPredicate("com.hazelcast.client.test.Employee"));

                ASSERT_EQ(3, (int) result.size());
                ASSERT_TRUE((result.end() != result.find(3)));
                ASSERT_TRUE((result.end() != result.find(4)));
                ASSERT_TRUE((result.end() != result.find(5)));
            }

            TEST_P(ClientMapTest, testExecuteOnEntriesWithNotPredicate) {
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);
                Employee empl3("deniz", 25);

                employees.put(3, empl1);
                employees.put(4, empl2);
                employees.put(5, empl3);

                EntryMultiplier processor(4);
                std::unique_ptr<query::Predicate> eqPredicate(new query::EqualPredicate<int>("a", 25));
                query::NotPredicate notPredicate(eqPredicate);
                std::map<int, std::shared_ptr<int> > result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, notPredicate);

                ASSERT_EQ(2, (int) result.size());
                ASSERT_TRUE((result.end() != result.find(3)));
                ASSERT_TRUE((result.end() != result.find(4)));

                query::NotPredicate notFalsePredicate(std::unique_ptr<query::Predicate>(new query::FalsePredicate()));
                result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, notFalsePredicate);

                ASSERT_EQ(3, (int) result.size());
                ASSERT_TRUE((result.end() != result.find(3)));
                ASSERT_TRUE((result.end() != result.find(4)));
                ASSERT_TRUE((result.end() != result.find(5)));

                query::NotPredicate notBetweenPredicate(
                        std::unique_ptr<query::Predicate>(new query::BetweenPredicate<int>("a", 25, 35)));
                result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, notBetweenPredicate);

                ASSERT_EQ(1, (int) result.size());
                ASSERT_TRUE((result.end() != result.find(4)));
            }

            TEST_P(ClientMapTest, testExecuteOnEntriesWithRegexPredicate) {
                Employee empl1("ahmet", 35);
                Employee empl2("mehmet", 21);
                Employee empl3("deniz", 25);

                employees.put(3, empl1);
                employees.put(4, empl2);
                employees.put(5, empl3);

                EntryMultiplier processor(4);

                std::map<int, std::shared_ptr<int> > result = employees.executeOnEntries<int, EntryMultiplier>(
                        processor, query::RegexPredicate("n", ".*met"));

                ASSERT_EQ(2, (int) result.size());
                ASSERT_TRUE((result.end() != result.find(3)));
                ASSERT_TRUE((result.end() != result.find(4)));
            }

            TEST_P(ClientMapTest, testAddInterceptor) {
                std::string prefix("My Prefix");
                MapGetInterceptor interceptor(prefix);
                std::string interceptorId = imap.
                        addInterceptor<MapGetInterceptor>(interceptor);

                std::shared_ptr<std::string> val = imap.get("nonexistent");
                ASSERT_NE((std::string *) NULL, val.get());
                ASSERT_EQ(prefix, *val);

                val = imap.put("key1", "value1");
                ASSERT_EQ((std::string *) NULL, val.get());

                val = imap.get("key1");
                ASSERT_NE((std::string *) NULL, val.get());
                ASSERT_EQ(prefix + "value1", *val);

                imap.removeInterceptor(interceptorId);
            }

            TEST_P(ClientMapTest, testJsonPutGet) {
                IMap<string, HazelcastJsonValue> map = client.getMap<std::string, HazelcastJsonValue>(
                        getTestName());
                HazelcastJsonValue value("{ \"age\": 4 }");
                map.put("item1", value);
                std::shared_ptr<HazelcastJsonValue> retrieved = map.get("item1");

                ASSERT_EQ_PTR(value, retrieved.get(), HazelcastJsonValue);
            }

            TEST_P(ClientMapTest, testQueryOverJsonObject) {
                IMap<string, HazelcastJsonValue> map = client.getMap<std::string, HazelcastJsonValue>(
                        getTestName());
                HazelcastJsonValue young("{ \"age\": 4 }");
                HazelcastJsonValue old("{ \"age\": 20 }");
                map.put("item1", young);
                map.put("item2", old);

                ASSERT_EQ(2, map.size());

// Get the objects whose age is less than 6
                std::vector<HazelcastJsonValue> result = map.values(
                        query::GreaterLessPredicate<int>("age", 6, false, true));
                ASSERT_EQ(1U, result.size());
                ASSERT_EQ(young, result[0]);
            }

            TEST_P(ClientMapTest, testExtendedAsciiString) {
                std::string key = "Num\xc3\xa9ro key";
                std::string value = "Num\xc3\xa9ro value";
                imap.put(key, value);

                std::shared_ptr<std::string> actualValue = imap.get(key);

                ASSERT_EQ_PTR(value, actualValue.get(), std::string);
            }
        }
    }
}



using namespace hazelcast::client::mixedtype;

namespace hazelcast {
    namespace client {
        namespace test {
            namespace mixedmap {
                class MapClientConfig : public ClientConfig {
                public:
                    MapClientConfig() {
                    }

                    virtual ~MapClientConfig() {
                    }
                };

                class NearCachedDataMapClientConfig : public MapClientConfig {
                public:
                    NearCachedDataMapClientConfig() {
                        std::shared_ptr<mixedtype::config::MixedNearCacheConfig> nearCacheConfig(
                                new mixedtype::config::MixedNearCacheConfig("MixedMapTestMap"));
                        addMixedNearCacheConfig(nearCacheConfig);

                        addNearCacheConfig<std::string, std::string>(std::shared_ptr<config::NearCacheConfig<std::string, std::string> >(new config::NearCacheConfig<std::string, std::string>("OneSecondTtlMap")));
                    }

                };

                class MixedMapAPITest : public ClientTestSupport, public ::testing::WithParamInterface<MapClientConfig *> {
                public:
                    MixedMapAPITest() : clientConfig(GetParam()) {
#ifdef HZ_BUILD_WITH_SSL
                        config::SSLConfig sslConfig;
                        sslConfig.setEnabled(true).setProtocol(config::tlsv12).addVerifyFile(getCAFilePath());
                        clientConfig->getNetworkConfig().setSSLConfig(sslConfig);
#endif // HZ_BUILD_WITH_SSL

                        client.reset(new HazelcastClient(*clientConfig));

                        imap = new mixedtype::IMap(client->toMixedType().getMap("MixedMapTestMap"));
                    }

                    static void SetUpTestSuite() {
#ifdef HZ_BUILD_WITH_SSL
                        sslFactory = new HazelcastServerFactory(g_srvFactory->getServerAddress(), getSslFilePath());
                        instance = new HazelcastServer(*sslFactory);
                        instance2 = new HazelcastServer(*sslFactory);
#else
                        instance = new HazelcastServer(*g_srvFactory);
                        instance2 = new HazelcastServer(*g_srvFactory);
#endif
                    }

                    static void TearDownTestSuite() {
                        delete instance2;
                        delete instance;
                        delete sslFactory;

                        instance2 = NULL;
                        instance = NULL;
                    }

                protected:
                    virtual void TearDown() {
                        imap->destroy();
                        client->toMixedType().getMap("OneSecondTtlMap").destroy();
                    }

                    class MapGetInterceptor : public serialization::IdentifiedDataSerializable {
                    public:
                        MapGetInterceptor(const std::string &prefix) : prefix(
                                std::unique_ptr<std::string>(new std::string(prefix))) {}

                        virtual int getFactoryId() const {
                            return 666;
                        }

                        virtual int getClassId() const {
                            return 6;
                        }

                        virtual void writeData(serialization::ObjectDataOutput &writer) const {
                            writer.writeUTF(prefix.get());
                        }

                        virtual void readData(serialization::ObjectDataInput &reader) {
                            prefix = reader.readUTF();
                        }

                    private:
                        std::unique_ptr<std::string> prefix;
                    };

                    /**
                     * This processor validates that the string value for the entry is the same as the test string
                     * "xyz123    "
                     */
                    class UTFValueValidatorProcessor : public serialization::IdentifiedDataSerializable {
                    public:
                        virtual int getFactoryId() const {
                            return 666;
                        }

                        virtual int getClassId() const {
                            return 9;
                        }

                        virtual void writeData(serialization::ObjectDataOutput &writer) const {
                        }

                        virtual void readData(serialization::ObjectDataInput &reader) {
                        }
                    };

                    void fillMap() {
                        for (int i = 0; i < 10; i++) {
                            std::string key = "key";
                            key += hazelcast::util::IOUtil::to_string(i);
                            std::string value = "value";
                            value += hazelcast::util::IOUtil::to_string(i);
                            imap->put<std::string, std::string>(key, value);
                        }
                    }

                    static HazelcastServer *instance;
                    static HazelcastServer *instance2;
                    static HazelcastServerFactory *sslFactory;
                    MapClientConfig *clientConfig;
                    std::unique_ptr<HazelcastClient> client;
                    mixedtype::IMap *imap;
                };

                INSTANTIATE_TEST_SUITE_P(MixedMapAPITestInstance,
                                         MixedMapAPITest,
                                         ::testing::Values(new MapClientConfig(), new NearCachedDataMapClientConfig()));

                HazelcastServer *MixedMapAPITest::instance = NULL;
                HazelcastServer *MixedMapAPITest::instance2 = NULL;
                HazelcastServerFactory *MixedMapAPITest::sslFactory = NULL;

                void tryPutThread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    mixedtype::IMap *imap = (mixedtype::IMap *) args.arg1;
                    bool result = imap->tryPut<std::string, std::string>("key1", "value3", 1 * 1000);
                    if (!result) {
                        latch->countDown();
                    }
                }

                void tryRemoveThread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    mixedtype::IMap *imap = (mixedtype::IMap *) args.arg1;
                    bool result = imap->tryRemove<std::string>("key2", 1 * 1000);
                    if (!result) {
                        latch->countDown();
                    }
                }

                void testLockThread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    mixedtype::IMap *imap = (mixedtype::IMap *) args.arg1;
                    imap->tryPut<std::string, std::string>("key1", "value2", 1);
                    latch->countDown();
                }

                void testLockTTLThread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    mixedtype::IMap *imap = (mixedtype::IMap *) args.arg1;
                    imap->tryPut<std::string, std::string>("key1", "value2", 5 * 1000);
                    latch->countDown();
                }

                void testLockTTL2Thread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    mixedtype::IMap *imap = (mixedtype::IMap *) args.arg1;
                    if (!imap->tryLock<std::string>("key1")) {
                        latch->countDown();
                    }
                    if (imap->tryLock<std::string>("key1", 5 * 1000)) {
                        latch->countDown();
                    }
                }

                void testMapTryLockThread1(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    mixedtype::IMap *imap = (mixedtype::IMap *) args.arg1;
                    if (!imap->tryLock<std::string>("key1", 2)) {
                        latch->countDown();
                    }
                }

                void testMapTryLockThread2(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    mixedtype::IMap *imap = (mixedtype::IMap *) args.arg1;
                    if (imap->tryLock<std::string>("key1", 20 * 1000)) {
                        latch->countDown();
                    }
                }

                void testMapForceUnlockThread(hazelcast::util::ThreadArgs &args) {
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg0;
                    mixedtype::IMap *imap = (mixedtype::IMap *) args.arg1;
                    imap->forceUnlock<std::string>("key1");
                    latch->countDown();
                }

                class CountdownListener : public MixedEntryListener {
                public:
                    CountdownListener(hazelcast::util::CountDownLatch &addLatch, hazelcast::util::CountDownLatch &removeLatch,
                                      hazelcast::util::CountDownLatch &updateLatch, hazelcast::util::CountDownLatch &evictLatch)
                            : addLatch(addLatch), removeLatch(removeLatch), updateLatch(updateLatch),
                              evictLatch(evictLatch) {
                    }

                    virtual void entryAdded(const MixedEntryEvent &event) {
                        addLatch.countDown();
                    }

                    virtual void entryRemoved(const MixedEntryEvent &event) {
                        removeLatch.countDown();
                    }

                    virtual void entryUpdated(const MixedEntryEvent &event) {
                        updateLatch.countDown();
                    }

                    virtual void entryEvicted(const MixedEntryEvent &event) {
                        evictLatch.countDown();
                    }

                    virtual void entryExpired(const MixedEntryEvent &event) {
                    }

                    virtual void entryMerged(const MixedEntryEvent &event) {

                    }

                    virtual void mapEvicted(const MapEvent &event) {
                    }

                    virtual void mapCleared(const MapEvent &event) {
                    }

                private:
                    hazelcast::util::CountDownLatch &addLatch;
                    hazelcast::util::CountDownLatch &removeLatch;
                    hazelcast::util::CountDownLatch &updateLatch;
                    hazelcast::util::CountDownLatch &evictLatch;
                };

                class MyListener : public MixedEntryListener {
                public:
                    MyListener(hazelcast::util::CountDownLatch &latch, hazelcast::util::CountDownLatch &nullLatch)
                            : latch(latch), nullLatch(nullLatch) {
                    }

                    virtual void entryAdded(const MixedEntryEvent &event) {
                        latch.countDown();
                    }

                    virtual void entryRemoved(const MixedEntryEvent &event) {
                    }

                    virtual void entryUpdated(const MixedEntryEvent &event) {
                    }

                    virtual void entryEvicted(const MixedEntryEvent &event) {
                        std::unique_ptr<std::string> oldValue = event.getOldValue()->get<std::string>();
                        if (oldValue->compare("")) {
                            nullLatch.countDown();
                        }
                        latch.countDown();
                    }

                    virtual void entryExpired(const MixedEntryEvent &event) {

                    }

                    virtual void entryMerged(const MixedEntryEvent &event) {

                    }

                    virtual void mapEvicted(const MapEvent &event) {
                    }

                    virtual void mapCleared(const MapEvent &event) {

                    }

                private:
                    hazelcast::util::CountDownLatch &latch;
                    hazelcast::util::CountDownLatch &nullLatch;
                };

                class ClearListener : public MixedEntryListener {
                public:
                    ClearListener(hazelcast::util::CountDownLatch &latch) : latch(latch) {
                    }

                    virtual void entryAdded(const MixedEntryEvent &event) {
                    }

                    virtual void entryRemoved(const MixedEntryEvent &event) {
                    }

                    virtual void entryUpdated(const MixedEntryEvent &event) {
                    }

                    virtual void entryEvicted(const MixedEntryEvent &event) {
                    }

                    virtual void entryExpired(const MixedEntryEvent &event) {
                    }

                    virtual void entryMerged(const MixedEntryEvent &event) {
                    }

                    virtual void mapEvicted(const MapEvent &event) {
                    }

                    void mapCleared(const MapEvent &event) {
                        latch.countDown();
                    }

                private:
                    hazelcast::util::CountDownLatch &latch;
                };

                class EvictListener : public MixedEntryListener {
                public:
                    EvictListener(hazelcast::util::CountDownLatch &latch) : latch(latch) {
                    }

                    virtual void entryAdded(const MixedEntryEvent &event) {
                    }

                    virtual void entryRemoved(const MixedEntryEvent &event) {
                    }

                    virtual void entryUpdated(const MixedEntryEvent &event) {
                    }

                    virtual void entryEvicted(const MixedEntryEvent &event) {
                    }

                    virtual void entryExpired(const MixedEntryEvent &event) {
                    }

                    virtual void entryMerged(const MixedEntryEvent &event) {
                    }

                    virtual void mapCleared(const MapEvent &event) {
                    }

                    virtual void mapEvicted(const MapEvent &event) {
                        latch.countDown();
                    }

                private:
                    hazelcast::util::CountDownLatch &latch;
                };

                class SampleEntryListenerForPortableKey : public MixedEntryListener {
                public:
                    SampleEntryListenerForPortableKey(hazelcast::util::CountDownLatch &latch, hazelcast::util::AtomicInt &atomicInteger)
                            : latch(latch), atomicInteger(atomicInteger) {

                    }

                    virtual void entryAdded(const MixedEntryEvent &event) {
                        ++atomicInteger;
                        latch.countDown();
                    }

                    virtual void entryRemoved(const MixedEntryEvent &event) {
                    }

                    virtual void entryUpdated(const MixedEntryEvent &event) {
                    }

                    virtual void entryEvicted(const MixedEntryEvent &event) {
                    }

                    virtual void entryExpired(const MixedEntryEvent &event) {
                    }

                    virtual void entryMerged(const MixedEntryEvent &event) {
                    }

                    virtual void mapEvicted(const MapEvent &event) {
                    }

                    virtual void mapCleared(const MapEvent &event) {
                    }

                private:
                    hazelcast::util::CountDownLatch &latch;
                    hazelcast::util::AtomicInt &atomicInteger;
                };

                class EntryMultiplier : public serialization::IdentifiedDataSerializable {
                public:
                    EntryMultiplier(int multiplier) : multiplier(multiplier) { }

                    /**
                     * @return factory id
                     */
                    virtual int getFactoryId() const {
                        return 666;
                    }

                    /**
                     * @return class id
                     */
                    virtual int getClassId() const {
                        return 3;
                    }

                    /**
                     * Defines how this class will be written.
                     * @param writer ObjectDataOutput
                     */
                    void writeData(serialization::ObjectDataOutput &writer) const {
                        writer.writeInt(multiplier);
                    }

                    /**
                     *Defines how this class will be read.
                     * @param reader ObjectDataInput
                     */
                    void readData(serialization::ObjectDataInput &reader) {
                        multiplier = reader.readInt();
                    }

                    int getMultiplier() const {
                        return multiplier;
                    }

                private:
                    int multiplier;
                };


                class WaitMultiplierProcessor : public serialization::IdentifiedDataSerializable {
                public:
                    WaitMultiplierProcessor(int waitTime, int multiplier)
                            : waiTimeInMillis(waitTime), multiplier(multiplier) { }

                    /**
                     * @return factory id
                     */
                    int getFactoryId() const {
                        return 666;
                    }

                    /**
                     * @return class id
                     */
                    int getClassId() const {
                        return 8;
                    }

                    /**
                     * Defines how this class will be written.
                     * @param writer ObjectDataOutput
                     */
                    void writeData(serialization::ObjectDataOutput &writer) const {
                        writer.writeInt(waiTimeInMillis);
                        writer.writeInt(multiplier);
                    }

                    /**
                     *Defines how this class will be read.
                     * @param reader ObjectDataInput
                     */
                    void readData(serialization::ObjectDataInput &reader) {
                        waiTimeInMillis = reader.readInt();
                        multiplier = reader.readInt();
                    }

                    int getMultiplier() const {
                        return multiplier;
                    }

                private:
                    int waiTimeInMillis;
                    int multiplier;
                };

                class EntryMultiplierWithNullableResult : public EntryMultiplier {
                public:
                    EntryMultiplierWithNullableResult(int multiplier) : EntryMultiplier(multiplier) { }

                    virtual int getFactoryId() const {
                        return 666;
                    }

                    virtual int getClassId() const {
                        return 7;
                    }
                };

                TEST_P(MixedMapAPITest, testIssue537) {
                    hazelcast::util::CountDownLatch latch(2);
                    hazelcast::util::CountDownLatch nullLatch(1);
                    MyListener myListener(latch, nullLatch);
                    std::string id = imap->addEntryListener(myListener, true);

                    imap->put<std::string, std::string>("key1", "value1", 2 * 1000);

                    ASSERT_TRUE(latch.await(10));
                    ASSERT_TRUE(nullLatch.await(1));

                    ASSERT_TRUE(imap->removeEntryListener(id));

                    imap->put<std::string, std::string>("key2", "value2");
                    ASSERT_EQ(1, imap->size());
                }

                TEST_P(MixedMapAPITest, testContains) {
                    fillMap();

                    ASSERT_FALSE(imap->containsKey<std::string>("key10"));
                    ASSERT_TRUE(imap->containsKey<std::string>("key1"));

                    ASSERT_FALSE(imap->containsValue<std::string>("value10"));
                    ASSERT_TRUE(imap->containsValue<std::string>("value1"));

                }

                TEST_P(MixedMapAPITest, testGet) {
                    fillMap();
                    for (int i = 0; i < 10; i++) {
                        std::string key = "key";
                        key += hazelcast::util::IOUtil::to_string(i);
                        std::unique_ptr<std::string> temp = imap->get<std::string>(key).get<std::string>();

                        std::string value = "value";
                        value += hazelcast::util::IOUtil::to_string(i);
                        ASSERT_EQ(*temp, value);
                    }
                }

                TEST_P(MixedMapAPITest, testRemoveAndDelete) {
                    fillMap();
                    std::unique_ptr<std::string> temp = imap->remove<std::string>("key10").get<std::string>();
                    ASSERT_EQ(temp.get(), (std::string *) NULL);
                    imap->deleteEntry<std::string>("key9");
                    ASSERT_EQ(imap->size(), 9);
                    for (int i = 0; i < 9; i++) {
                        std::string key = "key";
                        key += hazelcast::util::IOUtil::to_string(i);
                        std::unique_ptr<std::string> temp2 = imap->remove<std::string>(key).get<std::string>();
                        std::string value = "value";
                        value += hazelcast::util::IOUtil::to_string(i);
                        ASSERT_EQ(*temp2, value);
                    }
                    ASSERT_EQ(imap->size(), 0);
                }

                TEST_P(MixedMapAPITest, testRemoveIfSame) {
                    fillMap();

                    ASSERT_FALSE((imap->remove<std::string, std::string>("key2", "value")));
                    ASSERT_EQ(10, imap->size());

                    ASSERT_TRUE((imap->remove<std::string, std::string>("key2", "value2")));
                    ASSERT_EQ(9, imap->size());

                }

                TEST_P(MixedMapAPITest, testRemoveAll) {
                    fillMap();

                    imap->removeAll(
                            query::EqualPredicate<std::string>(query::QueryConstants::getKeyAttributeName(), "key5"));

                    std::unique_ptr<std::string> value = imap->get<std::string>("key5").get<std::string>();

                    ASSERT_NULL("key5 should not exist", value.get(), std::string);

                    query::LikePredicate likeAllValues(query::QueryConstants::getValueAttributeName(), "value%");

                    imap->removeAll(likeAllValues);

                    ASSERT_TRUE(imap->isEmpty());
                }


/**
                 * This failure with this test is reported at https://github.com/hazelcast/hazelcast-cpp-client/issues/379
                 * Do not forget to enable this test once the issue is resolved!!!
                 */
                TEST_P(MixedMapAPITest, DISABLED_testGetAllPutAll) {
                    std::map<std::string, std::string> mapTemp;

                    for (int i = 0; i < 100; i++) {
                        mapTemp[hazelcast::util::IOUtil::to_string(i)] = hazelcast::util::IOUtil::to_string(i);
                    }
                    imap->putAll<std::string, std::string>(mapTemp);
                    ASSERT_EQ(imap->size(), 100);

                    for (int i = 0; i < 100; i++) {
                        std::string expected = hazelcast::util::IOUtil::to_string(i);
                        std::unique_ptr<std::string> actual = imap->get<std::string>(
                                hazelcast::util::IOUtil::to_string(i)).get<std::string>();
                        ASSERT_EQ(expected, *actual);
                    }

                    std::set<std::string> tempSet;
                    tempSet.insert(hazelcast::util::IOUtil::to_string(1));
                    tempSet.insert(hazelcast::util::IOUtil::to_string(3));

                    std::vector<std::pair<TypedData, TypedData> > m2 = imap->getAll<std::string>(tempSet);

                    ASSERT_EQ(2U, m2.size());
                    std::unique_ptr<std::string> key1 = m2[0].first.get<std::string>();
                    ASSERT_NE((std::string *) NULL, key1.get());
                    std::unique_ptr<std::string> value1 = m2[0].second.get<std::string>();
                    ASSERT_NE((std::string *) NULL, value1.get());
                    ASSERT_EQ(*key1, *value1);
                    ASSERT_TRUE(*key1 == "1" || *key1 == "3");

                    const std::pair<TypedData, TypedData> &entry = m2[1];
                    ASSERT_NE((std::string *) NULL, entry.first.get<std::string>().get());
                    ASSERT_NE((std::string *) NULL, entry.second.get<std::string>().get());
                    ASSERT_EQ(*entry.first.get<std::string>(), *entry.second.get<std::string>());
                    ASSERT_TRUE(*entry.first.get<std::string>() == "1" || *entry.first.get<std::string>() == "3");
                    ASSERT_NE(*key1, *entry.first.get<std::string>());
                }

                TEST_P(MixedMapAPITest, testTryPutRemove) {
                    ASSERT_TRUE((imap->tryPut<std::string, std::string>("key1", "value1", 1 * 1000)));
                    ASSERT_TRUE((imap->tryPut<std::string, std::string>("key2", "value2", 1 * 1000)));
                    imap->lock<std::string>("key1");
                    imap->lock<std::string>("key2");

                    hazelcast::util::CountDownLatch latch(2);

                    hazelcast::util::StartedThread t1(tryPutThread, &latch, imap);
                    hazelcast::util::StartedThread t2(tryRemoveThread, &latch, imap);

                    ASSERT_TRUE(latch.await(20));
                    ASSERT_EQ("value1", *(imap->get<std::string>("key1").get<std::string>()));
                    ASSERT_EQ("value2", *(imap->get<std::string>("key2").get<std::string>()));
                    imap->forceUnlock<std::string>("key1");
                    imap->forceUnlock<std::string>("key2");
                }

                TEST_P(MixedMapAPITest, testGetEntryViewForNonExistentData) {
                    std::unique_ptr<EntryView<TypedData, TypedData> > view = imap->getEntryView<std::string>(
                            "non-existent");

                    ASSERT_EQ((EntryView<TypedData, TypedData> *) NULL, view.get());

// put an entry that will expire in 1 milliseconds
                    imap->put<std::string, std::string>("short_entry", "short living value", 1);

                    ASSERT_EQ_EVENTUALLY((EntryView<TypedData, TypedData> *) NULL,
                                         (imap->getEntryView<std::string>("short_entry").get()));
                }

                TEST_P(MixedMapAPITest, testPutTtl) {
                    mixedtype::IMap &map = *imap;

                    hazelcast::util::CountDownLatch dummy(10);
                    hazelcast::util::CountDownLatch evict(1);
                    CountdownListener sampleEntryListener(dummy, dummy, dummy, evict);
                    std::string id = map.addEntryListener(sampleEntryListener, false);

                    monitor::impl::NearCacheStatsImpl *nearCacheStatsImpl = (monitor::impl::NearCacheStatsImpl *) map.getLocalMapStats().getNearCacheStats();

                    int64_t initialInvalidationRequests = 0;
                    if (nearCacheStatsImpl) {
                        initialInvalidationRequests = nearCacheStatsImpl->getInvalidationRequests();
                    }

// put will cause an invalidation event sent from the server to the client
                    map.put<std::string, std::string>("key1", "value1", 1000);

// if near cache is enabled
                    if (nearCacheStatsImpl) {
                        ASSERT_EQ_EVENTUALLY(initialInvalidationRequests + 1,
                                             nearCacheStatsImpl->getInvalidationRequests());

// populate near cache
                        map.get<std::string>("key1");

// When ttl expires at server, the server does not send near cache invalidation.
                        ASSERT_TRUE_ALL_THE_TIME((map.get<std::string>("key1").get<std::string>().get() &&
                                                  nearCacheStatsImpl->getInvalidationRequests() ==
                                                  initialInvalidationRequests + 1), 2);
                    } else {
// trigger eviction
                        ASSERT_NULL_EVENTUALLY(map.get<std::string>("key1").get<std::string>().get(), std::string);
                    }

                    ASSERT_TRUE(evict.await(5));

                    ASSERT_TRUE(imap->removeEntryListener(id));
                }

                TEST_P(MixedMapAPITest, testPutConfigTtl) {
                    mixedtype::IMap map = client->toMixedType().getMap("OneSecondTtlMap");
                    hazelcast::util::CountDownLatch dummy(10);
                    hazelcast::util::CountDownLatch evict(1);
                    CountdownListener sampleEntryListener(dummy, dummy, dummy, evict);
                    std::string id = map.addEntryListener(sampleEntryListener, false);

                    monitor::impl::NearCacheStatsImpl *nearCacheStatsImpl = (monitor::impl::NearCacheStatsImpl *) map.getLocalMapStats().getNearCacheStats();

                    int64_t initialInvalidationRequests = 0;
                    if (nearCacheStatsImpl) {
                        initialInvalidationRequests = nearCacheStatsImpl->getInvalidationRequests();
                    }

// put will cause an invalidation event sent from the server to the client
                    map.put<std::string, std::string>("key1", "value1");

// if near cache is enabled
                    if (nearCacheStatsImpl) {
                        ASSERT_EQ_EVENTUALLY(initialInvalidationRequests + 1,
                                             nearCacheStatsImpl->getInvalidationRequests());

// populate near cache
                        map.get<std::string>("key1");

// When ttl expires at server, the server does not send near cache invalidation.
                        ASSERT_TRUE_ALL_THE_TIME((map.get<std::string>("key1").get<std::string>().get() &&
                                                  nearCacheStatsImpl->getInvalidationRequests() ==
                                                  initialInvalidationRequests + 1), 2);
                    } else {
// trigger eviction
                        ASSERT_NULL_EVENTUALLY(map.get<std::string>("key1").get<std::string>().get(), std::string);
                    }

                    ASSERT_TRUE(evict.await(5));

                    ASSERT_TRUE(map.removeEntryListener(id));
                }

                TEST_P(MixedMapAPITest, testPutIfAbsent) {
                    std::unique_ptr<std::string> o = imap->putIfAbsent<std::string, std::string>("key1",
                                                                                                 "value1").get<std::string>();
                    ASSERT_EQ(o.get(), (std::string *) NULL);
                    ASSERT_EQ("value1",
                              *(imap->putIfAbsent<std::string, std::string>("key1", "value3").get<std::string>()));
                }

                TEST_P(MixedMapAPITest, testPutIfAbsentTtl) {
                    ASSERT_EQ((std::string *) NULL, (imap->putIfAbsent<std::string, std::string>("key1", "value1",
                                                                                                 1000).get<std::string>().get()));
                    ASSERT_EQ("value1", *(imap->putIfAbsent<std::string, std::string>("key1", "value3",
                                                                                      1000).get<std::string>()));

                    ASSERT_NULL_EVENTUALLY((imap->putIfAbsent<std::string, std::string>("key1", "value3",
                                                                                        1000).get<std::string>().get()),
                                           std::string);
                    ASSERT_EQ("value3", *(imap->putIfAbsent<std::string, std::string>("key1", "value4",
                                                                                      1000).get<std::string>()));
                }

                TEST_P(MixedMapAPITest, testSet) {
                    imap->IMap::set<std::string, std::string>("key1", "value1");
                    ASSERT_EQ("value1", *(imap->get<std::string>("key1").get<std::string>()));

                    imap->IMap::set<std::string, std::string>("key1", "value2");
                    ASSERT_EQ("value2", *(imap->get<std::string>("key1").get<std::string>()));
                }

                TEST_P(MixedMapAPITest, testSetTtl) {
                    mixedtype::IMap &map = *imap;

                    hazelcast::util::CountDownLatch dummy(10);
                    hazelcast::util::CountDownLatch evict(1);
                    CountdownListener sampleEntryListener(dummy, dummy, dummy, evict);
                    std::string id = map.addEntryListener(sampleEntryListener, false);

                    monitor::impl::NearCacheStatsImpl *nearCacheStatsImpl = (monitor::impl::NearCacheStatsImpl *) map.getLocalMapStats().getNearCacheStats();

                    int64_t initialInvalidationRequests = 0;
                    if (nearCacheStatsImpl) {
                        initialInvalidationRequests = nearCacheStatsImpl->getInvalidationRequests();
                    }

// set will cause an invalidation event sent from the server to the client
                    map.IMap::set<std::string, std::string>("key1", "value1", 1000);

// if near cache is enabled
                    if (nearCacheStatsImpl) {
                        ASSERT_EQ_EVENTUALLY(initialInvalidationRequests + 1,
                                             nearCacheStatsImpl->getInvalidationRequests());

// populate near cache
                        map.get<std::string>("key1");

// When ttl expires at server, the server does not send near cache invalidation.
                        ASSERT_TRUE_ALL_THE_TIME((map.get<std::string>("key1").get<std::string>().get() &&
                                                  nearCacheStatsImpl->getInvalidationRequests() ==
                                                  initialInvalidationRequests + 1), 2);
                    } else {
// trigger eviction
                        ASSERT_NULL_EVENTUALLY(map.get<std::string>("key1").get<std::string>().get(), std::string);
                    }

                    ASSERT_TRUE(evict.await(5));

                    ASSERT_TRUE(map.removeEntryListener(id));
                }

                TEST_P(MixedMapAPITest, testSetConfigTtl) {
                    mixedtype::IMap map = client->toMixedType().getMap("OneSecondTtlMap");
                    hazelcast::util::CountDownLatch dummy(10);
                    hazelcast::util::CountDownLatch evict(1);
                    CountdownListener sampleEntryListener(dummy, dummy, dummy, evict);
                    std::string id = map.addEntryListener(sampleEntryListener, false);

                    monitor::impl::NearCacheStatsImpl *nearCacheStatsImpl = (monitor::impl::NearCacheStatsImpl *) map.getLocalMapStats().getNearCacheStats();

                    int64_t initialInvalidationRequests = 0;
                    if (nearCacheStatsImpl) {
                        initialInvalidationRequests = nearCacheStatsImpl->getInvalidationRequests();
                    }

// set will cause an invalidation event sent from the server to the client
                    map.IMap::set<std::string, std::string>("key1", "value1");

// if near cache is enabled
                    if (nearCacheStatsImpl) {
                        ASSERT_EQ_EVENTUALLY(initialInvalidationRequests + 1,
                                             nearCacheStatsImpl->getInvalidationRequests());

// populate near cache
                        map.get<std::string>("key1");

// When ttl expires at server, the server does not send near cache invalidation.
                        ASSERT_TRUE_ALL_THE_TIME((map.get<std::string>("key1").get<std::string>().get() &&
                                                  nearCacheStatsImpl->getInvalidationRequests() ==
                                                  initialInvalidationRequests + 1), 2);
                    } else {
// trigger eviction
                        ASSERT_NULL_EVENTUALLY(map.get<std::string>("key1").get<std::string>().get(), std::string);
                    }

                    ASSERT_TRUE(evict.await(5));

                    ASSERT_TRUE(map.removeEntryListener(id));
                }

                TEST_P(MixedMapAPITest, testLock) {
                    imap->put<std::string, std::string>("key1", "value1");
                    ASSERT_EQ("value1", *(imap->get<std::string>("key1").get<std::string>()));
                    imap->lock<std::string>("key1");
                    hazelcast::util::CountDownLatch latch(1);
                    hazelcast::util::StartedThread t1(testLockThread, &latch, imap);
                    ASSERT_TRUE(latch.await(5));
                    ASSERT_EQ("value1", *(imap->get<std::string>("key1").get<std::string>()));
                    imap->forceUnlock<std::string>("key1");

                }

                TEST_P(MixedMapAPITest, testLockTtl) {
                    imap->put<std::string, std::string>("key1", "value1");
                    ASSERT_EQ("value1", *(imap->get<std::string>("key1").get<std::string>()));
                    imap->lock<std::string>("key1", 2 * 1000);
                    hazelcast::util::CountDownLatch latch(1);
                    hazelcast::util::StartedThread t1(testLockTTLThread, &latch, imap);
                    ASSERT_TRUE(latch.await(10));
                    ASSERT_FALSE(imap->isLocked<std::string>("key1"));
                    ASSERT_EQ("value2", *(imap->get<std::string>("key1").get<std::string>()));
                    imap->forceUnlock<std::string>("key1");

                }

                TEST_P(MixedMapAPITest, testLockTtl2) {
                    imap->lock<std::string>("key1", 3 * 1000);
                    hazelcast::util::CountDownLatch latch(2);
                    hazelcast::util::StartedThread t1(testLockTTL2Thread, &latch, imap);
                    ASSERT_TRUE(latch.await(10));
                    imap->forceUnlock<std::string>("key1");

                }

                TEST_P(MixedMapAPITest, testTryLock) {

                    ASSERT_TRUE(imap->tryLock<std::string>("key1", 2 * 1000));
                    hazelcast::util::CountDownLatch latch(1);
                    hazelcast::util::StartedThread t1(testMapTryLockThread1, &latch, imap);

                    ASSERT_TRUE(latch.await(100));

                    ASSERT_TRUE(imap->isLocked<std::string>("key1"));

                    hazelcast::util::CountDownLatch latch2(1);
                    hazelcast::util::StartedThread t2(testMapTryLockThread2, &latch2, imap);

                    hazelcast::util::sleep(1);
                    imap->unlock<std::string>("key1");
                    ASSERT_TRUE(latch2.await(100));
                    ASSERT_TRUE(imap->isLocked<std::string>("key1"));
                    imap->forceUnlock<std::string>("key1");

                }

                TEST_P(MixedMapAPITest, testForceUnlock) {
                    imap->lock<std::string>("key1");
                    hazelcast::util::CountDownLatch latch(1);
                    hazelcast::util::StartedThread t2(testMapForceUnlockThread, &latch, imap);
                    ASSERT_TRUE(latch.await(100));
                    t2.join();
                    ASSERT_FALSE(imap->isLocked<std::string>("key1"));

                }

                TEST_P(MixedMapAPITest, testValues) {

                    fillMap();
                    query::SqlPredicate predicate("this == value1");
                    std::vector<TypedData> tempVector = imap->values(predicate);
                    ASSERT_EQ(1U, tempVector.size());

                    ASSERT_EQ("value1", *tempVector[0].get<std::string>());
                }

/*
                TEST_P(MixedMapAPITest, testValuesWithPredicate) {
                    const int numItems = 20;
                    for (int i = 0; i < numItems; ++i) {
                        imap->put<int, int>(i, 2 * i);
                    }

                    std::vector<TypedData> values = imap->values();
                    ASSERT_EQ(numItems, (int) values.size());
                    std::vector<int> actualValues;
                    for (int i = 0; i < (int) values.size(); ++i) {
                        int *value = values[i].get<int>().get();
                        ASSERT_NE((const int *) NULL, value);
                        actualValues.push_back(*value);
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems; ++i) {
                        ASSERT_EQ(2 * i, actualValues[i]);
                    }

                    // EqualPredicate
                    // key == 5
                    values = imap->values(
                            query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5));
                    ASSERT_EQ(1, (int) values.size());
                    ASSERT_NE((const int *) NULL, values[0].get<int>().get());
                    ASSERT_EQ(2 * 5, *values[0].get<int>());

                    // value == 8
                    values = imap->values(
                            query::EqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 8));
                    ASSERT_EQ(1, (int) values.size());
                    ASSERT_NE((const int *) NULL, values[0].get<int>().get());
                    ASSERT_EQ(8, *values[0].get<int>());

                    // key == numItems
                    values = imap->values(
                            query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), numItems));
                    ASSERT_EQ(0, (int) values.size());

                    // NotEqual Predicate
                    // key != 5
                    values = imap->values(
                            query::NotEqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5));
                    ASSERT_EQ(numItems - 1, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        std::unique_ptr<int> value = values[i].get<int>();
                        ASSERT_NE((const int *) NULL, value.get());
                        actualValues.push_back(*value);
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems - 1; ++i) {
                        if (i >= 5) {
                            ASSERT_EQ(2 * (i + 1), actualValues[i]);
                        } else {
                            ASSERT_EQ(2 * i, actualValues[i]);
                        }
                    }

                    // this(value) != 8
                    values = imap->values(
                            query::NotEqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 8));
                    ASSERT_EQ(numItems - 1, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        std::unique_ptr<int> value = values[i].get<int>();
                        ASSERT_NE((const int *) NULL, value.get());
                        actualValues.push_back(*value);
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems - 1; ++i) {
                        if (i >= 4) {
                            ASSERT_EQ(2 * (i + 1), actualValues[i]);
                        } else {
                            ASSERT_EQ(2 * i, actualValues[i]);
                        }
                    }

                    // TruePredicate
                    values = imap->values(query::TruePredicate());
                    ASSERT_EQ(numItems, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        std::unique_ptr<int> value = values[i].get<int>();
                        ASSERT_NE((const int *) NULL, value.get());
                        actualValues.push_back(*value);
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems; ++i) {
                        ASSERT_EQ(2 * i, actualValues[i]);
                    }

                    // FalsePredicate
                    values = imap->values(query::FalsePredicate());
                    ASSERT_EQ(0, (int) values.size());

                    // BetweenPredicate
                    // 5 <= key <= 10
                    values = imap->values(
                            query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                    ASSERT_EQ(6, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        std::unique_ptr<int> value = values[i].get<int>();
                        ASSERT_NE((const int *) NULL, value.get());
                        actualValues.push_back(*value);
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 6; ++i) {
                        ASSERT_EQ(2 * (i + 5), actualValues[i]);
                    }

                    // 20 <= key <=30
                    values = imap->values(
                            query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 20, 30));
                    ASSERT_EQ(0, (int) values.size());

                    // GreaterLessPredicate
                    // value <= 10
                    values = imap->values(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 10, true,
                                                             true));
                    ASSERT_EQ(6, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        std::unique_ptr<int> value = values[i].get<int>();
                        ASSERT_NE((const int *) NULL, value.get());
                        actualValues.push_back(*value);
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 6; ++i) {
                        ASSERT_EQ(2 * i, actualValues[i]);
                    }

                    // key < 7
                    values = imap->values(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 7, false,
                                                             true));
                    ASSERT_EQ(7, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        std::unique_ptr<int> value = values[i].get<int>();
                        ASSERT_NE((const int *) NULL, value.get());
                        actualValues.push_back(*value);
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 7; ++i) {
                        ASSERT_EQ(2 * i, actualValues[i]);
                    }

                    // value >= 15
                    values = imap->values(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 15, true,
                                                             false));
                    ASSERT_EQ(12, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        std::unique_ptr<int> value = values[i].get<int>();
                        ASSERT_NE((const int *) NULL, value.get());
                        actualValues.push_back(*value);
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 12; ++i) {
                        ASSERT_EQ(2 * (i + 8), actualValues[i]);
                    }

                    // key > 5
                    values = imap->values(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, false,
                                                             false));
                    ASSERT_EQ(14, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        std::unique_ptr<int> value = values[i].get<int>();
                        ASSERT_NE((const int *) NULL, value.get());
                        actualValues.push_back(*value);
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 14; ++i) {
                        ASSERT_EQ(2 * (i + 6), actualValues[i]);
                    }

                    // InPredicate
                    // key in {4, 10, 19}
                    std::vector<int> inVals(3);
                    inVals[0] = 4;
                    inVals[1] = 10;
                    inVals[2] = 19;
                    values = imap->values(
                            query::InPredicate<int>(query::QueryConstants::getKeyAttributeName(), inVals));
                    ASSERT_EQ(3, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        std::unique_ptr<int> value = values[i].get<int>();
                        ASSERT_NE((const int *) NULL, value.get());
                        actualValues.push_back(*value);
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    ASSERT_EQ(2 * 4, actualValues[0]);
                    ASSERT_EQ(2 * 10, actualValues[1]);
                    ASSERT_EQ(2 * 19, actualValues[2]);

                    // value in {4, 10, 19}
                    values = imap->values(
                            query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                    ASSERT_EQ(2, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        std::unique_ptr<int> value = values[i].get<int>();
                        ASSERT_NE((const int *) NULL, value.get());
                        actualValues.push_back(*value);
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    ASSERT_EQ(4, actualValues[0]);
                    ASSERT_EQ(10, actualValues[1]);

                    // InstanceOfPredicate
                    // value instanceof Integer
                    values = imap->values(query::InstanceOfPredicate("java.lang.Integer"));
                    ASSERT_EQ(20, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        std::unique_ptr<int> value = values[i].get<int>();
                        ASSERT_NE((const int *) NULL, value.get());
                        actualValues.push_back(*value);
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems; ++i) {
                        ASSERT_EQ(2 * i, actualValues[i]);
                    }

                    values = imap->values(query::InstanceOfPredicate("java.lang.String"));
                    ASSERT_EQ(0, (int) values.size());

                    // NotPredicate
                    // !(5 <= key <= 10)
                    std::unique_ptr<query::Predicate> bp = std::unique_ptr<query::Predicate>(
                            new query::BetweenPredicate<int>(
                                    query::QueryConstants::getKeyAttributeName(), 5, 10));
                    query::NotPredicate notPredicate(bp);
                    values = imap->values(notPredicate);
                    ASSERT_EQ(14, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        std::unique_ptr<int> value = values[i].get<int>();
                        ASSERT_NE((const int *) NULL, value.get());
                        actualValues.push_back(*value);
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 14; ++i) {
                        if (i >= 5) {
                            ASSERT_EQ(2 * (i + 6), actualValues[i]);
                        } else {
                            ASSERT_EQ(2 * i, actualValues[i]);
                        }
                    }

                    // AndPredicate
                    // 5 <= key <= 10 AND Values in {4, 10, 19} = values {4, 10}
                    bp = std::unique_ptr<query::Predicate>(
                            new query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                    std::unique_ptr<query::Predicate> inPred = std::unique_ptr<query::Predicate>(
                            new query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                    values = imap->values(query::AndPredicate().add(bp).add(inPred));
                    ASSERT_EQ(1, (int) values.size());
                    ASSERT_EQ(10, *values[0].get<int>());

                    // OrPredicate
                    // 5 <= key <= 10 OR Values in {4, 10, 19} = values {4, 10, 12, 14, 16, 18, 20}
                    bp = std::unique_ptr<query::Predicate>(
                            new query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                    inPred = std::unique_ptr<query::Predicate>(
                            new query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                    values = imap->values(query::OrPredicate().add(bp).add(inPred));
                    ASSERT_EQ(7, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        std::unique_ptr<int> value = values[i].get<int>();
                        ASSERT_NE((const int *) NULL, value.get());
                        actualValues.push_back(*value);
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    ASSERT_EQ(4, actualValues[0]);
                    ASSERT_EQ(10, actualValues[1]);
                    ASSERT_EQ(12, actualValues[2]);
                    ASSERT_EQ(14, actualValues[3]);
                    ASSERT_EQ(16, actualValues[4]);
                    ASSERT_EQ(18, actualValues[5]);
                    ASSERT_EQ(20, actualValues[6]);

                    for (int i = 0; i < 12; i++) {
                        std::string key = "key";
                        key += hazelcast::util::IOUtil::to_string(i);
                        std::string value = "value";
                        value += hazelcast::util::IOUtil::to_string(i);
                        imap->put<std::string, std::string>(key, value);
                    }
                    imap->put<std::string, std::string>("key_111_test", "myvalue_111_test");
                    imap->put<std::string, std::string>("key_22_test", "myvalue_22_test");

                    // LikePredicate
                    // value LIKE "value1" : {"value1"}
                    values = imap->keySet(
                            query::LikePredicate(query::QueryConstants::getValueAttributeName(), "value1"));
                    ASSERT_EQ(1, (int) values.size());
                    std::unique_ptr<std::string> stringValue = values[0].get<std::string>();
                    ASSERT_NE((const std::string *) NULL, stringValue.get());
                    ASSERT_EQ("key1", *stringValue);

                    // ILikePredicate
                    // value ILIKE "%VALue%1%" : {"myvalue_111_test", "value1", "value10", "value11"}
                    values = imap->keySet(
                            query::ILikePredicate(query::QueryConstants::getValueAttributeName(), "%VALue%1%"));
                    ASSERT_EQ(4, (int) values.size());
                    std::vector<std::string> actualStrs;
                    for (int i = 0; i < (int) values.size(); ++i) {
                        std::unique_ptr<std::string> value = values[i].get<std::string>();
                        ASSERT_NE((const std::string *) NULL, value.get());
                        actualStrs.push_back(*value);
                    }
                    std::sort(actualStrs.begin(), actualStrs.end());
                    ASSERT_EQ("key1", actualStrs[0]);
                    ASSERT_EQ("key10", actualStrs[1]);
                    ASSERT_EQ("key11", actualStrs[2]);
                    ASSERT_EQ("key_111_test", actualStrs[3]);

                    // value ILIKE "%VAL%2%" : {"myvalue_22_test", "value2"}
                    values = imap->keySet(
                            query::ILikePredicate(query::QueryConstants::getValueAttributeName(), "%VAL%2%"));
                    ASSERT_EQ(2, (int) values.size());
                    actualStrs.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        std::unique_ptr<std::string> value = values[i].get<std::string>();
                        ASSERT_NE((const std::string *) NULL, value.get());
                        actualStrs.push_back(*value);
                    }
                    std::sort(actualStrs.begin(), actualStrs.end());
                    ASSERT_EQ("key2", actualStrs[0]);
                    ASSERT_EQ("key_22_test", actualStrs[1]);

                    // SqlPredicate
                    // __key BETWEEN 4 and 7 : {4, 5, 6, 7} -> {8, 10, 12, 14}
                    char sql[100];
                    hazelcast::util::hz_snprintf(sql, 50, "%s BETWEEN 4 and 7", query::QueryConstants::getKeyAttributeName());
                    values = imap->values(query::SqlPredicate(sql));
                    ASSERT_EQ(4, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        std::unique_ptr<int> value = values[i].get<int>();
                        ASSERT_NE((const int *) NULL, value.get());
                        actualValues.push_back(*value);
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 4; ++i) {
                        ASSERT_EQ(2 * (i + 4), actualValues[i]);
                    }

                    // RegexPredicate
                    // value matches the regex ".*value.*2.*" : {myvalue_22_test, value2}
                    values = imap->keySet(
                            query::RegexPredicate(query::QueryConstants::getValueAttributeName(), ".*value.*2.*"));
                    ASSERT_EQ(2, (int) values.size());
                    actualStrs.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        std::unique_ptr<std::string> value = values[i].get<std::string>();
                        ASSERT_NE((const std::string *) NULL, value.get());
                        actualStrs.push_back(*value);
                    }
                    std::sort(actualStrs.begin(), actualStrs.end());
                    ASSERT_EQ("key2", actualStrs[0]);
                    ASSERT_EQ("key_22_test", actualStrs[1]);
                }
*/

/*
                TEST_P(MixedMapAPITest, testValuesWithPagingPredicate) {
                    int predSize = 5;
                    const int totalEntries = 25;

                    for (int i = 0; i < totalEntries; ++i) {
                        imap->put<int, int>(i, i);
                    }

                    query::PagingPredicate<int, int> predicate((size_t) predSize);

                    std::vector<int> values = imap->values(predicate);
                    ASSERT_EQ(predSize, (int) values.size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_EQ(i, values[i]);
                    }

                    values = imap->values(predicate);
                    ASSERT_EQ(predSize, (int) values.size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_EQ(i, values[i]);
                    }

                    predicate.nextPage();
                    values = imap->values(predicate);
                    ASSERT_EQ(predSize, (int) values.size());

                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_EQ(predSize + i, values[i]);
                    }

                    const std::pair<int *, int *> *anchor = predicate.getAnchor();
                    ASSERT_NE((const std::pair<int *, int *> *) NULL, anchor);
                    ASSERT_NE((int *) NULL, anchor->first);
                    ASSERT_NE((int *) NULL, anchor->second);
                    ASSERT_EQ(9, *anchor->first);
                    ASSERT_EQ(9, *anchor->second);

                    ASSERT_EQ(1, (int) predicate.getPage());

                    predicate.setPage(4);

                    values = imap->values(predicate);
                    ASSERT_EQ(predSize, (int) values.size());

                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_EQ(predSize * 4 + i, values[i]);
                    }

                    anchor = predicate.getAnchor();
                    ASSERT_NE((const std::pair<int *, int *> *) NULL, anchor);
                    ASSERT_NE((int *) NULL, anchor->first);
                    ASSERT_NE((int *) NULL, anchor->second);
                    ASSERT_EQ(24, *anchor->first);
                    ASSERT_EQ(24, *anchor->second);

                    const std::pair<size_t, std::pair<int *, int *> > *anchorEntry = predicate.getNearestAnchorEntry();
                    ASSERT_NE((const std::pair<size_t, std::pair<int *, int *> > *) NULL, anchorEntry);
                    ASSERT_NE((int *) NULL, anchorEntry->second.first);
                    ASSERT_NE((int *) NULL, anchorEntry->second.second);
                    ASSERT_EQ(3, (int) anchorEntry->first);
                    ASSERT_EQ(19, *anchorEntry->second.first);
                    ASSERT_EQ(19, *anchorEntry->second.second);

                    predicate.nextPage();
                    values = imap->values(predicate);
                    ASSERT_EQ(0, (int) values.size());

                    predicate.setPage(0);
                    values = imap->values(predicate);
                    ASSERT_EQ(predSize, (int) values.size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_EQ(i, values[i]);
                    }

                    predicate.previousPage();
                    ASSERT_EQ(0, (int) predicate.getPage());

                    predicate.setPage(5);
                    values = imap->values(predicate);
                    ASSERT_EQ(0, (int) values.size());

                    predicate.setPage(3);
                    values = imap->values(predicate);
                    ASSERT_EQ(predSize, (int) values.size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_EQ(3 * predSize + i, values[i]);
                    }

                    predicate.previousPage();
                    values = imap->values(predicate);
                    ASSERT_EQ(predSize, (int) values.size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_EQ(2 * predSize + i, values[i]);
                    }

                    // test PagingPredicate with inner predicate (value < 10)
                    std::unique_ptr<query::Predicate> lessThanTenPredicate(std::unique_ptr<query::Predicate>(
                            new query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 9,
                                                                 false,
                                                                 true)));
                    query::PagingPredicate<int, int> predicate2(lessThanTenPredicate, 5);
                    values = imap->values(predicate2);
                    ASSERT_EQ(predSize, (int) values.size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_EQ(i, values[i]);
                    }

                    predicate2.nextPage();
                    // match values 5,6, 7, 8
                    values = imap->values(predicate2);
                    ASSERT_EQ(predSize - 1, (int) values.size());
                    for (int i = 0; i < predSize - 1; ++i) {
                        ASSERT_EQ(predSize + i, values[i]);
                    }

                    predicate2.nextPage();
                    values = imap->values(predicate2);
                    ASSERT_EQ(0, (int) values.size());

                    // test paging predicate with comparator
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);
                    Employee empl4("ali", 33);
                    Employee empl5("veli", 44);
                    Employee empl6("aylin", 5);

                    imap->put<int, Employee>(3, empl1);
                    imap->put<int, Employee>(4, empl2);
                    imap->put<int, Employee>(5, empl3);
                    imap->put<int, Employee>(6, empl4);
                    imap->put<int, Employee>(7, empl5);
                    imap->put<int, Employee>(8, empl6);

                    predSize = 2;
                    query::PagingPredicate<int, Employee> predicate3(
                            std::unique_ptr<query::EntryComparator<int, Employee> >(new EmployeeEntryComparator()),
                            (size_t) predSize);
                    std::vector<Employee> employees = imap->values<int, Employee>(predicate3);
                    ASSERT_EQ(2, (int) employees.size());
                    ASSERT_EQ(empl6, employees[0]);
                    ASSERT_EQ(empl2, employees[1]);

                    predicate3.nextPage();
                    employees = imap->values<int, Employee>(predicate3);
                    ASSERT_EQ(2, (int) employees.size());
                    ASSERT_EQ(empl3, employees[0]);
                    ASSERT_EQ(empl4,  employees[1]);
                }
*/

/*
                TEST_P(MixedMapAPITest, testKeySetWithPredicate) {
                    const int numItems = 20;
                    for (int i = 0; i < numItems; ++i) {
                        imap->put<int, int>(i, 2 * i);
                    }

                    std::unique_ptr<DataArray<int> > values = imap->keySet();
                    ASSERT_EQ(numItems, (int) values.size());
                    std::vector<int> actualValues;
                    for (int i = 0; i < (int) values.size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems; ++i) {
                        ASSERT_EQ(i, actualValues[i]);
                    }

                    // EqualPredicate
                    // key == 5
                    values = imap->keySet(
                            query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5));
                    ASSERT_EQ(1, (int) values.size());
                    ASSERT_NE((const int *) NULL, (*values)[0]);
                    ASSERT_EQ(5, *((*values)[0]));

                    // value == 8
                    values = imap->keySet(
                            query::EqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 8));
                    ASSERT_EQ(1, (int) values.size());
                    ASSERT_NE((const int *) NULL, (*values)[0]);
                    ASSERT_EQ(4, *((*values)[0]));

                    // key == numItems
                    values = imap->keySet(
                            query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), numItems));
                    ASSERT_EQ(0, (int) values.size());

                    // NotEqual Predicate
                    // key != 5
                    values = imap->keySet(
                            query::NotEqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5));
                    ASSERT_EQ(numItems - 1, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems - 1; ++i) {
                        if (i >= 5) {
                            ASSERT_EQ((i + 1), actualValues[i]);
                        } else {
                            ASSERT_EQ(i, actualValues[i]);
                        }
                    }

                    // this(value) != 8
                    values = imap->keySet(
                            query::NotEqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 8));
                    ASSERT_EQ(numItems - 1, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems - 1; ++i) {
                        if (i >= 4) {
                            ASSERT_EQ((i + 1), actualValues[i]);
                        } else {
                            ASSERT_EQ(i, actualValues[i]);
                        }
                    }

                    // TruePredicate
                    values = imap->keySet(query::TruePredicate());
                    ASSERT_EQ(numItems, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems; ++i) {
                        ASSERT_EQ(i, actualValues[i]);
                    }

                    // FalsePredicate
                    values = imap->keySet(query::FalsePredicate());
                    ASSERT_EQ(0, (int) values.size());

                    // BetweenPredicate
                    // 5 <= key <= 10
                    values = imap->keySet(
                            query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                    ASSERT_EQ(6, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 6; ++i) {
                        ASSERT_EQ((i + 5), actualValues[i]);
                    }

                    // 20 <= key <=30
                    values = imap->keySet(
                            query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 20, 30));
                    ASSERT_EQ(0, (int) values.size());

                    // GreaterLessPredicate
                    // value <= 10
                    values = imap->keySet(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 10, true,
                                                             true));
                    ASSERT_EQ(6, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 6; ++i) {
                        ASSERT_EQ(i, actualValues[i]);
                    }

                    // key < 7
                    values = imap->keySet(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 7, false,
                                                             true));
                    ASSERT_EQ(7, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 7; ++i) {
                        ASSERT_EQ(i, actualValues[i]);
                    }

                    // value >= 15
                    values = imap->keySet(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 15, true,
                                                             false));
                    ASSERT_EQ(12, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 12; ++i) {
                        ASSERT_EQ((i + 8), actualValues[i]);
                    }

                    // key > 5
                    values = imap->keySet(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, false,
                                                             false));
                    ASSERT_EQ(14, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 14; ++i) {
                        ASSERT_EQ((i + 6), actualValues[i]);
                    }

                    // InPredicate
                    // key in {4, 10, 19}
                    std::vector<int> inVals(3);
                    inVals[0] = 4;
                    inVals[1] = 10;
                    inVals[2] = 19;
                    values = imap->keySet(
                            query::InPredicate<int>(query::QueryConstants::getKeyAttributeName(), inVals));
                    ASSERT_EQ(3, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    ASSERT_EQ(4, actualValues[0]);
                    ASSERT_EQ(10, actualValues[1]);
                    ASSERT_EQ(19, actualValues[2]);

                    // value in {4, 10, 19}
                    values = imap->keySet(
                            query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                    ASSERT_EQ(2, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    ASSERT_EQ(2, actualValues[0]);
                    ASSERT_EQ(5, actualValues[1]);

                    // InstanceOfPredicate
                    // value instanceof Integer
                    values = imap->keySet(query::InstanceOfPredicate("java.lang.Integer"));
                    ASSERT_EQ(20, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < numItems; ++i) {
                        ASSERT_EQ(i, actualValues[i]);
                    }

                    values = imap->keySet(query::InstanceOfPredicate("java.lang.String"));
                    ASSERT_EQ(0, (int) values.size());

                    // NotPredicate
                    // !(5 <= key <= 10)
                    std::unique_ptr<query::Predicate> bp = std::unique_ptr<query::Predicate>(
                            new query::BetweenPredicate<int>(
                                    query::QueryConstants::getKeyAttributeName(), 5, 10));
                    query::NotPredicate notPredicate(bp);
                    values = imap->keySet(notPredicate);
                    ASSERT_EQ(14, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 14; ++i) {
                        if (i >= 5) {
                            ASSERT_EQ((i + 6), actualValues[i]);
                        } else {
                            ASSERT_EQ(i, actualValues[i]);
                        }
                    }

                    // AndPredicate
                    // 5 <= key <= 10 AND Values in {4, 10, 19} = values {4, 10}
                    bp = std::unique_ptr<query::Predicate>(
                            new query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                    std::unique_ptr<query::Predicate> inPred = std::unique_ptr<query::Predicate>(
                            new query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                    values = imap->keySet(query::AndPredicate().add(bp).add(inPred));
                    ASSERT_EQ(1, (int) values.size());
                    ASSERT_EQ(5, *(values->release(0)));

                    // OrPredicate
                    // 5 <= key <= 10 OR Values in {4, 10, 19} = values {4, 10, 12, 14, 16, 18, 20}
                    bp = std::unique_ptr<query::Predicate>(
                            new query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                    inPred = std::unique_ptr<query::Predicate>(
                            new query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                    values = imap->keySet(query::OrPredicate().add(bp).add(inPred));
                    ASSERT_EQ(7, (int) values.size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values.size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    ASSERT_EQ(2, actualValues[0]);
                    ASSERT_EQ(5, actualValues[1]);
                    ASSERT_EQ(6, actualValues[2]);
                    ASSERT_EQ(7, actualValues[3]);
                    ASSERT_EQ(8, actualValues[4]);
                    ASSERT_EQ(9, actualValues[5]);
                    ASSERT_EQ(10, actualValues[6]);

                    for (int i = 0; i < 12; i++) {
                        std::string key = "key";
                        key += hazelcast::util::IOUtil::to_string(i);
                        std::string value = "value";
                        value += hazelcast::util::IOUtil::to_string(i);
                        imap->put<std::string, std::string>(key, value);
                    }
                    imap->put<std::string, std::string>("key_111_test", "myvalue_111_test");
                    imap->put<std::string, std::string>("key_22_test", "myvalue_22_test");

                    // LikePredicate
                    // value LIKE "value1" : {"value1"}
                    std::unique_ptr<DataArray<std::string> > strValues = imap->keySet(
                            query::LikePredicate(query::QueryConstants::getValueAttributeName(), "value1"));
                    ASSERT_EQ(1, (int) strvalues.size());
                    ASSERT_NE((const std::string *) NULL, strValues->get(0));
                    ASSERT_EQ("key1", *strValues->get(0));

                    // ILikePredicate
                    // value ILIKE "%VALue%1%" : {"key_111_test", "key1", "key10", "key11"}
                    strValues = imap->keySet(
                            query::ILikePredicate(query::QueryConstants::getValueAttributeName(), "%VALue%1%"));
                    ASSERT_EQ(4, (int) strvalues.size());
                    std::vector<std::string> actualStrs;
                    for (int i = 0; i < (int) strValues->size(); ++i) {
                        ASSERT_NE((const std::string *) NULL, strValues->get(i));
                        actualStrs.push_back(*strValues->get(i));
                    }
                    std::sort(actualStrs.begin(), actualStrs.end());
                    ASSERT_EQ("key1", actualStrs[0]);
                    ASSERT_EQ("key10", actualStrs[1]);
                    ASSERT_EQ("key11", actualStrs[2]);
                    ASSERT_EQ("key_111_test", actualStrs[3]);

                    // value ILIKE "%VAL%2%" : {"key_22_test", "key2"}
                    strValues = imap->keySet(
                            query::ILikePredicate(query::QueryConstants::getValueAttributeName(), "%VAL%2%"));
                    ASSERT_EQ(2, (int) strValues->size());
                    actualStrs.clear();
                    for (int i = 0; i < (int) strValues->size(); ++i) {
                        ASSERT_NE((const std::string *) NULL, strValues->get(i));
                        actualStrs.push_back(*strValues->get(i));
                    }
                    std::sort(actualStrs.begin(), actualStrs.end());
                    ASSERT_EQ("key2", actualStrs[0]);
                    ASSERT_EQ("key_22_test", actualStrs[1]);

                    // SqlPredicate
                    // __key BETWEEN 4 and 7 : {4, 5, 6, 7} -> {8, 10, 12, 14}
                    char sql[100];
                    hazelcast::util::hz_snprintf(sql, 50, "%s BETWEEN 4 and 7", query::QueryConstants::getKeyAttributeName());
                    values = imap->keySet(query::SqlPredicate(sql));
                    ASSERT_EQ(4, (int) values->size());
                    actualValues.clear();
                    for (int i = 0; i < (int) values->size(); ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        actualValues.push_back(*values->get(i));
                    }
                    std::sort(actualValues.begin(), actualValues.end());
                    for (int i = 0; i < 4; ++i) {
                        ASSERT_EQ(i + 4, actualValues[i]);
                    }

                    // RegexPredicate
                    // value matches the regex ".*value.*2.*" : {myvalue_22_test, value2}
                    strValues = imap->keySet(
                            query::RegexPredicate(query::QueryConstants::getValueAttributeName(), ".*value.*2.*"));
                    ASSERT_EQ(2, (int) strValues->size());
                    actualStrs.clear();
                    for (int i = 0; i < (int) strValues->size(); ++i) {
                        ASSERT_NE((const std::string *) NULL, strValues->get(i));
                        actualStrs.push_back(*strValues->get(i));
                    }
                    std::sort(actualStrs.begin(), actualStrs.end());
                    ASSERT_EQ("key2", actualStrs[0]);
                    ASSERT_EQ("key_22_test", actualStrs[1]);
                }

                TEST_P(MixedMapAPITest, testKeySetWithPagingPredicate) {
                    int predSize = 5;
                    const int totalEntries = 25;

                    for (int i = 0; i < totalEntries; ++i) {
                        imap->put<int, int>(i, i);
                    }

                    query::PagingPredicate<int, int> predicate((size_t) predSize);

                    std::unique_ptr<DataArray<int> > values = imap->keySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(i, *values->get(i));
                    }

                    values = imap->keySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(i, *values->get(i));
                    }

                    predicate.nextPage();
                    values = imap->keySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());

                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(predSize + i, *values->get(i));
                    }

                    const std::pair<int *, int *> *anchor = predicate.getAnchor();
                    ASSERT_NE((const std::pair<int *, int *> *) NULL, anchor);
                    ASSERT_NE((int *) NULL, anchor->first);
                    ASSERT_EQ(9, *anchor->first);

                    ASSERT_EQ(1, (int) predicate.getPage());

                    predicate.setPage(4);

                    values = imap->keySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());

                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(predSize * 4 + i, *values->get(i));
                    }

                    anchor = predicate.getAnchor();
                    ASSERT_NE((const std::pair<int *, int *> *) NULL, anchor);
                    ASSERT_NE((int *) NULL, anchor->first);
                    ASSERT_EQ(24, *anchor->first);

                    const std::pair<size_t, std::pair<int *, int *> > *anchorEntry = predicate.getNearestAnchorEntry();
                    ASSERT_NE((const std::pair<size_t, std::pair<int *, int *> > *) NULL, anchorEntry);
                    ASSERT_EQ(3, (int) anchorEntry->first);

                    predicate.nextPage();
                    values = imap->keySet(predicate);
                    ASSERT_EQ(0, (int) values->size());

                    predicate.setPage(0);
                    values = imap->keySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(i, *values->get(i));
                    }

                    predicate.previousPage();
                    ASSERT_EQ(0, (int) predicate.getPage());

                    predicate.setPage(5);
                    values = imap->keySet(predicate);
                    ASSERT_EQ(0, (int) values->size());

                    predicate.setPage(3);
                    values = imap->keySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(3 * predSize + i, *values->get(i));
                    }

                    predicate.previousPage();
                    values = imap->keySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        const int *value = values->get(i);
                        ASSERT_NE((const int *) NULL, value);
                        ASSERT_EQ(2 * predSize + i, *value);
                    }

                    // test PagingPredicate with inner predicate (value < 10)
                    std::unique_ptr<query::Predicate> lessThanTenPredicate(std::unique_ptr<query::Predicate>(
                            new query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 9,
                                                                 false,
                                                                 true)));
                    query::PagingPredicate<int, int> predicate2(lessThanTenPredicate, 5);
                    values = imap->keySet(predicate2);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(i, *values->get(i));
                    }

                    predicate2.nextPage();
                    // match values 5,6, 7, 8
                    values = imap->keySet(predicate2);
                    ASSERT_EQ(predSize - 1, (int) values->size());
                    for (int i = 0; i < predSize - 1; ++i) {
                        ASSERT_NE((const int *) NULL, values->get(i));
                        ASSERT_EQ(predSize + i, *values->get(i));
                    }

                    predicate2.nextPage();
                    values = imap->keySet(predicate2);
                    ASSERT_EQ(0, (int) values->size());

                    // test paging predicate with comparator
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);
                    Employee empl4("ali", 33);
                    Employee empl5("veli", 44);
                    Employee empl6("aylin", 5);

                    imap->put<int, Employee>(3, empl1);
                    imap->put<int, Employee>(4, empl2);
                    imap->put<int, Employee>(5, empl3);
                    imap->put<int, Employee>(6, empl4);
                    imap->put<int, Employee>(7, empl5);
                    imap->put<int, Employee>(8, empl6);

                    predSize = 2;
                    query::PagingPredicate<int, Employee> predicate3(
                            std::unique_ptr<query::EntryComparator<int, Employee> >(new EmployeeEntryKeyComparator()),
                            (size_t) predSize);
                    std::unique_ptr<DataArray<int> > result = imap->keySet(predicate3);
                    // since keyset result only returns keys from the server, no ordering based on the value but ordered based on the keys
                    ASSERT_EQ(2, (int) result->size());
                    ASSERT_NE((const int *) NULL, (*result)[0]);
                    ASSERT_NE((const int *) NULL, (*result)[1]);
                    ASSERT_EQ(3, *((*result)[0]));
                    ASSERT_EQ(4, *result->get(1));

                    predicate3.nextPage();
                    result = imap->keySet(predicate3);
                    ASSERT_EQ(2, (int) result->size());
                    ASSERT_NE((const int *) NULL, (*result)[0]);
                    ASSERT_NE((const int *) NULL, (*result)[1]);
                    ASSERT_EQ(5, *((*result)[0]));
                    ASSERT_EQ(6, *result->get(1));
                }

                TEST_P(MixedMapAPITest, testEntrySetWithPredicate) {
                    const int numItems = 20;
                    std::vector<std::pair<int, int> > expected(numItems);
                    for (int i = 0; i < numItems; ++i) {
                        imap->put<int, int>(i, 2 * i);
                        expected[i] = std::pair<int, int>(i, 2 * i);
                    }

                    std::unique_ptr<EntryArray<int, int> > entries = imap->entrySet();
                    ASSERT_EQ(numItems, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < numItems; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        ASSERT_EQ(expected[i], entry);
                    }

                    // EqualPredicate
                    // key == 5
                    entries = imap->entrySet(
                            query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5));
                    ASSERT_EQ(1, (int) entries->size());
                    std::pair<int, int> entry1(*entries->getKey(0), *entries->getValue(0));
                    ASSERT_EQ(expected[5], entry1);

                    // value == 8
                    entries = imap->entrySet(
                            query::EqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 8));
                    ASSERT_EQ(1, (int) entries->size());
                    std::pair<int, int> entry2(*entries->getKey(0), *entries->getValue(0));
                    ASSERT_EQ(expected[4], entry2);

                    // key == numItems
                    entries = imap->entrySet(
                            query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), numItems));
                    ASSERT_EQ(0, (int) entries->size());

                    // NotEqual Predicate
                    // key != 5
                    entries = imap->entrySet(
                            query::NotEqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5));
                    ASSERT_EQ(numItems - 1, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < numItems - 1; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        if (i >= 5) {
                            ASSERT_EQ(expected[i + 1], entry);
                        } else {
                            ASSERT_EQ(expected[i], entry);
                        }
                    }

                    // value != 8
                    entries = imap->entrySet(
                            query::NotEqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 8));
                    ASSERT_EQ(numItems - 1, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < numItems - 1; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        if (i >= 4) {
                            ASSERT_EQ(expected[i + 1], entry);
                        } else {
                            ASSERT_EQ(expected[i], entry);
                        }
                    }

                    // TruePredicate
                    entries = imap->entrySet(query::TruePredicate());
                    ASSERT_EQ(numItems, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < numItems; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        ASSERT_EQ(expected[i], entry);
                    }

                    // FalsePredicate
                    entries = imap->entrySet(query::FalsePredicate());
                    ASSERT_EQ(0, (int) entries->size());

                    // BetweenPredicate
                    // 5 <= key <= 10
                    entries = imap->entrySet(
                            query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                    entries->sort(query::ENTRY);
                    ASSERT_EQ(6, (int) entries->size());
                    for (int i = 0; i < 6; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        ASSERT_EQ(expected[i + 5], entry);
                    }

                    // 20 <= key <=30
                    entries = imap->entrySet(
                            query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 20, 30));
                    ASSERT_EQ(0, (int) entries->size());

                    // GreaterLessPredicate
                    // value <= 10
                    entries = imap->entrySet(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 10, true,
                                                             true));
                    ASSERT_EQ(6, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < 6; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        ASSERT_EQ(expected[i], entry);
                    }

                    // key < 7
                    entries = imap->entrySet(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 7, false,
                                                             true));
                    ASSERT_EQ(7, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < 7; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        ASSERT_EQ(expected[i], entry);
                    }

                    // value >= 15
                    entries = imap->entrySet(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 15, true,
                                                             false));
                    ASSERT_EQ(12, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < 12; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        ASSERT_EQ(expected[i + 8], entry);
                    }

                    // key > 5
                    entries = imap->entrySet(
                            query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, false,
                                                             false));
                    ASSERT_EQ(14, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < 14; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        ASSERT_EQ(expected[i + 6], entry);
                    }

                    // InPredicate
                    // key in {4, 10, 19}
                    std::vector<int> inVals(3);
                    inVals[0] = 4;
                    inVals[1] = 10;
                    inVals[2] = 19;
                    entries = imap->entrySet(
                            query::InPredicate<int>(query::QueryConstants::getKeyAttributeName(), inVals));
                    ASSERT_EQ(3, (int) entries->size());
                    entries->sort(query::ENTRY);
                    {
                        std::pair<int, int> entry(*entries->getKey(0), *entries->getValue(0));
                        ASSERT_EQ(expected[4], entry);
                    }
                    {
                        std::pair<int, int> entry(*entries->getKey(1), *entries->getValue(1));
                        ASSERT_EQ(expected[10], entry);
                    }
                    {
                        std::pair<int, int> entry(*entries->getKey(2), *entries->getValue(2));
                        ASSERT_EQ(expected[19], entry);
                    }

                    // value in {4, 10, 19}
                    entries = imap->entrySet(
                            query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                    ASSERT_EQ(2, (int) entries->size());
                    entries->sort(query::ENTRY);
                    std::pair<int, int> entry(*entries->getKey(0), *entries->getValue(0));
                    ASSERT_EQ(expected[2], entry);
                    entry = std::pair<int, int>(*entries->getKey(1), *entries->getValue(1));
                    ASSERT_EQ(expected[5], entry);

                    // InstanceOfPredicate
                    // value instanceof Integer
                    entries = imap->entrySet(query::InstanceOfPredicate("java.lang.Integer"));
                    ASSERT_EQ(20, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < numItems; ++i) {
                        std::pair<int, int> item(*entries->getKey(i), *entries->getValue(i));
                        ASSERT_EQ(expected[i], item);
                    }

                    entries = imap->entrySet(query::InstanceOfPredicate("java.lang.String"));
                    ASSERT_EQ(0, (int) entries->size());

                    // NotPredicate
                    // !(5 <= key <= 10)
                    std::unique_ptr<query::Predicate> bp = std::unique_ptr<query::Predicate>(
                            new query::BetweenPredicate<int>(
                                    query::QueryConstants::getKeyAttributeName(), 5, 10));
                    query::NotPredicate notPredicate(bp);
                    entries = imap->entrySet(notPredicate);
                    ASSERT_EQ(14, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < 14; ++i) {
                        std::pair<int, int> item(*entries->getKey(i), *entries->getValue(i));
                        if (i >= 5) {
                            ASSERT_EQ(expected[i + 6], item);
                        } else {
                            ASSERT_EQ(expected[i], item);
                        }
                    }

                    // AndPredicate
                    // 5 <= key <= 10 AND Values in {4, 10, 19} = entries {4, 10}
                    bp = std::unique_ptr<query::Predicate>(
                            new query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                    std::unique_ptr<query::Predicate> inPred = std::unique_ptr<query::Predicate>(
                            new query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                    entries = imap->entrySet(query::AndPredicate().add(bp).add(inPred));
                    ASSERT_EQ(1, (int) entries->size());
                    entries->sort(query::ENTRY);
                    entry = std::pair<int, int>(*entries->getKey(0), *entries->getValue(0));
                    ASSERT_EQ(expected[5], entry);

                    // OrPredicate
                    // 5 <= key <= 10 OR Values in {4, 10, 19} = entries keys {2, 5, 6, 7, 8, 9, 10}
                    bp = std::unique_ptr<query::Predicate>(
                            new query::BetweenPredicate<int>(query::QueryConstants::getKeyAttributeName(), 5, 10));
                    inPred = std::unique_ptr<query::Predicate>(
                            new query::InPredicate<int>(query::QueryConstants::getValueAttributeName(), inVals));
                    entries = imap->entrySet(query::OrPredicate().add(bp).add(inPred));
                    ASSERT_EQ(7, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < 7; ++i) {
                        entry = std::pair<int, int>(*entries->getKey(i), *entries->getValue(i));
                        if (i == 0) {
                            ASSERT_EQ(expected[2], entry);
                        } else {
                            ASSERT_EQ(expected[i + 4], entry);
                        }
                    }

                    std::vector<std::pair<std::string, std::string> > expectedStrEntries(14);
                    for (int i = 0; i < 12; i++) {
                        std::string key = "key";
                        key += hazelcast::util::IOUtil::to_string(i);
                        std::string value = "value";
                        value += hazelcast::util::IOUtil::to_string(i);
                        imap->put<std::string, std::string>(key, value);
                        expectedStrEntries[i] = std::pair<std::string, std::string>(key, value);
                    }
                    imap->put<std::string, std::string>("key_111_test", "myvalue_111_test");
                    expectedStrEntries[12] = std::pair<std::string, std::string>("key_111_test", "myvalue_111_test");
                    imap->put<std::string, std::string>("key_22_test", "myvalue_22_test");
                    expectedStrEntries[13] = std::pair<std::string, std::string>("key_22_test", "myvalue_22_test");

                    // LikePredicate
                    // value LIKE "value1" : {"value1"}
                    std::unique_ptr<EntryArray<std::string, std::string> > strEntries = imap->entrySet(
                            query::LikePredicate(query::QueryConstants::getValueAttributeName(), "value1"));
                    ASSERT_EQ(1, (int) strEntries->size());
                    std::pair<std::string, std::string> strEntry(*strEntries->getKey(0), *strEntries->getValue(0));
                    ASSERT_EQ(expectedStrEntries[1], strEntry);

                    // ILikePredicate
                    // value ILIKE "%VALue%1%" : {"key_111_test", "key1", "key10", "key11"}
                    strEntries = imap->entrySet(
                            query::ILikePredicate(query::QueryConstants::getValueAttributeName(), "%VALue%1%"));
                    ASSERT_EQ(4, (int) strEntries->size());
                    strEntries->sort(query::ENTRY);
                    for (int i = 0; i < 4; ++i) {
                        strEntry = std::pair<std::string, std::string>(*strEntries->getKey(i),
                                                                       *strEntries->getValue(i));
                        if (i == 0) {
                            ASSERT_EQ(expectedStrEntries[1], strEntry);
                        } else {
                            ASSERT_EQ(expectedStrEntries[i + 9], strEntry);
                        }
                    }

                    // key ILIKE "%VAL%2%" : {"key_22_test", "key2"}
                    strEntries = imap->entrySet(
                            query::ILikePredicate(query::QueryConstants::getValueAttributeName(), "%VAL%2%"));
                    ASSERT_EQ(2, (int) strEntries->size());
                    strEntries->sort(query::ENTRY);
                    strEntry = std::pair<std::string, std::string>(*strEntries->getKey(0), *strEntries->getValue(0));
                    ASSERT_EQ(expectedStrEntries[2], strEntry);
                    strEntry = std::pair<std::string, std::string>(*strEntries->getKey(1), *strEntries->getValue(1));
                    ASSERT_EQ(expectedStrEntries[13], strEntry);

                    // SqlPredicate
                    // __key BETWEEN 4 and 7 : {4, 5, 6, 7} -> {8, 10, 12, 14}
                    char sql[100];
                    hazelcast::util::hz_snprintf(sql, 50, "%s BETWEEN 4 and 7", query::QueryConstants::getKeyAttributeName());
                    entries = imap->entrySet(query::SqlPredicate(sql));
                    ASSERT_EQ(4, (int) entries->size());
                    entries->sort(query::ENTRY);
                    for (int i = 0; i < 4; ++i) {
                        std::pair<int, int> entry(*entries->getKey(i), *entries->getValue(i));
                        ASSERT_EQ(expected[i + 4], entry);
                    }

                    // RegexPredicate
                    // value matches the regex ".*value.*2.*" : {key_22_test, value2}
                    strEntries = imap->entrySet(
                            query::RegexPredicate(query::QueryConstants::getValueAttributeName(), ".*value.*2.*"));
                    ASSERT_EQ(2, (int) strEntries->size());
                    strEntries->sort(query::ENTRY);
                    strEntry = std::pair<std::string, std::string>(*strEntries->getKey(0), *strEntries->getValue(0));
                    ASSERT_EQ(expectedStrEntries[2], strEntry);
                    strEntry = std::pair<std::string, std::string>(*strEntries->getKey(1), *strEntries->getValue(1));
                    ASSERT_EQ(expectedStrEntries[13], strEntry);
                }

                TEST_P(MixedMapAPITest, testEntrySetWithPagingPredicate) {
                    int predSize = 5;
                    const int totalEntries = 25;

                    for (int i = 0; i < totalEntries; ++i) {
                        imap->put<int, int>(i, i);
                    }

                    query::PagingPredicate<int, int> predicate((size_t) predSize);

                    std::unique_ptr<EntryArray<int, int> > values = imap->entrySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        std::pair<int, int> expected(i, i);
                        std::pair<int, int> actual(*values->getKey(i), *values->getValue(i));
                        ASSERT_EQ(expected, actual);
                    }

                    values = imap->entrySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        std::pair<int, int> expected(i, i);
                        std::pair<int, int> actual(*values->getKey(i), *values->getValue(i));
                        ASSERT_EQ(expected, actual);
                    }

                    predicate.nextPage();
                    values = imap->entrySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());

                    for (int i = 0; i < predSize; ++i) {
                        std::pair<int, int> expected(predSize + i, predSize + i);
                        std::pair<int, int> actual(*values->getKey(i), *values->getValue(i));
                        ASSERT_EQ(expected, actual);
                    }

                    const std::pair<int *, int *> *anchor = predicate.getAnchor();
                    ASSERT_NE((const std::pair<int *, int *> *) NULL, anchor);
                    ASSERT_NE((int *) NULL, anchor->first);
                    ASSERT_NE((int *) NULL, anchor->second);
                    ASSERT_EQ(9, *anchor->first);
                    ASSERT_EQ(9, *anchor->second);

                    ASSERT_EQ(1, (int) predicate.getPage());

                    predicate.setPage(4);

                    values = imap->entrySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        std::pair<int, int> expected(predSize * 4 + i, predSize * 4 + i);
                        std::pair<int, int> actual(*values->getKey(i), *values->getValue(i));
                        ASSERT_EQ(expected, actual);
                    }

                    anchor = predicate.getAnchor();
                    ASSERT_NE((const std::pair<int *, int *> *) NULL, anchor);
                    ASSERT_NE((int *) NULL, anchor->first);
                    ASSERT_NE((int *) NULL, anchor->second);
                    ASSERT_EQ(24, *anchor->first);
                    ASSERT_EQ(24, *anchor->second);

                    const std::pair<size_t, std::pair<int *, int *> > *anchorEntry = predicate.getNearestAnchorEntry();
                    ASSERT_NE((const std::pair<size_t, std::pair<int *, int *> > *) NULL, anchorEntry);
                    ASSERT_NE((int *) NULL, anchorEntry->second.first);
                    ASSERT_NE((int *) NULL, anchorEntry->second.second);
                    ASSERT_EQ(3, (int) anchorEntry->first);
                    ASSERT_EQ(19, *anchorEntry->second.first);
                    ASSERT_EQ(19, *anchorEntry->second.second);

                    predicate.nextPage();
                    values = imap->entrySet(predicate);
                    ASSERT_EQ(0, (int) values->size());

                    predicate.setPage(0);
                    values = imap->entrySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        std::pair<int, int> expected(i, i);
                        std::pair<int, int> actual(*values->getKey(i), *values->getValue(i));
                        ASSERT_EQ(expected, actual);
                    }

                    predicate.previousPage();
                    ASSERT_EQ(0, (int) predicate.getPage());

                    predicate.setPage(5);
                    values = imap->entrySet(predicate);
                    ASSERT_EQ(0, (int) values->size());

                    predicate.setPage(3);
                    values = imap->entrySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        std::pair<int, int> expected(3 * predSize + i, 3 * predSize + i);
                        std::pair<int, int> actual(*values->getKey(i), *values->getValue(i));
                        ASSERT_EQ(expected, actual);
                    }

                    predicate.previousPage();
                    values = imap->entrySet(predicate);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        std::pair<int, int> expected(2 * predSize + i, 2 * predSize + i);
                        std::pair<int, int> actual(*values->getKey(i), *values->getValue(i));
                        ASSERT_EQ(expected, actual);
                    }

                    // test PagingPredicate with inner predicate (value < 10)
                    std::unique_ptr<query::Predicate> lessThanTenPredicate(std::unique_ptr<query::Predicate>(
                            new query::GreaterLessPredicate<int>(query::QueryConstants::getValueAttributeName(), 9,
                                                                 false,
                                                                 true)));
                    query::PagingPredicate<int, int> predicate2(lessThanTenPredicate, 5);
                    values = imap->entrySet(predicate2);
                    ASSERT_EQ(predSize, (int) values->size());
                    for (int i = 0; i < predSize; ++i) {
                        std::pair<int, int> expected(i, i);
                        std::pair<int, int> actual(*values->getKey(i), *values->getValue(i));
                        ASSERT_EQ(expected, actual);
                    }

                    predicate2.nextPage();
                    // match values 5,6, 7, 8
                    values = imap->entrySet(predicate2);
                    ASSERT_EQ(predSize - 1, (int) values->size());
                    for (int i = 0; i < predSize - 1; ++i) {
                        std::pair<int, int> expected(predSize + i, predSize + i);
                        std::pair<int, int> actual(*values->getKey(i), *values->getValue(i));
                        ASSERT_EQ(expected, actual);
                    }

                    predicate2.nextPage();
                    values = imap->entrySet(predicate2);
                    ASSERT_EQ(0, (int) values->size());

                    // test paging predicate with comparator
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);
                    Employee empl4("ali", 33);
                    Employee empl5("veli", 44);
                    Employee empl6("aylin", 5);

                    imap->put<int, Employee>(3, empl1);
                    imap->put<int, Employee>(4, empl2);
                    imap->put<int, Employee>(5, empl3);
                    imap->put<int, Employee>(6, empl4);
                    imap->put<int, Employee>(7, empl5);
                    imap->put<int, Employee>(8, empl6);

                    predSize = 2;
                    query::PagingPredicate<int, Employee> predicate3(
                            std::unique_ptr<query::EntryComparator<int, Employee> >(new EmployeeEntryComparator()),
                            (size_t) predSize);
                    std::unique_ptr<EntryArray<int, Employee> > result = imap->entrySet(predicate3);
                    ASSERT_EQ(2, (int) result->size());
                    std::pair<int, Employee> expected(8, empl6);
                    std::pair<int, Employee> actual(*result->getKey(0), *result->getValue(0));
                    ASSERT_EQ(expected, actual);
                    expected = std::pair<int, Employee>(4, empl2);
                    actual = std::pair<int, Employee>(*result->getKey(1), *result->getValue(1));
                    ASSERT_EQ(expected, actual);
                }

*/
                TEST_P(MixedMapAPITest, testReplace) {
                    std::unique_ptr<std::string> temp = imap->replace<std::string, std::string>("key1",
                                                                                                "value").get<std::string>();
                    ASSERT_EQ((std::string *) NULL, temp.get());

                    std::string tempKey = "key1";
                    std::string tempValue = "value1";
                    imap->put<std::string, std::string>(tempKey, tempValue);

                    ASSERT_EQ("value1",
                              (*(imap->replace<std::string, std::string>("key1", "value2").get<std::string>())));
                    ASSERT_EQ("value2", *(imap->get<std::string>("key1").get<std::string>()));

                    ASSERT_FALSE((imap->replace<std::string, std::string, std::string>("key1", "value1", "value3")));
                    ASSERT_EQ("value2", *(imap->get<std::string>("key1").get<std::string>()));

                    ASSERT_TRUE((imap->replace<std::string, std::string, std::string>("key1", "value2", "value3")));
                    ASSERT_EQ("value3", (*(imap->get<std::string>("key1").get<std::string>())));
                }

                TEST_P(MixedMapAPITest, testPredicateListenerWithPortableKey) {
                    hazelcast::util::CountDownLatch countDownLatch(1);
                    hazelcast::util::AtomicInt atomicInteger(0);
                    SampleEntryListenerForPortableKey listener(countDownLatch, atomicInteger);
                    Employee key("a", 1);
                    std::string id = imap->addEntryListener(key, listener, true);
                    Employee key2("a", 2);
                    imap->put<Employee, int>(key2, 1);
                    imap->put<Employee, int>(key, 3);
                    ASSERT_TRUE(countDownLatch.await(5));
                    ASSERT_EQ(1, (int) atomicInteger);

                    ASSERT_TRUE(imap->removeEntryListener(id));
                }

                TEST_P(MixedMapAPITest, testListener) {
                    hazelcast::util::CountDownLatch latch1Add(5);
                    hazelcast::util::CountDownLatch latch1Remove(2);
                    hazelcast::util::CountDownLatch dummy(10);
                    hazelcast::util::CountDownLatch latch2Add(1);
                    hazelcast::util::CountDownLatch latch2Remove(1);

                    CountdownListener listener1(latch1Add, latch1Remove, dummy, dummy);
                    CountdownListener listener2(latch2Add, latch2Remove, dummy, dummy);

                    std::string listener1ID = imap->addEntryListener(listener1, false);
                    std::string listener2ID = imap->addEntryListener<std::string>("key3", listener2, true);

                    hazelcast::util::sleep(2);

                    imap->put<std::string, std::string>("key1", "value1");
                    imap->put<std::string, std::string>("key2", "value2");
                    imap->put<std::string, std::string>("key3", "value3");
                    imap->put<std::string, std::string>("key4", "value4");
                    imap->put<std::string, std::string>("key5", "value5");

                    imap->remove<std::string>("key1");
                    imap->remove<std::string>("key3");

                    ASSERT_TRUE(latch1Add.await(10));
                    ASSERT_TRUE(latch1Remove.await(10));
                    ASSERT_TRUE(latch2Add.await(5));
                    ASSERT_TRUE(latch2Remove.await(5));

                    ASSERT_TRUE(imap->removeEntryListener(listener1ID));
                    ASSERT_TRUE(imap->removeEntryListener(listener2ID));

                }

                TEST_P(MixedMapAPITest, testListenerWithTruePredicate) {
                    hazelcast::util::CountDownLatch latchAdd(3);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener listener(latchAdd, latchRemove, latchUpdate, latchEvict);

                    std::string listenerId = imap->addEntryListener(listener, query::TruePredicate(), false);

                    imap->put<int, int>(1, 1);
                    imap->put<int, int>(2, 2);
                    imap->put<int, int>(3, 3, 1000); // evict after 1 second
                    imap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ((int *) NULL, imap->get<int>(3).get<int>().get()); // trigger eviction

// update an entry
                    imap->IMap::set<int, int>(1, 5);
                    std::unique_ptr<int> value = imap->get<int>(1).get<int>();
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchRemove).add(latchUpdate).add(latchEvict);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    ASSERT_TRUE(imap->removeEntryListener(listenerId));
                }

                TEST_P(MixedMapAPITest, testListenerWithFalsePredicate) {
                    hazelcast::util::CountDownLatch latchAdd(3);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener listener(latchAdd, latchRemove, latchUpdate, latchEvict);

                    std::string listenerId = imap->addEntryListener(listener, query::FalsePredicate(), false);

                    imap->put<int, int>(1, 1);
                    imap->put<int, int>(2, 2);
                    imap->put<int, int>(3, 3, 1000); // evict after 1 second
                    imap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ((int *) NULL, imap->get<int>(3).get<int>().get()); // trigger eviction

// update an entry
                    imap->IMap::set<int, int>(1, 5);
                    std::unique_ptr<int> value = imap->get<int>(1).get<int>();
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchRemove).add(latchUpdate).add(latchEvict);
                    ASSERT_FALSE(latches.awaitMillis(2000));

                    ASSERT_TRUE(imap->removeEntryListener(listenerId));
                }

                TEST_P(MixedMapAPITest, testListenerWithEqualPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(1);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener listener(latchAdd, latchRemove, latchUpdate, latchEvict);

                    std::string listenerId = imap->addEntryListener(listener, query::EqualPredicate<int>(
                            query::QueryConstants::getKeyAttributeName(), 3), true);

                    imap->put<int, int>(1, 1);
                    imap->put<int, int>(2, 2);
                    imap->put<int, int>(3, 3, 1000); // evict after 1 second
                    imap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ((int *) NULL, imap->get<int>(3).get<int>().get()); // trigger eviction

// update an entry
                    imap->IMap::set<int, int>(1, 5);
                    std::unique_ptr<int> value = imap->get<int>(1).get<int>();
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchEvict);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    latches.reset();
                    latches.add(latchUpdate).add(latchRemove);
                    ASSERT_FALSE(latches.awaitMillis(2000));

                    ASSERT_TRUE(imap->removeEntryListener(listenerId));
                }

                TEST_P(MixedMapAPITest, testListenerWithNotEqualPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(2);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener listener(latchAdd, latchRemove, latchUpdate, latchEvict);

                    std::string listenerId = imap->addEntryListener(listener, query::NotEqualPredicate<int>(
                            query::QueryConstants::getKeyAttributeName(), 3), true);

                    imap->put<int, int>(1, 1);
                    imap->put<int, int>(2, 2);
                    imap->put<int, int>(3, 3, 1000); // evict after 1 second
                    imap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ((int *) NULL, imap->get<int>(3).get<int>().get()); // trigger eviction

// update an entry
                    imap->IMap::set<int, int>(1, 5);
                    std::unique_ptr<int> value = imap->get<int>(1).get<int>();
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchRemove).add(latchUpdate);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    latches.reset();
                    latches.add(latchEvict);
                    ASSERT_FALSE(latches.awaitMillis(2000));

                    ASSERT_TRUE(imap->removeEntryListener(listenerId));
                }

                TEST_P(MixedMapAPITest, testListenerWithGreaterLessPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(2);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener listener(latchAdd, latchRemove, latchUpdate, latchEvict);

// key <= 2
                    std::string listenerId = imap->addEntryListener(listener, query::GreaterLessPredicate<int>(
                            query::QueryConstants::getKeyAttributeName(), 2, true, true), false);

                    imap->put<int, int>(1, 1);
                    imap->put<int, int>(2, 2);
                    imap->put<int, int>(3, 3, 1000); // evict after 1 second
                    imap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ((int *) NULL, imap->get<int>(3).get<int>().get()); // trigger eviction

// update an entry
                    imap->IMap::set<int, int>(1, 5);
                    std::unique_ptr<int> value = imap->get<int>(1).get<int>();
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchRemove).add(latchUpdate);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    ASSERT_FALSE(latchEvict.awaitMillis(2000));

                    ASSERT_TRUE(imap->removeEntryListener(listenerId));
                }

                TEST_P(MixedMapAPITest, testListenerWithBetweenPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(2);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener listener(latchAdd, latchRemove, latchUpdate, latchEvict);

// 1 <=key <= 2
                    std::string listenerId = imap->addEntryListener(listener, query::BetweenPredicate<int>(
                            query::QueryConstants::getKeyAttributeName(), 1, 2), true);

                    imap->put<int, int>(1, 1);
                    imap->put<int, int>(2, 2);
                    imap->put<int, int>(3, 3, 1000); // evict after 1 second
                    imap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ((int *) NULL, imap->get<int>(3).get<int>().get()); // trigger eviction

// update an entry
                    imap->IMap::set<int, int>(1, 5);
                    std::unique_ptr<int> value = imap->get<int>(1).get<int>();
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchRemove).add(latchUpdate);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    ASSERT_FALSE(latchEvict.awaitMillis(2000));

                    ASSERT_TRUE(imap->removeEntryListener(listenerId));
                }

                TEST_P(MixedMapAPITest, testListenerWithSqlPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(1);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener listener(latchAdd, latchRemove, latchUpdate, latchEvict);

// 1 <=key <= 2
                    std::string listenerId = imap->addEntryListener(listener, query::SqlPredicate("__key < 2"), true);

                    imap->put<int, int>(1, 1);
                    imap->put<int, int>(2, 2);
                    imap->put<int, int>(3, 3, 1000); // evict after 1 second
                    imap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ((int *) NULL, imap->get<int>(3).get<int>().get()); // trigger eviction

// update an entry
                    imap->IMap::set<int, int>(1, 5);
                    std::unique_ptr<int> value = imap->get<int>(1).get<int>();
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchUpdate);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    latches.reset();
                    latches.add(latchRemove).add(latchEvict);
                    ASSERT_FALSE(latches.awaitMillis(2000));

                    ASSERT_TRUE(imap->removeEntryListener(listenerId));
                }

                TEST_P(MixedMapAPITest, testListenerWithRegExPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(2);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener listener(latchAdd, latchRemove, latchUpdate,
                                               latchEvict);

// key matches any word containing ".*met.*"
                    std::string listenerId = imap->addEntryListener(listener, query::RegexPredicate(
                            query::QueryConstants::getKeyAttributeName(), ".*met.*"), true);

                    imap->put<std::string, std::string>("ilkay", "yasar");
                    imap->put<std::string, std::string>("mehmet", "demir");
                    imap->put<std::string, std::string>("metin", "ozen", 1000); // evict after 1 second
                    imap->put<std::string, std::string>("hasan", "can");
                    imap->remove<std::string>("mehmet");

                    hazelcast::util::sleep(2);

                    ASSERT_EQ((std::string *) NULL,
                              imap->get<std::string>("metin").get<std::string>().get()); // trigger eviction

// update an entry
                    imap->IMap::set<std::string, std::string>("hasan", "suphi");
                    std::unique_ptr<std::string> value = imap->get<std::string>("hasan").get<std::string>();
                    ASSERT_NE((std::string *) NULL, value.get());
                    ASSERT_EQ("suphi", *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchRemove).add(latchEvict);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    ASSERT_FALSE(latchUpdate.awaitMillis(2000));

                    ASSERT_TRUE(imap->removeEntryListener(listenerId));
                }

                TEST_P(MixedMapAPITest, testListenerWithInstanceOfPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(3);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener listener(latchAdd, latchRemove, latchUpdate, latchEvict);

// 1 <=key <= 2
                    std::string listenerId = imap->addEntryListener(listener,
                                                                    query::InstanceOfPredicate("java.lang.Integer"),
                                                                    false);

                    imap->put<int, int>(1, 1);
                    imap->put<int, int>(2, 2);
                    imap->put<int, int>(3, 3, 1000); // evict after 1 second
                    imap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ((int *) NULL, imap->get<int>(3).get<int>().get()); // trigger eviction

// update an entry
                    imap->IMap::set<int, int>(1, 5);
                    std::unique_ptr<int> value = imap->get<int>(1).get<int>();
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchRemove).add(latchUpdate).add(latchEvict);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    ASSERT_TRUE(imap->removeEntryListener(listenerId));
                }

                TEST_P(MixedMapAPITest, testListenerWithNotPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(2);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener listener(latchAdd, latchRemove, latchUpdate, latchEvict);

// key >= 3
                    std::unique_ptr<query::Predicate> greaterLessPred = std::unique_ptr<query::Predicate>(
                            new query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 3, true,
                                                                 false));
                    query::NotPredicate notPredicate(greaterLessPred);
                    std::string listenerId = imap->addEntryListener(listener, notPredicate, false);

                    imap->put<int, int>(1, 1);
                    imap->put<int, int>(2, 2);
                    imap->put<int, int>(3, 3, 1000); // evict after 1 second
                    imap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ((int *) NULL, imap->get<int>(3).get<int>().get()); // trigger eviction

// update an entry
                    imap->IMap::set<int, int>(1, 5);
                    std::unique_ptr<int> value = imap->get<int>(1).get<int>();
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchRemove).add(latchUpdate);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    latches.reset();
                    latches.add(latchEvict);
                    ASSERT_FALSE(latches.awaitMillis(1000));

                    ASSERT_TRUE(imap->removeEntryListener(listenerId));
                }

                TEST_P(MixedMapAPITest, testListenerWithAndPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(1);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener listener(latchAdd, latchRemove, latchUpdate, latchEvict);

// key < 3
                    std::unique_ptr<query::Predicate> greaterLessPred = std::unique_ptr<query::Predicate>(
                            new query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 3, false,
                                                                 true));
// value == 1
                    std::unique_ptr<query::Predicate> equalPred = std::unique_ptr<query::Predicate>(
                            new query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 1));
                    query::AndPredicate predicate;
// key < 3 AND key == 1 --> (1, 1)
                    predicate.add(greaterLessPred).add(equalPred);
                    std::string listenerId = imap->addEntryListener(listener, predicate, false);

                    imap->put<int, int>(1, 1);
                    imap->put<int, int>(2, 2);
                    imap->put<int, int>(3, 3, 1000); // evict after 1 second
                    imap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ((int *) NULL, imap->get<int>(3).get<int>().get()); // trigger eviction

// update an entry
                    imap->IMap::set<int, int>(1, 5);
                    std::unique_ptr<int> value = imap->get<int>(1).get<int>();
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchUpdate);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    latches.reset();
                    latches.add(latchEvict).add(latchRemove);
                    ASSERT_FALSE(latches.awaitMillis(1000));

                    ASSERT_TRUE(imap->removeEntryListener(listenerId));
                }

                TEST_P(MixedMapAPITest, testListenerWithOrPredicate) {
                    hazelcast::util::CountDownLatch latchAdd(2);
                    hazelcast::util::CountDownLatch latchRemove(1);
                    hazelcast::util::CountDownLatch latchEvict(1);
                    hazelcast::util::CountDownLatch latchUpdate(1);

                    CountdownListener listener(latchAdd, latchRemove, latchUpdate, latchEvict);

// key >= 3
                    std::unique_ptr<query::Predicate> greaterLessPred = std::unique_ptr<query::Predicate>(
                            new query::GreaterLessPredicate<int>(query::QueryConstants::getKeyAttributeName(), 3, true,
                                                                 false));
// value == 1
                    std::unique_ptr<query::Predicate> equalPred = std::unique_ptr<query::Predicate>(
                            new query::EqualPredicate<int>(query::QueryConstants::getValueAttributeName(), 2));
                    query::OrPredicate predicate;
// key >= 3 OR value == 2 --> (1, 1), (2, 2)
                    predicate.add(greaterLessPred).add(equalPred);
                    std::string listenerId = imap->addEntryListener(listener, predicate, true);

                    imap->put<int, int>(1, 1);
                    imap->put<int, int>(2, 2);
                    imap->put<int, int>(3, 3, 1000); // evict after 1 second
                    imap->remove(2);

                    hazelcast::util::sleep(2);

                    ASSERT_EQ((int *) NULL, imap->get<int>(3).get<int>().get()); // trigger eviction

// update an entry
                    imap->IMap::set<int, int>(1, 5);
                    std::unique_ptr<int> value = imap->get<int>(1).get<int>();
                    ASSERT_NE((int *) NULL, value.get());
                    ASSERT_EQ(5, *value);

                    hazelcast::util::CountDownLatchWaiter latches;
                    latches.add(latchAdd).add(latchEvict).add(latchRemove);
                    ASSERT_TRUE(latches.awaitMillis(2000));

                    ASSERT_FALSE(latchUpdate.awaitMillis(2000));

                    ASSERT_TRUE(imap->removeEntryListener(listenerId));
                }

                TEST_P(MixedMapAPITest, testClearEvent) {
                    hazelcast::util::CountDownLatch latch(1);
                    ClearListener clearListener(latch);
                    std::string listenerId = imap->addEntryListener(clearListener, false);
                    imap->put<std::string, std::string>("key1", "value1");
                    imap->clear();
                    ASSERT_TRUE(latch.await(120));
                    imap->removeEntryListener(listenerId);
                }

                TEST_P(MixedMapAPITest, testEvictAllEvent) {
                    hazelcast::util::CountDownLatch latch(1);
                    EvictListener evictListener(latch);
                    std::string listenerId = imap->addEntryListener(evictListener, false);
                    imap->put<std::string, std::string>("key1", "value1");
                    imap->evictAll();
                    ASSERT_TRUE(latch.await(120));
                    imap->removeEntryListener(listenerId);
                }

                TEST_P(MixedMapAPITest, testBasicPredicate) {
                    fillMap();

                    query::SqlPredicate predicate("this = 'value1'");
                    std::vector<TypedData> datas = imap->values(predicate);

                    std::unique_ptr<std::string> actualVal = datas[0].get<std::string>();
                    ASSERT_NE((std::string *) NULL, actualVal.get());
                    ASSERT_EQ("value1", *actualVal);

                    datas = imap->keySet(predicate);

                    actualVal = datas[0].get<std::string>();
                    ASSERT_NE((std::string *) NULL, actualVal.get());
                    ASSERT_EQ("key1", *actualVal);


                    std::vector<std::pair<TypedData, TypedData> > entries = imap->entrySet(predicate);
                    actualVal = entries[0].first.get<std::string>();
                    ASSERT_NE((std::string *) NULL, actualVal.get());
                    ASSERT_EQ("key1", *actualVal);

                    actualVal = entries[0].second.get<std::string>();
                    ASSERT_NE((std::string *) NULL, actualVal.get());
                    ASSERT_EQ("value1", *actualVal);
                }

                TEST_P(MixedMapAPITest, testKeySetAndValuesWithPredicates) {
                    Employee emp1("abc-123-xvz", 34);
                    Employee emp2("abc-123-xvz", 20);

                    imap->put<Employee, Employee>(emp1, emp1);
                    ASSERT_EQ((Employee *) NULL, (imap->put<Employee, Employee>(emp2, emp2).get<Employee>().get()));
                    ASSERT_EQ(2, (int) imap->size());
                    ASSERT_EQ(2, (int) imap->keySet().size());
                    query::SqlPredicate predicate("a = 10");
                    ASSERT_EQ(0, (int) imap->keySet(predicate).size());
                    query::SqlPredicate predicate2("a = 10");
                    ASSERT_EQ(0, (int) imap->values(predicate2).size());
                    query::SqlPredicate predicate3("a >= 10");
                    ASSERT_EQ(2, (int) imap->keySet(predicate3).size());
                    ASSERT_EQ(2, (int) imap->values(predicate3).size());
                    ASSERT_EQ(2, (int) imap->size());
                    ASSERT_EQ(2, (int) imap->values().size());
                }

                TEST_P(MixedMapAPITest, testMapWithPortable) {
                    std::unique_ptr<Employee> n1 = imap->get<int>(1).get<Employee>();
                    ASSERT_EQ(n1.get(), (Employee *) NULL);
                    Employee employee("sancar", 24);
                    std::unique_ptr<Employee> ptr = imap->put<int, Employee>(1, employee).get<Employee>();
                    ASSERT_EQ(ptr.get(), (Employee *) NULL);
                    ASSERT_FALSE(imap->isEmpty());
                    std::unique_ptr<EntryView<TypedData, TypedData> > view = imap->getEntryView(1);
                    ASSERT_NE((EntryView<TypedData, TypedData> *) NULL, view.get());
                    ASSERT_EQ(employee, *(view->value.get<Employee>()));
                    ASSERT_EQ(1, *(view->key.get<int>()));

                    imap->addIndex("a", true);
                    imap->addIndex("n", false);
                }

                TEST_P(MixedMapAPITest, testMapStoreRelatedRequests) {
                    imap->putTransient<std::string, std::string>("ali", "veli", 1100);
                    imap->flush();
                    ASSERT_EQ(1, imap->size());
                    ASSERT_FALSE(imap->evict<std::string>("deli"));
                    ASSERT_TRUE(imap->evict<std::string>("ali"));
                    ASSERT_EQ((std::string *) NULL, imap->get<std::string>("ali").get<std::string>().get());
                }

                TEST_P(MixedMapAPITest, testExecuteOnKey) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);

                    imap->put<int, Employee>(3, empl1);
                    imap->put<int, Employee>(4, empl2);

                    EntryMultiplier processor(4);

                    std::unique_ptr<int> result = imap->executeOnKey<int, EntryMultiplier>(4, processor).get<int>();

                    ASSERT_NE((int *) NULL, result.get());
                    ASSERT_EQ(4 * processor.getMultiplier(), *result);
                }

                TEST_P(MixedMapAPITest, testExecuteOnNonExistentKey) {
                    EntryMultiplier processor(4);

                    std::unique_ptr<int> result = imap->executeOnKey<int, EntryMultiplier>(17, processor).get<int>();

                    ASSERT_NE((int *) NULL, result.get());
                    ASSERT_EQ(-1, *result);
                }

                TEST_P(MixedMapAPITest, testSubmitToKey) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);

                    imap->put<int, Employee>(3, empl1);
                    imap->put<int, Employee>(4, empl2);

// Waits at the server side before running the operation
                    WaitMultiplierProcessor processor(3000, 4);

                    hazelcast::client::Future<TypedData> initialFuture = imap->submitToKey<int, WaitMultiplierProcessor>(
                            4, processor);

// Should invalidate the initialFuture
                    hazelcast::client::Future<TypedData> future = initialFuture;

                    ASSERT_FALSE(initialFuture.valid());
                    ASSERT_THROW(initialFuture.wait_for(1000), exception::FutureUninitialized);
                    ASSERT_TRUE(future.valid());

                    future_status status = future.wait_for(1 * 1000);
                    ASSERT_EQ(future_status::timeout, status);
                    ASSERT_TRUE(future.valid());

                    status = future.wait_for(3 * 1000);
                    ASSERT_EQ(future_status::ready, status);
                    TypedData result = future.get();
                    ASSERT_EQ(4 * processor.getMultiplier(), *result.get<int>());
                    ASSERT_FALSE(future.valid());
                }

                TEST_P(MixedMapAPITest, testSubmitToKeyMultipleAsyncCalls) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);

                    imap->put<int, Employee>(3, empl1);
                    imap->put<int, Employee>(4, empl2);

                    int waitTimeInMillis = 500;

// Waits at the server side before running the operation
                    WaitMultiplierProcessor processor(waitTimeInMillis, 4);

                    std::vector<hazelcast::client::Future<TypedData> > allFutures;

// test putting into a vector of futures
                    hazelcast::client::Future<TypedData> future = imap->submitToKey<int, WaitMultiplierProcessor>(3,
                                                                                                                  processor);
                    allFutures.push_back(future);

// test re-assigning a future and putting into the vector
                    future = imap->submitToKey<int, WaitMultiplierProcessor>(
                            3, processor);
                    allFutures.push_back(future);

// test submitting a non-existent key
                    allFutures.push_back(imap->submitToKey<int, WaitMultiplierProcessor>(
                            99, processor));

                    for (std::vector<hazelcast::client::Future<TypedData> >::const_iterator it = allFutures.begin();
                         it != allFutures.end(); ++it) {
                        future_status status = (*it).wait_for(2 * waitTimeInMillis);
                        ASSERT_EQ(future_status::ready, status);
                    }

                    for (std::vector<hazelcast::client::Future<TypedData> >::iterator it = allFutures.begin();
                         it != allFutures.end(); ++it) {
                        TypedData result = (*it).get();
                        ASSERT_NE((int *) NULL, result.get<int>().get());
                        ASSERT_FALSE((*it).valid());
                    }
                }

                TEST_P(MixedMapAPITest, testExecuteOnKeys) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    imap->put<int, Employee>(3, empl1);
                    imap->put<int, Employee>(4, empl2);
                    imap->put<int, Employee>(5, empl3);

                    EntryMultiplierWithNullableResult processor(4);

                    std::set<int> keys;
                    keys.insert(3);
                    keys.insert(5);
// put non existent key
                    keys.insert(999);

                    std::map<int, TypedData> result = imap->executeOnKeys<int, EntryMultiplier>(keys, processor);

                    ASSERT_EQ(2, (int) result.size());
                    ASSERT_NE(result.end(), result.find(3));
                    ASSERT_NE(result.end(), result.find(5));
                    ASSERT_EQ(result.end(), result.find(999));
                    ASSERT_EQ(3 * processor.getMultiplier(), *result[3].get<int>());
                    ASSERT_EQ(5 * processor.getMultiplier(), *result[5].get<int>());
                }

                TEST_P(MixedMapAPITest, testExecuteOnEntries) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    imap->put<int, Employee>(3, empl1);
                    imap->put<int, Employee>(4, empl2);
                    imap->put<int, Employee>(5, empl3);

                    EntryMultiplier processor(4);

                    std::map<TypedData, TypedData> result = imap->executeOnEntries<EntryMultiplier>(processor);

                    ASSERT_EQ(3, (int) result.size());
                    for (std::map<TypedData, TypedData>::const_iterator it = result.begin(); it != result.end(); ++it) {
                        std::unique_ptr<int> key = (*it).first.get<int>();
                        std::unique_ptr<int> value = (*it).second.get<int>();
                        ASSERT_TRUE(*key == 3 || *key == 4 || *key == 5);
                        ASSERT_EQ((*key) * processor.getMultiplier(), (*value));
                    }
                }

                TEST_P(MixedMapAPITest, testExecuteOnEntriesWithTruePredicate) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    imap->put<int, Employee>(3, empl1);
                    imap->put<int, Employee>(4, empl2);
                    imap->put<int, Employee>(5, empl3);

                    EntryMultiplier processor(4);

                    std::map<TypedData, TypedData> result = imap->executeOnEntries<EntryMultiplier>(processor,
                                                                                                    query::TruePredicate());

                    ASSERT_EQ(3, (int) result.size());
                    for (std::map<TypedData, TypedData>::const_iterator it = result.begin(); it != result.end(); ++it) {
                        std::unique_ptr<int> key = (*it).first.get<int>();
                        std::unique_ptr<int> value = (*it).second.get<int>();
                        ASSERT_TRUE(*key == 3 || *key == 4 || *key == 5);
                        ASSERT_EQ((*key) * processor.getMultiplier(), (*value));
                    }
                }

                TEST_P(MixedMapAPITest, testExecuteOnEntriesWithFalsePredicate) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    imap->put<int, Employee>(3, empl1);
                    imap->put<int, Employee>(4, empl2);
                    imap->put<int, Employee>(5, empl3);

                    EntryMultiplier processor(4);

                    std::map<TypedData, TypedData> result = imap->executeOnEntries<EntryMultiplier>(processor,
                                                                                                    query::FalsePredicate());

                    ASSERT_EQ(0, (int) result.size());
                }

                TEST_P(MixedMapAPITest, testExecuteOnEntriesWithAndPredicate) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    imap->put<int, Employee>(3, empl1);
                    imap->put<int, Employee>(4, empl2);
                    imap->put<int, Employee>(5, empl3);

                    query::AndPredicate andPredicate;
/* 25 <= age <= 35 AND age = 35 */
                    andPredicate.add(
                            std::unique_ptr<query::Predicate>(new query::BetweenPredicate<int>("a", 25, 35))).add(
                            std::unique_ptr<query::Predicate>(
                                    new query::NotPredicate(
                                            std::unique_ptr<query::Predicate>(
                                                    new query::EqualPredicate<int>("a", 35)))));

                    EntryMultiplier processor(4);

                    std::map<TypedData, TypedData> result = imap->executeOnEntries<EntryMultiplier>(processor,
                                                                                                    andPredicate);

                    ASSERT_EQ(1, (int) result.size());
                    ASSERT_EQ(5, *result.begin()->first.get<int>());
                    ASSERT_EQ(5 * processor.getMultiplier(), *result.begin()->second.get<int>());
                }

                TEST_P(MixedMapAPITest, testExecuteOnEntriesWithOrPredicate) {
                    Employee empl1("ahmet", 35);
                    Employee empl2("mehmet", 21);
                    Employee empl3("deniz", 25);

                    imap->put<int, Employee>(3, empl1);
                    imap->put<int, Employee>(4, empl2);
                    imap->put<int, Employee>(5, empl3);

                    query::OrPredicate orPredicate;
/* age == 21 OR age > 25 */
                    orPredicate.add(
                            std::unique_ptr<query::Predicate>(new query::EqualPredicate<int>("a", 21))).add(
                            std::unique_ptr<query::Predicate>(
                                    new query::GreaterLessPredicate<int>("a", 25, false, false)));

                    EntryMultiplier processor(4);

                    std::map<TypedData, TypedData> result = imap->executeOnEntries<EntryMultiplier>(processor,
                                                                                                    orPredicate);

                    ASSERT_EQ(2, (int) result.size());
                    std::map<hazelcast::client::TypedData, hazelcast::client::TypedData>::iterator iterator = result.begin();
                    std::unique_ptr<int> firstKey = (*iterator).first.get<int>();
                    if (3 == *firstKey) {
                        ASSERT_EQ(3 * processor.getMultiplier(), *(*iterator).second.get<int>());
                        ++iterator;
                        ASSERT_EQ(4, *(*iterator).first.get<int>());
                        ASSERT_EQ(4 * processor.getMultiplier(), *(*iterator).second.get<int>());
                    } else {
                        ASSERT_EQ(4 * processor.getMultiplier(), *(*iterator).second.get<int>());
                        ++iterator;
                        ASSERT_EQ(3, *(*iterator).first.get<int>());
                        ASSERT_EQ(3 * processor.getMultiplier(), *(*iterator).second.get<int>());
                    }
                }

                TEST_P(MixedMapAPITest, testAddInterceptor) {
                    std::string prefix("My Prefix");
                    MapGetInterceptor interceptor(prefix);
                    imap->addInterceptor<MapGetInterceptor>(interceptor);

                    std::unique_ptr<std::string> val = imap->get<std::string>("nonexistent").get<std::string>();
                    ASSERT_NE((std::string *) NULL, val.get());
                    ASSERT_EQ(prefix, *val);

                    val = imap->put<std::string, std::string>("key1", "value1").get<std::string>();
                    ASSERT_EQ((std::string *) NULL, val.get());

                    val = imap->get<std::string>("key1").get<std::string>();
                    ASSERT_NE((std::string *) NULL, val.get());
                    ASSERT_EQ(prefix + "value1", *val);
                }

                TEST_P(MixedMapAPITest, testReadUTFWrittenByJava) {
                    std::string value = "xyz123    ";
                    std::string key = "myutfkey";
                    imap->put<std::string, std::string>(key, value);
                    UTFValueValidatorProcessor processor;
                    TypedData result = imap->executeOnKey<std::string, UTFValueValidatorProcessor>(key, processor);
                    std::unique_ptr<bool> val = result.get<bool>();
                    ASSERT_NOTNULL(val.get(), bool);
                    ASSERT_TRUE(*val);
                }
            }
        }
    }
}





namespace hazelcast {
    namespace client {
        namespace test {
            class ClientSemaphoreTest : public ClientTestSupport {
            protected:
                virtual void SetUp() {
                }

                virtual void TearDown() {
                }

                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    client = new HazelcastClient(getConfig());
                }

                static void TearDownTestCase() {
                    delete client;
                    delete instance;

                    client = NULL;
                    instance = NULL;
                }

                static HazelcastServer *instance;
                static HazelcastClient *client;
            };

            HazelcastServer *ClientSemaphoreTest::instance = NULL;
            HazelcastClient *ClientSemaphoreTest::client = NULL;

            void testAcquireThread(hazelcast::util::ThreadArgs& args) {
                ISemaphore *s = (ISemaphore *) args.arg0;
                hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg1;
                s->acquire();
                latch->countDown();
            }

            TEST_F(ClientSemaphoreTest, testSemaphoreInit) {
                ISemaphore semaphore = client->getISemaphore(randomString());
                ASSERT_TRUE(semaphore.init(10));
            }

            TEST_F(ClientSemaphoreTest, testSemaphoreNegInit) {
                ISemaphore semaphore = client->getISemaphore(randomString());
                ASSERT_THROW(semaphore.init(-1), exception::IllegalArgumentException);
            }

            TEST_F(ClientSemaphoreTest, testRelease) {
                ISemaphore semaphore = client->getISemaphore(randomString());
                semaphore.init(0);
                semaphore.release();
                ASSERT_EQ(1, semaphore.availablePermits());
            }

            TEST_F(ClientSemaphoreTest, testdrainPermits) {
                ISemaphore semaphore = client->getISemaphore(randomString());
                semaphore.init(10);
                ASSERT_EQ(10, semaphore.drainPermits());
            }

            TEST_F(ClientSemaphoreTest, testAvailablePermits_AfterDrainPermits) {
                ISemaphore semaphore = client->getISemaphore(randomString());
                semaphore.init(10);
                semaphore.drainPermits();
                ASSERT_EQ(0, semaphore.availablePermits());
            }

            TEST_F(ClientSemaphoreTest, testTryAcquire_whenDrainPermits) {
                ISemaphore semaphore = client->getISemaphore(randomString());
                semaphore.init(10);
                semaphore.drainPermits();
                ASSERT_FALSE(semaphore.tryAcquire());
            }

            TEST_F(ClientSemaphoreTest, testAvailablePermits) {
                ISemaphore semaphore = client->getISemaphore(randomString());
                semaphore.init(10);
                ASSERT_EQ(10, semaphore.availablePermits());
            }

            TEST_F(ClientSemaphoreTest, testAvailableReducePermits) {
                ISemaphore semaphore = client->getISemaphore(randomString());
                semaphore.init(10);
                semaphore.reducePermits(5);
                ASSERT_EQ(5, semaphore.availablePermits());
            }

            TEST_F(ClientSemaphoreTest, testAvailableReducePermits_WhenZero) {
                ISemaphore semaphore = client->getISemaphore(randomString());
                semaphore.init(0);
                semaphore.reducePermits(1);
                ASSERT_EQ(-1, semaphore.availablePermits());
            }

            TEST_F(ClientSemaphoreTest, testAvailableIncreasePermits) {
                ISemaphore semaphore = client->getISemaphore(randomString());
                semaphore.init(10);
                semaphore.drainPermits();
                semaphore.increasePermits(5);
                ASSERT_EQ(5, semaphore.availablePermits());
            }

            TEST_F(ClientSemaphoreTest, testSimpleAcquire) {
                ISemaphore semaphore = client->getISemaphore("testSimpleAcquire");
                int numberOfPermits = 20;
                ASSERT_TRUE(semaphore.init(numberOfPermits));
                for (int i = 0; i < numberOfPermits; i++) {
                    ASSERT_EQ(numberOfPermits - i, semaphore.availablePermits());
                    semaphore.acquire();
                }

                ASSERT_EQ(semaphore.availablePermits(), 0);
            }

            TEST_F(ClientSemaphoreTest, testAcquire) {
                ISemaphore semaphore = client->getISemaphore("testAcquire");
                semaphore.init(10);
                ASSERT_EQ(10, semaphore.drainPermits());

                hazelcast::util::CountDownLatch latch(1);
                hazelcast::util::StartedThread t(testAcquireThread, &semaphore, &latch);

                hazelcast::util::sleep(1);

                semaphore.release(2);
                ASSERT_TRUE(latch.await(10));
                ASSERT_EQ(1, semaphore.availablePermits());

            }

            void testTryAcquireThread(hazelcast::util::ThreadArgs &args) {
                ISemaphore *s = (ISemaphore *) args.arg0;
                hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg1;
                if (s->tryAcquire(2, 5 * 1000)) {
                    latch->countDown();
                }
            }

            TEST_F(ClientSemaphoreTest, testTryAcquire) {
                ISemaphore semaphore = client->getISemaphore("testTryAcquire");
                semaphore.init(10);
                ASSERT_TRUE(semaphore.tryAcquire());
                ASSERT_TRUE(semaphore.tryAcquire(9));
                ASSERT_EQ(0, semaphore.availablePermits());
                ASSERT_FALSE(semaphore.tryAcquire(1 * 1000));
                ASSERT_FALSE(semaphore.tryAcquire(2, 1 * 1000));

                hazelcast::util::CountDownLatch latch(1);

                hazelcast::util::StartedThread t(testTryAcquireThread, &semaphore, &latch);

                semaphore.release(2);
                ASSERT_TRUE(latch.await(10));
                ASSERT_EQ(0, semaphore.availablePermits());
            }
        }
    }
}


//
//  ClientAtomiclLong.h
//  hazelcast
//
//  Created by Sancar on 02.08.2013.
//  Copyright (c) 2013 Sancar. All rights reserved.
//


namespace hazelcast {
    namespace client {
        namespace test {
            class IAtomicLongTest : public ClientTestSupport {
            public:
                IAtomicLongTest();

            protected:
                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                }

                static void TearDownTestCase() {
                    delete instance;
                }

                ClientConfig clientConfig;
                HazelcastClient client;
                std::unique_ptr<IAtomicLong> l;

                static HazelcastServer *instance;
            };

            HazelcastServer *IAtomicLongTest::instance = NULL;

            IAtomicLongTest::IAtomicLongTest() : client(getNewClient()),
                                                 l(new IAtomicLong(client.getIAtomicLong(getTestName()))) {
                l->set(0);
            }

            TEST_F(IAtomicLongTest, testSync) {
                ASSERT_EQ(0, l->getAndAdd(2));
                ASSERT_EQ(2, l->get());
                l->set(5);
                ASSERT_EQ(5, l->get());
                ASSERT_EQ(8, l->addAndGet(3));
                ASSERT_FALSE(l->compareAndSet(7, 4));
                ASSERT_EQ(8, l->get());
                ASSERT_TRUE(l->compareAndSet(8, 4));
                ASSERT_EQ(4, l->get());
                ASSERT_EQ(3, l->decrementAndGet());
                ASSERT_EQ(3, l->getAndIncrement());
                ASSERT_EQ(4, l->getAndSet(9));
                ASSERT_EQ(10, l->incrementAndGet());
            }

            TEST_F(IAtomicLongTest, testAsync) {
                std::shared_ptr<ICompletableFuture<int64_t> > future = l->getAndAddAsync(10);
                ASSERT_EQ(0, *future->get());

                std::shared_ptr<ICompletableFuture<bool> > booleanFuture = l->compareAndSetAsync(10, 42);
                ASSERT_TRUE(booleanFuture->get());

                future = l->getAsync();
                ASSERT_EQ(42, *future->get());

                future = l->incrementAndGetAsync();
                ASSERT_EQ(43, *future->get());

                future = l->addAndGetAsync(-13);
                ASSERT_EQ(30, *future->get());

                future = l->decrementAndGetAsync();
                ASSERT_EQ(29, *future->get());

                future = l->getAndSetAsync(15);
                ASSERT_EQ(29, *future->get());

                future = l->getAsync();
                ASSERT_EQ(15, *future->get());

                future = l->getAndIncrementAsync();
                ASSERT_EQ(15, *future->get());

                future = l->getAsync();
                ASSERT_EQ(16, *future->get());

                std::shared_ptr<ICompletableFuture<void> > voidFuture = l->setAsync(55);
                voidFuture->get();

                future = l->getAsync();
                ASSERT_EQ(55, *future->get());
            }
        }
    }
}






using namespace hazelcast::client::mixedtype;

namespace hazelcast {
    namespace client {
        namespace test {
            class MixedMultiMapTest : public ClientTestSupport {
            protected:
                class MyMultiMapListener : public MixedEntryListener {
                public:
                    MyMultiMapListener(hazelcast::util::CountDownLatch& addedLatch, hazelcast::util::CountDownLatch& removedLatch)
                            : addedLatch(addedLatch), removedLatch(removedLatch) {
                    }

                    virtual void entryUpdated(const MixedEntryEvent &event) {
                    }

                    virtual void entryEvicted(const MixedEntryEvent &event) {
                    }

                    virtual void entryExpired(const MixedEntryEvent &event) {
                    }

                    virtual void entryMerged(const MixedEntryEvent &event) {
                    }

                    virtual void mapEvicted(const MapEvent &event) {
                    }

                    virtual void mapCleared(const MapEvent &event) {
                    }

                    virtual void entryAdded(const MixedEntryEvent &event) {
                        addedLatch.countDown();

                    }

                    virtual void entryRemoved(const MixedEntryEvent &event) {
                        removedLatch.countDown();
                    }

                private:
                    hazelcast::util::CountDownLatch& addedLatch;
                    hazelcast::util::CountDownLatch& removedLatch;
                };

                static void lockTtlThread(hazelcast::util::ThreadArgs& args) {
                    mixedtype::MultiMap *map = (mixedtype::MultiMap *)args.arg0;
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *)args.arg1;

                    if (!map->tryLock<std::string>("key1")) {
                        latch->countDown();
                    }

                    if (map->tryLock<std::string>("key1", 5 * 1000)) {
                        latch->countDown();
                    }
                }

                static void forceUnlockThread(hazelcast::util::ThreadArgs& args) {
                    mixedtype::MultiMap *mm = (mixedtype::MultiMap *)args.arg0;
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *)args.arg1;
                    mm->forceUnlock<std::string>("key1");
                    latch->countDown();
                }

                static void lockThread(hazelcast::util::ThreadArgs& args) {
                    mixedtype::MultiMap *mm = (mixedtype::MultiMap *)args.arg0;
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *)args.arg1;
                    if (!mm->tryLock<std::string>("key1")) {
                        latch->countDown();
                    }
                }

                static void tryLockThread(hazelcast::util::ThreadArgs& args) {
                    mixedtype::MultiMap *mm = (mixedtype::MultiMap *)args.arg0;
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *)args.arg1;
                    try {
                        if (!mm->tryLock<std::string>("key1", 2)) {
                            latch->countDown();
                        }
                    } catch (...) {
                        std::cerr << "Unexpected exception at MixedMultiMapTest tryLockThread" << std::endl;
                    }
                }

                static void tryLockThread2(hazelcast::util::ThreadArgs& args) {
                    mixedtype::MultiMap *mm = (mixedtype::MultiMap *)args.arg0;
                    hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *)args.arg1;
                    try {
                        if (mm->tryLock<std::string>("key1", 20 * 1000)) {
                            latch->countDown();
                        }
                    } catch (...) {
                        std::cerr << "Unexpected exception at MixedMultiMapTest lockThread2" << std::endl;
                    }
                }

                virtual void TearDown() {
                    // clear mm
                    mm->clear();
                }

                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    client = new HazelcastClient;
                    mm = new mixedtype::MultiMap(client->toMixedType().getMultiMap("MixedMultimapTestMap"));
                }

                static void TearDownTestCase() {
                    delete mm;
                    delete client;
                    delete instance;

                    mm = NULL;
                    client = NULL;
                    instance = NULL;
                }

                static HazelcastServer *instance;
                static HazelcastClient *client;
                static mixedtype::MultiMap *mm;
            };

            HazelcastServer *MixedMultiMapTest::instance = NULL;
            HazelcastClient *MixedMultiMapTest::client = NULL;
            mixedtype::MultiMap *MixedMultiMapTest::mm = NULL;

            TEST_F(MixedMultiMapTest, testPutGetRemove) {
                ASSERT_TRUE((mm->put<std::string, std::string>("key1", "value1")));
                ASSERT_TRUE((mm->put<std::string, std::string>("key1", "value2")));
                ASSERT_TRUE((mm->put<std::string, std::string>("key1", "value3")));

                ASSERT_TRUE((mm->put<std::string, std::string>("key2", "value4")));
                ASSERT_TRUE((mm->put<std::string, std::string>("key2", "value5")));

                ASSERT_EQ(3, mm->valueCount<std::string>("key1"));
                ASSERT_EQ(2, mm->valueCount<std::string>("key2"));
                ASSERT_EQ(5, mm->size());

                std::vector<TypedData> coll = mm->get<std::string>("key1");
                ASSERT_EQ(3, (int) coll.size());

                coll = mm->remove<std::string>("key2");
                ASSERT_EQ(2, (int) coll.size());
                ASSERT_EQ(0, mm->valueCount<std::string>("key2"));
                ASSERT_EQ(0, (int) mm->get<std::string>("key2").size());

                ASSERT_FALSE((mm->remove<std::string, std::string>("key1", "value4")));
                ASSERT_EQ(3, mm->size());

                ASSERT_TRUE((mm->remove<std::string, std::string>("key1", "value2")));
                ASSERT_EQ(2, mm->size());

                ASSERT_TRUE((mm->remove<std::string, std::string>("key1", "value1")));
                ASSERT_EQ(1, mm->size());
                coll = mm->get<std::string>("key1");
                std::unique_ptr<std::string> val = coll[0].get<std::string>();
                ASSERT_NE((std::string *) NULL, val.get());
                ASSERT_EQ("value3", *val);
            }

            TEST_F(MixedMultiMapTest, testKeySetEntrySetAndValues) {
                ASSERT_TRUE((mm->put<std::string, std::string>("key1", "value1")));
                ASSERT_TRUE((mm->put<std::string, std::string>("key1", "value2")));
                ASSERT_TRUE((mm->put<std::string, std::string>("key1", "value3")));

                ASSERT_TRUE((mm->put<std::string, std::string>("key2", "value4")));
                ASSERT_TRUE((mm->put<std::string, std::string>("key2", "value5")));


                ASSERT_EQ(2, (int) mm->keySet().size());
                ASSERT_EQ(5, (int) mm->values().size());
                ASSERT_EQ(5, (int) mm->entrySet().size());
            }

            TEST_F(MixedMultiMapTest, testContains) {
                ASSERT_TRUE((mm->put<std::string, std::string>("key1", "value1")));
                ASSERT_TRUE((mm->put<std::string, std::string>("key1", "value2")));
                ASSERT_TRUE((mm->put<std::string, std::string>("key1", "value3")));

                ASSERT_TRUE((mm->put<std::string, std::string>("key2", "value4")));
                ASSERT_TRUE((mm->put<std::string, std::string>("key2", "value5")));

                ASSERT_FALSE(mm->containsKey<std::string>("key3"));
                ASSERT_TRUE(mm->containsKey<std::string>("key1"));

                ASSERT_FALSE(mm->containsValue<std::string>("value6"));
                ASSERT_TRUE(mm->containsValue<std::string>("value4"));

                ASSERT_FALSE((mm->containsEntry<std::string, std::string>("key1", "value4")));
                ASSERT_FALSE((mm->containsEntry<std::string, std::string>("key2", "value3")));
                ASSERT_TRUE((mm->containsEntry<std::string, std::string>("key1", "value1")));
                ASSERT_TRUE((mm->containsEntry<std::string, std::string>("key2", "value5")));
            }

            TEST_F(MixedMultiMapTest, testListener) {
                hazelcast::util::CountDownLatch latch1Add(8);
                hazelcast::util::CountDownLatch latch1Remove(4);

                hazelcast::util::CountDownLatch latch2Add(3);
                hazelcast::util::CountDownLatch latch2Remove(3);

                MyMultiMapListener mmener1(latch1Add, latch1Remove);
                MyMultiMapListener mmener2(latch2Add, latch2Remove);

                std::string id1 = mm->addEntryListener(mmener1, true);
                std::string id2 = mm->addEntryListener<std::string>(mmener2, "key3", true);

                mm->put<std::string, std::string>("key1", "value1");
                mm->put<std::string, std::string>("key1", "value2");
                mm->put<std::string, std::string>("key1", "value3");
                mm->put<std::string, std::string>("key2", "value4");
                mm->put<std::string, std::string>("key2", "value5");

                mm->remove<std::string, std::string>("key1", "value2");

                mm->put<std::string, std::string>("key3", "value6");
                mm->put<std::string, std::string>("key3", "value7");
                mm->put<std::string, std::string>("key3", "value8");

                mm->remove<std::string>("key3");

                ASSERT_TRUE(latch1Add.await(20));
                ASSERT_TRUE(latch1Remove.await(20));

                ASSERT_TRUE(latch2Add.await(20));
                ASSERT_TRUE(latch2Remove.await(20));

                ASSERT_TRUE(mm->removeEntryListener(id1));
                ASSERT_TRUE(mm->removeEntryListener(id2));

            }

            TEST_F(MixedMultiMapTest, testLock) {
                mm->lock<std::string>("key1");
                hazelcast::util::CountDownLatch latch(1);
                hazelcast::util::StartedThread t(lockThread, mm, &latch);
                ASSERT_TRUE(latch.await(5));
                mm->forceUnlock<std::string>("key1");
                t.join();
            }

            TEST_F(MixedMultiMapTest, testLockTtl) {
                mm->lock<std::string>("key1", 3 * 1000);
                hazelcast::util::CountDownLatch latch(2);
                hazelcast::util::StartedThread t(lockTtlThread, mm, &latch);
                ASSERT_TRUE(latch.await(10));
                mm->forceUnlock<std::string>("key1");
                t.join();
            }

            TEST_F(MixedMultiMapTest, testTryLock) {
                ASSERT_TRUE(mm->tryLock<std::string>("key1", 2 * 1000));
                hazelcast::util::CountDownLatch latch(1);
                hazelcast::util::StartedThread t(tryLockThread, mm, &latch);
                ASSERT_TRUE(latch.await(100));
                ASSERT_TRUE(mm->isLocked<std::string>("key1"));

                hazelcast::util::CountDownLatch latch2(1);
                hazelcast::util::StartedThread t2(tryLockThread2, mm, &latch2);

                hazelcast::util::sleep(1);
                mm->unlock<std::string>("key1");
                ASSERT_TRUE(latch2.await(100));
                ASSERT_TRUE(mm->isLocked<std::string>("key1"));
                mm->forceUnlock<std::string>("key1");
            }

            TEST_F(MixedMultiMapTest, testForceUnlock) {
                mm->lock<std::string>("key1");
                hazelcast::util::CountDownLatch latch(1);
                hazelcast::util::StartedThread t(forceUnlockThread, mm, &latch);
                ASSERT_TRUE(latch.await(100));
                ASSERT_FALSE(mm->isLocked<std::string>("key1"));
            }
        }
    }
}

//
// Created by sancar koyunlu on 8/27/13.



namespace hazelcast {
    namespace client {
        namespace test {
            class ClientMultiMapTest : public ClientTestSupport {
            protected:
                virtual void TearDown() {
                    // clear mm
                    mm->clear();
                }

                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    client = new HazelcastClient(getConfig());
                    mm = new MultiMap<std::string, std::string>(client->getMultiMap<std::string, std::string>("MyMultiMap"));
                }

                static void TearDownTestCase() {
                    delete mm;
                    delete client;
                    delete instance;

                    mm = NULL;
                    client = NULL;
                    instance = NULL;
                }

                static HazelcastServer *instance;
                static HazelcastClient *client;
                static MultiMap<std::string, std::string> *mm;
            };

            HazelcastServer *ClientMultiMapTest::instance = NULL;
            HazelcastClient *ClientMultiMapTest::client = NULL;
            MultiMap<std::string, std::string> *ClientMultiMapTest::mm = NULL;

            TEST_F(ClientMultiMapTest, testPutGetRemove) {
                ASSERT_TRUE(mm->put("key1", "value1"));
                ASSERT_TRUE(mm->put("key1", "value2"));
                ASSERT_TRUE(mm->put("key1", "value3"));

                ASSERT_TRUE(mm->put("key2", "value4"));
                ASSERT_TRUE(mm->put("key2", "value5"));

                ASSERT_EQ(3, mm->valueCount("key1"));
                ASSERT_EQ(2, mm->valueCount("key2"));
                ASSERT_EQ(5, mm->size());

                std::vector<std::string> coll = mm->get("key1");
                ASSERT_EQ(3, (int) coll.size());

                coll = mm->remove("key2");
                ASSERT_EQ(2, (int) coll.size());
                ASSERT_EQ(0, mm->valueCount("key2"));
                ASSERT_EQ(0, (int) mm->get("key2").size());

                ASSERT_FALSE(mm->remove("key1", "value4"));
                ASSERT_EQ(3, mm->size());

                ASSERT_TRUE(mm->remove("key1", "value2"));
                ASSERT_EQ(2, mm->size());

                ASSERT_TRUE(mm->remove("key1", "value1"));
                ASSERT_EQ(1, mm->size());
                ASSERT_EQ("value3", mm->get("key1")[0]);
            }


            TEST_F(ClientMultiMapTest, testKeySetEntrySetAndValues) {
                ASSERT_TRUE(mm->put("key1", "value1"));
                ASSERT_TRUE(mm->put("key1", "value2"));
                ASSERT_TRUE(mm->put("key1", "value3"));

                ASSERT_TRUE(mm->put("key2", "value4"));
                ASSERT_TRUE(mm->put("key2", "value5"));


                ASSERT_EQ(2, (int) mm->keySet().size());
                ASSERT_EQ(5, (int) mm->values().size());
                ASSERT_EQ(5, (int) mm->entrySet().size());
            }


            TEST_F(ClientMultiMapTest, testContains) {
                ASSERT_TRUE(mm->put("key1", "value1"));
                ASSERT_TRUE(mm->put("key1", "value2"));
                ASSERT_TRUE(mm->put("key1", "value3"));

                ASSERT_TRUE(mm->put("key2", "value4"));
                ASSERT_TRUE(mm->put("key2", "value5"));

                ASSERT_FALSE(mm->containsKey("key3"));
                ASSERT_TRUE(mm->containsKey("key1"));

                ASSERT_FALSE(mm->containsValue("value6"));
                ASSERT_TRUE(mm->containsValue("value4"));

                ASSERT_FALSE(mm->containsEntry("key1", "value4"));
                ASSERT_FALSE(mm->containsEntry("key2", "value3"));
                ASSERT_TRUE(mm->containsEntry("key1", "value1"));
                ASSERT_TRUE(mm->containsEntry("key2", "value5"));
            }

            class MyMultiMapListener : public EntryAdapter<std::string, std::string> {
            public:
                MyMultiMapListener(hazelcast::util::CountDownLatch &addedLatch,
                                   hazelcast::util::CountDownLatch &removedLatch)
                        : addedLatch(addedLatch), removedLatch(removedLatch) {
                }

                void entryAdded(const EntryEvent<std::string, std::string> &event) {
                    addedLatch.countDown();
                }

                void entryRemoved(const EntryEvent<std::string, std::string> &event) {
                    removedLatch.countDown();
                }

            private:
                hazelcast::util::CountDownLatch &addedLatch;
                hazelcast::util::CountDownLatch &removedLatch;
            };

            TEST_F(ClientMultiMapTest, testListener) {
                hazelcast::util::CountDownLatch latch1Add(8);
                hazelcast::util::CountDownLatch latch1Remove(4);

                hazelcast::util::CountDownLatch latch2Add(3);
                hazelcast::util::CountDownLatch latch2Remove(3);

                MyMultiMapListener listener1(latch1Add, latch1Remove);
                MyMultiMapListener listener2(latch2Add, latch2Remove);

                std::string id1 = mm->addEntryListener(listener1, true);
                std::string id2 = mm->addEntryListener(listener2, "key3", true);

                mm->put("key1", "value1");
                mm->put("key1", "value2");
                mm->put("key1", "value3");
                mm->put("key2", "value4");
                mm->put("key2", "value5");

                mm->remove("key1", "value2");

                mm->put("key3", "value6");
                mm->put("key3", "value7");
                mm->put("key3", "value8");

                mm->remove("key3");

                ASSERT_TRUE(latch1Add.await(20));
                ASSERT_TRUE(latch1Remove.await(20));

                ASSERT_TRUE(latch2Add.await(20));
                ASSERT_TRUE(latch2Remove.await(20));

                ASSERT_TRUE(mm->removeEntryListener(id1));
                ASSERT_TRUE(mm->removeEntryListener(id2));

            }

            void lockThread(hazelcast::util::ThreadArgs &args) {
                MultiMap<std::string, std::string> *mm = (MultiMap<std::string, std::string> *) args.arg0;
                hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg1;
                if (!mm->tryLock("key1")) {
                    latch->countDown();
                }
            }

            TEST_F(ClientMultiMapTest, testLock) {
                mm->lock("key1");
                hazelcast::util::CountDownLatch latch(1);
                hazelcast::util::StartedThread t(lockThread, mm, &latch);
                ASSERT_TRUE(latch.await(5));
                mm->forceUnlock("key1");
            }

            void lockTtlThread(hazelcast::util::ThreadArgs &args) {
                MultiMap<std::string, std::string> *mm = (MultiMap<std::string, std::string> *) args.arg0;
                hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg1;

                if (!mm->tryLock("key1")) {
                    latch->countDown();
                }

                if (mm->tryLock("key1", 5 * 1000)) {
                    latch->countDown();
                }
            }

            TEST_F(ClientMultiMapTest, testLockTtl) {
                mm->lock("key1", 3 * 1000);
                hazelcast::util::CountDownLatch latch(2);
                hazelcast::util::StartedThread t(lockTtlThread, mm, &latch);
                ASSERT_TRUE(latch.await(10));
                mm->forceUnlock("key1");
            }


            void tryLockThread(hazelcast::util::ThreadArgs &args) {
                MultiMap<std::string, std::string> *mm = (MultiMap<std::string, std::string> *) args.arg0;
                hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg1;
                try {
                    if (!mm->tryLock("key1", 2)) {
                        latch->countDown();
                    }
                } catch (...) {
                    std::cerr << "Unexpected exception at ClientMultiMapTest tryLockThread" << std::endl;
                }
            }

            void tryLockThread2(hazelcast::util::ThreadArgs &args) {
                MultiMap<std::string, std::string> *mm = (MultiMap<std::string, std::string> *) args.arg0;
                hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg1;
                try {
                    if (mm->tryLock("key1", 20 * 1000)) {
                        latch->countDown();
                    }
                } catch (...) {
                    std::cerr << "Unexpected exception at ClientMultiMapTest lockThread2" << std::endl;
                }
            }

            TEST_F(ClientMultiMapTest, testTryLock) {
                ASSERT_TRUE(mm->tryLock("key1", 2 * 1000));
                hazelcast::util::CountDownLatch latch(1);
                hazelcast::util::StartedThread t(tryLockThread, mm, &latch);
                ASSERT_TRUE(latch.await(100));
                ASSERT_TRUE(mm->isLocked("key1"));

                hazelcast::util::CountDownLatch latch2(1);
                hazelcast::util::StartedThread t2(tryLockThread2, mm, &latch2);

                hazelcast::util::sleep(1);
                mm->unlock("key1");
                ASSERT_TRUE(latch2.await(100));
                ASSERT_TRUE(mm->isLocked("key1"));
                mm->forceUnlock("key1");
            }

            void forceUnlockThread(hazelcast::util::ThreadArgs &args) {
                MultiMap<std::string, std::string> *mm = (MultiMap<std::string, std::string> *) args.arg0;
                hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg1;
                mm->forceUnlock("key1");
                latch->countDown();
            }

            TEST_F(ClientMultiMapTest, testForceUnlock) {
                mm->lock("key1");
                hazelcast::util::CountDownLatch latch(1);
                hazelcast::util::StartedThread t(forceUnlockThread, mm, &latch);
                ASSERT_TRUE(latch.await(100));
                ASSERT_FALSE(mm->isLocked("key1"));
            }
        }
    }
}




using namespace hazelcast::client::mixedtype;

namespace hazelcast {
    namespace client {
        namespace test {
            class MixedListTest : public ClientTestSupport {
            protected:
                class MyListItemListener : public MixedItemListener {
                public:
                    MyListItemListener(hazelcast::util::CountDownLatch& latch)
                            : latch(latch) {

                    }

                    virtual void itemAdded(const ItemEvent<TypedData> &item) {
                        latch.countDown();
                    }

                    virtual void itemRemoved(const ItemEvent<TypedData> &item) {
                    }
                private:
                    hazelcast::util::CountDownLatch& latch;
                };

                virtual void TearDown() {
                    // clear list
                    list->clear();
                }

                static void SetUpTestCase() {
#ifdef HZ_BUILD_WITH_SSL
                    sslFactory = new HazelcastServerFactory(g_srvFactory->getServerAddress(), getSslFilePath());
                    instance = new HazelcastServer(*sslFactory);
#else
                    instance = new HazelcastServer(*g_srvFactory);
#endif

                    ClientConfig clientConfig = getConfig();

#ifdef HZ_BUILD_WITH_SSL
                    config::ClientNetworkConfig networkConfig;
                    config::SSLConfig sslConfig;
                    sslConfig.setEnabled(true).addVerifyFile(getCAFilePath()).setCipherList("HIGH");
                    networkConfig.setSSLConfig(sslConfig);
                    clientConfig.setNetworkConfig(networkConfig);
#endif // HZ_BUILD_WITH_SSL

                    client = new HazelcastClient(clientConfig);
                    list = new mixedtype::IList(client->toMixedType().getList("MyMixedList"));
                }

                static void TearDownTestCase() {
                    delete list;
                    delete client;
                    delete instance;
                    delete sslFactory;

                    list = NULL;
                    client = NULL;
                    instance = NULL;
                }

                static HazelcastServer *instance;
                static HazelcastClient *client;
                static mixedtype::IList *list;
                static HazelcastServerFactory *sslFactory;
            };

            HazelcastServer *MixedListTest::instance = NULL;
            HazelcastClient *MixedListTest::client = NULL;
            mixedtype::IList *MixedListTest::list = NULL;
            HazelcastServerFactory *MixedListTest::sslFactory = NULL;

            TEST_F(MixedListTest, testAddAll) {
                std::vector<std::string> l;
                l.push_back("item1");
                l.push_back("item2");
                ASSERT_TRUE(list->addAll<std::string>(l));

                ASSERT_TRUE(list->addAll<std::string>(1, l));
                ASSERT_EQ(4, list->size());

                ASSERT_EQ("item1", *(list->get(0).get<std::string>()));
                ASSERT_EQ("item1", *(list->get(1).get<std::string>()));
                ASSERT_EQ("item2", *(list->get(2).get<std::string>()));
                ASSERT_EQ("item2", *(list->get(3).get<std::string>()));
            }

            TEST_F(MixedListTest, testAddSetRemove) {
                ASSERT_TRUE(list->add<std::string>("item1"));
                ASSERT_TRUE(list->add<std::string>("item2"));
                list->add<std::string>(0, "item3");
                ASSERT_EQ(3, list->size());
                std::unique_ptr<std::string> temp = list->IList::set<std::string>(2, "item4").get<std::string>();
                ASSERT_EQ("item2", *temp);

                ASSERT_EQ(3, list->size());
                ASSERT_EQ("item3", *(list->get(0).get<std::string>()));
                ASSERT_EQ("item1", *(list->get(1).get<std::string>()));
                ASSERT_EQ("item4", *(list->get(2).get<std::string>()));

                ASSERT_FALSE(list->remove<std::string>("item2"));
                ASSERT_TRUE(list->remove<std::string>("item3"));

                temp = list->remove(1).get<std::string>();
                ASSERT_EQ("item4", *temp);

                ASSERT_EQ(1, list->size());
                ASSERT_EQ("item1", *(list->get(0).get<std::string>()));
            }

            TEST_F(MixedListTest, testIndexOf) {
                ASSERT_TRUE(list->add<std::string>("item1"));
                ASSERT_TRUE(list->add<std::string>("item2"));
                ASSERT_TRUE(list->add<std::string>("item1"));
                ASSERT_TRUE(list->add<std::string>("item4"));

                ASSERT_EQ(-1, list->indexOf<std::string>("item5"));
                ASSERT_EQ(0, list->indexOf<std::string>("item1"));

                ASSERT_EQ(-1, list->lastIndexOf<std::string>("item6"));
                ASSERT_EQ(2, list->lastIndexOf<std::string>("item1"));
            }

            TEST_F(MixedListTest, testToArray) {
                ASSERT_TRUE(list->add<std::string>("item1"));
                ASSERT_TRUE(list->add<std::string>("item2"));
                ASSERT_TRUE(list->add<std::string>("item1"));
                ASSERT_TRUE(list->add<std::string>("item4"));

                std::vector<TypedData> ar = list->toArray();

                ASSERT_EQ("item1", *ar[0].get<std::string>());
                ASSERT_EQ("item2", *ar[1].get<std::string>());
                ASSERT_EQ("item1", *ar[2].get<std::string>());
                ASSERT_EQ("item4", *ar[3].get<std::string>());

                std::vector<TypedData> arr2 = list->subList(1, 3);

                ASSERT_EQ(2, (int) arr2.size());
                ASSERT_EQ("item2", *arr2[0].get<std::string>());
                ASSERT_EQ("item1", *arr2[1].get<std::string>());
            }

            TEST_F(MixedListTest, testContains) {
                ASSERT_TRUE(list->add<std::string>("item1"));
                ASSERT_TRUE(list->add<std::string>("item2"));
                ASSERT_TRUE(list->add<std::string>("item1"));
                ASSERT_TRUE(list->add<std::string>("item4"));

                ASSERT_FALSE(list->contains<std::string>("item3"));
                ASSERT_TRUE(list->contains<std::string>("item2"));

                std::vector<std::string> l;
                l.push_back("item4");
                l.push_back("item3");

                ASSERT_FALSE(list->containsAll<std::string>(l));
                ASSERT_TRUE(list->add<std::string>("item3"));
                ASSERT_TRUE(list->containsAll<std::string>(l));
            }

            TEST_F(MixedListTest, testRemoveRetainAll) {
                ASSERT_TRUE(list->add<std::string>("item1"));
                ASSERT_TRUE(list->add<std::string>("item2"));
                ASSERT_TRUE(list->add<std::string>("item1"));
                ASSERT_TRUE(list->add<std::string>("item4"));

                std::vector<std::string> l;
                l.push_back("item4");
                l.push_back("item3");

                ASSERT_TRUE(list->removeAll<std::string>(l));
                ASSERT_EQ(3, (int) list->size());
                ASSERT_FALSE(list->removeAll<std::string>(l));
                ASSERT_EQ(3, (int) list->size());

                l.clear();
                l.push_back("item1");
                l.push_back("item2");
                ASSERT_FALSE(list->retainAll<std::string>(l));
                ASSERT_EQ(3, (int) list->size());

                l.clear();
                ASSERT_TRUE(list->retainAll<std::string>(l));
                ASSERT_EQ(0, (int) list->size());

            }

            TEST_F(MixedListTest, testListener) {
                hazelcast::util::CountDownLatch latch(5);

                MyListItemListener listener(latch);
                std::string registrationId = list->addItemListener(listener, true);

                for (int i = 0; i < 5; i++) {
                    list->add(std::string("item") + hazelcast::util::IOUtil::to_string(i));
                }

                ASSERT_TRUE(latch.await(20));

                ASSERT_TRUE(list->removeItemListener(registrationId));
            }
        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            class ClientListTest : public ClientTestSupport {
            protected:
                class MyListItemListener : public ItemListener<std::string> {
                public:
                    MyListItemListener(hazelcast::util::CountDownLatch& latch)
                            : latch(latch) {

                    }

                    void itemAdded(const ItemEvent<std::string>& itemEvent) {
                        int type = itemEvent.getEventType();
                        assertEquals((int) ItemEventType::ADDED, type);
                        assertEquals("MyList", itemEvent.getName());
                        std::string host = itemEvent.getMember().getAddress().getHost();
                        assertTrue(host == "localhost" || host == "127.0.0.1");
                        assertEquals(5701, itemEvent.getMember().getAddress().getPort());
                        assertEquals("item-1", itemEvent.getItem());
                        latch.countDown();
                    }

                    void itemRemoved(const ItemEvent<std::string>& item) {
                    }

                private:
                    hazelcast::util::CountDownLatch& latch;
                };

                virtual void TearDown() {
                    // clear list
                    list->clear();
                }

                static void SetUpTestCase() {
#ifdef HZ_BUILD_WITH_SSL
                    sslFactory = new HazelcastServerFactory(g_srvFactory->getServerAddress(), getSslFilePath());
                    instance = new HazelcastServer(*sslFactory);
#else
                    instance = new HazelcastServer(*g_srvFactory);
#endif

                    ClientConfig clientConfig = getConfig();

#ifdef HZ_BUILD_WITH_SSL
                    config::ClientNetworkConfig networkConfig;
                    config::SSLConfig sslConfig;
                    sslConfig.setEnabled(true).addVerifyFile(getCAFilePath()).setCipherList("HIGH");
                    networkConfig.setSSLConfig(sslConfig);
                    clientConfig.setNetworkConfig(networkConfig);
#endif // HZ_BUILD_WITH_SSL

                    client = new HazelcastClient(clientConfig);
                    list = new IList<std::string>(client->getList<std::string>("MyList"));
                }

                static void TearDownTestCase() {
                    delete list;
                    delete client;
                    delete instance;
                    delete sslFactory;

                    list = NULL;
                    client = NULL;
                    instance = NULL;
                }

                static HazelcastServer *instance;
                static HazelcastClient *client;
                static IList<std::string> *list;
                static HazelcastServerFactory *sslFactory;
            };

            HazelcastServer *ClientListTest::instance = NULL;
            HazelcastClient *ClientListTest::client = NULL;
            IList<std::string> *ClientListTest::list = NULL;
            HazelcastServerFactory *ClientListTest::sslFactory = NULL;

            TEST_F(ClientListTest, testAddAll) {
                std::vector<std::string> l;
                l.push_back("item1");
                l.push_back("item2");
                ASSERT_TRUE(list->addAll(l));

                ASSERT_TRUE(list->addAll(1, l));
                ASSERT_EQ(4, list->size());

                ASSERT_EQ("item1", *(list->get(0)));
                ASSERT_EQ("item1", *(list->get(1)));
                ASSERT_EQ("item2", *(list->get(2)));
                ASSERT_EQ("item2", *(list->get(3)));
            }

            TEST_F(ClientListTest, testAddSetRemove) {
                ASSERT_TRUE(list->add("item1"));
                ASSERT_TRUE(list->add("item2"));
                list->add(0, "item3");
                ASSERT_EQ(3, list->size());
                std::shared_ptr<std::string> temp = list->set(2, "item4");
                ASSERT_EQ("item2", *temp);

                ASSERT_EQ(3, list->size());
                ASSERT_EQ("item3", *(list->get(0)));
                ASSERT_EQ("item1", *(list->get(1)));
                ASSERT_EQ("item4", *(list->get(2)));

                ASSERT_FALSE(list->remove("item2"));
                ASSERT_TRUE(list->remove("item3"));

                temp = list->remove(1);
                ASSERT_EQ("item4", *temp);

                ASSERT_EQ(1, list->size());
                ASSERT_EQ("item1", *(list->get(0)));
            }

            TEST_F(ClientListTest, testIndexOf) {
                ASSERT_TRUE(list->add("item1"));
                ASSERT_TRUE(list->add("item2"));
                ASSERT_TRUE(list->add("item1"));
                ASSERT_TRUE(list->add("item4"));

                ASSERT_EQ(-1, list->indexOf("item5"));
                ASSERT_EQ(0, list->indexOf("item1"));

                ASSERT_EQ(-1, list->lastIndexOf("item6"));
                ASSERT_EQ(2, list->lastIndexOf("item1"));
            }

            TEST_F(ClientListTest, testToArray) {
                ASSERT_TRUE(list->add("item1"));
                ASSERT_TRUE(list->add("item2"));
                ASSERT_TRUE(list->add("item1"));
                ASSERT_TRUE(list->add("item4"));

                std::vector<std::string> ar = list->toArray();

                ASSERT_EQ("item1", ar[0]);
                ASSERT_EQ("item2", ar[1]);
                ASSERT_EQ("item1", ar[2]);
                ASSERT_EQ("item4", ar[3]);

                std::vector<std::string> arr2 = list->subList(1, 3);

                ASSERT_EQ(2, (int) arr2.size());
                ASSERT_EQ("item2", arr2[0]);
                ASSERT_EQ("item1", arr2[1]);
            }

            TEST_F(ClientListTest, testContains) {
                ASSERT_TRUE(list->add("item1"));
                ASSERT_TRUE(list->add("item2"));
                ASSERT_TRUE(list->add("item1"));
                ASSERT_TRUE(list->add("item4"));

                ASSERT_FALSE(list->contains("item3"));
                ASSERT_TRUE(list->contains("item2"));

                std::vector<std::string> l;
                l.push_back("item4");
                l.push_back("item3");

                ASSERT_FALSE(list->containsAll(l));
                ASSERT_TRUE(list->add("item3"));
                ASSERT_TRUE(list->containsAll(l));
            }

            TEST_F(ClientListTest, testRemoveRetainAll) {
                ASSERT_TRUE(list->add("item1"));
                ASSERT_TRUE(list->add("item2"));
                ASSERT_TRUE(list->add("item1"));
                ASSERT_TRUE(list->add("item4"));

                std::vector<std::string> l;
                l.push_back("item4");
                l.push_back("item3");

                ASSERT_TRUE(list->removeAll(l));
                ASSERT_EQ(3, (int) list->size());
                ASSERT_FALSE(list->removeAll(l));
                ASSERT_EQ(3, (int) list->size());

                l.clear();
                l.push_back("item1");
                l.push_back("item2");
                ASSERT_FALSE(list->retainAll(l));
                ASSERT_EQ(3, (int) list->size());

                l.clear();
                ASSERT_TRUE(list->retainAll(l));
                ASSERT_EQ(0, (int) list->size());

            }

            TEST_F(ClientListTest, testListener) {
                hazelcast::util::CountDownLatch latch(1);

                MyListItemListener listener(latch);
                std::string registrationId = list->addItemListener(listener, true);

                list->add("item-1");

                ASSERT_TRUE(latch.await(20));

                ASSERT_TRUE(list->removeItemListener(registrationId));
            }

            TEST_F(ClientListTest, testIsEmpty) {
                ASSERT_TRUE(list->isEmpty());
                ASSERT_TRUE(list->add("item1"));
                ASSERT_FALSE(list->isEmpty());
            }

        }
    }
}





namespace hazelcast {
    namespace client {
        namespace test {
            class ClientQueueTest : public ClientTestSupport {
            protected:
                virtual void TearDown() {
                    q->clear();
                }

                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    client = new HazelcastClient(getConfig());
                    q = new IQueue<std::string>(client->getQueue<std::string>("MyQueue"));
                }

                static void TearDownTestCase() {
                    delete q;
                    delete client;
                    delete instance;

                    q = NULL;
                    client = NULL;
                    instance = NULL;
                }

                static HazelcastServer *instance;
                static HazelcastClient *client;
                static IQueue<std::string> *q;
            };

            HazelcastServer *ClientQueueTest::instance = NULL;
            HazelcastClient *ClientQueueTest::client = NULL;
            IQueue<std::string> *ClientQueueTest::q = NULL;

            class QueueTestItemListener : public ItemListener<std::string> {
            public:
                QueueTestItemListener(hazelcast::util::CountDownLatch &latch)
                        : latch(latch) {

                }

                void itemAdded(const ItemEvent<std::string> &itemEvent) {
                    latch.countDown();
                }

                void itemRemoved(const ItemEvent<std::string> &item) {
                }

            private:
                hazelcast::util::CountDownLatch &latch;
            };

            TEST_F(ClientQueueTest, testListener) {
                ASSERT_EQ(0, q->size());

                hazelcast::util::CountDownLatch latch(5);

                QueueTestItemListener listener(latch);
                std::string id = q->addItemListener(listener, true);

                hazelcast::util::sleep(1);

                for (int i = 0; i < 5; i++) {
                    ASSERT_TRUE(q->offer(std::string("event_item") + hazelcast::util::IOUtil::to_string(i)));
                }

                ASSERT_TRUE(latch.await(5));
                ASSERT_TRUE(q->removeItemListener(id));

                // added for test coverage
                ASSERT_NO_THROW(q->destroy());
            }

            void testOfferPollThread2(hazelcast::util::ThreadArgs &args) {
                IQueue<std::string> *q = (IQueue<std::string> *) args.arg0;
                hazelcast::util::sleep(2);
                q->offer("item1");
            }

            TEST_F(ClientQueueTest, testOfferPoll) {
                for (int i = 0; i < 10; i++) {
                    bool result = q->offer("item");
                    ASSERT_TRUE(result);
                }
                ASSERT_EQ(10, q->size());
                q->poll();
                bool result = q->offer("item", 5);
                ASSERT_TRUE(result);

                for (int i = 0; i < 10; i++) {
                    ASSERT_NE(q->poll().get(), (std::string *) NULL);
                }
                ASSERT_EQ(0, q->size());

                hazelcast::util::StartedThread t2(testOfferPollThread2, q);

                std::shared_ptr<std::string> item = q->poll(30 * 1000);
                ASSERT_NE(item.get(), (std::string *) NULL);
                ASSERT_EQ("item1", *item);
                t2.join();
            }

            TEST_F(ClientQueueTest, testPeek) {
                ASSERT_TRUE(q->offer("peek 1"));
                ASSERT_TRUE(q->offer("peek 2"));
                ASSERT_TRUE(q->offer("peek 3"));

                std::shared_ptr<std::string> item = q->peek();
                ASSERT_NE((std::string *) NULL, item.get());
                ASSERT_EQ("peek 1", *item);
            }

            TEST_F(ClientQueueTest, testTake) {
                q->put("peek 1");
                ASSERT_TRUE(q->offer("peek 2"));
                ASSERT_TRUE(q->offer("peek 3"));

                std::shared_ptr<std::string> item = q->take();
                ASSERT_NE((std::string *) NULL, item.get());
                ASSERT_EQ("peek 1", *item);

                item = q->take();
                ASSERT_NE((std::string *) NULL, item.get());
                ASSERT_EQ("peek 2", *item);

                item = q->take();
                ASSERT_NE((std::string *) NULL, item.get());
                ASSERT_EQ("peek 3", *item);

                ASSERT_TRUE(q->isEmpty());

// start a thread to insert an item
                hazelcast::util::StartedThread t2(testOfferPollThread2, q);

                item = q->take();  //  should block till it gets an item
                ASSERT_NE((std::string *) NULL, item.get());
                ASSERT_EQ("item1", *item);

                t2.join();
            }

            TEST_F(ClientQueueTest, testRemainingCapacity) {
                int capacity = q->remainingCapacity();
                ASSERT_TRUE(capacity > 10000);
                q->offer("item");
                ASSERT_EQ(capacity - 1, q->remainingCapacity());
            }


            TEST_F(ClientQueueTest, testRemove) {
                ASSERT_TRUE(q->offer("item1"));
                ASSERT_TRUE(q->offer("item2"));
                ASSERT_TRUE(q->offer("item3"));

                ASSERT_FALSE(q->remove("item4"));
                ASSERT_EQ(3, q->size());

                ASSERT_TRUE(q->remove("item2"));

                ASSERT_EQ(2, q->size());

                ASSERT_EQ("item1", *(q->poll()));
                ASSERT_EQ("item3", *(q->poll()));
            }


            TEST_F(ClientQueueTest, testContains) {
                ASSERT_TRUE(q->offer("item1"));
                ASSERT_TRUE(q->offer("item2"));
                ASSERT_TRUE(q->offer("item3"));
                ASSERT_TRUE(q->offer("item4"));
                ASSERT_TRUE(q->offer("item5"));


                ASSERT_TRUE(q->contains("item3"));
                ASSERT_FALSE(q->contains("item"));

                std::vector<std::string> list;
                list.push_back("item4");
                list.push_back("item2");

                ASSERT_TRUE(q->containsAll(list));

                list.push_back("item");
                ASSERT_FALSE(q->containsAll(list));
            }

            TEST_F(ClientQueueTest, testDrain) {
                ASSERT_TRUE(q->offer("item1"));
                ASSERT_TRUE(q->offer("item2"));
                ASSERT_TRUE(q->offer("item3"));
                ASSERT_TRUE(q->offer("item4"));
                ASSERT_TRUE(q->offer("item5"));

                std::vector<std::string> list;
                size_t result = q->drainTo(list, 2);
                ASSERT_EQ(2U, result);
                ASSERT_EQ("item1", list[0]);
                ASSERT_EQ("item2", list[1]);

                std::vector<std::string> list2;
                result = q->drainTo(list2);
                ASSERT_EQ(3U, result);
                ASSERT_EQ("item3", list2[0]);
                ASSERT_EQ("item4", list2[1]);
                ASSERT_EQ("item5", list2[2]);

                ASSERT_TRUE(q->offer("item1"));
                ASSERT_TRUE(q->offer("item2"));
                ASSERT_TRUE(q->offer("item3"));
                list2.clear();
                result = q->drainTo(list2, 5);
                ASSERT_EQ(3U, result);
                ASSERT_EQ("item1", list2[0]);
                ASSERT_EQ("item2", list2[1]);
                ASSERT_EQ("item3", list2[2]);
            }

            TEST_F(ClientQueueTest, testToArray) {
                ASSERT_TRUE(q->offer("item1"));
                ASSERT_TRUE(q->offer("item2"));
                ASSERT_TRUE(q->offer("item3"));
                ASSERT_TRUE(q->offer("item4"));
                ASSERT_TRUE(q->offer("item5"));

                std::vector<std::string> array = q->toArray();
                size_t size = array.size();
                for (size_t i = 0; i < size; i++) {
                    ASSERT_EQ(std::string("item") + hazelcast::util::IOUtil::to_string(i + 1), array[i]);
                }
            }

            TEST_F(ClientQueueTest, testAddAll) {
                std::vector<std::string> coll;
                coll.push_back("item1");
                coll.push_back("item2");
                coll.push_back("item3");
                coll.push_back("item4");

                ASSERT_TRUE(q->addAll(coll));
                int size = q->size();
                ASSERT_EQ(size, (int) coll.size());
            }

            TEST_F(ClientQueueTest, testRemoveRetain) {
                ASSERT_TRUE(q->offer("item1"));
                ASSERT_TRUE(q->offer("item2"));
                ASSERT_TRUE(q->offer("item3"));
                ASSERT_TRUE(q->offer("item4"));
                ASSERT_TRUE(q->offer("item5"));

                std::vector<std::string> list;
                list.push_back("item8");
                list.push_back("item9");
                ASSERT_FALSE(q->removeAll(list));
                ASSERT_EQ(5, q->size());

                list.push_back("item3");
                list.push_back("item4");
                list.push_back("item1");
                ASSERT_TRUE(q->removeAll(list));
                ASSERT_EQ(2, q->size());

                list.clear();
                list.push_back("item2");
                list.push_back("item5");
                ASSERT_FALSE(q->retainAll(list));
                ASSERT_EQ(2, q->size());

                list.clear();
                ASSERT_TRUE(q->retainAll(list));
                ASSERT_EQ(0, q->size());
            }

            TEST_F(ClientQueueTest, testClear) {
                ASSERT_TRUE(q->offer("item1"));
                ASSERT_TRUE(q->offer("item2"));
                ASSERT_TRUE(q->offer("item3"));
                ASSERT_TRUE(q->offer("item4"));
                ASSERT_TRUE(q->offer("item5"));

                q->clear();

                ASSERT_EQ(0, q->size());
                ASSERT_EQ(q->poll().get(), (std::string *) NULL);
            }

            TEST_F(ClientQueueTest, testIsEmpty) {
                ASSERT_TRUE(q->isEmpty());
                ASSERT_TRUE(q->offer("item1"));
                ASSERT_FALSE(q->isEmpty());
            }

            TEST_F(ClientQueueTest, testPut) {
                q->put("item1");
                ASSERT_EQ(1, q->size());
            }
        }
    }
}





using namespace hazelcast::client::mixedtype;

namespace hazelcast {
    namespace client {
        namespace test {
            class MixedQueueTest : public ClientTestSupport {
            protected:
                virtual void TearDown() {
                    q->clear();
                }

                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    client = new HazelcastClient;
                    q = new mixedtype::IQueue(client->toMixedType().getQueue("MyQueue"));
                }

                static void TearDownTestCase() {
                    delete q;
                    delete client;
                    delete instance;

                    q = NULL;
                    client = NULL;
                    instance = NULL;
                }

                static void testOfferPollThread2(hazelcast::util::ThreadArgs &args) {
                    mixedtype::IQueue *queue = (mixedtype::IQueue *) args.arg0;
                    hazelcast::util::sleep(2);
                    queue->offer<std::string>("item1");
                }

                static HazelcastServer *instance;
                static HazelcastClient *client;
                static mixedtype::IQueue *q;
            };

            HazelcastServer *MixedQueueTest::instance = NULL;
            HazelcastClient *MixedQueueTest::client = NULL;
            mixedtype::IQueue *MixedQueueTest::q = NULL;

            class MixedQueueTestItemListener : public MixedItemListener {
            public:
                MixedQueueTestItemListener(hazelcast::util::CountDownLatch &latch)
                        : latch(latch) {
                }

                virtual void itemAdded(const ItemEvent<TypedData> &item) {
                    latch.countDown();
                }

                virtual void itemRemoved(const ItemEvent<TypedData> &item) {
                }

            private:
                hazelcast::util::CountDownLatch &latch;
            };

            TEST_F(MixedQueueTest, testListener) {
                ASSERT_EQ(0, q->size());

                hazelcast::util::CountDownLatch latch(5);

                MixedQueueTestItemListener listener(latch);
                std::string id = q->addItemListener(listener, true);

                hazelcast::util::sleep(1);

                for (int i = 0; i < 5; i++) {
                    ASSERT_TRUE(
                            q->offer<std::string>(std::string("event_item") + hazelcast::util::IOUtil::to_string(i)));
                }

                ASSERT_TRUE(latch.await(5));
                ASSERT_TRUE(q->removeItemListener(id));

                // added for test coverage
                ASSERT_NO_THROW(q->destroy());
            }

            TEST_F(MixedQueueTest, testOfferPoll) {
                for (int i = 0; i < 10; i++) {
                    bool result = q->offer<std::string>("item");
                    ASSERT_TRUE(result);
                }
                ASSERT_EQ(10, q->size());
                q->poll();
                bool result = q->offer<std::string>("item", 5);
                ASSERT_TRUE(result);

                for (int i = 0; i < 10; i++) {
                    ASSERT_NE(q->poll().get<std::string>().get(), (std::string *) NULL);
                }
                ASSERT_EQ(0, q->size());

                hazelcast::util::StartedThread t2(testOfferPollThread2, q);

                std::unique_ptr<std::string> item = q->poll(30 * 1000).get<std::string>();
                ASSERT_NE(item.get(), (std::string *) NULL);
                ASSERT_EQ("item1", *item);
                t2.join();
            }

            TEST_F(MixedQueueTest, testPeek) {
                ASSERT_TRUE(q->offer<std::string>("peek 1"));
                ASSERT_TRUE(q->offer<std::string>("peek 2"));
                ASSERT_TRUE(q->offer<std::string>("peek 3"));

                std::unique_ptr<std::string> item = q->peek().get<std::string>();
                ASSERT_NE((std::string *) NULL, item.get());
                ASSERT_EQ("peek 1", *item);
            }

            TEST_F(MixedQueueTest, testTake) {
                ASSERT_TRUE(q->offer<std::string>("peek 1"));
                ASSERT_TRUE(q->offer<std::string>("peek 2"));
                ASSERT_TRUE(q->offer<std::string>("peek 3"));

                std::unique_ptr<std::string> item = q->take().get<std::string>();
                ASSERT_NE((std::string *) NULL, item.get());
                ASSERT_EQ("peek 1", *item);

                item = q->take().get<std::string>();
                ASSERT_NE((std::string *) NULL, item.get());
                ASSERT_EQ("peek 2", *item);

                item = q->take().get<std::string>();
                ASSERT_NE((std::string *) NULL, item.get());
                ASSERT_EQ("peek 3", *item);

                ASSERT_TRUE(q->isEmpty());

// start a thread to insert an item
                hazelcast::util::StartedThread t2(testOfferPollThread2, q);

                item = q->take().get<std::string>();  //  should block till it gets an item
                ASSERT_NE((std::string *) NULL, item.get());
                ASSERT_EQ("item1", *item);

                t2.join();
            }

            TEST_F(MixedQueueTest, testRemainingCapacity) {
                int capacity = q->remainingCapacity();
                ASSERT_TRUE(capacity > 10000);
                q->offer<std::string>("item");
                ASSERT_EQ(capacity - 1, q->remainingCapacity());
            }


            TEST_F(MixedQueueTest, testRemove) {
                ASSERT_TRUE(q->offer<std::string>("item1"));
                ASSERT_TRUE(q->offer<std::string>("item2"));
                ASSERT_TRUE(q->offer<std::string>("item3"));

                ASSERT_FALSE(q->remove<std::string>("item4"));
                ASSERT_EQ(3, q->size());

                ASSERT_TRUE(q->remove<std::string>("item2"));

                ASSERT_EQ(2, q->size());

                ASSERT_EQ("item1", *(q->poll().get<std::string>()));
                ASSERT_EQ("item3", *(q->poll().get<std::string>()));
            }


            TEST_F(MixedQueueTest, testContains) {
                ASSERT_TRUE(q->offer<std::string>("item1"));
                ASSERT_TRUE(q->offer<std::string>("item2"));
                ASSERT_TRUE(q->offer<std::string>("item3"));
                ASSERT_TRUE(q->offer<std::string>("item4"));
                ASSERT_TRUE(q->offer<std::string>("item5"));


                ASSERT_TRUE(q->contains<std::string>("item3"));
                ASSERT_FALSE(q->contains<std::string>("item"));

                std::vector<std::string> list;
                list.push_back("item4");
                list.push_back("item2");

                ASSERT_TRUE(q->containsAll<std::string>(list));

                list.push_back("item");
                ASSERT_FALSE(q->containsAll(list));
            }

            TEST_F(MixedQueueTest, testDrain) {
                ASSERT_TRUE(q->offer<std::string>("item1"));
                ASSERT_TRUE(q->offer<std::string>("item2"));
                ASSERT_TRUE(q->offer<std::string>("item3"));
                ASSERT_TRUE(q->offer<std::string>("item4"));
                ASSERT_TRUE(q->offer<std::string>("item5"));

                std::vector<TypedData> list;
                size_t result = q->drainTo(list, 2);
                ASSERT_EQ(2U, result);
                ASSERT_EQ("item1", *list[0].get<std::string>());
                ASSERT_EQ("item2", *list[1].get<std::string>());

                std::vector<TypedData> list2;
                result = q->drainTo(list2);
                ASSERT_EQ(3U, result);
                ASSERT_EQ("item3", *list2[0].get<std::string>());
                ASSERT_EQ("item4", *list2[1].get<std::string>());
                ASSERT_EQ("item5", *list2[2].get<std::string>());

                ASSERT_TRUE(q->offer<std::string>("item1"));
                ASSERT_TRUE(q->offer<std::string>("item2"));
                ASSERT_TRUE(q->offer<std::string>("item3"));
                list2.clear();
                result = q->drainTo(list2, 5);
                ASSERT_EQ(3U, result);
                ASSERT_EQ("item1", *list2[0].get<std::string>());
                ASSERT_EQ("item2", *list2[1].get<std::string>());
                ASSERT_EQ("item3", *list2[2].get<std::string>());
            }

            TEST_F(MixedQueueTest, testToArray) {
                ASSERT_TRUE(q->offer<std::string>("item1"));
                ASSERT_TRUE(q->offer<std::string>("item2"));
                ASSERT_TRUE(q->offer<std::string>("item3"));
                ASSERT_TRUE(q->offer<std::string>("item4"));
                ASSERT_TRUE(q->offer<std::string>("item5"));

                std::vector<TypedData> array = q->toArray();
                size_t size = array.size();
                for (size_t i = 0; i < size; i++) {
                    ASSERT_EQ(std::string("item") + hazelcast::util::IOUtil::to_string(i + 1),
                              *array[i].get<std::string>());
                }
            }

            TEST_F(MixedQueueTest, testAddAll) {
                std::vector<std::string> coll;
                coll.push_back("item1");
                coll.push_back("item2");
                coll.push_back("item3");
                coll.push_back("item4");

                ASSERT_TRUE(q->addAll<std::string>(coll));
                int size = q->size();
                ASSERT_EQ(size, (int) coll.size());
            }

            TEST_F(MixedQueueTest, testRemoveRetain) {
                ASSERT_TRUE(q->offer<std::string>("item1"));
                ASSERT_TRUE(q->offer<std::string>("item2"));
                ASSERT_TRUE(q->offer<std::string>("item3"));
                ASSERT_TRUE(q->offer<std::string>("item4"));
                ASSERT_TRUE(q->offer<std::string>("item5"));

                std::vector<std::string> list;
                list.push_back("item8");
                list.push_back("item9");
                ASSERT_FALSE(q->removeAll(list));
                ASSERT_EQ(5, q->size());

                list.push_back("item3");
                list.push_back("item4");
                list.push_back("item1");
                ASSERT_TRUE(q->removeAll(list));
                ASSERT_EQ(2, q->size());

                list.clear();
                list.push_back("item2");
                list.push_back("item5");
                ASSERT_FALSE(q->retainAll<std::string>(list));
                ASSERT_EQ(2, q->size());

                list.clear();
                ASSERT_TRUE(q->retainAll<std::string>(list));
                ASSERT_EQ(0, q->size());
            }

            TEST_F(MixedQueueTest, testClear) {
                ASSERT_TRUE(q->offer<std::string>("item1"));
                ASSERT_TRUE(q->offer<std::string>("item2"));
                ASSERT_TRUE(q->offer<std::string>("item3"));
                ASSERT_TRUE(q->offer<std::string>("item4"));
                ASSERT_TRUE(q->offer<std::string>("item5"));

                q->clear();

                ASSERT_EQ(0, q->size());
                ASSERT_EQ(q->poll().get<std::string>().get(), (std::string *) NULL);
            }
        }
    }
}




int hazelcast::client::test::executor::tasks::SelectAllMembers::getFactoryId() const {
    return IdentifiedFactory::FACTORY_ID;
}

int hazelcast::client::test::executor::tasks::SelectAllMembers::getClassId() const {
    return IdentifiedFactory::SELECT_ALL_MEMBERS;
}

void hazelcast::client::test::executor::tasks::SelectAllMembers::writeData(
        hazelcast::client::serialization::ObjectDataOutput &writer) const {
}

void hazelcast::client::test::executor::tasks::SelectAllMembers::readData(
        hazelcast::client::serialization::ObjectDataInput &reader) {
}

hazelcast::client::test::executor::tasks::SelectAllMembers::SelectAllMembers() {}

bool hazelcast::client::test::executor::tasks::SelectAllMembers::select(const hazelcast::client::Member &member) const {
    return true;
}

void hazelcast::client::test::executor::tasks::SelectAllMembers::toString(std::ostream &os) const {
    os << "SelectAllMembers";
}




int hazelcast::client::test::executor::tasks::CancellationAwareTask::getFactoryId() const {
    return IdentifiedFactory::FACTORY_ID;
}

int hazelcast::client::test::executor::tasks::CancellationAwareTask::getClassId() const {
    return IdentifiedFactory::CANCELLATION_AWARE_TASK;
}

void hazelcast::client::test::executor::tasks::CancellationAwareTask::writeData(
        hazelcast::client::serialization::ObjectDataOutput &writer) const {
    writer.writeLong(sleepTime);
}

void hazelcast::client::test::executor::tasks::CancellationAwareTask::readData(
        hazelcast::client::serialization::ObjectDataInput &reader) {
    sleepTime = reader.readLong();
}

hazelcast::client::test::executor::tasks::CancellationAwareTask::CancellationAwareTask(int64_t sleepTime) : sleepTime(
        sleepTime) {}

hazelcast::client::test::executor::tasks::CancellationAwareTask::CancellationAwareTask() {}



int hazelcast::client::test::executor::tasks::NullCallable::getFactoryId() const {
    return IdentifiedFactory::FACTORY_ID;
}

int hazelcast::client::test::executor::tasks::NullCallable::getClassId() const {
    return IdentifiedFactory::NULL_CALLABLE;
}

void hazelcast::client::test::executor::tasks::NullCallable::writeData(
        hazelcast::client::serialization::ObjectDataOutput &writer) const {
}

void hazelcast::client::test::executor::tasks::NullCallable::readData(
        hazelcast::client::serialization::ObjectDataInput &reader) {
}

hazelcast::client::test::executor::tasks::NullCallable::NullCallable() {}



int hazelcast::client::test::executor::tasks::SerializedCounterCallable::getFactoryId() const {
    return IdentifiedFactory::FACTORY_ID;
}

int hazelcast::client::test::executor::tasks::SerializedCounterCallable::getClassId() const {
    return IdentifiedFactory::SERIALIZED_COUNTER_CALLABLE;
}

void hazelcast::client::test::executor::tasks::SerializedCounterCallable::writeData(
        hazelcast::client::serialization::ObjectDataOutput &writer) const {
    writer.writeInt(counter + 1);
}

void hazelcast::client::test::executor::tasks::SerializedCounterCallable::readData(
        hazelcast::client::serialization::ObjectDataInput &reader) {
    counter = reader.readInt() + 1;
}

hazelcast::client::test::executor::tasks::SerializedCounterCallable::SerializedCounterCallable() : counter(0) {}



int hazelcast::client::test::executor::tasks::MapPutPartitionAwareCallable::getFactoryId() const {
    return IdentifiedFactory::FACTORY_ID;
}

int hazelcast::client::test::executor::tasks::MapPutPartitionAwareCallable::getClassId() const {
    return IdentifiedFactory::MAP_PUTPARTITIONAWARE_CALLABLE;
}

void hazelcast::client::test::executor::tasks::MapPutPartitionAwareCallable::writeData(
        hazelcast::client::serialization::ObjectDataOutput &writer) const {
    writer.writeUTF(&mapName);
    writer.writeObject<std::string>(&partitionKey);
}

void hazelcast::client::test::executor::tasks::MapPutPartitionAwareCallable::readData(
        hazelcast::client::serialization::ObjectDataInput &reader) {
    // no need to implement at client side for the tests
}

hazelcast::client::test::executor::tasks::MapPutPartitionAwareCallable::MapPutPartitionAwareCallable() {}

hazelcast::client::test::executor::tasks::MapPutPartitionAwareCallable::MapPutPartitionAwareCallable(
        const std::string &mapName, const std::string &partitionKey) : mapName(mapName), partitionKey(partitionKey) {}

const std::string *hazelcast::client::test::executor::tasks::MapPutPartitionAwareCallable::getPartitionKey() const {
    return &partitionKey;
}



int hazelcast::client::test::executor::tasks::SelectNoMembers::getFactoryId() const {
    return IdentifiedFactory::FACTORY_ID;
}

int hazelcast::client::test::executor::tasks::SelectNoMembers::getClassId() const {
    return IdentifiedFactory::SELECT_NO_MEMBERS;
}

void hazelcast::client::test::executor::tasks::SelectNoMembers::writeData(
        hazelcast::client::serialization::ObjectDataOutput &writer) const {
}

void hazelcast::client::test::executor::tasks::SelectNoMembers::readData(
        hazelcast::client::serialization::ObjectDataInput &reader) {
}

hazelcast::client::test::executor::tasks::SelectNoMembers::SelectNoMembers() {}

bool hazelcast::client::test::executor::tasks::SelectNoMembers::select(const hazelcast::client::Member &member) const {
    return false;
}

void hazelcast::client::test::executor::tasks::SelectNoMembers::toString(std::ostream &os) const {
    os << "SelectNoMembers";
}



int hazelcast::client::test::executor::tasks::GetMemberUuidTask::getFactoryId() const {
    return IdentifiedFactory::FACTORY_ID;
}

int hazelcast::client::test::executor::tasks::GetMemberUuidTask::getClassId() const {
    return IdentifiedFactory::GET_MEMBER_UUID_TASK;
}

void hazelcast::client::test::executor::tasks::GetMemberUuidTask::writeData(
        hazelcast::client::serialization::ObjectDataOutput &writer) const {
}

void hazelcast::client::test::executor::tasks::GetMemberUuidTask::readData(
        hazelcast::client::serialization::ObjectDataInput &reader) {
}

hazelcast::client::test::executor::tasks::GetMemberUuidTask::GetMemberUuidTask() {}



int hazelcast::client::test::executor::tasks::FailingCallable::getFactoryId() const {
    return IdentifiedFactory::FACTORY_ID;
}

int hazelcast::client::test::executor::tasks::FailingCallable::getClassId() const {
    return IdentifiedFactory::FAILING_CALLABLE;
}

void hazelcast::client::test::executor::tasks::FailingCallable::writeData(
        hazelcast::client::serialization::ObjectDataOutput &writer) const {
}

void hazelcast::client::test::executor::tasks::FailingCallable::readData(
        hazelcast::client::serialization::ObjectDataInput &reader) {
}

hazelcast::client::test::executor::tasks::FailingCallable::FailingCallable() {}



std::string hazelcast::client::test::executor::tasks::AppendCallable::APPENDAGE = ":CallableResult";

int hazelcast::client::test::executor::tasks::AppendCallable::getFactoryId() const {
    return IdentifiedFactory::FACTORY_ID;
}

int hazelcast::client::test::executor::tasks::AppendCallable::getClassId() const {
    return IdentifiedFactory::APPEND_CALLABLE;
}

void hazelcast::client::test::executor::tasks::AppendCallable::writeData(
        hazelcast::client::serialization::ObjectDataOutput &writer) const {
    writer.writeUTF(&msg);
}

void hazelcast::client::test::executor::tasks::AppendCallable::readData(
        hazelcast::client::serialization::ObjectDataInput &reader) {
    // No need to implement this part for the client
}

hazelcast::client::test::executor::tasks::AppendCallable::AppendCallable() {}

hazelcast::client::test::executor::tasks::AppendCallable::AppendCallable(const std::string &msg) : msg(msg) {}



int hazelcast::client::test::executor::tasks::TaskWithUnserializableResponse::getFactoryId() const {
    return IdentifiedFactory::FACTORY_ID;
}

int hazelcast::client::test::executor::tasks::TaskWithUnserializableResponse::getClassId() const {
    return IdentifiedFactory::TASK_WITH_UNSERIALIZABLE_RESPONSE;
}

void hazelcast::client::test::executor::tasks::TaskWithUnserializableResponse::writeData(
        hazelcast::client::serialization::ObjectDataOutput &writer) const {
}

void hazelcast::client::test::executor::tasks::TaskWithUnserializableResponse::readData(
        hazelcast::client::serialization::ObjectDataInput &reader) {
}

hazelcast::client::test::executor::tasks::TaskWithUnserializableResponse::TaskWithUnserializableResponse() {}





namespace hazelcast {
    namespace client {
        namespace test {
            class ClientExecutorServiceTest : public ClientTestSupport {
            protected:
                static const size_t numberOfMembers;

                virtual void TearDown() {
                }

                static void SetUpTestCase() {
                    factory = new HazelcastServerFactory(g_srvFactory->getServerAddress(),
                                                         "hazelcast/test/resources/hazelcast-test-executor.xml");
                    for (size_t i = 0; i < numberOfMembers; ++i) {
                        instances.push_back(new HazelcastServer(*factory));
                    }
                    client = new HazelcastClient;
                }

                static void TearDownTestCase() {
                    delete client;
                    for (HazelcastServer *server : instances) {
                        server->shutdown();
                        delete server;
                    }

                    client = NULL;
                }

                class FailingExecutionCallback : public ExecutionCallback<std::string> {
                public:
                    FailingExecutionCallback(const std::shared_ptr<hazelcast::util::CountDownLatch> &latch) : latch(latch) {}

                    virtual void onResponse(const std::shared_ptr<std::string> &response) {
                    }

                    virtual void onFailure(const std::shared_ptr<exception::IException> &e) {
                        latch->countDown();
                        exception = e;
                    }

                    std::shared_ptr<exception::IException> getException() {
                        return exception.get();
                    }

                private:
                    const std::shared_ptr<hazelcast::util::CountDownLatch> latch;
                    hazelcast::util::Sync<std::shared_ptr<exception::IException> > exception;
                };

                class SuccessfullExecutionCallback : public ExecutionCallback<std::string> {
                public:
                    SuccessfullExecutionCallback(const std::shared_ptr<hazelcast::util::CountDownLatch> &latch) : latch(latch) {}

                    virtual void onResponse(const std::shared_ptr<std::string> &response) {
                        latch->countDown();
                    }

                    virtual void onFailure(const std::shared_ptr<exception::IException> &e) {
                    }

                private:
                    const std::shared_ptr<hazelcast::util::CountDownLatch> latch;
                };

                class ResultSettingExecutionCallback : public ExecutionCallback<std::string> {
                public:
                    ResultSettingExecutionCallback(const std::shared_ptr<hazelcast::util::CountDownLatch> &latch) : latch(latch) {}

                    virtual void onResponse(const std::shared_ptr<std::string> &response) {
                        result.set(response);
                        latch->countDown();
                    }

                    virtual void onFailure(const std::shared_ptr<exception::IException> &e) {
                    }

                    std::shared_ptr<std::string> getResult() {
                        return result.get();
                    }

                private:
                    const std::shared_ptr<hazelcast::util::CountDownLatch> latch;
                    hazelcast::util::Sync<std::shared_ptr<std::string>> result;
                };

                class MultiExecutionCompletionCallback : public MultiExecutionCallback<std::string> {
                public:
                    MultiExecutionCompletionCallback(const string &msg,
                                                     const std::shared_ptr<hazelcast::util::CountDownLatch> &responseLatch,
                                                     const std::shared_ptr<hazelcast::util::CountDownLatch> &completeLatch)
                            : msg(
                            msg),
                              responseLatch(
                                      responseLatch),
                              completeLatch(
                                      completeLatch) {}

                    virtual void onResponse(const Member &member, const std::shared_ptr<std::string> &response) {
                        if (response.get() && *response == msg + executor::tasks::AppendCallable::APPENDAGE) {
                            responseLatch->countDown();
                        }
                    }

                    virtual void
                    onFailure(const Member &member, const std::shared_ptr<exception::IException> &exception) {
                    }

                    virtual void onComplete(const std::map<Member, std::shared_ptr<std::string> > &values,
                                            const std::map<Member, std::shared_ptr<exception::IException> > &exceptions) {
                        typedef std::map<Member, std::shared_ptr<std::string> > VALUE_MAP;
                        std::string expectedValue(msg + executor::tasks::AppendCallable::APPENDAGE);
                        for (const VALUE_MAP::value_type &entry  : values) {
                            if (entry.second.get() && *entry.second == expectedValue) {
                                completeLatch->countDown();
                            }
                        }
                    }

                private:
                    std::string msg;
                    const std::shared_ptr<hazelcast::util::CountDownLatch> responseLatch;
                    const std::shared_ptr<hazelcast::util::CountDownLatch> completeLatch;
                };

                class MultiExecutionNullCallback : public MultiExecutionCallback<std::string> {
                public:
                    MultiExecutionNullCallback(const std::shared_ptr<hazelcast::util::CountDownLatch> &responseLatch,
                                               const std::shared_ptr<hazelcast::util::CountDownLatch> &completeLatch)
                            : responseLatch(responseLatch), completeLatch(completeLatch) {}

                    virtual void onResponse(const Member &member, const std::shared_ptr<std::string> &response) {
                        if (response.get() == NULL) {
                            responseLatch->countDown();
                        }
                    }

                    virtual void
                    onFailure(const Member &member, const std::shared_ptr<exception::IException> &exception) {
                    }

                    virtual void onComplete(const std::map<Member, std::shared_ptr<std::string> > &values,
                                            const std::map<Member, std::shared_ptr<exception::IException> > &exceptions) {
                        typedef std::map<Member, std::shared_ptr<std::string> > VALUE_MAP;
                        for (const VALUE_MAP::value_type &entry  : values) {
                            if (entry.second.get() == NULL) {
                                completeLatch->countDown();
                            }
                        }
                    }

                private:
                    const std::shared_ptr<hazelcast::util::CountDownLatch> responseLatch;
                    const std::shared_ptr<hazelcast::util::CountDownLatch> completeLatch;
                };

                static std::vector<HazelcastServer *> instances;
                static HazelcastClient *client;
                static HazelcastServerFactory *factory;
            };

            std::vector<HazelcastServer *>ClientExecutorServiceTest::instances;
            HazelcastClient *ClientExecutorServiceTest::client = NULL;
            HazelcastServerFactory *ClientExecutorServiceTest::factory = NULL;
            const size_t ClientExecutorServiceTest::numberOfMembers = 4;

            TEST_F(ClientExecutorServiceTest, testIsTerminated) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                ASSERT_FALSE(service->isTerminated());
            }

            TEST_F(ClientExecutorServiceTest, testIsShutdown) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                ASSERT_FALSE(service->isShutdown());
            }

            TEST_F(ClientExecutorServiceTest, testShutdown) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                service->shutdown();

                ASSERT_TRUE_EVENTUALLY(service->isShutdown());
            }

            TEST_F(ClientExecutorServiceTest, testShutdownMultipleTimes) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                service->shutdown();
                service->shutdown();

                ASSERT_TRUE_EVENTUALLY(service->isShutdown());
            }

            TEST_F(ClientExecutorServiceTest, testCancellationAwareTask_whenTimeOut) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                executor::tasks::CancellationAwareTask task(INT64_MAX);

                std::shared_ptr<ICompletableFuture<bool> > future = service->submit<executor::tasks::CancellationAwareTask, bool>(
                        task);

                ASSERT_THROW(future->get(1, hazelcast::util::concurrent::TimeUnit::SECONDS()),
                             exception::TimeoutException);
            }

            TEST_F(ClientExecutorServiceTest, testFutureAfterCancellationAwareTaskTimeOut) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                executor::tasks::CancellationAwareTask task(INT64_MAX);

                std::shared_ptr<ICompletableFuture<bool> > future = service->submit<executor::tasks::CancellationAwareTask, bool>(
                        task);

                try {
                    future->get(1, hazelcast::util::concurrent::TimeUnit::SECONDS());
                } catch (TimeoutException &ignored) {
                }

                ASSERT_FALSE(future->isDone());
                ASSERT_FALSE(future->isCancelled());
            }

            TEST_F(ClientExecutorServiceTest, testGetFutureAfterCancel) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                executor::tasks::CancellationAwareTask task(INT64_MAX);

                std::shared_ptr<ICompletableFuture<bool> > future = service->submit<executor::tasks::CancellationAwareTask, bool>(
                        task);

                try {
                    future->get(1, hazelcast::util::concurrent::TimeUnit::SECONDS());
                } catch (TimeoutException &ignored) {
                }

                ASSERT_TRUE(future->cancel(true));

                ASSERT_THROW(future->get(), exception::CancellationException);
            }

            TEST_F(ClientExecutorServiceTest, testSubmitFailingCallableException) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                executor::tasks::FailingCallable task;

                std::shared_ptr<ICompletableFuture<std::string> > future = service->submit<executor::tasks::FailingCallable, std::string>(
                        task);

                ASSERT_THROW(future->get(), exception::ExecutionException);
            }

            TEST_F(ClientExecutorServiceTest, testSubmitFailingCallableException_withExecutionCallback) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                std::shared_ptr<hazelcast::util::CountDownLatch> latch(new hazelcast::util::CountDownLatch(1));

                executor::tasks::FailingCallable task;
                std::shared_ptr<ExecutionCallback<std::string> > callback(new FailingExecutionCallback(latch));

                service->submit<executor::tasks::FailingCallable, std::string>(task, callback);

                ASSERT_OPEN_EVENTUALLY(*latch);
            }

            TEST_F(ClientExecutorServiceTest, testSubmitFailingCallableReasonExceptionCause) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                const std::shared_ptr<ICompletableFuture<std::string> > &failingFuture = service->submit<executor::tasks::FailingCallable, std::string>(
                        executor::tasks::FailingCallable());

                try {
                    failingFuture->get();
                } catch (exception::ExecutionException &e) {
                    ASSERT_THROW(e.getCause()->raise(), exception::IllegalStateException);
                }
            }

            TEST_F(ClientExecutorServiceTest, testExecute_withNoMemberSelected) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                std::string mapName = randomMapName();

                executor::tasks::SelectNoMembers selector;

                ASSERT_THROW(service->execute<executor::tasks::MapPutPartitionAwareCallable>(
                        executor::tasks::MapPutPartitionAwareCallable(mapName, randomString()),
                        selector),
                             exception::RejectedExecutionException);
            }

            TEST_F(ClientExecutorServiceTest, testCallableSerializedOnce) {
                std::string name = getTestName();

                std::shared_ptr<IExecutorService> service = client->getExecutorService(name);

                executor::tasks::SerializedCounterCallable counterCallable;

                std::shared_ptr<ICompletableFuture<int> > future = service->submitToKeyOwner<executor::tasks::SerializedCounterCallable, int, std::string>(
                        counterCallable, name);
                std::shared_ptr<int> value = future->get();
                ASSERT_NOTNULL(value.get(), int);
                ASSERT_EQ(2, *value);
            }

            TEST_F(ClientExecutorServiceTest, testCallableSerializedOnce_submitToAddress) {
                std::string name = getTestName();

                std::shared_ptr<IExecutorService> service = client->getExecutorService(name);

                executor::tasks::SerializedCounterCallable counterCallable;

                std::vector<Member> members = client->getCluster().getMembers();
                ASSERT_FALSE(members.empty());
                std::shared_ptr<ICompletableFuture<int> > future = service->submitToMember<executor::tasks::SerializedCounterCallable, int>(
                        counterCallable, members[0]);
                std::shared_ptr<int> value = future->get();
                ASSERT_NOTNULL(value.get(), int);
                ASSERT_EQ(2, *value);
            }

            TEST_F(ClientExecutorServiceTest, testUnserializableResponse_exceptionPropagatesToClient) {
                std::string name = getTestName();

                std::shared_ptr<IExecutorService> service = client->getExecutorService(name);

                executor::tasks::TaskWithUnserializableResponse taskWithUnserializableResponse;

                std::shared_ptr<ICompletableFuture<bool> > future = service->submit<executor::tasks::TaskWithUnserializableResponse, bool>(
                        taskWithUnserializableResponse);

                try {
                    future->get();
                } catch (exception::ExecutionException &e) {
                    ASSERT_THROW(e.getCause()->raise(), exception::HazelcastSerializationException);
                }
            }

            TEST_F(ClientExecutorServiceTest, testUnserializableResponse_exceptionPropagatesToClientCallback) {
                std::string name = getTestName();

                std::shared_ptr<IExecutorService> service = client->getExecutorService(name);

                executor::tasks::TaskWithUnserializableResponse taskWithUnserializableResponse;

                std::shared_ptr<hazelcast::util::CountDownLatch> latch(new hazelcast::util::CountDownLatch(1));

                std::shared_ptr<FailingExecutionCallback> callback(new FailingExecutionCallback(latch));

                service->submit<executor::tasks::TaskWithUnserializableResponse, std::string>(
                        taskWithUnserializableResponse, callback);

                ASSERT_OPEN_EVENTUALLY(*latch);

                std::shared_ptr<exception::IException> exception = callback->getException();
                ASSERT_NOTNULL(exception.get(), exception::IException);
                ASSERT_THROW(exception->raise(), exception::HazelcastSerializationException);
            }

            TEST_F(ClientExecutorServiceTest, testSubmitCallableToMember) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                executor::tasks::GetMemberUuidTask task;

                std::vector<Member> members = client->getCluster().getMembers();
                ASSERT_EQ(numberOfMembers, members.size());

                std::shared_ptr<ICompletableFuture<std::string> > future = service->submitToMember<executor::tasks::GetMemberUuidTask, std::string>(
                        task, members[0]);

                std::shared_ptr<std::string> uuid = future->get();
                ASSERT_NOTNULL(uuid.get(), std::string);
                ASSERT_EQ(members[0].getUuid(), *uuid);
            }

            TEST_F(ClientExecutorServiceTest, testSubmitCallableToMembers) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                executor::tasks::GetMemberUuidTask task;

                std::vector<Member> members = client->getCluster().getMembers();
                ASSERT_EQ(numberOfMembers, members.size());

                std::map<Member, std::shared_ptr<ICompletableFuture<std::string> > > futuresMap = service->submitToMembers<executor::tasks::GetMemberUuidTask, std::string>(
                        task, members);

                for (const Member &member : members) {
                    ASSERT_EQ(1U, futuresMap.count(member));
                    std::shared_ptr<std::string> uuid = futuresMap[member]->get();
                    ASSERT_NOTNULL(uuid.get(), std::string);
                    ASSERT_EQ(member.getUuid(), *uuid);
                }
            }

            TEST_F(ClientExecutorServiceTest, testSubmitCallable_withMemberSelector) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                std::string msg = randomString();
                executor::tasks::AppendCallable callable(msg);
                executor::tasks::SelectAllMembers selectAll;

                std::shared_ptr<ICompletableFuture<std::string> > f = service->submit<executor::tasks::AppendCallable, std::string>(
                        callable, selectAll);

                std::shared_ptr<std::string> result = f->get();
                ASSERT_NOTNULL(result.get(), std::string);
                ASSERT_EQ(msg + executor::tasks::AppendCallable::APPENDAGE, *result);
            }

            TEST_F(ClientExecutorServiceTest, testSubmitCallableToMembers_withMemberSelector) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                executor::tasks::GetMemberUuidTask task;
                executor::tasks::SelectAllMembers selectAll;

                typedef std::map<Member, std::shared_ptr<ICompletableFuture<std::string> > > FUTURESMAP;
                FUTURESMAP futuresMap = service->submitToMembers<executor::tasks::GetMemberUuidTask, std::string>(
                        task, selectAll);

                for (const FUTURESMAP::value_type &pair : futuresMap) {
                    const Member &member = pair.first;
                    const std::shared_ptr<ICompletableFuture<std::string> > &future = pair.second;

                    std::shared_ptr<std::string> uuid = future->get();

                    ASSERT_NOTNULL(uuid.get(), std::string);
                    ASSERT_EQ(member.getUuid(), *uuid);
                }
            }

            TEST_F(ClientExecutorServiceTest, submitCallableToAllMembers) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                std::string msg = randomString();
                executor::tasks::AppendCallable callable(msg);

                typedef std::map<Member, std::shared_ptr<ICompletableFuture<std::string> > > FUTURESMAP;
                FUTURESMAP futuresMap = service->submitToAllMembers<executor::tasks::AppendCallable, std::string>(
                        callable);

                for (const FUTURESMAP::value_type &pair : futuresMap) {
                    const std::shared_ptr<ICompletableFuture<std::string> > &future = pair.second;

                    std::shared_ptr<std::string> result = future->get();

                    ASSERT_NOTNULL(result.get(), std::string);
                    ASSERT_EQ(msg + executor::tasks::AppendCallable::APPENDAGE, *result);
                }
            }

            TEST_F(ClientExecutorServiceTest, submitCallableToMember_withExecutionCallback) {
                std::string testName = getTestName();
                std::shared_ptr<IExecutorService> service = client->getExecutorService(testName);

                executor::tasks::MapPutPartitionAwareCallable callable(testName, randomString());

                std::shared_ptr<hazelcast::util::CountDownLatch> latch(new hazelcast::util::CountDownLatch(1));
                std::shared_ptr<SuccessfullExecutionCallback> callback(new SuccessfullExecutionCallback(latch));

                std::vector<Member> members = client->getCluster().getMembers();
                ASSERT_EQ(numberOfMembers, members.size());

                service->submitToMember<executor::tasks::MapPutPartitionAwareCallable, std::string>(callable,
                                                                                                    members[0],
                                                                                                    callback);

                IMap<std::string, std::string> map = client->getMap<std::string, std::string>(testName);

                ASSERT_OPEN_EVENTUALLY(*latch);
                ASSERT_EQ(1, map.size());
            }

            TEST_F(ClientExecutorServiceTest, submitCallableToMember_withMultiExecutionCallback) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                std::shared_ptr<hazelcast::util::CountDownLatch> responseLatch(
                        new hazelcast::util::CountDownLatch(numberOfMembers));
                std::shared_ptr<hazelcast::util::CountDownLatch> completeLatch(
                        new hazelcast::util::CountDownLatch(numberOfMembers));

                std::string msg = randomString();
                executor::tasks::AppendCallable callable(msg);
                std::vector<Member> members = client->getCluster().getMembers();
                ASSERT_EQ(numberOfMembers, members.size());

                std::shared_ptr<MultiExecutionCallback<std::string> > callback(
                        new MultiExecutionCompletionCallback(msg, responseLatch, completeLatch));

                service->submitToMembers<executor::tasks::AppendCallable, std::string>(callable, members, callback);

                ASSERT_OPEN_EVENTUALLY(*responseLatch);
                ASSERT_OPEN_EVENTUALLY(*completeLatch);
            }

            TEST_F(ClientExecutorServiceTest, submitCallable_withExecutionCallback) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                std::string msg = randomString();
                executor::tasks::AppendCallable callable(msg);
                executor::tasks::SelectAllMembers selector;
                std::shared_ptr<hazelcast::util::CountDownLatch> responseLatch(new hazelcast::util::CountDownLatch(1));
                std::shared_ptr<ResultSettingExecutionCallback> callback(
                        new ResultSettingExecutionCallback(responseLatch));

                service->submit<executor::tasks::AppendCallable, std::string>(callable, selector,
                                                                              static_pointer_cast<ExecutionCallback<std::string>>(
                                                                                      callback));

                ASSERT_OPEN_EVENTUALLY(*responseLatch);
                std::shared_ptr<std::string> message = callback->getResult();
                ASSERT_NOTNULL(message.get(), std::string);
                ASSERT_EQ(msg + executor::tasks::AppendCallable::APPENDAGE, *message);
            }

            TEST_F(ClientExecutorServiceTest, submitCallableToMembers_withExecutionCallback) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                std::shared_ptr<hazelcast::util::CountDownLatch> responseLatch(
                        new hazelcast::util::CountDownLatch(numberOfMembers));
                std::shared_ptr<hazelcast::util::CountDownLatch> completeLatch(
                        new hazelcast::util::CountDownLatch(numberOfMembers));

                std::string msg = randomString();
                executor::tasks::AppendCallable callable(msg);
                executor::tasks::SelectAllMembers selector;

                std::shared_ptr<MultiExecutionCallback<std::string> > callback(
                        new MultiExecutionCompletionCallback(msg, responseLatch, completeLatch));

                service->submitToMembers<executor::tasks::AppendCallable, std::string>(callable, selector, callback);

                ASSERT_OPEN_EVENTUALLY(*responseLatch);
                ASSERT_OPEN_EVENTUALLY(*completeLatch);
            }

            TEST_F(ClientExecutorServiceTest, submitCallableToAllMembers_withMultiExecutionCallback) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                std::shared_ptr<hazelcast::util::CountDownLatch> responseLatch(
                        new hazelcast::util::CountDownLatch(numberOfMembers));
                std::shared_ptr<hazelcast::util::CountDownLatch> completeLatch(
                        new hazelcast::util::CountDownLatch(numberOfMembers));

                std::string msg = randomString();
                executor::tasks::AppendCallable callable(msg);

                std::shared_ptr<MultiExecutionCallback<std::string> > callback(
                        new MultiExecutionCompletionCallback(msg, responseLatch, completeLatch));

                service->submitToAllMembers<executor::tasks::AppendCallable, std::string>(callable, callback);

                ASSERT_OPEN_EVENTUALLY(*completeLatch);
                ASSERT_OPEN_EVENTUALLY(*responseLatch);
            }

            TEST_F(ClientExecutorServiceTest, submitCallableWithNullResultToAllMembers_withMultiExecutionCallback) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                std::shared_ptr<hazelcast::util::CountDownLatch> responseLatch(
                        new hazelcast::util::CountDownLatch(numberOfMembers));
                std::shared_ptr<hazelcast::util::CountDownLatch> completeLatch(
                        new hazelcast::util::CountDownLatch(numberOfMembers));

                executor::tasks::NullCallable callable;

                std::shared_ptr<MultiExecutionCallback<std::string> > callback(
                        new MultiExecutionNullCallback(responseLatch, completeLatch));

                service->submitToAllMembers<executor::tasks::NullCallable, std::string>(callable, callback);

                ASSERT_OPEN_EVENTUALLY(*responseLatch);
                ASSERT_OPEN_EVENTUALLY(*completeLatch);
            }

            TEST_F(ClientExecutorServiceTest, testSubmitCallable) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                std::string msg = randomString();
                executor::tasks::AppendCallable callable(msg);

                std::shared_ptr<ICompletableFuture<std::string> > result = service->submit<executor::tasks::AppendCallable, std::string>(
                        callable);

                std::shared_ptr<std::string> message = result->get();
                ASSERT_NOTNULL(message.get(), std::string);
                ASSERT_EQ(msg + executor::tasks::AppendCallable::APPENDAGE, *message);
            }

            TEST_F(ClientExecutorServiceTest, testSubmitCallable_withExecutionCallback) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                std::string msg = randomString();
                executor::tasks::AppendCallable callable(msg);

                std::shared_ptr<hazelcast::util::CountDownLatch> latch(new hazelcast::util::CountDownLatch(1));
                std::shared_ptr<ResultSettingExecutionCallback> callback(new ResultSettingExecutionCallback(latch));

                service->submit<executor::tasks::AppendCallable, std::string>(callable,
                                                                              static_pointer_cast<ExecutionCallback<std::string>>(
                                                                                      callback));

                ASSERT_OPEN_EVENTUALLY(*latch);
                std::shared_ptr<std::string> value = callback->getResult();
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ(msg + executor::tasks::AppendCallable::APPENDAGE, *value);
            }

            TEST_F(ClientExecutorServiceTest, submitCallableToKeyOwner) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                std::string msg = randomString();
                executor::tasks::AppendCallable callable(msg);

                std::shared_ptr<ICompletableFuture<std::string> > f = service->submitToKeyOwner<executor::tasks::AppendCallable, std::string, std::string>(
                        callable, "key");

                std::shared_ptr<std::string> result = f->get();
                ASSERT_NOTNULL(result.get(), std::string);
                ASSERT_EQ(msg + executor::tasks::AppendCallable::APPENDAGE, *result);
            }

            TEST_F(ClientExecutorServiceTest, submitCallableToKeyOwner_withExecutionCallback) {
                std::shared_ptr<IExecutorService> service = client->getExecutorService(getTestName());

                std::string msg = randomString();
                executor::tasks::AppendCallable callable(msg);

                std::shared_ptr<hazelcast::util::CountDownLatch> latch(new hazelcast::util::CountDownLatch(1));
                std::shared_ptr<ResultSettingExecutionCallback> callback(new ResultSettingExecutionCallback(latch));

                service->submitToKeyOwner<executor::tasks::AppendCallable, std::string, std::string>(callable, "key",
                                                                                                     static_pointer_cast<ExecutionCallback<std::string>>(
                                                                                                             callback));

                ASSERT_OPEN_EVENTUALLY(*latch);
                std::shared_ptr<std::string> value = callback->getResult();
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ(msg + executor::tasks::AppendCallable::APPENDAGE, *value);
            }

            TEST_F(ClientExecutorServiceTest, submitCallablePartitionAware) {
                std::string testName = getTestName();
                std::shared_ptr<IExecutorService> service = client->getExecutorService(testName);

                IMap<std::string, std::string> map = client->getMap<std::string, std::string>(testName);

                std::vector<Member> members = client->getCluster().getMembers();
                spi::ClientContext clientContext(*client);
                Member &member = members[0];
                std::string key = generateKeyOwnedBy(clientContext, member);

                executor::tasks::MapPutPartitionAwareCallable callable(testName, key);

                std::shared_ptr<ICompletableFuture<std::string> > f = service->submit<executor::tasks::MapPutPartitionAwareCallable, std::string>(
                        callable);

                std::shared_ptr<std::string> result = f->get();
                ASSERT_NOTNULL(result.get(), std::string);
                ASSERT_EQ(member.getUuid(), *result);
                ASSERT_TRUE(map.containsKey(member.getUuid()));
            }

            TEST_F(ClientExecutorServiceTest, submitCallablePartitionAware_WithExecutionCallback) {
                std::string testName = getTestName();
                std::shared_ptr<IExecutorService> service = client->getExecutorService(testName);

                IMap<std::string, std::string> map = client->getMap<std::string, std::string>(testName);

                std::vector<Member> members = client->getCluster().getMembers();
                spi::ClientContext clientContext(*client);
                Member &member = members[0];
                std::string key = generateKeyOwnedBy(clientContext, member);

                executor::tasks::MapPutPartitionAwareCallable callable(testName, key);

                std::shared_ptr<hazelcast::util::CountDownLatch> latch(new hazelcast::util::CountDownLatch(1));
                std::shared_ptr<ExecutionCallback<std::string>> callback(new ResultSettingExecutionCallback(latch));

                service->submit<executor::tasks::MapPutPartitionAwareCallable, std::string>(callable, callback);

                ASSERT_OPEN_EVENTUALLY(*latch);
                std::shared_ptr<std::string> value = static_pointer_cast<ResultSettingExecutionCallback>(
                        callback)->getResult();
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ(member.getUuid(), *value);
                ASSERT_TRUE(map.containsKey(member.getUuid()));
            }

            TEST_F(ClientExecutorServiceTest, testExecute) {
                std::string testName = getTestName();
                std::shared_ptr<IExecutorService> service = client->getExecutorService(testName);

                service->execute<executor::tasks::MapPutPartitionAwareCallable>(
                        executor::tasks::MapPutPartitionAwareCallable(testName, "key"));

                IMap<std::string, std::string> map = client->getMap<std::string, std::string>(testName);

                assertSizeEventually(1, map);
            }

            TEST_F(ClientExecutorServiceTest, testExecute_withMemberSelector) {
                std::string testName = getTestName();
                std::shared_ptr<IExecutorService> service = client->getExecutorService(testName);
                executor::tasks::SelectAllMembers selector;

                service->execute<executor::tasks::MapPutPartitionAwareCallable>(
                        executor::tasks::MapPutPartitionAwareCallable(testName, "key"), selector);
                IMap<std::string, std::string> map = client->getMap<std::string, std::string>(testName);

                assertSizeEventually(1, map);
            }

            TEST_F(ClientExecutorServiceTest, testExecuteOnKeyOwner) {
                std::string testName = getTestName();
                std::shared_ptr<IExecutorService> service = client->getExecutorService(testName);

                IMap<std::string, std::string> map = client->getMap<std::string, std::string>(testName);

                std::vector<Member> members = client->getCluster().getMembers();
                spi::ClientContext clientContext(*client);
                Member &member = members[0];
                std::string targetUuid = member.getUuid();
                std::string key = generateKeyOwnedBy(clientContext, member);

                executor::tasks::MapPutPartitionAwareCallable callable(testName, key);

                service->executeOnKeyOwner<executor::tasks::MapPutPartitionAwareCallable, std::string>(callable, key);

                ASSERT_TRUE_EVENTUALLY(map.containsKey(targetUuid));
            }

            TEST_F(ClientExecutorServiceTest, testExecuteOnMember) {
                std::string testName = getTestName();
                std::shared_ptr<IExecutorService> service = client->getExecutorService(testName);

                IMap<std::string, std::string> map = client->getMap<std::string, std::string>(testName);

                std::vector<Member> members = client->getCluster().getMembers();
                Member &member = members[0];
                std::string targetUuid = member.getUuid();

                executor::tasks::MapPutPartitionAwareCallable callable(testName, "key");

                service->executeOnMember<executor::tasks::MapPutPartitionAwareCallable>(callable, member);

                ASSERT_TRUE_EVENTUALLY(map.containsKey(targetUuid));
            }

            TEST_F(ClientExecutorServiceTest, testExecuteOnMembers) {
                std::string testName = getTestName();
                std::shared_ptr<IExecutorService> service = client->getExecutorService(testName);

                IMap<std::string, std::string> map = client->getMap<std::string, std::string>(testName);

                std::vector<Member> allMembers = client->getCluster().getMembers();
                std::vector<Member> members(allMembers.begin(), allMembers.begin() + 2);

                executor::tasks::MapPutPartitionAwareCallable callable(testName, "key");

                service->executeOnMembers<executor::tasks::MapPutPartitionAwareCallable>(callable, members);

                ASSERT_TRUE_EVENTUALLY(map.containsKey(members[0].getUuid()) && map.containsKey(members[1].getUuid()));
            }

            TEST_F(ClientExecutorServiceTest, testExecuteOnMembers_withEmptyCollection) {
                std::string testName = getTestName();
                std::shared_ptr<IExecutorService> service = client->getExecutorService(testName);

                IMap<std::string, std::string> map = client->getMap<std::string, std::string>(testName);

                executor::tasks::MapPutPartitionAwareCallable callable(testName, "key");

                service->executeOnMembers<executor::tasks::MapPutPartitionAwareCallable>(callable,
                                                                                         std::vector<Member>());

                assertSizeEventually(0, map);
            }

            TEST_F(ClientExecutorServiceTest, testExecuteOnMembers_withSelector) {
                std::string testName = getTestName();
                std::shared_ptr<IExecutorService> service = client->getExecutorService(testName);

                IMap<std::string, std::string> map = client->getMap<std::string, std::string>(testName);

                executor::tasks::MapPutPartitionAwareCallable callable(testName, "key");

                executor::tasks::SelectAllMembers selector;

                service->executeOnMembers<executor::tasks::MapPutPartitionAwareCallable>(callable, selector);

                assertSizeEventually((int) numberOfMembers, map);
            }

            TEST_F(ClientExecutorServiceTest, testExecuteOnAllMembers) {
                std::string testName = getTestName();
                std::shared_ptr<IExecutorService> service = client->getExecutorService(testName);

                IMap<std::string, std::string> map = client->getMap<std::string, std::string>(testName);

                executor::tasks::MapPutPartitionAwareCallable callable(testName, "key");

                service->executeOnAllMembers<executor::tasks::MapPutPartitionAwareCallable>(callable);

                assertSizeEventually((int) numberOfMembers, map);
            }
        }
    }
}



#ifdef HZ_BUILD_WITH_SSL





namespace hazelcast {
    namespace client {
        namespace test {
            namespace aws {
                class AwsConfigTest : public ::testing::Test {
                };

                TEST_F (AwsConfigTest, testDefaultValues) {
                    client::config::ClientAwsConfig awsConfig;
                    ASSERT_EQ("", awsConfig.getAccessKey());
                    ASSERT_EQ("us-east-1", awsConfig.getRegion());
                    ASSERT_EQ("ec2.amazonaws.com", awsConfig.getHostHeader());
                    ASSERT_EQ("", awsConfig.getIamRole());
                    ASSERT_EQ("", awsConfig.getSecretKey());
                    ASSERT_EQ("", awsConfig.getSecurityGroupName());
                    ASSERT_EQ("", awsConfig.getTagKey());
                    ASSERT_EQ("", awsConfig.getTagValue());
                    ASSERT_FALSE(awsConfig.isInsideAws());
                    ASSERT_FALSE(awsConfig.isEnabled());
                }

                TEST_F (AwsConfigTest, testSetValues) {
                    client::config::ClientAwsConfig awsConfig;

                    awsConfig.setAccessKey("mykey");
                    awsConfig.setRegion("myregion");
                    awsConfig.setHostHeader("myheader");
                    awsConfig.setIamRole("myrole");
                    awsConfig.setSecretKey("mysecret");
                    awsConfig.setSecurityGroupName("mygroup");
                    awsConfig.setTagKey("mytagkey");
                    awsConfig.setTagValue("mytagvalue");
                    awsConfig.setInsideAws(true);
                    awsConfig.setEnabled(true);

                    ASSERT_EQ("mykey", awsConfig.getAccessKey());
                    ASSERT_EQ("myregion", awsConfig.getRegion());
                    ASSERT_EQ("myheader", awsConfig.getHostHeader());
                    ASSERT_EQ("myrole", awsConfig.getIamRole());
                    ASSERT_EQ("mysecret", awsConfig.getSecretKey());
                    ASSERT_EQ("mygroup", awsConfig.getSecurityGroupName());
                    ASSERT_EQ("mytagkey", awsConfig.getTagKey());
                    ASSERT_EQ("mytagvalue", awsConfig.getTagValue());
                    ASSERT_TRUE(awsConfig.isInsideAws());
                    ASSERT_TRUE(awsConfig.isEnabled()) << awsConfig;
                }

                TEST_F (AwsConfigTest, testSetEmptyValues) {
                    client::config::ClientAwsConfig awsConfig;

                    ASSERT_THROW(awsConfig.setAccessKey(""), exception::IllegalArgumentException);
                    ASSERT_THROW(awsConfig.setRegion(""), exception::IllegalArgumentException);
                    ASSERT_THROW(awsConfig.setHostHeader(""), exception::IllegalArgumentException);
                    ASSERT_THROW(awsConfig.setSecretKey(""), exception::IllegalArgumentException);
                }

                TEST_F (AwsConfigTest, testClientConfigUsage) {
                    ClientConfig clientConfig;
                    client::config::ClientAwsConfig &awsConfig = clientConfig.getNetworkConfig().getAwsConfig();
                    awsConfig.setEnabled(true);

                    ASSERT_TRUE(clientConfig.getNetworkConfig().getAwsConfig().isEnabled());

                    client::config::ClientAwsConfig newConfig;

                    clientConfig.getNetworkConfig().setAwsConfig(newConfig);
                    // default constructor sets enabled to false
                    ASSERT_FALSE(clientConfig.getNetworkConfig().getAwsConfig().isEnabled());
                }

                TEST_F (AwsConfigTest, testInvalidAwsMemberPortConfig) {
                    ClientConfig clientConfig;

                    clientConfig.getProperties()[ClientProperties::PROP_AWS_MEMBER_PORT] = "65536";
                    clientConfig.getNetworkConfig().getAwsConfig().setEnabled(true).
                            setAccessKey(getenv("AWS_ACCESS_KEY_ID")).setSecretKey(getenv("AWS_SECRET_ACCESS_KEY")).
                            setTagKey("aws-test-tag").setTagValue("aws-tag-value-1").setInsideAws(true);

                    clientConfig.getProperties()[ClientProperties::PROP_AWS_MEMBER_PORT] = "-1";

                    ASSERT_THROW(HazelcastClient hazelcastClient(clientConfig),
                                 exception::InvalidConfigurationException);
                }
            }
        }
    }
}


#endif // HZ_BUILD_WITH_SSL


#ifdef HZ_BUILD_WITH_SSL





namespace hazelcast {
    namespace client {
        namespace test {
            namespace aws {
                class AwsClientTest : public ::testing::Test {
                };

                TEST_F (AwsClientTest, testClientAwsMemberNonDefaultPortConfig) {
                    ClientConfig clientConfig;

                    clientConfig.getProperties()[ClientProperties::PROP_AWS_MEMBER_PORT] = "60000";
                    clientConfig.getNetworkConfig().getAwsConfig().setEnabled(true).
                            setAccessKey(getenv("AWS_ACCESS_KEY_ID")).setSecretKey(getenv("AWS_SECRET_ACCESS_KEY")).
                            setTagKey("aws-test-tag").setTagValue("aws-tag-value-1");

#if  defined(WIN32) || defined(_WIN32) || defined(WIN64) || defined(_WIN64)
                    clientConfig.getNetworkConfig().getAwsConfig().setInsideAws(true);
#else
                    clientConfig.getNetworkConfig().getAwsConfig().setInsideAws(false);
#endif

                    HazelcastClient hazelcastClient(clientConfig);

                    IMap<int, int> map = hazelcastClient.getMap<int, int>("myMap");
                    map.put(5, 20);
                    std::shared_ptr<int> val = map.get(5);
                    ASSERT_NE((int *) NULL, val.get());
                    ASSERT_EQ(20, *val);
                }

                TEST_F (AwsClientTest, testClientAwsMemberWithSecurityGroupDefaultIamRole) {
                    ClientConfig clientConfig;

                    clientConfig.getProperties()[ClientProperties::PROP_AWS_MEMBER_PORT] = "60000";
                    clientConfig.getNetworkConfig().getAwsConfig().setEnabled(true).
                            setSecurityGroupName("launch-wizard-147");

#if  defined(WIN32) || defined(_WIN32) || defined(WIN64) || defined(_WIN64)
                                                                                                                                            // The access key and secret will be retrieved from default IAM role at windows machine
                    clientConfig.getNetworkConfig().getAwsConfig().setInsideAws(true);
#else
                    clientConfig.getNetworkConfig().getAwsConfig().setAccessKey(getenv("AWS_ACCESS_KEY_ID")).
                            setSecretKey(getenv("AWS_SECRET_ACCESS_KEY"));
#endif

                    HazelcastClient hazelcastClient(clientConfig);

                    IMap<int, int> map = hazelcastClient.getMap<int, int>("myMap");
                    map.put(5, 20);
                    std::shared_ptr<int> val = map.get(5);
                    ASSERT_NE((int *) NULL, val.get());
                    ASSERT_EQ(20, *val);
                }

                // FIPS_mode_set is not available for Mac OS X built-in openssl library
#ifndef __APPLE__
                                                                                                                                        TEST_F (AwsClientTest, testFipsEnabledAwsDiscovery) {
                    ClientConfig clientConfig;

                    clientConfig.getProperties()[ClientProperties::PROP_AWS_MEMBER_PORT] = "60000";
                    clientConfig.getNetworkConfig().getAwsConfig().setEnabled(true).
                            setAccessKey(getenv("AWS_ACCESS_KEY_ID")).setSecretKey(getenv("AWS_SECRET_ACCESS_KEY")).
                            setTagKey("aws-test-tag").setTagValue("aws-tag-value-1");

                    #if  defined(WIN32) || defined(_WIN32) || defined(WIN64) || defined(_WIN64)
                    clientConfig.getNetworkConfig().getAwsConfig().setInsideAws(true);
                    #else
                    clientConfig.getNetworkConfig().getAwsConfig().setInsideAws(false);
                    #endif

                    // Turn Fips mode on
                    FIPS_mode_set(1);

                    HazelcastClient hazelcastClient(clientConfig);
                    IMap<int, int> map = hazelcastClient.getMap<int, int>("myMap");
                    map.put(5, 20);
                    std::shared_ptr<int> val = map.get(5);
                    ASSERT_NE((int *) NULL, val.get());
                    ASSERT_EQ(20, *val);
                }
#endif // ifndef __APPLE__

                /**
                 * Following test can only run from inside the AWS network
                 */
#if  defined(WIN32) || defined(_WIN32) || defined(WIN64) || defined(_WIN64)
                                                                                                                                        TEST_F (AwsClientTest, testRetrieveCredentialsFromIamRoleAndConnect) {
                    ClientConfig clientConfig;

                    clientConfig.getProperties()[ClientProperties::PROP_AWS_MEMBER_PORT] = "60000";
                    clientConfig.getNetworkConfig().getAwsConfig().setEnabled(true).setIamRole("cloudbees-role").setTagKey(
                            "aws-test-tag").setTagValue("aws-tag-value-1").setInsideAws(true);

                    HazelcastClient hazelcastClient(clientConfig);
                }

                TEST_F (AwsClientTest, testRetrieveCredentialsFromInstanceProfileDefaultIamRoleAndConnect) {
                    ClientConfig clientConfig;

                    clientConfig.getProperties()[ClientProperties::PROP_AWS_MEMBER_PORT] = "60000";
                    clientConfig.getNetworkConfig().getAwsConfig().setEnabled(true).setTagKey(
                            "aws-test-tag").setTagValue("aws-tag-value-1").setInsideAws(true);

                    HazelcastClient hazelcastClient(clientConfig);
                }
#endif
            }
        }
    }
}

#endif // HZ_BUILD_WITH_SSL


#ifdef HZ_BUILD_WITH_SSL

namespace hazelcast {
    namespace client {
        namespace test {
            namespace aws {
                class DescribeInstancesTest : public ClientTestSupport {
                };

                TEST_F (DescribeInstancesTest, testDescribeInstancesTagAndValueSet) {
                    client::config::ClientAwsConfig awsConfig;
                    awsConfig.setEnabled(true).setAccessKey(getenv("AWS_ACCESS_KEY_ID")).setSecretKey(
                            getenv("AWS_SECRET_ACCESS_KEY")).setTagKey("aws-test-tag").setTagValue("aws-tag-value-1");
                    client::aws::impl::DescribeInstances desc(awsConfig, awsConfig.getHostHeader(), getLogger());
                    std::map<std::string, std::string> results = desc.execute();
                    ASSERT_EQ(results.size(), 1U);
                    ASSERT_NE(results.end(), results.find(getenv("HZ_TEST_AWS_INSTANCE_PRIVATE_IP")));
                }

                TEST_F (DescribeInstancesTest, testDescribeInstancesTagAndNonExistentValueSet) {
                    client::config::ClientAwsConfig awsConfig;
                    awsConfig.setEnabled(true).setAccessKey(getenv("AWS_ACCESS_KEY_ID")).setSecretKey(
                            getenv("AWS_SECRET_ACCESS_KEY")).setTagKey("aws-test-tag").setTagValue(
                            "non-existent-value");
                    client::aws::impl::DescribeInstances desc(awsConfig, awsConfig.getHostHeader(), getLogger());
                    std::map<std::string, std::string> results = desc.execute();
                    ASSERT_TRUE(results.empty());
                }

                TEST_F (DescribeInstancesTest, testDescribeInstancesOnlyTagIsSet) {
                    client::config::ClientAwsConfig awsConfig;
                    awsConfig.setEnabled(true).setAccessKey(getenv("AWS_ACCESS_KEY_ID")).setSecretKey(
                            getenv("AWS_SECRET_ACCESS_KEY")).setTagKey("aws-test-tag");
                    client::aws::impl::DescribeInstances desc(awsConfig, awsConfig.getHostHeader(), getLogger());
                    std::map<std::string, std::string> results = desc.execute();
                    ASSERT_EQ(results.size(), 1U);
                    ASSERT_NE(results.end(), results.find(getenv("HZ_TEST_AWS_INSTANCE_PRIVATE_IP")));
                }

                TEST_F (DescribeInstancesTest, testDescribeInstancesOnlyTagIsSetToNonExistentTag) {
                    client::config::ClientAwsConfig awsConfig;
                    awsConfig.setEnabled(true).setAccessKey(getenv("AWS_ACCESS_KEY_ID")).setSecretKey(
                            getenv("AWS_SECRET_ACCESS_KEY")).setTagKey("non-existent-tag");
                    client::aws::impl::DescribeInstances desc(awsConfig, awsConfig.getHostHeader(), getLogger());
                    std::map<std::string, std::string> results = desc.execute();
                    ASSERT_TRUE(results.empty());
                }

                TEST_F (DescribeInstancesTest, testDescribeInstancesOnlyValueIsSet) {
                    client::config::ClientAwsConfig awsConfig;
                    awsConfig.setEnabled(true).setAccessKey(getenv("AWS_ACCESS_KEY_ID")).setSecretKey(
                            getenv("AWS_SECRET_ACCESS_KEY")).setTagValue("aws-tag-value-1");
                    client::aws::impl::DescribeInstances desc(awsConfig, awsConfig.getHostHeader(), getLogger());
                    std::map<std::string, std::string> results = desc.execute();
                    ASSERT_EQ(results.size(), 1U);
                    ASSERT_NE(results.end(), results.find(getenv("HZ_TEST_AWS_INSTANCE_PRIVATE_IP")));
                }

                TEST_F (DescribeInstancesTest, testDescribeInstancesOnlyValueIsSetToNonExistentValue) {
                    client::config::ClientAwsConfig awsConfig;
                    awsConfig.setEnabled(true).setAccessKey(getenv("AWS_ACCESS_KEY_ID")).setSecretKey(
                            getenv("AWS_SECRET_ACCESS_KEY")).setTagValue("non-existent-value");
                    client::aws::impl::DescribeInstances desc(awsConfig, awsConfig.getHostHeader(), getLogger());
                    std::map<std::string, std::string> results = desc.execute();
                    ASSERT_TRUE(results.empty());
                }

                TEST_F (DescribeInstancesTest, testDescribeInstancesSecurityGroup) {
                    client::config::ClientAwsConfig awsConfig;
                    awsConfig.setEnabled(true).setAccessKey(getenv("AWS_ACCESS_KEY_ID")).setSecretKey(
                            getenv("AWS_SECRET_ACCESS_KEY")).setSecurityGroupName("launch-wizard-147");
                    client::aws::impl::DescribeInstances desc(awsConfig, awsConfig.getHostHeader(), getLogger());
                    std::map<std::string, std::string> results = desc.execute();
                    ASSERT_EQ(results.size(), 1U);
                    ASSERT_NE(results.end(), results.find(getenv("HZ_TEST_AWS_INSTANCE_PRIVATE_IP")));
                }

                TEST_F (DescribeInstancesTest, testDescribeInstancesNonExistentSecurityGroup) {
                    client::config::ClientAwsConfig awsConfig;
                    awsConfig.setEnabled(true).setAccessKey(getenv("AWS_ACCESS_KEY_ID")).setSecretKey(
                            getenv("AWS_SECRET_ACCESS_KEY")).setSecurityGroupName("non-existent-group");
                    client::aws::impl::DescribeInstances desc(awsConfig, awsConfig.getHostHeader(), getLogger());
                    std::map<std::string, std::string> results = desc.execute();
                    ASSERT_TRUE(results.empty());
                }

            }
        }
    }
}

#endif //HZ_BUILD_WITH_SSL


#ifdef HZ_BUILD_WITH_SSL



namespace awsutil = hazelcast::client::aws::utility;

namespace hazelcast {
    namespace client {
        namespace test {
            namespace aws {
                class CloudUtilityTest : public ClientTestSupport {
                };

                TEST_F (CloudUtilityTest, testUnmarshallResponseXml) {
                    std::filebuf fb;
                    ASSERT_TRUE(fb.open("hazelcast/test/resources/sample_aws_response.xml", std::ios::in));
                    std::istream responseStream(&fb);

                    config::ClientAwsConfig awsConfig;
                    std::map<std::string, std::string> results = hazelcast::client::aws::utility::CloudUtility::unmarshalTheResponse(
                            responseStream, getLogger());
                    ASSERT_EQ(4U, results.size());
                    ASSERT_NE(results.end(), results.find("10.0.16.13"));
                    ASSERT_EQ("", results["10.0.16.13"]);
                    ASSERT_NE(results.end(), results.find("10.0.16.17"));
                    ASSERT_EQ("54.85.192.215", results["10.0.16.17"]);
                    ASSERT_NE(results.end(), results.find("10.0.16.25"));
                    ASSERT_EQ("", results["10.0.16.25"]);
                    ASSERT_NE(results.end(), results.find("172.30.4.118"));
                    ASSERT_EQ("54.85.192.213", results["172.30.4.118"]);
                }
            }
        }
    }
}

#endif //HZ_BUILD_WITH_SSL


namespace hazelcast {
    namespace client {
        namespace test {


            TestCustomXSerializable::TestCustomXSerializable() {

            }

            TestCustomXSerializable::TestCustomXSerializable(int id) :id(id){

            }

            bool TestCustomXSerializable::operator==(const TestCustomXSerializable& rhs) const {
                if (this == &rhs)
                    return true;
                if (id != rhs.id) return false;
                return true;
            }

            bool TestCustomXSerializable::operator!=(const TestCustomXSerializable& rhs) const {
                return !(*this == rhs);
            }

            int getHazelcastTypeId(TestCustomXSerializable const* param) {
                return 666;
            }

            TestCustomPerson::TestCustomPerson() {

            }

            TestCustomPerson::TestCustomPerson(const std::string& name):name(name) {

            }

            bool TestCustomPerson::operator==(const TestCustomPerson& rhs) const {
                if (this == &rhs)
                    return true;
                if (name.compare(rhs.name))
                    return false;
                return true;
            }

            bool TestCustomPerson::operator!=(const TestCustomPerson& rhs) const {
                return !(*this == rhs);
            }

            void TestCustomPerson::setName(const std::string& name) {
                this->name = name;
            }

            std::string TestCustomPerson::getName() const {
                return name;
            }

            int getHazelcastTypeId(TestCustomPerson const* param) {
                return 999;
            }

        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {

            void TestCustomPersonSerializer::write(serialization::ObjectDataOutput & out, const TestCustomPerson& object) {
                out.writeInt(999);
                const std::string &name = object.getName();
                out.writeUTF(&name);
                out.writeInt(999);
            }

            void TestCustomPersonSerializer::read(serialization::ObjectDataInput & in, TestCustomPerson& object) {
                int i = in.readInt();
                assert(i == 999);
                object.setName(*in.readUTF());
                i = in.readInt();
                assert(i == 999);
            }

            int TestCustomPersonSerializer::getHazelcastTypeId() const {
                return 999;
            }

        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            class BasicClientNearCacheTest
                    : public ClientTestSupport, public ::testing::WithParamInterface<config::InMemoryFormat> {
            public:
                static void SetUpTestSuite() {
                    instance = new HazelcastServer(*g_srvFactory);
                    instance2 = new HazelcastServer(*g_srvFactory);
                }

                static void TearDownTestSuite() {
                    delete instance2;
                    delete instance;
                    instance2 = NULL;
                    instance = NULL;
                }

                virtual void SetUp() {
                    nearCacheConfig = NearCacheTestUtils::createNearCacheConfig<int, std::string>(GetParam(),
                                                                                                  getTestName());
                }

                virtual void TearDown() {
                    if (nearCachedMap.get()) {
                        nearCachedMap->destroy();
                    }
                    if (noNearCacheMap.get()) {
                        noNearCacheMap->destroy();
                    }
                    if (NULL != client.get()) {
                        client->shutdown();
                    }
                    if (NULL != nearCachedClient.get()) {
                        nearCachedClient->shutdown();
                    }
                }

            protected:
                /**
                 * Provides utility methods for unified Near Cache tests.
                 */
                class NearCacheTestUtils : public ClientTestSupport {
                public:
                    /**
                     * Creates a {@link NearCacheConfig} with a given {@link InMemoryFormat}.
                     *
                     * @param inMemoryFormat the {@link InMemoryFormat} to set
                     * @return the {@link NearCacheConfig}
                     */
                    template<typename K, typename V>
                    static std::shared_ptr<config::NearCacheConfig<K, V> > createNearCacheConfig(
                            config::InMemoryFormat inMemoryFormat, const std::string &mapName) {
                        std::shared_ptr<config::NearCacheConfig<K, V> > nearCacheConfig(
                                new config::NearCacheConfig<K, V>());

                        nearCacheConfig->setName(mapName).setInMemoryFormat(inMemoryFormat).setInvalidateOnChange(true);

                        return nearCacheConfig;
                    }

                    /**
                     * Configures the {@link EvictionConfig} of the given {@link NearCacheConfig}.
                     *
                     * @param nearCacheConfig the {@link NearCacheConfig} to configure
                     * @param evictionPolicy  the {@link EvictionPolicy} to set
                     * @param maxSizePolicy   the {@link MaxSizePolicy} to set
                     * @param maxSize         the max size to set
                     */
                    template<typename K, typename V>
                    static void setEvictionConfig(config::NearCacheConfig<K, V> &nearCacheConfig,
                                                  config::EvictionPolicy evictionPolicy,
                                                  typename config::EvictionConfig<K, V>::MaxSizePolicy maxSizePolicy,
                                                  int maxSize) {
                        nearCacheConfig.getEvictionConfig()
                                ->setEvictionPolicy(evictionPolicy)
                                .setMaximumSizePolicy(maxSizePolicy)
                                .setSize(maxSize);
                    }

                    /**
                     * Asserts the {@link NearCacheStats} for expected values.
                     *
                     * @param stats                   stats of the near cache
                     * @param expectedOwnedEntryCount the expected owned entry count
                     * @param expectedHits            the expected Near Cache hits
                     * @param expectedMisses          the expected Near Cache misses
                     */
                    static void assertNearCacheStats(monitor::NearCacheStats &stats,
                                                     int64_t expectedOwnedEntryCount, int64_t expectedHits,
                                                     int64_t expectedMisses) {
                        assertNearCacheStats(stats, expectedOwnedEntryCount, expectedHits, expectedMisses, 0, 0);
                    }

                    /**
                     * Asserts the {@link NearCacheStats} for expected values.
                     *
                     * @param stats                   stats of the near cache
                     * @param expectedOwnedEntryCount the expected owned entry count
                     * @param expectedHits            the expected Near Cache hits
                     * @param expectedMisses          the expected Near Cache misses
                     * @param expectedEvictions       the expected Near Cache evictions
                     * @param expectedExpirations     the expected Near Cache expirations
                     */
                    static void assertNearCacheStats(monitor::NearCacheStats &stats,
                                                     int64_t expectedOwnedEntryCount, int64_t expectedHits,
                                                     int64_t expectedMisses,
                                                     int64_t expectedEvictions, int64_t expectedExpirations) {
                        assertEqualsFormat("Near Cache entry count should be %ld, but was %ld ",
                                           expectedOwnedEntryCount, stats.getOwnedEntryCount(), stats);
                        assertEqualsFormat("Near Cache hits should be %ld, but were %ld ",
                                           expectedHits, stats.getHits(), stats);
                        assertEqualsFormat("Near Cache misses should be %ld, but were %ld ",
                                           expectedMisses, stats.getMisses(), stats);
                        assertEqualsFormat("Near Cache evictions should be %ld, but were %ld ",
                                           expectedEvictions, stats.getEvictions(), stats);
                        assertEqualsFormat("Near Cache expirations should be %ld, but were %ld ",
                                           expectedExpirations, stats.getExpirations(), stats);
                    }

                    static void assertEqualsFormat(const char *messageFormat, int64_t expected, int64_t actual,
                                                   monitor::NearCacheStats &stats) {
                        char buf[300];
                        hazelcast::util::hz_snprintf(buf, 300, messageFormat, expected, actual);
                        ASSERT_EQ(expected, actual) << buf << "(" << stats.toString() << ")";
                    }

                private:
                    NearCacheTestUtils();

                    NearCacheTestUtils(const NearCacheTestUtils &);
                };

                /**
                 * The default count to be inserted into the Near Caches.
                 */
                static const int DEFAULT_RECORD_COUNT;

                void createContext() {
                    createNoNearCacheContext();
                    createNearCacheContext();
                }

                void createNoNearCacheContext() {
                    client = std::unique_ptr<HazelcastClient>(new HazelcastClient(getConfig()));
                    noNearCacheMap = std::unique_ptr<IMap<int, std::string> >(
                            new IMap<int, std::string>(client->getMap<int, std::string>(getTestName())));
                }

                void createNearCacheContext() {
                    nearCachedClientConfig = getConfig();
                    nearCachedClientConfig.addNearCacheConfig(nearCacheConfig);
                    nearCachedClient = std::unique_ptr<HazelcastClient>(new HazelcastClient(nearCachedClientConfig));
                    nearCachedMap = std::unique_ptr<IMap<int, std::string> >(new IMap<int, std::string>(
                            nearCachedClient->getMap<int, std::string>(getTestName())));
                    spi::ClientContext clientContext(*nearCachedClient);
                    nearCacheManager = &clientContext.getNearCacheManager();
                    nearCache = nearCacheManager->
                            getNearCache<int, std::string, serialization::pimpl::Data>(getTestName());
                    this->stats = (nearCache.get() == NULL) ? NULL : &nearCache->getNearCacheStats();
                }

                void testContainsKey(bool useNearCachedMapForRemoval) {
                    createNoNearCacheContext();

                    // populate map
                    noNearCacheMap->put(1, "value1");
                    noNearCacheMap->put(2, "value2");
                    noNearCacheMap->put(3, "value3");

                    createNearCacheContext();

                    // populate Near Cache
                    nearCachedMap->get(1);
                    nearCachedMap->get(2);
                    nearCachedMap->get(3);

                    ASSERT_TRUE(nearCachedMap->containsKey(1));
                    ASSERT_TRUE(nearCachedMap->containsKey(2));
                    ASSERT_TRUE(nearCachedMap->containsKey(3));
                    ASSERT_FALSE(nearCachedMap->containsKey(5));

                    // remove a key which is in the Near Cache
                    IMap<int, std::string> &adapter = useNearCachedMapForRemoval ? *nearCachedMap
                                                                                 : *noNearCacheMap;
                    adapter.remove(1);

                    WAIT_TRUE_EVENTUALLY(checkContainKeys());
                    ASSERT_FALSE(nearCachedMap->containsKey(1));
                    ASSERT_TRUE(nearCachedMap->containsKey(2));
                    ASSERT_TRUE(nearCachedMap->containsKey(3));
                    ASSERT_FALSE(nearCachedMap->containsKey(5));
                }

                bool checkContainKeys() {
                    return !nearCachedMap->containsKey(1) && nearCachedMap->containsKey(2) &&
                           nearCachedMap->containsKey(3) && !nearCachedMap->containsKey(5);
                }

                void
                assertNearCacheInvalidationRequests(monitor::NearCacheStats &stats, int64_t invalidationRequests) {
                    if (nearCacheConfig->isInvalidateOnChange() && invalidationRequests > 0) {
                        monitor::impl::NearCacheStatsImpl &nearCacheStatsImpl = (monitor::impl::NearCacheStatsImpl &) stats;
                        ASSERT_EQ_EVENTUALLY(invalidationRequests, nearCacheStatsImpl.getInvalidationRequests());
                        nearCacheStatsImpl.resetInvalidationEvents();
                    }
                }

                void populateMap() {
                    char buf[30];
                    for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                        hazelcast::util::hz_snprintf(buf, 30, "value-%d", i);
                        noNearCacheMap->put(i, buf);
                    }

                    assertNearCacheInvalidationRequests(*stats, DEFAULT_RECORD_COUNT);
                }

                void populateNearCache() {
                    char buf[30];
                    for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                        std::shared_ptr<string> value = nearCachedMap->get(i);
                        ASSERT_NOTNULL(value.get(), std::string);
                        hazelcast::util::hz_snprintf(buf, 30, "value-%d", i);
                        ASSERT_EQ(buf, *value);
                    }
                }

                std::shared_ptr<serialization::pimpl::Data> getNearCacheKey(int key) {
                    spi::ClientContext clientContext(*client);
                    return clientContext.getSerializationService().toSharedData<int>(&key);
                }

                int64_t getExpectedMissesWithLocalUpdatePolicy() {
                    if (nearCacheConfig->getLocalUpdatePolicy() == config::NearCacheConfig<int, std::string>::CACHE) {
                        // we expect the first and second get() to be hits, since the value should be already be cached
                        return stats->getMisses();
                    }
                    // we expect the first get() to be a miss, due to the replaced / invalidated value
                    return stats->getMisses() + 1;
                }

                int64_t getExpectedHitsWithLocalUpdatePolicy() {
                    if (nearCacheConfig->getLocalUpdatePolicy() == config::NearCacheConfig<int, std::string>::CACHE) {
                        // we expect the first and second get() to be hits, since the value should be already be cached
                        return stats->getHits() + 2;
                    }
                    // we expect the second get() to be a hit, since it should be served from the Near Cache
                    return stats->getHits() + 1;
                }

                bool checkMissesAndHits(int64_t &expectedMisses, int64_t &expectedHits,
                                        std::shared_ptr<std::string> &value) {
                    expectedMisses = getExpectedMissesWithLocalUpdatePolicy();
                    expectedHits = getExpectedHitsWithLocalUpdatePolicy();

                    value = nearCachedMap->get(1);
                    if (NULL == value.get() || *value != "newValue") {
                        return false;
                    }
                    value = nearCachedMap->get(1);
                    if (NULL == value.get() || *value != "newValue") {
                        return false;
                    }

                    return expectedHits == stats->getHits() && expectedMisses == stats->getMisses();
                }

                void whenPutAllIsUsed_thenNearCacheShouldBeInvalidated(bool useNearCacheAdapter) {
                    createNoNearCacheContext();

                    createNearCacheContext();

                    populateMap();

                    populateNearCache();

                    std::map<int, std::string> invalidationMap;
                    char buf[30];
                    for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                        hazelcast::util::hz_snprintf(buf, 30, "value-%d", i);
                        invalidationMap[i] = buf;
                    }

                    // this should invalidate the Near Cache
                    IMap<int, std::string> &adapter = useNearCacheAdapter ? *nearCachedMap
                                                                          : *noNearCacheMap;
                    adapter.putAll(invalidationMap);

                    WAIT_EQ_EVENTUALLY(0, nearCache->size());
                    ASSERT_EQ(0, nearCache->size()) << "Invalidation is not working on putAll()";
                }

                ClientConfig clientConfig;
                ClientConfig nearCachedClientConfig;
                std::shared_ptr<config::NearCacheConfig<int, std::string> > nearCacheConfig;
                std::unique_ptr<HazelcastClient> client;
                std::unique_ptr<HazelcastClient> nearCachedClient;
                std::unique_ptr<IMap<int, std::string> > noNearCacheMap;
                std::unique_ptr<IMap<int, std::string> > nearCachedMap;
                hazelcast::client::internal::nearcache::NearCacheManager *nearCacheManager;
                std::shared_ptr<hazelcast::client::internal::nearcache::NearCache<serialization::pimpl::Data, std::string> > nearCache;
                monitor::NearCacheStats *stats;
                static HazelcastServer *instance;
                static HazelcastServer *instance2;
            };

            const int BasicClientNearCacheTest::DEFAULT_RECORD_COUNT = 1000;
            HazelcastServer *BasicClientNearCacheTest::instance = NULL;
            HazelcastServer *BasicClientNearCacheTest::instance2 = NULL;

            /**
             * Checks that the Near Cache keys are correctly checked when {@link DataStructureAdapter#containsKey(Object)} is used.
             *
             * This variant uses the {@link NearCacheTestContext#nearCacheAdapter}, so there is no Near Cache invalidation necessary.
             */
            TEST_P(BasicClientNearCacheTest, testContainsKey_withUpdateOnNearCacheAdapter) {
                testContainsKey(true);
            }

            /**
             * Checks that the memory costs are calculated correctly.
             *
             * This variant uses the noNearCacheMap(client with no near cache), so we need to configure Near Cache
             * invalidation.
             */
            TEST_P(BasicClientNearCacheTest, testContainsKey_withUpdateOnDataAdapter) {
                nearCacheConfig->setInvalidateOnChange(true);
                testContainsKey(false);
            }

            /**
             * Checks that the Near Cache never returns its internal {@link NearCache#NULL_OBJECT} to the public API.
             */
            TEST_P(BasicClientNearCacheTest, whenEmptyMap_thenPopulatedNearCacheShouldReturnNull_neverNULLOBJECT) {
                createContext();

                for (int i = 0; i < DEFAULT_RECORD_COUNT; i++) {
                    // populate Near Cache
                    ASSERT_NULL("Expected null from original data structure for key " << i,
                                nearCachedMap->get(i).get(), std::string);
                    // fetch value from Near Cache
                    ASSERT_NULL("Expected null from Near cached data structure for key " << i,
                                nearCachedMap->get(i).get(), std::string);

                    // fetch internal value directly from Near Cache
                    std::shared_ptr<serialization::pimpl::Data> key = getNearCacheKey(i);
                    std::shared_ptr<std::string> value = nearCache->get(key);
                    if (value.get() != NULL) {
                        // the internal value should either be `null` or `NULL_OBJECT`
                        std::shared_ptr<std::string> nullObj = std::static_pointer_cast<std::string>(
                                hazelcast::client::internal::nearcache::NearCache<int, std::string>::NULL_OBJECT);
                        ASSERT_EQ(nullObj, nearCache->get(key)) << "Expected NULL_OBJECT in Near Cache for key " << i;
                    }
                }
            }

/**
             * Checks that the Near Cache updates value for keys which are already in the Near Cache,
             * even if the Near Cache is full an the eviction is disabled (via {@link com.hazelcast.config.EvictionPolicy#NONE}.
             *
             * This variant uses the {@link NearCacheTestContext#nearCacheAdapter}, so there is no Near Cache invalidation necessary.
             */
            TEST_P(BasicClientNearCacheTest,
                   whenCacheIsFull_thenPutOnSameKeyShouldUpdateValue_withUpdateOnNearCacheAdapter) {
                int size = DEFAULT_RECORD_COUNT / 2;
                NearCacheTestUtils::setEvictionConfig<int, std::string>(*nearCacheConfig, config::NONE,
                                                                        config::EvictionConfig<int, std::string>::ENTRY_COUNT,
                                                                        size);
                createNoNearCacheContext();

                createNearCacheContext();

                populateMap();

                populateNearCache();

                ASSERT_EQ(size, nearCache->size());
                std::shared_ptr<std::string> value = nearCachedMap->get(1);
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ("value-1", *value);

                nearCachedMap->put(1, "newValue");

                int64_t expectedMisses = getExpectedMissesWithLocalUpdatePolicy();
                int64_t expectedHits = getExpectedHitsWithLocalUpdatePolicy();

                value = nearCachedMap->get(1);
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ("newValue", *value);
                value = nearCachedMap->get(1);
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ("newValue", *value);

                NearCacheTestUtils::assertNearCacheStats(*stats, size, expectedHits, expectedMisses);
            }

/**
             * Checks that the Near Cache updates value for keys which are already in the Near Cache,
             * even if the Near Cache is full an the eviction is disabled (via {@link com.hazelcast.config.EvictionPolicy#NONE}.
             *
             * This variant uses the {@link NearCacheTestContext#dataAdapter}, so we need to configure Near Cache invalidation.
             */
            TEST_P(BasicClientNearCacheTest,
                   whenCacheIsFull_thenPutOnSameKeyShouldUpdateValue_withUpdateOnDataAdapter) {
                int size = DEFAULT_RECORD_COUNT / 2;
                NearCacheTestUtils::setEvictionConfig<int, std::string>(*nearCacheConfig, config::NONE,
                                                                        config::EvictionConfig<int, std::string>::ENTRY_COUNT,
                                                                        size);
                nearCacheConfig->setInvalidateOnChange(true);

                createNoNearCacheContext();

                createNearCacheContext();

                populateMap();

                populateNearCache();

                ASSERT_EQ(size, nearCache->size());
                std::shared_ptr<std::string> value = nearCachedMap->get(1);
                ASSERT_NOTNULL(value.get(), std::string);
                ASSERT_EQ("value-1", *value);

                noNearCacheMap->put(1, "newValue");

// we have to use assertTrueEventually since the invalidation is done asynchronously
                int64_t expectedMisses = 0;
                int64_t expectedHits = 0;
                WAIT_TRUE_EVENTUALLY(checkMissesAndHits(expectedMisses, expectedHits, value));
                SCOPED_TRACE("whenCacheIsFull_thenPutOnSameKeyShouldUpdateValue_withUpdateOnDataAdapter");
                NearCacheTestUtils::assertNearCacheStats(*stats, size, expectedHits, expectedMisses);
            }

/**
             * Checks that the Near Cache values are eventually invalidated when {@link DataStructureAdapter#putAll(Map)} is used.
             *
             * This variant uses the nearCacheMap, so there is no Near Cache invalidation necessary.
             */
            TEST_P(BasicClientNearCacheTest,
                   whenPutAllIsUsed_thenNearCacheShouldBeInvalidated_withUpdateOnNearCacheAdapter) {
                whenPutAllIsUsed_thenNearCacheShouldBeInvalidated(true);
            }

/**
             * Checks that the Near Cache values are eventually invalidated when {@link DataStructureAdapter#putAll(Map)} is used.
             *
             * This variant uses the noNearCacheMap, so we need to configure Near Cache invalidation.
             */
            TEST_P(BasicClientNearCacheTest,
                   whenPutAllIsUsed_thenNearCacheShouldBeInvalidated_withUpdateOnDataAdapter) {
                nearCacheConfig->setInvalidateOnChange(true);
                whenPutAllIsUsed_thenNearCacheShouldBeInvalidated(false);
            }

/**
             * Checks that the {@link com.hazelcast.monitor.NearCacheStats} are calculated correctly.
             */
            TEST_P(BasicClientNearCacheTest, testNearCacheStats) {
                createNoNearCacheContext();

                createNearCacheContext();

// populate map
                populateMap();

                {
                    SCOPED_TRACE("testNearCacheStats when near cache is empty");
                    NearCacheTestUtils::assertNearCacheStats(*stats, 0, 0, 0);
                }

// populate Near Cache. Will cause misses and will increment the owned entry count
                populateNearCache();
                {
                    SCOPED_TRACE("testNearCacheStats when near cache is initially populated");
                    NearCacheTestUtils::assertNearCacheStats(*stats, DEFAULT_RECORD_COUNT, 0, DEFAULT_RECORD_COUNT);
                }

// make some hits
                populateNearCache();
                {
                    SCOPED_TRACE("testNearCacheStats when near cache is hit after being populated.");
                    NearCacheTestUtils::assertNearCacheStats(*stats, DEFAULT_RECORD_COUNT, DEFAULT_RECORD_COUNT,
                                                             DEFAULT_RECORD_COUNT);
                }
            }

            TEST_P(BasicClientNearCacheTest, testNearCacheEviction) {
                NearCacheTestUtils::setEvictionConfig<int, std::string>(*nearCacheConfig, config::LRU,
                                                                        config::EvictionConfig<int, std::string>::ENTRY_COUNT,
                                                                        DEFAULT_RECORD_COUNT);
                createNoNearCacheContext();

                createNearCacheContext();

// all Near Cache implementations use the same eviction algorithm, which evicts a single entry
                int64_t expectedEvictions = 1;

// populate map with an extra entry
                populateMap();
                char buf[20];
                hazelcast::util::hz_snprintf(buf, 20, "value-%d", DEFAULT_RECORD_COUNT);
                noNearCacheMap->put(DEFAULT_RECORD_COUNT, buf);

// populate Near Caches
                populateNearCache();

// we expect (size + the extra entry - the expectedEvictions) entries in the Near Cache
                int64_t expectedOwnedEntryCount = DEFAULT_RECORD_COUNT + 1 - expectedEvictions;
                int64_t expectedHits = stats->getHits();
                int64_t expectedMisses = stats->getMisses() + 1;

// trigger eviction via fetching the extra entry
                nearCachedMap->get(DEFAULT_RECORD_COUNT);

                int64_t evictions = stats->getEvictions();
                ASSERT_GE(evictions, expectedEvictions)
                                            << "Near Cache eviction count didn't reach the desired value ("
                                            << expectedEvictions << " vs. " << evictions << ") ("
                                            << stats->toString();

                SCOPED_TRACE("testNearCacheEviction");

                NearCacheTestUtils::assertNearCacheStats(*stats, expectedOwnedEntryCount, expectedHits, expectedMisses,
                                                         expectedEvictions, 0);
            }

            INSTANTIATE_TEST_SUITE_P(ClientNearCacheTest, BasicClientNearCacheTest,
                                     ::testing::Values(config::BINARY, config::OBJECT));
        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            class ClientMapNearCacheTest : public ClientTestSupport {
            protected:
                /**
                 * The default name used for the data structures which have a Near Cache.
                 */
                static const std::string DEFAULT_NEAR_CACHE_NAME;

                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    instance2 = new HazelcastServer(*g_srvFactory);
                }

                static void TearDownTestCase() {
                    delete instance2;
                    delete instance;
                    instance2 = NULL;
                    instance = NULL;
                }


                virtual void TearDown() {
                    if (map.get()) {
                        map->destroy();
                    }
                }

                std::shared_ptr<config::NearCacheConfig<int, int> > newNoInvalidationNearCacheConfig() {
                    std::shared_ptr<config::NearCacheConfig<int, int> > nearCacheConfig(newNearCacheConfig());
                    nearCacheConfig->setInMemoryFormat(config::OBJECT);
                    nearCacheConfig->setInvalidateOnChange(false);
                    return nearCacheConfig;
                }

                std::shared_ptr<config::NearCacheConfig<int, int> > newNearCacheConfig() {
                    return std::shared_ptr<config::NearCacheConfig<int, int> >(
                            new config::NearCacheConfig<int, int>());
                }

                std::unique_ptr<ClientConfig> newClientConfig() {
                    return std::unique_ptr<ClientConfig>(new ClientConfig());
                }

                IMap<int, int> &getNearCachedMapFromClient(
                        std::shared_ptr<config::NearCacheConfig<int, int> > nearCacheConfig) {
                    std::string mapName = DEFAULT_NEAR_CACHE_NAME;

                    nearCacheConfig->setName(mapName);

                    clientConfig = newClientConfig();
                    clientConfig->addNearCacheConfig(nearCacheConfig);

                    client = std::unique_ptr<HazelcastClient>(new HazelcastClient(*clientConfig));
                    map.reset(new IMap<int, int>(client->getMap<int, int>(mapName)));
                    return *map;
                }

                monitor::NearCacheStats *getNearCacheStats(IMap<int, int> &map) {
                    return map.getLocalMapStats().getNearCacheStats();
                }

                void assertThatOwnedEntryCountEquals(IMap<int, int> &clientMap, int64_t expected) {
                    ASSERT_EQ(expected, getNearCacheStats(clientMap)->getOwnedEntryCount());
                }

                std::unique_ptr<ClientConfig> clientConfig;
                std::shared_ptr<config::NearCacheConfig<int, int> > nearCacheConfig;
                std::unique_ptr<HazelcastClient> client;
                std::shared_ptr<IMap<int, int> > map;
                static HazelcastServer *instance;
                static HazelcastServer *instance2;
            };

            const std::string ClientMapNearCacheTest::DEFAULT_NEAR_CACHE_NAME = "defaultNearCache";
            HazelcastServer *ClientMapNearCacheTest::instance = NULL;
            HazelcastServer *ClientMapNearCacheTest::instance2 = NULL;

            TEST_F(ClientMapNearCacheTest, testGetAllChecksNearCacheFirst) {
                IMap<int, int> &map = getNearCachedMapFromClient(newNoInvalidationNearCacheConfig());

                std::set<int> keys;

                int size = 1003;
                for (int i = 0; i < size; i++) {
                    map.put(i, i);
                    keys.insert(i);
                }
                // populate Near Cache
                for (int i = 0; i < size; i++) {
                    map.get(i);
                }
                // getAll() generates the Near Cache hits
                map.getAll(keys);

                monitor::NearCacheStats *stats = getNearCacheStats(map);
                ASSERT_EQ(size, stats->getOwnedEntryCount());
                ASSERT_EQ(size, stats->getHits());
            }

            TEST_F(ClientMapNearCacheTest, testGetAllPopulatesNearCache) {
                IMap<int, int> &map = getNearCachedMapFromClient(newNoInvalidationNearCacheConfig());

                std::set<int> keys;

                int size = 1214;
                for (int i = 0; i < size; i++) {
                    map.put(i, i);
                    keys.insert(i);
                }
// populate Near Cache
                for (int i = 0; i < size; i++) {
                    map.get(i);
                }
// getAll() generates the Near Cache hits
                map.getAll(keys);

                assertThatOwnedEntryCountEquals(map, size);
            }

            TEST_F(ClientMapNearCacheTest, testRemoveAllNearCache) {
                IMap<int, int> &map = getNearCachedMapFromClient(newNearCacheConfig());

                std::set<int> keys;

                int size = 1214;
                for (int i = 0; i < size; i++) {
                    map.put(i, i);
                    keys.insert(i);
                }
// populate Near Cache
                for (int i = 0; i < size; i++) {
                    map.get(i);
                }

                map.removeAll(query::EqualPredicate<int>(query::QueryConstants::getKeyAttributeName(), 20));

                assertThatOwnedEntryCountEquals(map, 0);
            }
        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            class MySetItemListener : public ItemListener<std::string> {
            public:
                MySetItemListener(hazelcast::util::CountDownLatch &latch)
                        :latch(latch) {

                }

                void itemAdded(const ItemEvent<std::string>& itemEvent) {
                    latch.countDown();
                }

                void itemRemoved(const ItemEvent<std::string>& item) {
                }

            private:
                hazelcast::util::CountDownLatch &latch;
            };

            class ClientSetTest : public ClientTestSupport {
            protected:
                virtual void TearDown() {
                    set->clear();
                }

                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    client = new HazelcastClient(getConfig());
                    set = new ISet<std::string>(client->getSet<std::string>("MySet"));
                }

                static void TearDownTestCase() {
                    delete set;
                    delete client;
                    delete instance;

                    set = NULL;
                    client = NULL;
                    instance = NULL;
                }

                bool itemExists(const std::vector<std::string> &items, const std::string &item) const {
                    bool found = false;
                    for (std::vector<std::string>::const_iterator it = items.begin();it != items.end();++it) {
                        if (item == *it) {
                            found = true;
                            break;
                        }
                    }
                    return found;
                }

                static HazelcastServer *instance;
                static HazelcastClient *client;
                static ISet<std::string> *set;
            };

            HazelcastServer *ClientSetTest::instance = NULL;
            HazelcastClient *ClientSetTest::client = NULL;
            ISet<std::string> *ClientSetTest::set = NULL;

            TEST_F(ClientSetTest, testAddAll) {
                std::vector<std::string> l;
                l.push_back("item1");
                l.push_back("item2");

                ASSERT_TRUE(set->addAll(l));
                ASSERT_EQ(2, set->size());

                ASSERT_FALSE(set->addAll(l));
                ASSERT_EQ(2, set->size());
            }

            TEST_F(ClientSetTest, testAddRemove) {
                ASSERT_TRUE(set->add("item1"));
                ASSERT_TRUE(set->add("item2"));
                ASSERT_TRUE(set->add("item3"));
                ASSERT_EQ(3, set->size());

                ASSERT_FALSE(set->add("item3"));
                ASSERT_EQ(3, set->size());


                ASSERT_FALSE(set->remove("item4"));
                ASSERT_TRUE(set->remove("item3"));
            }

            TEST_F(ClientSetTest, testContains) {
                ASSERT_TRUE(set->add("item1"));
                ASSERT_TRUE(set->add("item2"));
                ASSERT_TRUE(set->add("item3"));
                ASSERT_TRUE(set->add("item4"));

                ASSERT_FALSE(set->contains("item5"));
                ASSERT_TRUE(set->contains("item2"));

                std::vector<std::string> l;
                l.push_back("item6");
                l.push_back("item3");

                ASSERT_FALSE(set->containsAll(l));
                ASSERT_TRUE(set->add("item6"));
                ASSERT_TRUE(set->containsAll(l));
            }

            TEST_F(ClientSetTest, testToArray) {
                ASSERT_TRUE(set->add("item1"));
                ASSERT_TRUE(set->add("item2"));
                ASSERT_TRUE(set->add("item3"));
                ASSERT_TRUE(set->add("item4"));
                ASSERT_FALSE(set->add("item4"));

                std::vector<std::string> items = set->toArray();

                ASSERT_EQ((size_t) 4, items.size());
                ASSERT_TRUE(itemExists(items, "item1"));
                ASSERT_TRUE(itemExists(items, "item2"));
                ASSERT_TRUE(itemExists(items, "item3"));
                ASSERT_TRUE(itemExists(items, "item4"));
            }

            TEST_F(ClientSetTest, testRemoveRetainAll) {
                ASSERT_TRUE(set->add("item1"));
                ASSERT_TRUE(set->add("item2"));
                ASSERT_TRUE(set->add("item3"));
                ASSERT_TRUE(set->add("item4"));

                std::vector<std::string> l;
                l.push_back("item4");
                l.push_back("item3");

                ASSERT_TRUE(set->removeAll(l));
                ASSERT_EQ(2, set->size());
                ASSERT_FALSE(set->removeAll(l));
                ASSERT_EQ(2, set->size());

                l.clear();
                l.push_back("item1");
                l.push_back("item2");
                ASSERT_FALSE(set->retainAll(l));
                ASSERT_EQ(2, set->size());

                l.clear();
                ASSERT_TRUE(set->retainAll(l));
                ASSERT_EQ(0, set->size());

            }

            TEST_F(ClientSetTest, testListener) {
                hazelcast::util::CountDownLatch latch(6);

                MySetItemListener listener(latch);
                std::string registrationId = set->addItemListener(listener, true);

                for (int i = 0; i < 5; i++) {
                    set->add(std::string("item") + hazelcast::util::IOUtil::to_string(i));
                }
                set->add("done");

                ASSERT_TRUE(latch.await(20));

                ASSERT_TRUE(set->removeItemListener(registrationId));
            }

            TEST_F(ClientSetTest, testIsEmpty) {
                ASSERT_TRUE(set->isEmpty());
                ASSERT_TRUE(set->add("item1"));
                ASSERT_FALSE(set->isEmpty());
            }
        }
    }
}





using namespace hazelcast::client::mixedtype;

namespace hazelcast {
    namespace client {
        namespace test {
            class MixedSetItemListener : public MixedItemListener {
            public:
                MixedSetItemListener(hazelcast::util::CountDownLatch &latch)
                        :latch(latch) {
                }

                virtual void itemAdded(const ItemEvent<TypedData> &item) {
                    latch.countDown();
                }

                virtual void itemRemoved(const ItemEvent<TypedData> &item) {
                }

            private:
                hazelcast::util::CountDownLatch &latch;
            };

            class MixedSetTest : public ClientTestSupport {
            protected:
                virtual void TearDown() {
                    set->clear();
                }

                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    client = new HazelcastClient;
                    set = new mixedtype::ISet(client->toMixedType().getSet("MySet"));
                }

                static void TearDownTestCase() {
                    delete set;
                    delete client;
                    delete instance;

                    set = NULL;
                    client = NULL;
                    instance = NULL;
                }

                bool itemExists(const std::vector<TypedData> &items, const std::string &item) const {
                    bool found = false;
                    for (std::vector<TypedData>::const_iterator it = items.begin();it != items.end();++it) {
                        if (item == *((*it).get<std::string>())) {
                            found = true;
                            break;
                        }
                    }
                    return found;
                }

                static HazelcastServer *instance;
                static HazelcastClient *client;
                static  mixedtype::ISet *set;
            };

            HazelcastServer *MixedSetTest::instance = NULL;
            HazelcastClient *MixedSetTest::client = NULL;
            mixedtype::ISet *MixedSetTest::set = NULL;

            TEST_F(MixedSetTest, testAddAll) {
                std::vector<std::string> l;
                l.push_back("item1");
                l.push_back("item2");

                ASSERT_TRUE(set->addAll<std::string>(l));
                ASSERT_EQ(2, set->size());

                ASSERT_FALSE(set->addAll<std::string>(l));
                ASSERT_EQ(2, set->size());
            }

            TEST_F(MixedSetTest, testAddRemove) {
                ASSERT_TRUE(set->add<std::string>("item1"));
                ASSERT_TRUE(set->add<std::string>("item2"));
                ASSERT_TRUE(set->add<std::string>("item3"));
                ASSERT_EQ(3, set->size());

                ASSERT_FALSE(set->add<std::string>("item3"));
                ASSERT_EQ(3, set->size());


                ASSERT_FALSE(set->remove<std::string>("item4"));
                ASSERT_TRUE(set->remove<std::string>("item3"));
            }

            TEST_F(MixedSetTest, testContains) {
                ASSERT_TRUE(set->add<std::string>("item1"));
                ASSERT_TRUE(set->add<std::string>("item2"));
                ASSERT_TRUE(set->add<std::string>("item3"));
                ASSERT_TRUE(set->add<std::string>("item4"));

                ASSERT_FALSE(set->contains<std::string>("item5"));
                ASSERT_TRUE(set->contains<std::string>("item2"));

                std::vector<std::string> l;
                l.push_back("item6");
                l.push_back("item3");

                ASSERT_FALSE(set->containsAll<std::string>(l));
                ASSERT_TRUE(set->add<std::string>("item6"));
                ASSERT_TRUE(set->containsAll<std::string>(l));
            }

            TEST_F(MixedSetTest, testToArray) {
                ASSERT_TRUE(set->add<std::string>("item1"));
                ASSERT_TRUE(set->add<std::string>("item2"));
                ASSERT_TRUE(set->add<std::string>("item3"));
                ASSERT_TRUE(set->add<std::string>("item4"));
                ASSERT_FALSE(set->add<std::string>("item4"));

                std::vector<TypedData> items = set->toArray();

                ASSERT_EQ((size_t) 4, items.size());
                ASSERT_TRUE(itemExists(items, "item1"));
                ASSERT_TRUE(itemExists(items, "item2"));
                ASSERT_TRUE(itemExists(items, "item3"));
                ASSERT_TRUE(itemExists(items, "item4"));
            }

            TEST_F(MixedSetTest, testRemoveRetainAll) {
                ASSERT_TRUE(set->add<std::string>("item1"));
                ASSERT_TRUE(set->add<std::string>("item2"));
                ASSERT_TRUE(set->add<std::string>("item3"));
                ASSERT_TRUE(set->add<std::string>("item4"));

                std::vector<std::string> l;
                l.push_back("item4");
                l.push_back("item3");

                ASSERT_TRUE(set->removeAll<std::string>(l));
                ASSERT_EQ(2, set->size());
                ASSERT_FALSE(set->removeAll<std::string>(l));
                ASSERT_EQ(2, set->size());

                l.clear();
                l.push_back("item1");
                l.push_back("item2");
                ASSERT_FALSE(set->retainAll<std::string>(l));
                ASSERT_EQ(2, set->size());

                l.clear();
                ASSERT_TRUE(set->retainAll<std::string>(l));
                ASSERT_EQ(0, set->size());

            }

            TEST_F(MixedSetTest, testListener) {
                hazelcast::util::CountDownLatch latch(6);

                MixedSetItemListener listener(latch);
                std::string registrationId = set->addItemListener(listener, true);

                for (int i = 0; i < 5; i++) {
                    set->add<std::string>(std::string("item") + hazelcast::util::IOUtil::to_string(i));
                }
                set->add<std::string>("done");

                ASSERT_TRUE(latch.await(20));

                ASSERT_TRUE(set->removeItemListener(registrationId));
            }
        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            class ICountDownLatchTest : public ClientTestSupport {
            public:
                ICountDownLatchTest();

                ~ICountDownLatchTest();
            protected:
                HazelcastServer instance;
                ClientConfig clientConfig;
                HazelcastClient client;
                std::unique_ptr<ICountDownLatch> l;
            };

            ICountDownLatchTest::ICountDownLatchTest()
                    : instance(*g_srvFactory), client(getNewClient()),
                      l(new ICountDownLatch(client.getICountDownLatch("ICountDownLatchTest"))) {
            }

            ICountDownLatchTest::~ICountDownLatchTest() {
            }

            void testLatchThread(hazelcast::util::ThreadArgs &args) {
                ICountDownLatch *l = (ICountDownLatch *) args.arg0;
                for (int i = 0; i < 20; i++) {
                    l->countDown();
                }
            }

            TEST_F(ICountDownLatchTest, testLatch) {
                ASSERT_TRUE(l->trySetCount(20));
                ASSERT_FALSE(l->trySetCount(10));
                ASSERT_EQ(20, l->getCount());

                hazelcast::util::StartedThread t(testLatchThread, l.get());

                ASSERT_TRUE(l->await(10 * 1000));

                t.join();
            }

        }
    }
}






namespace hazelcast {
    namespace client {
        namespace test {
            class ReliableTopicTest : public ClientTestSupport {
            public:
                static void publishTopics(hazelcast::util::ThreadArgs &args) {
                    ReliableTopic<int> *topic = (ReliableTopic<int> *)args.arg0;
                    std::vector<int> *publishValues = (std::vector<int> *)args.arg1;

                    hazelcast::util::sleep(5);

                    for (std::vector<int>::const_iterator it = publishValues->begin();it != publishValues->end(); ++it) {
                        topic->publish(&(*it));
                    }
                }
            protected:
                template <typename T>
                class GenericListener : public topic::ReliableMessageListener<T> {
                public:
                    GenericListener(hazelcast::util::CountDownLatch &countDownLatch) : latch(countDownLatch),
                                                                                       startSequence(-1),
                                                                                       numberOfMessagesReceived(0) {
                    }

                    GenericListener(hazelcast::util::CountDownLatch &countDownLatch, int64_t sequence) : latch(
                            countDownLatch),
                                                                                                         startSequence(
                                                                                                                 sequence),
                                                                                                         numberOfMessagesReceived(
                                                                                                                 0) {
                    }

                    virtual ~GenericListener() {
                        topic::Message<T> *m = NULL;
                        while ((m = messages.poll()) != NULL) {
                            delete (m);
                        }
                    }

                    virtual void onMessage(std::unique_ptr<topic::Message<T> > &&message) {
                        ++numberOfMessagesReceived;

                        messages.offer(message.release());

                        latch.countDown();
                    }

                    virtual int64_t retrieveInitialSequence() const {
                        return startSequence;
                    }

                    virtual void storeSequence(int64_t sequence) {
                    }

                    virtual bool isLossTolerant() const {
                        return false;
                    }

                    virtual bool isTerminal(const exception::IException &failure) const {
                        return false;
                    }

                    int getNumberOfMessagesReceived() {
                        int value = numberOfMessagesReceived;
                        return value;
                    }

                    hazelcast::util::ConcurrentQueue<topic::Message<T> > &getMessages() {
                        return messages;
                    }
                private:
                    hazelcast::util::CountDownLatch &latch;
                    int64_t startSequence;
                    hazelcast::util::AtomicInt numberOfMessagesReceived;
                    hazelcast::util::ConcurrentQueue<topic::Message<T> > messages;
                };

                class IntListener : public GenericListener<int> {
                public:
                    IntListener(hazelcast::util::CountDownLatch &countDownLatch) : GenericListener<int>(countDownLatch) { }

                    IntListener(hazelcast::util::CountDownLatch &countDownLatch, int64_t sequence) : GenericListener<int>(
                            countDownLatch, sequence) { }
                };

                class MyReliableListener : public GenericListener<Employee> {
                public:
                    MyReliableListener(hazelcast::util::CountDownLatch &countDownLatch, int64_t sequence) : GenericListener<Employee>(
                            countDownLatch, sequence) { }

                    MyReliableListener(hazelcast::util::CountDownLatch &countDownLatch) : GenericListener<Employee>(countDownLatch) { }
                };

                virtual void TearDown() {
                }

                static void SetUpTestCase() {
                    instance = new HazelcastServer(*g_srvFactory);
                    client = new HazelcastClient(getConfig());
                }

                static void TearDownTestCase() {
                    delete client;
                    delete instance;

                    client = NULL;
                    instance = NULL;
                }

                static HazelcastServer *instance;
                static HazelcastClient *client;
            };

            HazelcastServer *ReliableTopicTest::instance = NULL;
            HazelcastClient *ReliableTopicTest::client = NULL;

            TEST_F(ReliableTopicTest, testBasics) {
                std::shared_ptr<ReliableTopic<Employee> > rt;
                ASSERT_NO_THROW(rt = client->getReliableTopic<Employee>("testBasics"));

                ASSERT_EQ("testBasics", rt->getName());

                hazelcast::util::CountDownLatch latch(1);

                MyReliableListener listener(latch);

                std::string listenerId;
                ASSERT_NO_THROW(listenerId = rt->addMessageListener(listener));

                Employee empl1("first", 20);

                ASSERT_NO_THROW(rt->publish(&empl1));

                ASSERT_TRUE(latch.await(2));
                ASSERT_EQ(1, listener.getNumberOfMessagesReceived());
                const Employee *employee = listener.getMessages().poll()->getMessageObject();
                ASSERT_NE((Employee *) NULL, employee);
                ASSERT_EQ(empl1, *employee);

                // remove listener
                ASSERT_TRUE(rt->removeMessageListener(listenerId));
                ASSERT_FALSE(rt->removeMessageListener(listenerId));
            }

            TEST_F(ReliableTopicTest, testListenerSequence) {
                std::shared_ptr<ReliableTopic<Employee> > rt;
                ASSERT_NO_THROW(rt = client->getReliableTopic<Employee>("testListenerSequence"));

                Employee empl1("first", 10);
                Employee empl2("second", 20);

                ASSERT_NO_THROW(rt->publish(&empl1));
                ASSERT_NO_THROW(rt->publish(&empl2));

                hazelcast::util::CountDownLatch latch(1);

                MyReliableListener listener(latch, 1);
                std::string listenerId;
                ASSERT_NO_THROW(listenerId = rt->addMessageListener(listener));

                ASSERT_TRUE(latch.await(1));
                ASSERT_EQ(1, listener.getNumberOfMessagesReceived());
                const Employee *employee = listener.getMessages().poll()->getMessageObject();
                ASSERT_NE((Employee *) NULL, employee);
                ASSERT_EQ(empl2, *employee);

                // remove listener
                ASSERT_TRUE(rt->removeMessageListener(listenerId));
            }

            TEST_F(ReliableTopicTest, removeMessageListener_whenExisting) {
                std::shared_ptr<ReliableTopic<Employee> > rt;
                ASSERT_NO_THROW(rt = client->getReliableTopic<Employee>("removeMessageListener_whenExisting"));

                Employee empl1("first", 10);

                hazelcast::util::CountDownLatch latch(1);

                MyReliableListener listener(latch);
                std::string listenerId;
                ASSERT_NO_THROW(listenerId = rt->addMessageListener(listener));

                // remove listener
                ASSERT_TRUE(rt->removeMessageListener(listenerId));

                ASSERT_NO_THROW(rt->publish(&empl1));

                ASSERT_FALSE(latch.await(2));
                ASSERT_EQ(0, listener.getNumberOfMessagesReceived());
            }

            TEST_F(ReliableTopicTest, removeMessageListener_whenNonExisting) {
                std::shared_ptr<ReliableTopic<Employee> > rt;
                ASSERT_NO_THROW(rt = client->getReliableTopic<Employee>("removeMessageListener_whenNonExisting"));

// remove listener
                ASSERT_FALSE(rt->removeMessageListener("abc"));
            }

            TEST_F(ReliableTopicTest, publishNull) {
                std::shared_ptr<ReliableTopic<int> > intTopic;
                ASSERT_NO_THROW(intTopic = client->getReliableTopic<int>("publishNull"));

                hazelcast::util::CountDownLatch latch(1);
                IntListener listener(latch);

                std::string listenerId;
                ASSERT_NO_THROW(listenerId = intTopic->addMessageListener(listener));

                intTopic->publish((int *) NULL);

                ASSERT_TRUE(latch.await(5));
                ASSERT_EQ(1, listener.getNumberOfMessagesReceived());
                const int *val = listener.getMessages().poll()->getMessageObject();
                ASSERT_EQ((const int *) NULL, val);
            }

            TEST_F(ReliableTopicTest, publishMultiple) {
                std::shared_ptr<ReliableTopic<std::string> > topic;
                ASSERT_NO_THROW(topic = client->getReliableTopic<std::string>("publishMultiple"));

                hazelcast::util::CountDownLatch latch(5);
                GenericListener <std::string> listener(latch);

                std::string listenerId;
                ASSERT_NO_THROW(listenerId = topic->addMessageListener(listener));

                std::vector<std::string> items;
                for (int k = 0; k < 5; k++) {
                    std::string item = hazelcast::util::IOUtil::to_string<int>(k);
                    topic->publish(&item);
                    items.push_back(item);
                }

                ASSERT_TRUE(latch.await(5));
                ASSERT_EQ(5, listener.getNumberOfMessagesReceived());
                hazelcast::util::ConcurrentQueue<topic::Message<std::string> > &queue = listener.getMessages();
                for (int k = 0; k < 5; k++) {
                    const std::string *val = queue.poll()->getMessageObject();
                    ASSERT_NE((const std::string *) NULL, val);
                    ASSERT_EQ(items[k], *val);
                }
            }

            TEST_F(ReliableTopicTest, testConfig) {
                ClientConfig clientConfig;
                clientConfig.addAddress(Address(g_srvFactory->getServerAddress(), 5701));
                config::ReliableTopicConfig relConfig("testConfig");
                relConfig.setReadBatchSize(2);
                clientConfig.addReliableTopicConfig(relConfig);
                HazelcastClient configClient(clientConfig);

                std::shared_ptr<ReliableTopic<std::string> > topic;
                ASSERT_NO_THROW(topic = configClient.getReliableTopic<std::string>("testConfig"));

                hazelcast::util::CountDownLatch latch(5);
                GenericListener <std::string> listener(latch);

                std::string listenerId;
                ASSERT_NO_THROW(listenerId = topic->addMessageListener(listener));

                std::vector<std::string> items;
                for (int k = 0; k < 5; k++) {
                    std::string item = hazelcast::util::IOUtil::to_string<int>(k);
                    topic->publish(&item);
                    items.push_back(item);
                }

                ASSERT_TRUE(latch.await(5));
                ASSERT_EQ(5, listener.getNumberOfMessagesReceived());
                hazelcast::util::ConcurrentQueue<topic::Message<std::string> > &queue = listener.getMessages();
                for (int k = 0; k < 5; k++) {
                    const std::string *val = queue.poll()->getMessageObject();
                    ASSERT_NE((const std::string *) NULL, val);
                    ASSERT_EQ(items[k], *val);
                }
            }

            TEST_F(ReliableTopicTest, testMessageFieldSetCorrectly) {
                std::shared_ptr<ReliableTopic<int> > intTopic;
                ASSERT_NO_THROW(intTopic = client->getReliableTopic<int>("testMessageFieldSetCorrectly"));

                hazelcast::util::CountDownLatch latch(1);
                IntListener listener(latch);

                std::string listenerId;
                ASSERT_NO_THROW(listenerId = intTopic->addMessageListener(listener));

                int64_t timeBeforePublish = hazelcast::util::currentTimeMillis();
                int publishedValue = 3;
                intTopic->publish(&publishedValue);
                int64_t timeAfterPublish = hazelcast::util::currentTimeMillis();

                ASSERT_TRUE(latch.await(5));
                ASSERT_EQ(1, listener.getNumberOfMessagesReceived());
                topic::Message<int> *message = listener.getMessages().poll();
                const int *val = message->getMessageObject();
                ASSERT_EQ(publishedValue, *val);

                ASSERT_LE(timeBeforePublish, message->getPublishTime());
                ASSERT_GE(timeAfterPublish, message->getPublishTime());
                ASSERT_EQ(intTopic->getName(), message->getSource());
                ASSERT_EQ((Member *) NULL, message->getPublishingMember());
            }

// makes sure that when a listener is register, we don't see any messages being published before
// it got registered. We'll only see the messages after it got registered.
            TEST_F(ReliableTopicTest, testAlwaysStartAfterTail) {
                std::shared_ptr<ReliableTopic<int> > intTopic;
                ASSERT_NO_THROW(intTopic = client->getReliableTopic<int>("testAlwaysStartAfterTail"));

                int publishedValue = 1;
                ASSERT_NO_THROW(intTopic->publish(&publishedValue));
                publishedValue = 2;
                ASSERT_NO_THROW(intTopic->publish(&publishedValue));
                publishedValue = 3;
                ASSERT_NO_THROW(intTopic->publish(&publishedValue));

                std::vector<int> expectedValues;
                expectedValues.push_back(4);
                expectedValues.push_back(5);
                expectedValues.push_back(6);

// spawn a thread for publishing new data
                hazelcast::util::StartedThread t(publishTopics, intTopic.get(), &expectedValues);

                hazelcast::util::CountDownLatch latch(3);
                IntListener listener(latch);

                std::string listenerId;
                ASSERT_NO_THROW(listenerId = intTopic->addMessageListener(listener));

                ASSERT_TRUE(latch.await(10));
                ASSERT_EQ((int) expectedValues.size(), listener.getNumberOfMessagesReceived());
                hazelcast::util::ConcurrentQueue<topic::Message<int> > &objects = listener.getMessages();

                for (std::vector<int>::const_iterator it = expectedValues.begin(); it != expectedValues.end(); ++it) {
                    std::unique_ptr<int> val = objects.poll()->releaseMessageObject();
                    ASSERT_NE((int *) NULL, val.get());
                    ASSERT_EQ(*it, *val);
                }
            }
        }
    }
}





using namespace hazelcast::client;

namespace hazelcast {
    namespace client {
        namespace test {
            namespace performance {
                class SimpleMapTest : public ClientTestSupport {
                protected:
                    static const int THREAD_COUNT = 40;
                    static const int ENTRY_COUNT = 10000;
                    static const int VALUE_SIZE = 10;
                    static const int STATS_SECONDS = 10;
                    static const int GET_PERCENTAGE = 40;
                    static const int PUT_PERCENTAGE = 40;

                    class Stats {
                    public:
                        Stats() : getCount(0), putCount(0), removeCount(0) {
                        }

                        Stats(const Stats &rhs) : getCount(const_cast<Stats &>(rhs).getCount.load()),
                                                  putCount(const_cast<Stats &>(rhs).putCount.load()),
                                                  removeCount(const_cast<Stats &>(rhs).removeCount.load()) {
                        }

                        Stats getAndReset() {
                            Stats newOne(*this);
                            getCount = 0;
                            putCount = 0;
                            removeCount = 0;
                            return newOne;
                        }

                        mutable std::atomic<int64_t> getCount;
                        mutable std::atomic<int64_t> putCount;
                        mutable std::atomic<int64_t> removeCount;

                        void print() const {
                            std::cerr << "Total = " << total() << ", puts = " << putCount << " , gets = " << getCount
                                      << " , removes = "
                                      << removeCount << std::endl;
                        }

                        int total() const {
                            return (int) getCount + (int) putCount + (int) removeCount;
                        }
                    };

                    class StatsPrinterTask : public hazelcast::util::Runnable {
                    public:
                        StatsPrinterTask(Stats &stats) : stats(stats) {}

                        virtual void run() {
                            while (true) {
                                try {
                                    hazelcast::util::sleep((unsigned int) STATS_SECONDS);
                                    const Stats statsNow = stats.getAndReset();
                                    statsNow.print();
                                    std::cerr << "Operations per Second : " << statsNow.total() / STATS_SECONDS
                                              << std::endl;
                                } catch (std::exception &e) {
                                    std::cerr << e.what() << std::endl;
                                }
                            }
                        }

                        virtual const std::string getName() const {
                            return "StatPrinterTask";
                        }

                    private:
                        Stats &stats;
                    };

                    class Task : public hazelcast::util::Runnable {
                    public:
                        Task(Stats &stats, IMap<int, std::vector<char> > &map,
                             const std::shared_ptr<hazelcast::util::ILogger> &logger) : stats(stats), map(map),
                                                                                        logger(logger) {
                        }

                        virtual void run() {
                            std::vector<char> value(VALUE_SIZE);
                            bool running = true;
                            int getCount = 0;
                            int putCount = 0;
                            int removeCount = 0;

                            int updateIntervalCount = 1000;
                            while (running) {
                                int key = rand() % ENTRY_COUNT;
                                int operation = (rand() % 100);
                                try {
                                    if (operation < GET_PERCENTAGE) {
                                        map.get(key);
                                        ++getCount;
                                    } else if (operation < GET_PERCENTAGE + PUT_PERCENTAGE) {
                                        std::shared_ptr<std::vector<char> > vector = map.put(key, value);
                                        ++putCount;
                                    } else {
                                        map.remove(key);
                                        ++removeCount;
                                    }
                                    updateStats(updateIntervalCount, getCount, putCount, removeCount);
                                } catch (hazelcast::client::exception::IOException &e) {
                                    logger->warning(
                                            std::string("[SimpleMapTest IOException] ") + e.what());
                                } catch (hazelcast::client::exception::HazelcastClientNotActiveException &e) {
                                    logger->warning(
                                            std::string("[SimpleMapTest::run] ") + e.what());
                                } catch (hazelcast::client::exception::IException &e) {
                                    logger->warning(
                                            std::string("[SimpleMapTest:run] ") + e.what());
                                } catch (...) {
                                    logger->warning("[SimpleMapTest:run] unknown exception!");
                                    running = false;
                                    throw;
                                }
                            }
                        }

                        virtual const std::string getName() const {
                            return "SimpleMapTest Task";
                        }

                    private:
                        void
                        updateStats(int updateIntervalCount, int &getCount, int &putCount, int &removeCount) const {
                            if ((getCount + putCount + removeCount) % updateIntervalCount == 0) {
                                int64_t current = stats.getCount;
                                stats.getCount = current + getCount;
                                getCount = 0;

                                current = stats.putCount;
                                stats.putCount = current + putCount;
                                putCount = 0;

                                current = stats.removeCount;
                                stats.removeCount = current + removeCount;
                                removeCount = 0;
                            }
                        }

                        Stats &stats;
                        IMap<int, std::vector<char> > &map;
                        std::shared_ptr<hazelcast::util::ILogger> logger;
                    };


                    void start(const HazelcastServer &server) {
                        std::cerr << "Starting Test with  " << std::endl;
                        std::cerr << "      Thread Count: " << THREAD_COUNT << std::endl;
                        std::cerr << "       Entry Count: " << ENTRY_COUNT << std::endl;
                        std::cerr << "        Value Size: " << VALUE_SIZE << std::endl;
                        std::cerr << "    Get Percentage: " << GET_PERCENTAGE << std::endl;
                        std::cerr << "    Put Percentage: " << PUT_PERCENTAGE << std::endl;
                        std::cerr << " Remove Percentage: " << (100 - (PUT_PERCENTAGE + GET_PERCENTAGE)) << std::endl;
                        ClientConfig clientConfig;
                        clientConfig.setProperty(ClientProperties::PROP_HEARTBEAT_TIMEOUT, "10");
                        clientConfig.getGroupConfig().setName("dev").setPassword("dev-pass");
                        auto member = server.getMember();
                        clientConfig.addAddress(Address(member.host, member.port)).setAttemptPeriod(10 * 1000);
                        clientConfig.setLogLevel(FINEST);

                        Stats stats;
                        std::shared_ptr<hazelcast::util::ILogger> logger(
                                new hazelcast::util::ILogger("SimpleMapTest", "SimpleMapTest", "testversion",
                                                             config::LoggerConfig()));
                        if (!logger->start()) {
                            throw (client::exception::ExceptionBuilder<client::exception::IllegalStateException>(
                                    "SimpleMapTest::start") << "Could not start logger "
                                                            << logger->getInstanceName()).build();
                        }

                        hazelcast::util::Thread monitor(
                                std::shared_ptr<hazelcast::util::Runnable>(new StatsPrinterTask(stats)),
                                *logger);

                        HazelcastClient hazelcastClient(clientConfig);

                        IMap<int, std::vector<char> > map = hazelcastClient.getMap<int, std::vector<char> >(
                                "cppDefault");

                        std::vector<std::shared_ptr<hazelcast::util::Thread> > threads;

                        for (int i = 0; i < THREAD_COUNT; i++) {
                            std::shared_ptr<hazelcast::util::Thread> thread = std::shared_ptr<hazelcast::util::Thread>(
                                    new hazelcast::util::Thread(
                                            std::shared_ptr<hazelcast::util::Runnable>(new Task(stats, map, logger)),
                                            *logger));
                            thread->start();
                            threads.push_back(thread);
                        }

                        monitor.start();
                        monitor.join();
                    }
                };

                TEST_F(SimpleMapTest, DISABLED_testThroughput) {
                    HazelcastServer server(*g_srvFactory);

                    start(server);
                }

            }
        }
    }
}



namespace hazelcast {
    namespace client {
        namespace test {
            class IdGeneratorTest : public ClientTestSupport {
            public:
                IdGeneratorTest();

            protected:
                HazelcastServer instance;
                ClientConfig clientConfig;
                HazelcastClient client;
                std::unique_ptr<IdGenerator> generator;

            };

            IdGeneratorTest::IdGeneratorTest()
                    : instance(*g_srvFactory), client(getNewClient()),
                      generator(new IdGenerator(client.getIdGenerator("clientIdGenerator"))) {
            }

            TEST_F (IdGeneratorTest, testGenerator) {
                int initValue = 3569;
                ASSERT_TRUE(generator->init(initValue));
                ASSERT_FALSE(generator->init(4569));
                for (int i = 0; i < 2000; i++) {
                    ASSERT_EQ(++initValue, generator->newId());
                }
            }

        }
    }
}





namespace hazelcast {
    namespace client {
        namespace test {
            class IssueTest : public ClientTestSupport {

            public:
                IssueTest();

                ~IssueTest();

            protected:
                class Issue864MapListener : public hazelcast::client::EntryAdapter<int, int> {
                public:
                    Issue864MapListener(hazelcast::util::CountDownLatch &l);

                    virtual void entryAdded(const EntryEvent<int, int> &event);

                    virtual void entryUpdated(const EntryEvent<int, int> &event);

                private:
                    hazelcast::util::CountDownLatch &latch;
                };

                hazelcast::util::CountDownLatch latch;
                Issue864MapListener listener;
            };

            IssueTest::IssueTest()
                    : latch(2), listener(latch) {
            }

            IssueTest::~IssueTest() {
            }

            void threadTerminateNode(hazelcast::util::ThreadArgs &args) {
                HazelcastServer *node = (HazelcastServer *) args.arg0;
                node->shutdown();
            }

            void putMapMessage(hazelcast::util::ThreadArgs &args) {
                IMap<int, int> *map = (IMap<int, int> *) args.arg0;
                hazelcast::util::CountDownLatch *latch = (hazelcast::util::CountDownLatch *) args.arg1;

                do {
                    // 7. Put a 2nd entry to the map
                    try {
                        map->put(2, 20);
                    } catch (std::exception &e) {
                        // suppress the error
                        (void) e; // suppress the unused variable warning
                    }
                    hazelcast::util::sleep(1);
                } while (latch->get() > 0);

            }

            TEST_F(IssueTest, testOperationRedo_smartRoutingDisabled) {
                HazelcastServer hz1(*g_srvFactory);
                HazelcastServer hz2(*g_srvFactory);

                ClientConfig clientConfig(getConfig());
                clientConfig.setRedoOperation(true);
                clientConfig.setSmart(false);

                HazelcastClient client(clientConfig);

                client::IMap<int, int> map = client.getMap<int, int>("m");
                hazelcast::util::StartedThread *thread = NULL;
                int expected = 1000;
                for (int i = 0; i < expected; i++) {
                    if (i == 5) {
                        thread = new hazelcast::util::StartedThread(threadTerminateNode, &hz1);
                    }
                    map.put(i, i);
                }
                thread->join();
                delete thread;
                ASSERT_EQ(expected, map.size());
            }

            TEST_F(IssueTest, testListenerSubscriptionOnSingleServerRestart) {
                HazelcastServer server(*g_srvFactory);

// 2. Start a client
                ClientConfig clientConfig(getConfig());
                clientConfig.setConnectionAttemptLimit(10);

                HazelcastClient client(clientConfig);

// 3. Get a map
                IMap<int, int> map = client.getMap<int, int>("IssueTest_map");

// 4. Subscribe client to entry added event
                map.addEntryListener(listener, true);

// Put a key, value to the map
                ASSERT_EQ((int *) NULL, map.put(1, 10).get());

                ASSERT_TRUE(latch.await(20, 1)); // timeout of 20 seconds

// 5. Verify that the listener got the entry added event
                ASSERT_EQ(1, latch.get());

// 6. Restart the server
                ASSERT_TRUE(server.shutdown());
                HazelcastServer server2(*g_srvFactory);

                std::string putThreadName("Map Put Thread");
                hazelcast::util::StartedThread t(putThreadName, putMapMessage, &map, &latch);

// 8. Verify that the 2nd entry is received by the listener
                ASSERT_TRUE(latch.await(20, 0)); // timeout of 20 seconds

                t.cancel();
                t.join();

// 9. Shut down the server
                ASSERT_TRUE(server2.shutdown());
            }

            TEST_F(IssueTest, testIssue221) {
// start a server
                HazelcastServer server(*g_srvFactory);

// start a client
                HazelcastClient client(getConfig());

                IMap<int, int> map = client.getMap<int, int>("Issue221_test_map");

                server.shutdown();

                ASSERT_THROW(map.get(1), exception::HazelcastClientNotActiveException);
            }

            void IssueTest::Issue864MapListener::entryAdded(const EntryEvent<int, int> &event) {
                int count = latch.get();
                if (2 == count) {
                    // The received event should be the addition of key value: 1, 10
                    ASSERT_EQ(1, event.getKey());
                    ASSERT_EQ(10, event.getValue());
                } else if (1 == count) {
                    // The received event should be the addition of key value: 2, 20
                    ASSERT_EQ(2, event.getKey());
                    ASSERT_EQ(20, event.getValue());
                }

                latch.countDown();
            }

            void IssueTest::Issue864MapListener::entryUpdated(const EntryEvent<int, int> &event) {
                ASSERT_EQ(2, event.getKey());
                ASSERT_EQ(20, event.getValue());
                latch.countDown();
            }

            IssueTest::Issue864MapListener::Issue864MapListener(hazelcast::util::CountDownLatch &l) : latch(l) {

            }
        }
    }
}

//
//  hazelcastInstance.cpp
//  hazelcast
//
//  Created by Sancar on 14.08.2013.
//  Copyright (c) 2013 Sancar. All rights reserved.
//



namespace hazelcast {
    namespace client {
        namespace test {
            HazelcastServer::HazelcastServer(HazelcastServerFactory &factory) : factory(factory), isStarted(false),
                                                                                isShutdown(false),
                                                                                logger(new hazelcast::util::ILogger(
                                                                                        "HazelcastServer",
                                                                                        "HazelcastServer",
                                                                                        "testversion",
                                                                                        config::LoggerConfig())) {
                start();
            }

            bool HazelcastServer::start() {
                if (!logger->start()) {
                    throw (client::exception::ExceptionBuilder<client::exception::IllegalStateException>(
                            "HazelcastServer::start") << "Could not start logger " << logger->getInstanceName()).build();
                }

                bool expected = false;
                if (!isStarted.compare_exchange_strong(expected, true)) {
                    return true;
                }

                try {
                    member = factory.startServer();
                    isStarted = true;
                    return true;
                } catch (exception::IllegalStateException &illegalStateException) {
                    std::ostringstream out;
                    out << "Could not start new member!!! " << illegalStateException.what();
                    logger->severe(out.str());
                    isStarted = false;
                    return false;
                }
            }

            bool HazelcastServer::shutdown() {
                bool expected = false;
                if (!isShutdown.compare_exchange_strong(expected, true)) {
                    return false;
                }

                if (!isStarted) {
                    return true;
                }

                if (!factory.shutdownServer(member)) {
                    return false;
                }

                isStarted = false;
                return true;
            }

            bool HazelcastServer::terminate() {
                bool expected = false;
                if (!isShutdown.compare_exchange_strong(expected, true)) {
                    return false;
                }

                if (!isStarted) {
                    return true;
                }

                if (!factory.terminateServer(member)) {
                    return false;
                }

                isStarted = false;
                return true;
            }

            HazelcastServer::~HazelcastServer() {
                shutdown();
            }

            bool HazelcastServer::setAttributes(int memberStartOrder) {
                if (!isStarted) {
                    return false;
                }
                return factory.setAttributes(memberStartOrder);
            }

            const remote::Member &HazelcastServer::getMember() const {
                return member;
            }

        }
    }
}




namespace hazelcast {
    namespace client {
        namespace test {
            ClientTestSupport::ClientTestSupport() {
                const testing::TestInfo *testInfo = testing::UnitTest::GetInstance()->current_test_info();
                std::ostringstream out;
                out << testInfo->test_case_name() << "_" << testInfo->name();
                testName = out.str();
                logger.reset(new hazelcast::util::ILogger("Test", testName, "TestVersion", config::LoggerConfig()));
                if (!logger->start()) {
                    throw (exception::ExceptionBuilder<exception::IllegalStateException>(
                            "ClientTestSupport::ClientTestSupport()") << "Could not start logger "
                                                                      << testInfo->name()).build();
                }
            }

            hazelcast::util::ILogger &ClientTestSupport::getLogger() {
                return *logger;
            }

            const std::string &ClientTestSupport::getTestName() const {
                return testName;
            }
        }
    }
}

#if  defined(WIN32) || defined(_WIN32) || defined(WIN64) || defined(_WIN64)
#pragma warning(pop)
#endif
